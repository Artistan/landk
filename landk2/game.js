function GameClass(options) {
  "use strict";
  var _isMobile = !1, _instanceDependencies = {}, _gameOptions = {
    game: "lordsandknights",
    lang: "en",
    environment: "dev"
  }, _completed = { theme: !1, music: !1 };
  (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0, 4))) && (_isMobile = !0), this.injector = {
    set: function(name, d) {
      _instanceDependencies[name] = d
    }, get: function(name) {
      var fn = null;
      if (!_instanceDependencies[name])throw new Error("Dependence " + name + " does not exist");
      if (fn = _instanceDependencies[name], fn instanceof Array) {
        var realFn = fn.pop(), args = [];
        fn.forEach(function(subDependenceName) {
          args.push(this.get(subDependenceName))
        }, this), fn = realFn.apply(this, args), _instanceDependencies[name] = fn
      }
      return fn
    }
  }, this.initializationComplete = function(complete) {
    Object.assign(_completed, complete);
    var key;
    for (key in _completed)if (_completed.hasOwnProperty(key) && _completed[key] !== !0)return;
    this.finalInitializations()
  }, this.initializationTheme = function() {
    var resourcesManager = this.injector.get(xy.dNames.services.resourcesManager), ClassTheme = this.injector.get(xy.dNames.core.serviceClassTheme), json = resourcesManager.getResourcesValue(xy.res.themeMain), theme = new ClassTheme(json);
    this.injector.set(xy.dNames.services.theme, theme), this.initializationComplete({ theme: !0 })
  }, this.finalInitializations = function() {
    var network, theme = this.injector.get(xy.dNames.services.theme), connectionSetting = theme.getConnectionSettings(_gameOptions.environment), ClassNetwork = this.injector.get(xy.dNames.core.serviceClassNetwork);
    connectionSetting.lang = _gameOptions.lang, network = new ClassNetwork(connectionSetting), this.injector.set(xy.dNames.services.network, network), this.initializationDataManager()
  }, this.initializationResourceManager = function() {
    var ClassResourceManager = this.injector.get(xy.dNames.core.serviceClassResourcesManager), resourcesManager = new ClassResourceManager;
    this.injector.set(xy.dNames.services.resourcesManager, resourcesManager)
  }, this.initializationMusicManager = function() {
    if (!this.isMobileMode()) {
      var ClassMusicManager = this.injector.get(xy.dNames.core.serviceClassMusicManager), musicManager = new ClassMusicManager;
      this.injector.set(xy.dNames.services.musicManager, musicManager)
    }
    this.initializationComplete({ music: !0 })
  }, this.initializationInternationalization = function() {
    var ClassInternationalization = this.injector.get(xy.dNames.core.serviceClassInternationalization), internationalization = new ClassInternationalization;
    this.injector.set(xy.dNames.services.internationalization, internationalization)
  }, this.initializationDataManager = function() {
    var ClassGameDataManager = this.injector.get(xy.dNames.core.serviceClassGameDataManager), dataManager = new ClassGameDataManager;
    dataManager.initGameData(), this.injector.set(xy.dNames.services.gameDataManager, dataManager)
  }, this.initializationLocalStorage = function() {
    var ClassLocalStorage = this.injector.get(xy.dNames.core.serviceClassLocalStorage), localStorage = new ClassLocalStorage;
    localStorage.initClientStorage({ game: _gameOptions.game }), this.injector.set(xy.dNames.services.storage, localStorage)
  }, this.initializationWorldSetting = function() {
    var ClassWorldSettings = this.injector.get(xy.dNames.core.serviceClassWorldSettings), worldSettings = new ClassWorldSettings;
    this.injector.set(xy.dNames.services.worldSettings, worldSettings)
  }, this.initializationSessionUpdateSchedule = function() {
    var ClassSessionUpdateSchedule = this.injector.get(xy.dNames.core.serviceClassSessionUpdateSchedule), sessionUpdateScheduler = new ClassSessionUpdateSchedule;
    this.injector.set(xy.dNames.services.sessionUpdateSchedule, sessionUpdateScheduler)
  }, this.initializationKeyBoardManager = function() {
    var ClassKeyBoardManager = this.injector.get(xy.dNames.core.serviceClassKeyboardManager), keyBoardManager = new ClassKeyBoardManager;
    this.injector.set(xy.dNames.services.keyboardManager, keyBoardManager)
  }, this.initializationEventManager = function() {
    var ClassEventManager = this.injector.get(xy.dNames.core.serviceClassEventManager), eventManager = new ClassEventManager;
    this.injector.set(xy.dNames.services.eventManager, eventManager)
  }, this.initializationDirector = function() {
    var ClassDirector = this.injector.get(xy.dNames.core.graphicalEngineDirector), classDirector = new ClassDirector;
    classDirector.init({
      canvasId: xy.DomElements.gameCanvas,
      isFullWindow: !0
    }), this.injector.set(xy.dNames.graphicEngine.mainDirector, classDirector)
  }, this.initializationGameLanguage = function() {
    var settingsGameConstant = this.injector.get(xy.dNames.settings.gameConstant), serviceLog = this.injector.get(xy.dNames.services.log), localStorage = this.injector.get(xy.dNames.services.storage), locale = (navigator.language || navigator.userLanguage || "").toLowerCase(), lang = localStorage.getClientLanguage();
    lang || (lang = ["zh-hk", "zh-tw"].indexOf(locale) > -1 ? "zh-trad" : ["zh-sg", "zh-cn", "zh", "zh-hans-cn"].indexOf(locale) > -1 ? "zh-cn" : locale.indexOf("-") > -1 ? function() {
      var noCountyLang;
      try {
        return noCountyLang = locale.split("-"), noCountyLang[0]
      } catch (eX) {
        serviceLog("warn", "Can not extract language from locale: " + locale), serviceLog("debug", eX)
      }
    }() : locale), settingsGameConstant.AVAILABLE_LANGUAGES[lang] || (lang = settingsGameConstant.DEFAULT_LANGUAGE), _gameOptions.lang = lang, serviceLog("log", "Client locale: " + locale), serviceLog("log", "Client language: " + lang)
  }, this.initializationAnalytics = function() {
    var ClassAnalytics = this.injector.get(xy.dNames.core.serviceClassAnalytics), analytics = new ClassAnalytics;
    this.injector.set(xy.dNames.services.analytics, analytics)
  }, this.getGameLanguage = function() {
    return _gameOptions.lang
  }, this.setGameLanguage = function(lang) {
    var localStorage = this.injector.get(xy.dNames.services.storage);
    localStorage.setClientLanguage(lang), _gameOptions.lang = lang
  }, this.getCurrentGame = function() {
    return _gameOptions.game
  }, this.isMobileMode = function() {
    return _isMobile
  }, this.initGame = function(options) {
    Object.assign(_gameOptions, options), this.initializationDirector(), this.initializationEventManager(), this.initializationLocalStorage(), this.initializationInternationalization(), this.initializationSessionUpdateSchedule(), this.initializationWorldSetting(), this.initializationKeyBoardManager(), this.initializationResourceManager(), this.initializationAnalytics(), this.initializationGameLanguage(), xy.resourceLoader(_gameOptions.game, _gameOptions.lang)
  }, this.loadGameResources = function(options) {
    var resourcesManager = this.injector.get(xy.dNames.services.resourcesManager);
    resourcesManager.loadGameInitialResources(options.resources, {
      context: null,
      onLoaded: options.onLoaded,
      onProgress: options.onProgress,
      onError: options.onError
    })
  }, Object.assign(_instanceDependencies, xy.dStaticInjector.resources), this.injector.set(xy.dNames.gameInstance, this)
}
!function(f) {
  if ("object" == typeof exports && "undefined" != typeof module)module.exports = f(); else if ("function" == typeof define && define.amd)define([], f); else {
    var g;
    g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, g.React = f()
  }
}(
        function() {
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = "function" == typeof require && require;
          if (!u && a)return a(o, !0);
          if (i)return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f
        }
        var l = n[o] = { exports: {} };
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e)
        }, l, l.exports, e, t, n, r)
      }
      return n[o].exports
    }

    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++)s(r[o]);
    return s
  }({
    1: [
            function(_dereq_, module, exports) {
      "use strict";
      var EventPluginUtils = _dereq_(19), ReactChildren = _dereq_(32), ReactComponent = _dereq_(34), ReactClass = _dereq_(33), ReactContext = _dereq_(38), ReactCurrentOwner = _dereq_(39), ReactElement = _dereq_(57), ReactElementValidator = _dereq_(58), ReactDOM = _dereq_(40), ReactDOMTextComponent = _dereq_(51), ReactDefaultInjection = _dereq_(54), ReactInstanceHandles = _dereq_(66), ReactMount = _dereq_(70), ReactPerf = _dereq_(75), ReactPropTypes = _dereq_(78), ReactReconciler = _dereq_(81), ReactServerRendering = _dereq_(84), assign = _dereq_(27), findDOMNode = _dereq_(117), onlyChild = _dereq_(144);
      ReactDefaultInjection.inject();
      var createElement = ReactElement.createElement, createFactory = ReactElement.createFactory, cloneElement = ReactElement.cloneElement;
      createElement = ReactElementValidator.createElement, createFactory = ReactElementValidator.createFactory, cloneElement = ReactElementValidator.cloneElement;
      var render = ReactPerf.measure("React", "render", ReactMount.render), React = {
        Children: {
          map: ReactChildren.map,
          forEach: ReactChildren.forEach,
          count: ReactChildren.count,
          only: onlyChild
        },
        Component: ReactComponent,
        DOM: ReactDOM,
        PropTypes: ReactPropTypes,
        initializeTouchEvents: function(shouldUseTouch) {
          EventPluginUtils.useTouchEvents = shouldUseTouch
        },
        createClass: ReactClass.createClass,
        createElement: createElement,
        cloneElement: cloneElement,
        createFactory: createFactory,
        createMixin: function(mixin) {
          return mixin
        },
        constructAndRenderComponent: ReactMount.constructAndRenderComponent,
        constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
        findDOMNode: findDOMNode,
        render: render,
        renderToString: ReactServerRendering.renderToString,
        renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
        unmountComponentAtNode: ReactMount.unmountComponentAtNode,
        isValidElement: ReactElement.isValidElement,
        withContext: ReactContext.withContext,
        __spread: assign
      };
      "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject && __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        CurrentOwner: ReactCurrentOwner,
        InstanceHandles: ReactInstanceHandles,
        Mount: ReactMount,
        Reconciler: ReactReconciler,
        TextComponent: ReactDOMTextComponent
      });
      var ExecutionEnvironment = _dereq_(21);
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        navigator.userAgent.indexOf("Chrome") > -1 && "undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && console.debug("Download the React DevTools for a better development experience: http://fb.me/react-devtools");
        for (var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim, Object.create, Object.freeze], i = 0; i < expectedFeatures.length; i++)if (!expectedFeatures[i]) {
          console.error("One or more ES5 shim/shams expected by React are not available: http://fb.me/react-warning-polyfills");
          break
        }
      }
      React.version = "0.13.1", module.exports = React
    }, {
      117: 117,
      144: 144,
      19: 19,
      21: 21,
      27: 27,
      32: 32,
      33: 33,
      34: 34,
      38: 38,
      39: 39,
      40: 40,
      51: 51,
      54: 54,
      57: 57,
      58: 58,
      66: 66,
      70: 70,
      75: 75,
      78: 78,
      81: 81,
      84: 84
    }],
    2: [
            function(_dereq_, module, exports) {
      "use strict";
      var focusNode = _dereq_(119), AutoFocusMixin = {
        componentDidMount: function() {
          this.props.autoFocus && focusNode(this.getDOMNode())
        }
      };
      module.exports = AutoFocusMixin
    }, { 119: 119 }],
    3: [
            function(_dereq_, module, exports) {
      "use strict";
      function isPresto() {
        var opera = window.opera;
        return "object" == typeof opera && "function" == typeof opera.version && parseInt(opera.version(), 10) <= 12
      }

      function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey)
      }

      function getCompositionEventType(topLevelType) {
        switch (topLevelType) {
          case topLevelTypes.topCompositionStart:
            return eventTypes.compositionStart;
          case topLevelTypes.topCompositionEnd:
            return eventTypes.compositionEnd;
          case topLevelTypes.topCompositionUpdate:
            return eventTypes.compositionUpdate
        }
      }

      function isFallbackCompositionStart(topLevelType, nativeEvent) {
        return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE
      }

      function isFallbackCompositionEnd(topLevelType, nativeEvent) {
        switch (topLevelType) {
          case topLevelTypes.topKeyUp:
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
          case topLevelTypes.topKeyDown:
            return nativeEvent.keyCode !== START_KEYCODE;
          case topLevelTypes.topKeyPress:
          case topLevelTypes.topMouseDown:
          case topLevelTypes.topBlur:
            return !0;
          default:
            return !1
        }
      }

      function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        return "object" == typeof detail && "data" in detail ? detail.data : null
      }

      function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var eventType, fallbackData;
        if (canUseCompositionEvent ? eventType = getCompositionEventType(topLevelType) : currentComposition ? isFallbackCompositionEnd(topLevelType, nativeEvent) && (eventType = eventTypes.compositionEnd) : isFallbackCompositionStart(topLevelType, nativeEvent) && (eventType = eventTypes.compositionStart), !eventType)return null;
        useFallbackCompositionData && (currentComposition || eventType !== eventTypes.compositionStart ? eventType === eventTypes.compositionEnd && currentComposition && (fallbackData = currentComposition.getData()) : currentComposition = FallbackCompositionState.getPooled(topLevelTarget));
        var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent);
        if (fallbackData)event.data = fallbackData; else {
          var customData = getDataFromCustomEvent(nativeEvent);
          null !== customData && (event.data = customData)
        }
        return EventPropagators.accumulateTwoPhaseDispatches(event), event
      }

      function getNativeBeforeInputChars(topLevelType, nativeEvent) {
        switch (topLevelType) {
          case topLevelTypes.topCompositionEnd:
            return getDataFromCustomEvent(nativeEvent);
          case topLevelTypes.topKeyPress:
            var which = nativeEvent.which;
            return which !== SPACEBAR_CODE ? null : (hasSpaceKeypress = !0, SPACEBAR_CHAR);
          case topLevelTypes.topTextInput:
            var chars = nativeEvent.data;
            return chars === SPACEBAR_CHAR && hasSpaceKeypress ? null : chars;
          default:
            return null
        }
      }

      function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
        if (currentComposition) {
          if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
            var chars = currentComposition.getData();
            return FallbackCompositionState.release(currentComposition), currentComposition = null, chars
          }
          return null
        }
        switch (topLevelType) {
          case topLevelTypes.topPaste:
            return null;
          case topLevelTypes.topKeyPress:
            return nativeEvent.which && !isKeypressCommand(nativeEvent) ? String.fromCharCode(nativeEvent.which) : null;
          case topLevelTypes.topCompositionEnd:
            return useFallbackCompositionData ? null : nativeEvent.data;
          default:
            return null
        }
      }

      function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
        var chars;
        if (chars = canUseTextInputEvent ? getNativeBeforeInputChars(topLevelType, nativeEvent) : getFallbackBeforeInputChars(topLevelType, nativeEvent), !chars)return null;
        var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent);
        return event.data = chars, EventPropagators.accumulateTwoPhaseDispatches(event), event
      }

      var EventConstants = _dereq_(15), EventPropagators = _dereq_(20), ExecutionEnvironment = _dereq_(21), FallbackCompositionState = _dereq_(22), SyntheticCompositionEvent = _dereq_(93), SyntheticInputEvent = _dereq_(97), keyOf = _dereq_(141), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = ExecutionEnvironment.canUseDOM && "CompositionEvent" in window, documentMode = null;
      ExecutionEnvironment.canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && "TextEvent" in window && !documentMode && !isPresto(), useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), topLevelTypes = EventConstants.topLevelTypes, eventTypes = {
        beforeInput: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onBeforeInput: null }),
            captured: keyOf({ onBeforeInputCapture: null })
          },
          dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
        },
        compositionEnd: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onCompositionEnd: null }),
            captured: keyOf({ onCompositionEndCapture: null })
          },
          dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
        },
        compositionStart: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onCompositionStart: null }),
            captured: keyOf({ onCompositionStartCapture: null })
          },
          dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
        },
        compositionUpdate: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onCompositionUpdate: null }),
            captured: keyOf({ onCompositionUpdateCapture: null })
          },
          dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
        }
      }, hasSpaceKeypress = !1, currentComposition = null, BeforeInputEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent)]
        }
      };
      module.exports = BeforeInputEventPlugin
    }, { 141: 141, 15: 15, 20: 20, 21: 21, 22: 22, 93: 93, 97: 97 }],
    4: [
            function(_dereq_, module, exports) {
      "use strict";
      function prefixKey(prefix, key) {
        return prefix + key.charAt(0).toUpperCase() + key.substring(1)
      }

      var isUnitlessNumber = {
        boxFlex: !0,
        boxFlexGroup: !0,
        columnCount: !0,
        flex: !0,
        flexGrow: !0,
        flexShrink: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        strokeOpacity: !0
      }, prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix) {
          isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop]
        })
      });
      var shorthandPropertyExpansions = {
        background: {
          backgroundImage: !0,
          backgroundPosition: !0,
          backgroundRepeat: !0,
          backgroundColor: !0
        },
        border: { borderWidth: !0, borderStyle: !0, borderColor: !0 },
        borderBottom: { borderBottomWidth: !0, borderBottomStyle: !0, borderBottomColor: !0 },
        borderLeft: { borderLeftWidth: !0, borderLeftStyle: !0, borderLeftColor: !0 },
        borderRight: { borderRightWidth: !0, borderRightStyle: !0, borderRightColor: !0 },
        borderTop: { borderTopWidth: !0, borderTopStyle: !0, borderTopColor: !0 },
        font: { fontStyle: !0, fontVariant: !0, fontWeight: !0, fontSize: !0, lineHeight: !0, fontFamily: !0 }
      }, CSSProperty = { isUnitlessNumber: isUnitlessNumber, shorthandPropertyExpansions: shorthandPropertyExpansions };
      module.exports = CSSProperty
    }, {}],
    5: [
            function(_dereq_, module, exports) {
      "use strict";
      var CSSProperty = _dereq_(4), ExecutionEnvironment = _dereq_(21), camelizeStyleName = _dereq_(108), dangerousStyleValue = _dereq_(113), hyphenateStyleName = _dereq_(133), memoizeStringOnly = _dereq_(143), warning = _dereq_(154), processStyleName = memoizeStringOnly(function(styleName) {
        return hyphenateStyleName(styleName)
      }), styleFloatAccessor = "cssFloat";
      ExecutionEnvironment.canUseDOM && void 0 === document.documentElement.style.cssFloat && (styleFloatAccessor = "styleFloat");
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnHyphenatedStyleName = function(name) {
        warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, warning(!1, "Unsupported style property %s. Did you mean %s?", name, camelizeStyleName(name)))
      }, warnBadVendoredStyleName = function(name) {
        warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, warning(!1, "Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)))
      }, warnStyleValueWithSemicolon = function(name, value) {
        warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, warning(!1, 'Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, "")))
      }, warnValidStyle = function(name, value) {
        name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value) && warnStyleValueWithSemicolon(name, value)
      }, CSSPropertyOperations = {
        createMarkupForStyles: function(styles) {
          var serialized = "";
          for (var styleName in styles)if (styles.hasOwnProperty(styleName)) {
            var styleValue = styles[styleName];
            warnValidStyle(styleName, styleValue), null != styleValue && (serialized += processStyleName(styleName) + ":", serialized += dangerousStyleValue(styleName, styleValue) + ";")
          }
          return serialized || null
        }, setValueForStyles: function(node, styles) {
          var style = node.style;
          for (var styleName in styles)if (styles.hasOwnProperty(styleName)) {
            warnValidStyle(styleName, styles[styleName]);
            var styleValue = dangerousStyleValue(styleName, styles[styleName]);
            if ("float" === styleName && (styleName = styleFloatAccessor), styleValue)style[styleName] = styleValue; else {
              var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
              if (expansion)for (var individualStyleName in expansion)style[individualStyleName] = ""; else style[styleName] = ""
            }
          }
        }
      };
      module.exports = CSSPropertyOperations
    }, { 108: 108, 113: 113, 133: 133, 143: 143, 154: 154, 21: 21, 4: 4 }],
    6: [
            function(_dereq_, module, exports) {
      "use strict";
      function CallbackQueue() {
        this._callbacks = null, this._contexts = null
      }

      var PooledClass = _dereq_(28), assign = _dereq_(27), invariant = _dereq_(135);
      assign(CallbackQueue.prototype, {
        enqueue: function(callback, context) {
          this._callbacks = this._callbacks || [], this._contexts = this._contexts || [], this._callbacks.push(callback), this._contexts.push(context)
        }, notifyAll: function() {
          var callbacks = this._callbacks, contexts = this._contexts;
          if (callbacks) {
            invariant(callbacks.length === contexts.length, "Mismatched list of contexts in callback queue"), this._callbacks = null, this._contexts = null;
            for (var i = 0, l = callbacks.length; i < l; i++)callbacks[i].call(contexts[i]);
            callbacks.length = 0, contexts.length = 0
          }
        }, reset: function() {
          this._callbacks = null, this._contexts = null
        }, destructor: function() {
          this.reset()
        }
      }), PooledClass.addPoolingTo(CallbackQueue), module.exports = CallbackQueue
    }, { 135: 135, 27: 27, 28: 28 }],
    7: [
            function(_dereq_, module, exports) {
      "use strict";
      function shouldUseChangeEvent(elem) {
        return "SELECT" === elem.nodeName || "INPUT" === elem.nodeName && "file" === elem.type
      }

      function manualDispatchChangeEvent(nativeEvent) {
        var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent);
        EventPropagators.accumulateTwoPhaseDispatches(event), ReactUpdates.batchedUpdates(runEventInBatch, event)
      }

      function runEventInBatch(event) {
        EventPluginHub.enqueueEvents(event), EventPluginHub.processEventQueue()
      }

      function startWatchingForChangeEventIE8(target, targetID) {
        activeElement = target, activeElementID = targetID, activeElement.attachEvent("onchange", manualDispatchChangeEvent)
      }

      function stopWatchingForChangeEventIE8() {
        activeElement && (activeElement.detachEvent("onchange", manualDispatchChangeEvent), activeElement = null, activeElementID = null)
      }

      function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topChange)return topLevelTargetID
      }

      function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
        topLevelType === topLevelTypes.topFocus ? (stopWatchingForChangeEventIE8(), startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID)) : topLevelType === topLevelTypes.topBlur && stopWatchingForChangeEventIE8()
      }

      function startWatchingForValueChange(target, targetID) {
        activeElement = target, activeElementID = targetID, activeElementValue = target.value, activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, "value"), Object.defineProperty(activeElement, "value", newValueProp), activeElement.attachEvent("onpropertychange", handlePropertyChange)
      }

      function stopWatchingForValueChange() {
        activeElement && (delete activeElement.value, activeElement.detachEvent("onpropertychange", handlePropertyChange), activeElement = null, activeElementID = null, activeElementValue = null, activeElementValueProp = null)
      }

      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName) {
          var value = nativeEvent.srcElement.value;
          value !== activeElementValue && (activeElementValue = value, manualDispatchChangeEvent(nativeEvent))
        }
      }

      function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topInput)return topLevelTargetID
      }

      function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
        topLevelType === topLevelTypes.topFocus ? (stopWatchingForValueChange(), startWatchingForValueChange(topLevelTarget, topLevelTargetID)) : topLevelType === topLevelTypes.topBlur && stopWatchingForValueChange()
      }

      function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
        if ((topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) && activeElement && activeElement.value !== activeElementValue)return activeElementValue = activeElement.value, activeElementID
      }

      function shouldUseClickEvent(elem) {
        return "INPUT" === elem.nodeName && ("checkbox" === elem.type || "radio" === elem.type)
      }

      function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
        if (topLevelType === topLevelTypes.topClick)return topLevelTargetID
      }

      var EventConstants = _dereq_(15), EventPluginHub = _dereq_(17), EventPropagators = _dereq_(20), ExecutionEnvironment = _dereq_(21), ReactUpdates = _dereq_(87), SyntheticEvent = _dereq_(95), isEventSupported = _dereq_(136), isTextInputElement = _dereq_(138), keyOf = _dereq_(141), topLevelTypes = EventConstants.topLevelTypes, eventTypes = {
        change: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onChange: null }),
            captured: keyOf({ onChangeCapture: null })
          },
          dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
        }
      }, activeElement = null, activeElementID = null, activeElementValue = null, activeElementValueProp = null, doesChangeEventBubble = !1;
      ExecutionEnvironment.canUseDOM && (doesChangeEventBubble = isEventSupported("change") && (!("documentMode" in document) || document.documentMode > 8));
      var isInputEventSupported = !1;
      ExecutionEnvironment.canUseDOM && (isInputEventSupported = isEventSupported("input") && (!("documentMode" in document) || document.documentMode > 9));
      var newValueProp = {
        get: function() {
          return activeElementValueProp.get.call(this)
        }, set: function(val) {
          activeElementValue = "" + val, activeElementValueProp.set.call(this, val)
        }
      }, ChangeEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          var getTargetIDFunc, handleEventFunc;
          if (shouldUseChangeEvent(topLevelTarget) ? doesChangeEventBubble ? getTargetIDFunc = getTargetIDForChangeEvent : handleEventFunc = handleEventsForChangeEventIE8 : isTextInputElement(topLevelTarget) ? isInputEventSupported ? getTargetIDFunc = getTargetIDForInputEvent : (getTargetIDFunc = getTargetIDForInputEventIE, handleEventFunc = handleEventsForInputEventIE) : shouldUseClickEvent(topLevelTarget) && (getTargetIDFunc = getTargetIDForClickEvent), getTargetIDFunc) {
            var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
            if (targetID) {
              var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent);
              return EventPropagators.accumulateTwoPhaseDispatches(event), event
            }
          }
          handleEventFunc && handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID)
        }
      };
      module.exports = ChangeEventPlugin
    }, { 136: 136, 138: 138, 141: 141, 15: 15, 17: 17, 20: 20, 21: 21, 87: 87, 95: 95 }],
    8: [function(_dereq_, module, exports) {
      "use strict";
      var nextReactRootIndex = 0, ClientReactRootIndex = {
        createReactRootIndex: function() {
          return nextReactRootIndex++
        }
      };
      module.exports = ClientReactRootIndex
    }, {}],
    9: [function(_dereq_, module, exports) {
      "use strict";
      function insertChildAt(parentNode, childNode, index) {
        parentNode.insertBefore(childNode, parentNode.childNodes[index] || null)
      }

      var Danger = _dereq_(12), ReactMultiChildUpdateTypes = _dereq_(72), setTextContent = _dereq_(149), invariant = _dereq_(135), DOMChildrenOperations = {
        dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
        updateTextContent: setTextContent,
        processUpdates: function(updates, markupList) {
          for (var update, initialChildren = null, updatedChildren = null, i = 0; i < updates.length; i++)if (update = updates[i], update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
            var updatedIndex = update.fromIndex, updatedChild = update.parentNode.childNodes[updatedIndex], parentID = update.parentID;
            invariant(updatedChild, "processUpdates(): Unable to find child %s of element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a <tbody> when using tables, nesting tags like <form>, <p>, or <a>, or using non-SVG elements in an <svg> parent. Try inspecting the child nodes of the element with React ID `%s`.", updatedIndex, parentID), initialChildren = initialChildren || {}, initialChildren[parentID] = initialChildren[parentID] || [], initialChildren[parentID][updatedIndex] = updatedChild, updatedChildren = updatedChildren || [], updatedChildren.push(updatedChild)
          }
          var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
          if (updatedChildren)for (var j = 0; j < updatedChildren.length; j++)updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
          for (var k = 0; k < updates.length; k++)switch (update = updates[k], update.type) {
            case ReactMultiChildUpdateTypes.INSERT_MARKUP:
              insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.MOVE_EXISTING:
              insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
              break;
            case ReactMultiChildUpdateTypes.TEXT_CONTENT:
              setTextContent(update.parentNode, update.textContent);
              break;
            case ReactMultiChildUpdateTypes.REMOVE_NODE:
          }
        }
      };
      module.exports = DOMChildrenOperations
    }, { 12: 12, 135: 135, 149: 149, 72: 72 }],
    10: [function(_dereq_, module, exports) {
      "use strict";
      function checkMask(value, bitmask) {
        return (value & bitmask) === bitmask
      }

      var invariant = _dereq_(135), DOMPropertyInjection = {
        MUST_USE_ATTRIBUTE: 1,
        MUST_USE_PROPERTY: 2,
        HAS_SIDE_EFFECTS: 4,
        HAS_BOOLEAN_VALUE: 8,
        HAS_NUMERIC_VALUE: 16,
        HAS_POSITIVE_NUMERIC_VALUE: 48,
        HAS_OVERLOADED_BOOLEAN_VALUE: 64,
        injectDOMPropertyConfig: function(domPropertyConfig) {
          var Properties = domPropertyConfig.Properties || {}, DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {}, DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {}, DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
          domPropertyConfig.isCustomAttribute && DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
          for (var propName in Properties) {
            invariant(!DOMProperty.isStandardName.hasOwnProperty(propName), "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName),
                    DOMProperty.isStandardName[propName] = !0;
            var lowerCased = propName.toLowerCase();
            if (DOMProperty.getPossibleStandardName[lowerCased] = propName, DOMAttributeNames.hasOwnProperty(propName)) {
              var attributeName = DOMAttributeNames[propName];
              DOMProperty.getPossibleStandardName[attributeName] = propName, DOMProperty.getAttributeName[propName] = attributeName
            } else DOMProperty.getAttributeName[propName] = lowerCased;
            DOMProperty.getPropertyName[propName] = DOMPropertyNames.hasOwnProperty(propName) ? DOMPropertyNames[propName] : propName, DOMMutationMethods.hasOwnProperty(propName) ? DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName] : DOMProperty.getMutationMethod[propName] = null;
            var propConfig = Properties[propName];
            DOMProperty.mustUseAttribute[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE), DOMProperty.mustUseProperty[propName] = checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY), DOMProperty.hasSideEffects[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS), DOMProperty.hasBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE), DOMProperty.hasNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE), DOMProperty.hasPositiveNumericValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE), DOMProperty.hasOverloadedBooleanValue[propName] = checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE), invariant(!DOMProperty.mustUseAttribute[propName] || !DOMProperty.mustUseProperty[propName], "DOMProperty: Cannot require using both attribute and property: %s", propName), invariant(DOMProperty.mustUseProperty[propName] || !DOMProperty.hasSideEffects[propName], "DOMProperty: Properties that have side effects must use property: %s", propName), invariant(!!DOMProperty.hasBooleanValue[propName] + !!DOMProperty.hasNumericValue[propName] + !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName)
          }
        }
      }, defaultValueCache = {}, DOMProperty = {
        ID_ATTRIBUTE_NAME: "data-reactid",
        isStandardName: {},
        getPossibleStandardName: {},
        getAttributeName: {},
        getPropertyName: {},
        getMutationMethod: {},
        mustUseAttribute: {},
        mustUseProperty: {},
        hasSideEffects: {},
        hasBooleanValue: {},
        hasNumericValue: {},
        hasPositiveNumericValue: {},
        hasOverloadedBooleanValue: {},
        _isCustomAttributeFunctions: [],
        isCustomAttribute: function(attributeName) {
          for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
            var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
            if (isCustomAttributeFn(attributeName))return !0
          }
          return !1
        },
        getDefaultValueForProperty: function(nodeName, prop) {
          var testElement, nodeDefaults = defaultValueCache[nodeName];
          return nodeDefaults || (defaultValueCache[nodeName] = nodeDefaults = {}), prop in nodeDefaults || (testElement = document.createElement(nodeName), nodeDefaults[prop] = testElement[prop]), nodeDefaults[prop]
        },
        injection: DOMPropertyInjection
      };
      module.exports = DOMProperty
    }, { 135: 135 }],
    11: [function(_dereq_, module, exports) {
      "use strict";
      function shouldIgnoreValue(name, value) {
        return null == value || DOMProperty.hasBooleanValue[name] && !value || DOMProperty.hasNumericValue[name] && isNaN(value) || DOMProperty.hasPositiveNumericValue[name] && value < 1 || DOMProperty.hasOverloadedBooleanValue[name] && value === !1
      }

      var DOMProperty = _dereq_(10), quoteAttributeValueForBrowser = _dereq_(147), warning = _dereq_(154), reactProps = {
        children: !0,
        dangerouslySetInnerHTML: !0,
        key: !0,
        ref: !0
      }, warnedProperties = {}, warnUnknownProperty = function(name) {
        if (!(reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name])) {
          warnedProperties[name] = !0;
          var lowerCasedName = name.toLowerCase(), standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
          warning(null == standardName, "Unknown DOM property %s. Did you mean %s?", name, standardName)
        }
      }, DOMPropertyOperations = {
        createMarkupForID: function(id) {
          return DOMProperty.ID_ATTRIBUTE_NAME + "=" + quoteAttributeValueForBrowser(id)
        }, createMarkupForProperty: function(name, value) {
          if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
            if (shouldIgnoreValue(name, value))return "";
            var attributeName = DOMProperty.getAttributeName[name];
            return DOMProperty.hasBooleanValue[name] || DOMProperty.hasOverloadedBooleanValue[name] && value === !0 ? attributeName : attributeName + "=" + quoteAttributeValueForBrowser(value)
          }
          return DOMProperty.isCustomAttribute(name) ? null == value ? "" : name + "=" + quoteAttributeValueForBrowser(value) : (warnUnknownProperty(name), null)
        }, setValueForProperty: function(node, name, value) {
          if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
            var mutationMethod = DOMProperty.getMutationMethod[name];
            if (mutationMethod)mutationMethod(node, value); else if (shouldIgnoreValue(name, value))this.deleteValueForProperty(node, name); else if (DOMProperty.mustUseAttribute[name])node.setAttribute(DOMProperty.getAttributeName[name], "" + value); else {
              var propName = DOMProperty.getPropertyName[name];
              DOMProperty.hasSideEffects[name] && "" + node[propName] == "" + value || (node[propName] = value)
            }
          } else DOMProperty.isCustomAttribute(name) ? null == value ? node.removeAttribute(name) : node.setAttribute(name, "" + value) : warnUnknownProperty(name)
        }, deleteValueForProperty: function(node, name) {
          if (DOMProperty.isStandardName.hasOwnProperty(name) && DOMProperty.isStandardName[name]) {
            var mutationMethod = DOMProperty.getMutationMethod[name];
            if (mutationMethod)mutationMethod(node, void 0); else if (DOMProperty.mustUseAttribute[name])node.removeAttribute(DOMProperty.getAttributeName[name]); else {
              var propName = DOMProperty.getPropertyName[name], defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
              DOMProperty.hasSideEffects[name] && "" + node[propName] === defaultValue || (node[propName] = defaultValue)
            }
          } else DOMProperty.isCustomAttribute(name) ? node.removeAttribute(name) : warnUnknownProperty(name)
        }
      };
      module.exports = DOMPropertyOperations
    }, { 10: 10, 147: 147, 154: 154 }],
    12: [function(_dereq_, module, exports) {
      "use strict";
      function getNodeName(markup) {
        return markup.substring(1, markup.indexOf(" "))
      }

      var ExecutionEnvironment = _dereq_(21), createNodesFromMarkup = _dereq_(112), emptyFunction = _dereq_(114), getMarkupWrap = _dereq_(127), invariant = _dereq_(135), OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/, RESULT_INDEX_ATTR = "data-danger-index", Danger = {
        dangerouslyRenderMarkup: function(markupList) {
          invariant(ExecutionEnvironment.canUseDOM, "dangerouslyRenderMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use React.renderToString for server rendering.");
          for (var nodeName, markupByNodeName = {}, i = 0; i < markupList.length; i++)invariant(markupList[i], "dangerouslyRenderMarkup(...): Missing markup."), nodeName = getNodeName(markupList[i]), nodeName = getMarkupWrap(nodeName) ? nodeName : "*", markupByNodeName[nodeName] = markupByNodeName[nodeName] || [], markupByNodeName[nodeName][i] = markupList[i];
          var resultList = [], resultListAssignmentCount = 0;
          for (nodeName in markupByNodeName)if (markupByNodeName.hasOwnProperty(nodeName)) {
            var resultIndex, markupListByNodeName = markupByNodeName[nodeName];
            for (resultIndex in markupListByNodeName)if (markupListByNodeName.hasOwnProperty(resultIndex)) {
              var markup = markupListByNodeName[resultIndex];
              markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, "$1 " + RESULT_INDEX_ATTR + '="' + resultIndex + '" ')
            }
            for (var renderNodes = createNodesFromMarkup(markupListByNodeName.join(""), emptyFunction), j = 0; j < renderNodes.length; ++j) {
              var renderNode = renderNodes[j];
              renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR) ? (resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR), renderNode.removeAttribute(RESULT_INDEX_ATTR), invariant(!resultList.hasOwnProperty(resultIndex), "Danger: Assigning to an already-occupied result index."), resultList[resultIndex] = renderNode, resultListAssignmentCount += 1) : console.error("Danger: Discarding unexpected node:", renderNode)
            }
          }
          return invariant(resultListAssignmentCount === resultList.length, "Danger: Did not assign to every index of resultList."), invariant(resultList.length === markupList.length, "Danger: Expected markup to render %s nodes, but rendered %s.", markupList.length, resultList.length), resultList
        }, dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
          invariant(ExecutionEnvironment.canUseDOM, "dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use React.renderToString for server rendering."), invariant(markup, "dangerouslyReplaceNodeWithMarkup(...): Missing markup."), invariant("html" !== oldChild.tagName.toLowerCase(), "dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See React.renderToString().");
          var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
          oldChild.parentNode.replaceChild(newChild, oldChild)
        }
      };
      module.exports = Danger
    }, { 112: 112, 114: 114, 127: 127, 135: 135, 21: 21 }],
    13: [function(_dereq_, module, exports) {
      "use strict";
      var keyOf = _dereq_(141), DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null }), keyOf({ AnalyticsEventPlugin: null }), keyOf({ MobileSafariClickEventPlugin: null })];
      module.exports = DefaultEventPluginOrder
    }, { 141: 141 }],
    14: [function(_dereq_, module, exports) {
      "use strict";
      var EventConstants = _dereq_(15), EventPropagators = _dereq_(20), SyntheticMouseEvent = _dereq_(99), ReactMount = _dereq_(70), keyOf = _dereq_(141), topLevelTypes = EventConstants.topLevelTypes, getFirstReactDOM = ReactMount.getFirstReactDOM, eventTypes = {
        mouseEnter: {
          registrationName: keyOf({ onMouseEnter: null }),
          dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
        },
        mouseLeave: {
          registrationName: keyOf({ onMouseLeave: null }),
          dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
        }
      }, extractedEvents = [null, null], EnterLeaveEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement))return null;
          if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver)return null;
          var win;
          if (topLevelTarget.window === topLevelTarget)win = topLevelTarget; else {
            var doc = topLevelTarget.ownerDocument;
            win = doc ? doc.defaultView || doc.parentWindow : window
          }
          var from, to;
          if (topLevelType === topLevelTypes.topMouseOut ? (from = topLevelTarget, to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) || win) : (from = win, to = topLevelTarget), from === to)return null;
          var fromID = from ? ReactMount.getID(from) : "", toID = to ? ReactMount.getID(to) : "", leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent);
          leave.type = "mouseleave", leave.target = from, leave.relatedTarget = to;
          var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent);
          return enter.type = "mouseenter", enter.target = to, enter.relatedTarget = from, EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID), extractedEvents[0] = leave, extractedEvents[1] = enter, extractedEvents
        }
      };
      module.exports = EnterLeaveEventPlugin
    }, { 141: 141, 15: 15, 20: 20, 70: 70, 99: 99 }],
    15: [function(_dereq_, module, exports) {
      "use strict";
      var keyMirror = _dereq_(140), PropagationPhases = keyMirror({
        bubbled: null,
        captured: null
      }), topLevelTypes = keyMirror({
        topBlur: null,
        topChange: null,
        topClick: null,
        topCompositionEnd: null,
        topCompositionStart: null,
        topCompositionUpdate: null,
        topContextMenu: null,
        topCopy: null,
        topCut: null,
        topDoubleClick: null,
        topDrag: null,
        topDragEnd: null,
        topDragEnter: null,
        topDragExit: null,
        topDragLeave: null,
        topDragOver: null,
        topDragStart: null,
        topDrop: null,
        topError: null,
        topFocus: null,
        topInput: null,
        topKeyDown: null,
        topKeyPress: null,
        topKeyUp: null,
        topLoad: null,
        topMouseDown: null,
        topMouseMove: null,
        topMouseOut: null,
        topMouseOver: null,
        topMouseUp: null,
        topPaste: null,
        topReset: null,
        topScroll: null,
        topSelectionChange: null,
        topSubmit: null,
        topTextInput: null,
        topTouchCancel: null,
        topTouchEnd: null,
        topTouchMove: null,
        topTouchStart: null,
        topWheel: null
      }), EventConstants = { topLevelTypes: topLevelTypes, PropagationPhases: PropagationPhases };
      module.exports = EventConstants
    }, { 140: 140 }],
    16: [function(_dereq_, module, exports) {
      var emptyFunction = _dereq_(114), EventListener = {
        listen: function(target, eventType, callback) {
          return target.addEventListener ? (target.addEventListener(eventType, callback, !1), {
            remove: function() {
              target.removeEventListener(eventType, callback, !1)
            }
          }) : target.attachEvent ? (target.attachEvent("on" + eventType, callback), {
            remove: function() {
              target.detachEvent("on" + eventType, callback)
            }
          }) : void 0
        }, capture: function(target, eventType, callback) {
          return target.addEventListener ? (target.addEventListener(eventType, callback, !0), {
            remove: function() {
              target.removeEventListener(eventType, callback, !0)
            }
          }) : (console.error("Attempted to listen to events during the capture phase on a browser that does not support the capture phase. Your application will not receive some events."), { remove: emptyFunction })
        }, registerDefault: function() {
        }
      };
      module.exports = EventListener
    }, { 114: 114 }],
    17: [function(_dereq_, module, exports) {
      "use strict";
      function validateInstanceHandle() {
        var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
        invariant(valid, "InstanceHandle not injected before use!")
      }

      var EventPluginRegistry = _dereq_(18), EventPluginUtils = _dereq_(19), accumulateInto = _dereq_(105), forEachAccumulated = _dereq_(120), invariant = _dereq_(135), listenerBank = {}, eventQueue = null, executeDispatchesAndRelease = function(event) {
        if (event) {
          var executeDispatch = EventPluginUtils.executeDispatch, PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
          PluginModule && PluginModule.executeDispatch && (executeDispatch = PluginModule.executeDispatch), EventPluginUtils.executeDispatchesInOrder(event, executeDispatch), event.isPersistent() || event.constructor.release(event)
        }
      }, InstanceHandle = null, EventPluginHub = {
        injection: {
          injectMount: EventPluginUtils.injection.injectMount,
          injectInstanceHandle: function(InjectedInstanceHandle) {
            InstanceHandle = InjectedInstanceHandle, validateInstanceHandle()
          },
          getInstanceHandle: function() {
            return validateInstanceHandle(), InstanceHandle
          },
          injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
          injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
        },
        eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
        registrationNameModules: EventPluginRegistry.registrationNameModules,
        putListener: function(id, registrationName, listener) {
          invariant(!listener || "function" == typeof listener, "Expected %s listener to be a function, instead got type %s", registrationName, typeof listener);
          var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
          bankForRegistrationName[id] = listener
        },
        getListener: function(id, registrationName) {
          var bankForRegistrationName = listenerBank[registrationName];
          return bankForRegistrationName && bankForRegistrationName[id]
        },
        deleteListener: function(id, registrationName) {
          var bankForRegistrationName = listenerBank[registrationName];
          bankForRegistrationName && delete bankForRegistrationName[id]
        },
        deleteAllListeners: function(id) {
          for (var registrationName in listenerBank)delete listenerBank[registrationName][id]
        },
        extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          for (var events, plugins = EventPluginRegistry.plugins, i = 0, l = plugins.length; i < l; i++) {
            var possiblePlugin = plugins[i];
            if (possiblePlugin) {
              var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
              extractedEvents && (events = accumulateInto(events, extractedEvents))
            }
          }
          return events
        },
        enqueueEvents: function(events) {
          events && (eventQueue = accumulateInto(eventQueue, events))
        },
        processEventQueue: function() {
          var processingEventQueue = eventQueue;
          eventQueue = null, forEachAccumulated(processingEventQueue, executeDispatchesAndRelease), invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.")
        },
        __purge: function() {
          listenerBank = {}
        },
        __getListenerBank: function() {
          return listenerBank
        }
      };
      module.exports = EventPluginHub
    }, { 105: 105, 120: 120, 135: 135, 18: 18, 19: 19 }],
    18: [function(_dereq_, module, exports) {
      "use strict";
      function recomputePluginOrdering() {
        if (EventPluginOrder)for (var pluginName in namesToPlugins) {
          var PluginModule = namesToPlugins[pluginName], pluginIndex = EventPluginOrder.indexOf(pluginName);
          if (invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.", pluginName), !EventPluginRegistry.plugins[pluginIndex]) {
            invariant(PluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.", pluginName), EventPluginRegistry.plugins[pluginIndex] = PluginModule;
            var publishedEvents = PluginModule.eventTypes;
            for (var eventName in publishedEvents)invariant(publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName)
          }
        }
      }

      function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
        invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.", eventName), EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
        var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
        if (phasedRegistrationNames) {
          for (var phaseName in phasedRegistrationNames)if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, PluginModule, eventName)
          }
          return !0
        }
        return !!dispatchConfig.registrationName && (publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName), !0)
      }

      function publishRegistrationName(registrationName, PluginModule, eventName) {
        invariant(!EventPluginRegistry.registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.", registrationName), EventPluginRegistry.registrationNameModules[registrationName] = PluginModule, EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies
      }

      var invariant = _dereq_(135), EventPluginOrder = null, namesToPlugins = {}, EventPluginRegistry = {
        plugins: [],
        eventNameDispatchConfigs: {},
        registrationNameModules: {},
        registrationNameDependencies: {},
        injectEventPluginOrder: function(InjectedEventPluginOrder) {
          invariant(!EventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React."), EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder), recomputePluginOrdering()
        },
        injectEventPluginsByName: function(injectedNamesToPlugins) {
          var isOrderingDirty = !1;
          for (var pluginName in injectedNamesToPlugins)if (injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            var PluginModule = injectedNamesToPlugins[pluginName];
            namesToPlugins.hasOwnProperty(pluginName) && namesToPlugins[pluginName] === PluginModule || (invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.", pluginName), namesToPlugins[pluginName] = PluginModule, isOrderingDirty = !0)
          }
          isOrderingDirty && recomputePluginOrdering()
        },
        getPluginModuleForEvent: function(event) {
          var dispatchConfig = event.dispatchConfig;
          if (dispatchConfig.registrationName)return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
          for (var phase in dispatchConfig.phasedRegistrationNames)if (dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
            var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
            if (PluginModule)return PluginModule
          }
          return null
        },
        _resetEventPlugins: function() {
          EventPluginOrder = null;
          for (var pluginName in namesToPlugins)namesToPlugins.hasOwnProperty(pluginName) && delete namesToPlugins[pluginName];
          EventPluginRegistry.plugins.length = 0;
          var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
          for (var eventName in eventNameDispatchConfigs)eventNameDispatchConfigs.hasOwnProperty(eventName) && delete eventNameDispatchConfigs[eventName];
          var registrationNameModules = EventPluginRegistry.registrationNameModules;
          for (var registrationName in registrationNameModules)registrationNameModules.hasOwnProperty(registrationName) && delete registrationNameModules[registrationName]
        }
      };
      module.exports = EventPluginRegistry
    }, { 135: 135 }],
    19: [function(_dereq_, module, exports) {
      "use strict";
      function isEndish(topLevelType) {
        return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel
      }

      function isMoveish(topLevelType) {
        return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove
      }

      function isStartish(topLevelType) {
        return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart
      }

      function forEachEventDispatch(event, cb) {
        var dispatchListeners = event._dispatchListeners, dispatchIDs = event._dispatchIDs;
        if (validateEventDispatches(event), Array.isArray(dispatchListeners))for (var i = 0; i < dispatchListeners.length && !event.isPropagationStopped(); i++)cb(event, dispatchListeners[i], dispatchIDs[i]); else dispatchListeners && cb(event, dispatchListeners, dispatchIDs)
      }

      function executeDispatch(event, listener, domID) {
        event.currentTarget = injection.Mount.getNode(domID);
        var returnValue = listener(event, domID);
        return event.currentTarget = null, returnValue
      }

      function executeDispatchesInOrder(event, cb) {
        forEachEventDispatch(event, cb), event._dispatchListeners = null, event._dispatchIDs = null
      }

      function executeDispatchesInOrderStopAtTrueImpl(event) {
        var dispatchListeners = event._dispatchListeners, dispatchIDs = event._dispatchIDs;
        if (validateEventDispatches(event), Array.isArray(dispatchListeners)) {
          for (var i = 0; i < dispatchListeners.length && !event.isPropagationStopped(); i++)if (dispatchListeners[i](event, dispatchIDs[i]))return dispatchIDs[i]
        } else if (dispatchListeners && dispatchListeners(event, dispatchIDs))return dispatchIDs;
        return null
      }

      function executeDispatchesInOrderStopAtTrue(event) {
        var ret = executeDispatchesInOrderStopAtTrueImpl(event);
        return event._dispatchIDs = null, event._dispatchListeners = null, ret
      }

      function executeDirectDispatch(event) {
        validateEventDispatches(event);
        var dispatchListener = event._dispatchListeners, dispatchID = event._dispatchIDs;
        invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
        var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
        return event._dispatchListeners = null, event._dispatchIDs = null, res
      }

      function hasDispatches(event) {
        return !!event._dispatchListeners
      }

      var validateEventDispatches, EventConstants = _dereq_(15), invariant = _dereq_(135), injection = {
        Mount: null,
        injectMount: function(InjectedMount) {
          injection.Mount = InjectedMount, invariant(InjectedMount && InjectedMount.getNode, "EventPluginUtils.injection.injectMount(...): Injected Mount module is missing getNode.")
        }
      }, topLevelTypes = EventConstants.topLevelTypes;
      validateEventDispatches = function(event) {
        var dispatchListeners = event._dispatchListeners, dispatchIDs = event._dispatchIDs, listenersIsArr = Array.isArray(dispatchListeners), idsIsArr = Array.isArray(dispatchIDs), IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0, listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen, "EventPluginUtils: Invalid `event`.")
      };
      var EventPluginUtils = {
        isEndish: isEndish,
        isMoveish: isMoveish,
        isStartish: isStartish,
        executeDirectDispatch: executeDirectDispatch,
        executeDispatch: executeDispatch,
        executeDispatchesInOrder: executeDispatchesInOrder,
        executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
        hasDispatches: hasDispatches,
        injection: injection,
        useTouchEvents: !1
      };
      module.exports = EventPluginUtils
    }, { 135: 135, 15: 15 }],
    20: [function(_dereq_, module, exports) {
      "use strict";
      function listenerAtPhase(id, event, propagationPhase) {
        var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
        return getListener(id, registrationName)
      }

      function accumulateDirectionalDispatches(domID, upwards, event) {
        if (!domID)throw new Error("Dispatching id must not be null");
        var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured, listener = listenerAtPhase(domID, event, phase);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchIDs = accumulateInto(event._dispatchIDs, domID))
      }

      function accumulateTwoPhaseDispatchesSingle(event) {
        event && event.dispatchConfig.phasedRegistrationNames && EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event)
      }

      function accumulateDispatches(id, ignoredDirection, event) {
        if (event && event.dispatchConfig.registrationName) {
          var registrationName = event.dispatchConfig.registrationName, listener = getListener(id, registrationName);
          listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchIDs = accumulateInto(event._dispatchIDs, id))
        }
      }

      function accumulateDirectDispatchesSingle(event) {
        event && event.dispatchConfig.registrationName && accumulateDispatches(event.dispatchMarker, null, event)
      }

      function accumulateTwoPhaseDispatches(events) {
        forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle)
      }

      function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
        EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter)
      }

      function accumulateDirectDispatches(events) {
        forEachAccumulated(events, accumulateDirectDispatchesSingle)
      }

      var EventConstants = _dereq_(15), EventPluginHub = _dereq_(17), accumulateInto = _dereq_(105), forEachAccumulated = _dereq_(120), PropagationPhases = EventConstants.PropagationPhases, getListener = EventPluginHub.getListener, EventPropagators = {
        accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
        accumulateDirectDispatches: accumulateDirectDispatches,
        accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
      };
      module.exports = EventPropagators
    }, { 105: 105, 120: 120, 15: 15, 17: 17 }],
    21: [function(_dereq_, module, exports) {
      "use strict";
      var canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement), ExecutionEnvironment = {
        canUseDOM: canUseDOM,
        canUseWorkers: "undefined" != typeof Worker,
        canUseEventListeners: canUseDOM && !(!window.addEventListener && !window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen,
        isInWorker: !canUseDOM
      };
      module.exports = ExecutionEnvironment
    }, {}],
    22: [function(_dereq_, module, exports) {
      "use strict";
      function FallbackCompositionState(root) {
        this._root = root, this._startText = this.getText(), this._fallbackText = null
      }

      var PooledClass = _dereq_(28), assign = _dereq_(27), getTextContentAccessor = _dereq_(130);
      assign(FallbackCompositionState.prototype, {
        getText: function() {
          return "value" in this._root ? this._root.value : this._root[getTextContentAccessor()]
        }, getData: function() {
          if (this._fallbackText)return this._fallbackText;
          var start, end, startValue = this._startText, startLength = startValue.length, endValue = this.getText(), endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
          var sliceTail = end > 1 ? 1 - end : void 0;
          return this._fallbackText = endValue.slice(start, sliceTail), this._fallbackText
        }
      }), PooledClass.addPoolingTo(FallbackCompositionState), module.exports = FallbackCompositionState
    }, { 130: 130, 27: 27, 28: 28 }],
    23: [function(_dereq_, module, exports) {
      "use strict";
      var hasSVG, DOMProperty = _dereq_(10), ExecutionEnvironment = _dereq_(21), MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE, MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY, HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE, HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS, HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE, HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE, HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
      if (ExecutionEnvironment.canUseDOM) {
        var implementation = document.implementation;
        hasSVG = implementation && implementation.hasFeature && implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")
      }
      var HTMLDOMPropertyConfig = {
        isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
        Properties: {
          accept: null,
          acceptCharset: null,
          accessKey: null,
          action: null,
          allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
          allowTransparency: MUST_USE_ATTRIBUTE,
          alt: null,
          async: HAS_BOOLEAN_VALUE,
          autoComplete: null,
          autoPlay: HAS_BOOLEAN_VALUE,
          cellPadding: null,
          cellSpacing: null,
          charSet: MUST_USE_ATTRIBUTE,
          checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          classID: MUST_USE_ATTRIBUTE,
          className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
          cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
          colSpan: null,
          content: null,
          contentEditable: null,
          contextMenu: MUST_USE_ATTRIBUTE,
          controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          coords: null,
          crossOrigin: null,
          data: null,
          dateTime: MUST_USE_ATTRIBUTE,
          defer: HAS_BOOLEAN_VALUE,
          dir: null,
          disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
          download: HAS_OVERLOADED_BOOLEAN_VALUE,
          draggable: null,
          encType: null,
          form: MUST_USE_ATTRIBUTE,
          formAction: MUST_USE_ATTRIBUTE,
          formEncType: MUST_USE_ATTRIBUTE,
          formMethod: MUST_USE_ATTRIBUTE,
          formNoValidate: HAS_BOOLEAN_VALUE,
          formTarget: MUST_USE_ATTRIBUTE,
          frameBorder: MUST_USE_ATTRIBUTE,
          headers: null,
          height: MUST_USE_ATTRIBUTE,
          hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
          href: null,
          hrefLang: null,
          htmlFor: null,
          httpEquiv: null,
          icon: null,
          id: MUST_USE_PROPERTY,
          label: null,
          lang: null,
          list: MUST_USE_ATTRIBUTE,
          loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          manifest: MUST_USE_ATTRIBUTE,
          marginHeight: null,
          marginWidth: null,
          max: null,
          maxLength: MUST_USE_ATTRIBUTE,
          media: MUST_USE_ATTRIBUTE,
          mediaGroup: null,
          method: null,
          min: null,
          multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          name: null,
          noValidate: HAS_BOOLEAN_VALUE,
          open: HAS_BOOLEAN_VALUE,
          pattern: null,
          placeholder: null,
          poster: null,
          preload: null,
          radioGroup: null,
          readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          rel: null,
          required: HAS_BOOLEAN_VALUE,
          role: MUST_USE_ATTRIBUTE,
          rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
          rowSpan: null,
          sandbox: null,
          scope: null,
          scrolling: null,
          seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
          selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
          shape: null,
          size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
          sizes: MUST_USE_ATTRIBUTE,
          span: HAS_POSITIVE_NUMERIC_VALUE,
          spellCheck: null,
          src: null,
          srcDoc: MUST_USE_PROPERTY,
          srcSet: MUST_USE_ATTRIBUTE,
          start: HAS_NUMERIC_VALUE,
          step: null,
          style: null,
          tabIndex: null,
          target: null,
          title: null,
          type: null,
          useMap: null,
          value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
          width: MUST_USE_ATTRIBUTE,
          wmode: MUST_USE_ATTRIBUTE,
          autoCapitalize: null,
          autoCorrect: null,
          itemProp: MUST_USE_ATTRIBUTE,
          itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
          itemType: MUST_USE_ATTRIBUTE,
          itemID: MUST_USE_ATTRIBUTE,
          itemRef: MUST_USE_ATTRIBUTE,
          property: null
        },
        DOMAttributeNames: {
          acceptCharset: "accept-charset",
          className: "class",
          htmlFor: "for",
          httpEquiv: "http-equiv"
        },
        DOMPropertyNames: {
          autoCapitalize: "autocapitalize",
          autoComplete: "autocomplete",
          autoCorrect: "autocorrect",
          autoFocus: "autofocus",
          autoPlay: "autoplay",
          encType: "encoding",
          hrefLang: "hreflang",
          radioGroup: "radiogroup",
          spellCheck: "spellcheck",
          srcDoc: "srcdoc",
          srcSet: "srcset"
        }
      };
      module.exports = HTMLDOMPropertyConfig
    }, { 10: 10, 21: 21 }],
    24: [function(_dereq_, module, exports) {
      "use strict";
      function _assertSingleLink(input) {
        invariant(null == input.props.checkedLink || null == input.props.valueLink, "Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don't want to use valueLink and vice versa.")
      }

      function _assertValueLink(input) {
        _assertSingleLink(input), invariant(null == input.props.value && null == input.props.onChange, "Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don't want to use valueLink.");
      }

      function _assertCheckedLink(input) {
        _assertSingleLink(input), invariant(null == input.props.checked && null == input.props.onChange, "Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don't want to use checkedLink")
      }

      function _handleLinkedValueChange(e) {
        this.props.valueLink.requestChange(e.target.value)
      }

      function _handleLinkedCheckChange(e) {
        this.props.checkedLink.requestChange(e.target.checked)
      }

      var ReactPropTypes = _dereq_(78), invariant = _dereq_(135), hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      }, LinkedValueUtils = {
        Mixin: {
          propTypes: {
            value: function(props, propName, componentName) {
              return !props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled ? null : new Error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.")
            }, checked: function(props, propName, componentName) {
              return !props[propName] || props.onChange || props.readOnly || props.disabled ? null : new Error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.")
            }, onChange: ReactPropTypes.func
          }
        }, getValue: function(input) {
          return input.props.valueLink ? (_assertValueLink(input), input.props.valueLink.value) : input.props.value
        }, getChecked: function(input) {
          return input.props.checkedLink ? (_assertCheckedLink(input), input.props.checkedLink.value) : input.props.checked
        }, getOnChange: function(input) {
          return input.props.valueLink ? (_assertValueLink(input), _handleLinkedValueChange) : input.props.checkedLink ? (_assertCheckedLink(input), _handleLinkedCheckChange) : input.props.onChange
        }
      };
      module.exports = LinkedValueUtils
    }, { 135: 135, 78: 78 }],
    25: [function(_dereq_, module, exports) {
      "use strict";
      function remove(event) {
        event.remove()
      }

      var ReactBrowserEventEmitter = _dereq_(30), accumulateInto = _dereq_(105), forEachAccumulated = _dereq_(120), invariant = _dereq_(135), LocalEventTrapMixin = {
        trapBubbledEvent: function(topLevelType, handlerBaseName) {
          invariant(this.isMounted(), "Must be mounted to trap events");
          var node = this.getDOMNode();
          invariant(node, "LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.");
          var listener = ReactBrowserEventEmitter.trapBubbledEvent(topLevelType, handlerBaseName, node);
          this._localEventListeners = accumulateInto(this._localEventListeners, listener)
        }, componentWillUnmount: function() {
          this._localEventListeners && forEachAccumulated(this._localEventListeners, remove)
        }
      };
      module.exports = LocalEventTrapMixin
    }, { 105: 105, 120: 120, 135: 135, 30: 30 }],
    26: [function(_dereq_, module, exports) {
      "use strict";
      var EventConstants = _dereq_(15), emptyFunction = _dereq_(114), topLevelTypes = EventConstants.topLevelTypes, MobileSafariClickEventPlugin = {
        eventTypes: null,
        extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          if (topLevelType === topLevelTypes.topTouchStart) {
            var target = nativeEvent.target;
            target && !target.onclick && (target.onclick = emptyFunction)
          }
        }
      };
      module.exports = MobileSafariClickEventPlugin
    }, { 114: 114, 15: 15 }],
    27: [function(_dereq_, module, exports) {
      "use strict";
      function assign(target, sources) {
        if (null == target)throw new TypeError("Object.assign target cannot be null or undefined");
        for (var to = Object(target), hasOwnProperty = Object.prototype.hasOwnProperty, nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
          var nextSource = arguments[nextIndex];
          if (null != nextSource) {
            var from = Object(nextSource);
            for (var key in from)hasOwnProperty.call(from, key) && (to[key] = from[key])
          }
        }
        return to
      }

      module.exports = assign
    }, {}],
    28: [function(_dereq_, module, exports) {
      "use strict";
      var invariant = _dereq_(135), oneArgumentPooler = function(copyFieldsFrom) {
        var Klass = this;
        if (Klass.instancePool.length) {
          var instance = Klass.instancePool.pop();
          return Klass.call(instance, copyFieldsFrom), instance
        }
        return new Klass(copyFieldsFrom)
      }, twoArgumentPooler = function(a1, a2) {
        var Klass = this;
        if (Klass.instancePool.length) {
          var instance = Klass.instancePool.pop();
          return Klass.call(instance, a1, a2), instance
        }
        return new Klass(a1, a2)
      }, threeArgumentPooler = function(a1, a2, a3) {
        var Klass = this;
        if (Klass.instancePool.length) {
          var instance = Klass.instancePool.pop();
          return Klass.call(instance, a1, a2, a3), instance
        }
        return new Klass(a1, a2, a3)
      }, fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
        var Klass = this;
        if (Klass.instancePool.length) {
          var instance = Klass.instancePool.pop();
          return Klass.call(instance, a1, a2, a3, a4, a5), instance
        }
        return new Klass(a1, a2, a3, a4, a5)
      }, standardReleaser = function(instance) {
        var Klass = this;
        invariant(instance instanceof Klass, "Trying to release an instance into a pool of a different type."), instance.destructor && instance.destructor(), Klass.instancePool.length < Klass.poolSize && Klass.instancePool.push(instance)
      }, DEFAULT_POOL_SIZE = 10, DEFAULT_POOLER = oneArgumentPooler, addPoolingTo = function(CopyConstructor, pooler) {
        var NewKlass = CopyConstructor;
        return NewKlass.instancePool = [], NewKlass.getPooled = pooler || DEFAULT_POOLER, NewKlass.poolSize || (NewKlass.poolSize = DEFAULT_POOL_SIZE), NewKlass.release = standardReleaser, NewKlass
      }, PooledClass = {
        addPoolingTo: addPoolingTo,
        oneArgumentPooler: oneArgumentPooler,
        twoArgumentPooler: twoArgumentPooler,
        threeArgumentPooler: threeArgumentPooler,
        fiveArgumentPooler: fiveArgumentPooler
      };
      module.exports = PooledClass
    }, { 135: 135 }],
    29: [function(_dereq_, module, exports) {
      "use strict";
      var findDOMNode = _dereq_(117), ReactBrowserComponentMixin = {
        getDOMNode: function() {
          return findDOMNode(this)
        }
      };
      module.exports = ReactBrowserComponentMixin
    }, { 117: 117 }],
    30: [function(_dereq_, module, exports) {
      "use strict";
      function getListeningForDocument(mountAt) {
        return Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey) || (mountAt[topListenersIDKey] = reactTopListenersCounter++, alreadyListeningTo[mountAt[topListenersIDKey]] = {}), alreadyListeningTo[mountAt[topListenersIDKey]]
      }

      var EventConstants = _dereq_(15), EventPluginHub = _dereq_(17), EventPluginRegistry = _dereq_(18), ReactEventEmitterMixin = _dereq_(61), ViewportMetrics = _dereq_(104), assign = _dereq_(27), isEventSupported = _dereq_(136), alreadyListeningTo = {}, isMonitoringScrollValue = !1, reactTopListenersCounter = 0, topEventMapping = {
        topBlur: "blur",
        topChange: "change",
        topClick: "click",
        topCompositionEnd: "compositionend",
        topCompositionStart: "compositionstart",
        topCompositionUpdate: "compositionupdate",
        topContextMenu: "contextmenu",
        topCopy: "copy",
        topCut: "cut",
        topDoubleClick: "dblclick",
        topDrag: "drag",
        topDragEnd: "dragend",
        topDragEnter: "dragenter",
        topDragExit: "dragexit",
        topDragLeave: "dragleave",
        topDragOver: "dragover",
        topDragStart: "dragstart",
        topDrop: "drop",
        topFocus: "focus",
        topInput: "input",
        topKeyDown: "keydown",
        topKeyPress: "keypress",
        topKeyUp: "keyup",
        topMouseDown: "mousedown",
        topMouseMove: "mousemove",
        topMouseOut: "mouseout",
        topMouseOver: "mouseover",
        topMouseUp: "mouseup",
        topPaste: "paste",
        topScroll: "scroll",
        topSelectionChange: "selectionchange",
        topTextInput: "textInput",
        topTouchCancel: "touchcancel",
        topTouchEnd: "touchend",
        topTouchMove: "touchmove",
        topTouchStart: "touchstart",
        topWheel: "wheel"
      }, topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2), ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
        ReactEventListener: null,
        injection: {
          injectReactEventListener: function(ReactEventListener) {
            ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel), ReactBrowserEventEmitter.ReactEventListener = ReactEventListener
          }
        },
        setEnabled: function(enabled) {
          ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled)
        },
        isEnabled: function() {
          return !(!ReactBrowserEventEmitter.ReactEventListener || !ReactBrowserEventEmitter.ReactEventListener.isEnabled())
        },
        listenTo: function(registrationName, contentDocumentHandle) {
          for (var mountAt = contentDocumentHandle, isListening = getListeningForDocument(mountAt), dependencies = EventPluginRegistry.registrationNameDependencies[registrationName], topLevelTypes = EventConstants.topLevelTypes, i = 0, l = dependencies.length; i < l; i++) {
            var dependency = dependencies[i];
            isListening.hasOwnProperty(dependency) && isListening[dependency] || (dependency === topLevelTypes.topWheel ? isEventSupported("wheel") ? ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "wheel", mountAt) : isEventSupported("mousewheel") ? ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "mousewheel", mountAt) : ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, "DOMMouseScroll", mountAt) : dependency === topLevelTypes.topScroll ? isEventSupported("scroll", !0) ? ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, "scroll", mountAt) : ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, "scroll", ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE) : dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur ? (isEventSupported("focus", !0) ? (ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, "focus", mountAt), ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, "blur", mountAt)) : isEventSupported("focusin") && (ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, "focusin", mountAt), ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, "focusout", mountAt)), isListening[topLevelTypes.topBlur] = !0, isListening[topLevelTypes.topFocus] = !0) : topEventMapping.hasOwnProperty(dependency) && ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt), isListening[dependency] = !0)
          }
        },
        trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
          return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle)
        },
        trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
          return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle)
        },
        ensureScrollValueMonitoring: function() {
          if (!isMonitoringScrollValue) {
            var refresh = ViewportMetrics.refreshScrollValues;
            ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh), isMonitoringScrollValue = !0
          }
        },
        eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
        registrationNameModules: EventPluginHub.registrationNameModules,
        putListener: EventPluginHub.putListener,
        getListener: EventPluginHub.getListener,
        deleteListener: EventPluginHub.deleteListener,
        deleteAllListeners: EventPluginHub.deleteAllListeners
      });
      module.exports = ReactBrowserEventEmitter
    }, { 104: 104, 136: 136, 15: 15, 17: 17, 18: 18, 27: 27, 61: 61 }],
    31: [function(_dereq_, module, exports) {
      "use strict";
      var ReactReconciler = _dereq_(81), flattenChildren = _dereq_(118), instantiateReactComponent = _dereq_(134), shouldUpdateReactComponent = _dereq_(151), ReactChildReconciler = {
        instantiateChildren: function(nestedChildNodes, transaction, context) {
          var children = flattenChildren(nestedChildNodes);
          for (var name in children)if (children.hasOwnProperty(name)) {
            var child = children[name], childInstance = instantiateReactComponent(child, null);
            children[name] = childInstance
          }
          return children
        }, updateChildren: function(prevChildren, nextNestedChildNodes, transaction, context) {
          var nextChildren = flattenChildren(nextNestedChildNodes);
          if (!nextChildren && !prevChildren)return null;
          var name;
          for (name in nextChildren)if (nextChildren.hasOwnProperty(name)) {
            var prevChild = prevChildren && prevChildren[name], prevElement = prevChild && prevChild._currentElement, nextElement = nextChildren[name];
            if (shouldUpdateReactComponent(prevElement, nextElement))ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context), nextChildren[name] = prevChild; else {
              prevChild && ReactReconciler.unmountComponent(prevChild, name);
              var nextChildInstance = instantiateReactComponent(nextElement, null);
              nextChildren[name] = nextChildInstance
            }
          }
          for (name in prevChildren)!prevChildren.hasOwnProperty(name) || nextChildren && nextChildren.hasOwnProperty(name) || ReactReconciler.unmountComponent(prevChildren[name]);
          return nextChildren
        }, unmountChildren: function(renderedChildren) {
          for (var name in renderedChildren) {
            var renderedChild = renderedChildren[name];
            ReactReconciler.unmountComponent(renderedChild)
          }
        }
      };
      module.exports = ReactChildReconciler
    }, { 118: 118, 134: 134, 151: 151, 81: 81 }],
    32: [function(_dereq_, module, exports) {
      "use strict";
      function ForEachBookKeeping(forEachFunction, forEachContext) {
        this.forEachFunction = forEachFunction, this.forEachContext = forEachContext
      }

      function forEachSingleChild(traverseContext, child, name, i) {
        var forEachBookKeeping = traverseContext;
        forEachBookKeeping.forEachFunction.call(forEachBookKeeping.forEachContext, child, i)
      }

      function forEachChildren(children, forEachFunc, forEachContext) {
        if (null == children)return children;
        var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
        traverseAllChildren(children, forEachSingleChild, traverseContext), ForEachBookKeeping.release(traverseContext)
      }

      function MapBookKeeping(mapResult, mapFunction, mapContext) {
        this.mapResult = mapResult, this.mapFunction = mapFunction, this.mapContext = mapContext
      }

      function mapSingleChildIntoContext(traverseContext, child, name, i) {
        var mapBookKeeping = traverseContext, mapResult = mapBookKeeping.mapResult, keyUnique = !mapResult.hasOwnProperty(name);
        if (warning(keyUnique, "ReactChildren.map(...): Encountered two children with the same key, `%s`. Child keys must be unique; when two children share a key, only the first child will be used.", name), keyUnique) {
          var mappedChild = mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
          mapResult[name] = mappedChild
        }
      }

      function mapChildren(children, func, context) {
        if (null == children)return children;
        var mapResult = {}, traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
        return traverseAllChildren(children, mapSingleChildIntoContext, traverseContext), MapBookKeeping.release(traverseContext), ReactFragment.create(mapResult)
      }

      function forEachSingleChildDummy(traverseContext, child, name, i) {
        return null
      }

      function countChildren(children, context) {
        return traverseAllChildren(children, forEachSingleChildDummy, null)
      }

      var PooledClass = _dereq_(28), ReactFragment = _dereq_(63), traverseAllChildren = _dereq_(153), warning = _dereq_(154), twoArgumentPooler = PooledClass.twoArgumentPooler, threeArgumentPooler = PooledClass.threeArgumentPooler;
      PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler), PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);
      var ReactChildren = { forEach: forEachChildren, map: mapChildren, count: countChildren };
      module.exports = ReactChildren
    }, { 153: 153, 154: 154, 28: 28, 63: 63 }],
    33: [function(_dereq_, module, exports) {
      "use strict";
      function validateTypeDef(Constructor, typeDef, location) {
        for (var propName in typeDef)typeDef.hasOwnProperty(propName) && warning("function" == typeof typeDef[propName], "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName)
      }

      function validateMethodOverride(proto, name) {
        var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
        ReactClassMixin.hasOwnProperty(name) && invariant(specPolicy === SpecPolicy.OVERRIDE_BASE, "ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.", name), proto.hasOwnProperty(name) && invariant(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED, "ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name)
      }

      function mixSpecIntoComponent(Constructor, spec) {
        if (spec) {
          invariant("function" != typeof spec, "ReactClass: You're attempting to use a component class as a mixin. Instead, just use a regular object."), invariant(!ReactElement.isValidElement(spec), "ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object.");
          var proto = Constructor.prototype;
          spec.hasOwnProperty(MIXINS_KEY) && RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
          for (var name in spec)if (spec.hasOwnProperty(name) && name !== MIXINS_KEY) {
            var property = spec[name];
            if (validateMethodOverride(proto, name), RESERVED_SPEC_KEYS.hasOwnProperty(name))RESERVED_SPEC_KEYS[name](Constructor, property); else {
              var isReactClassMethod = ReactClassInterface.hasOwnProperty(name), isAlreadyDefined = proto.hasOwnProperty(name), markedDontBind = property && property.__reactDontBind, isFunction = "function" == typeof property, shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && !markedDontBind;
              if (shouldAutoBind)proto.__reactAutoBindMap || (proto.__reactAutoBindMap = {}), proto.__reactAutoBindMap[name] = property, proto[name] = property; else if (isAlreadyDefined) {
                var specPolicy = ReactClassInterface[name];
                invariant(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY), "ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.", specPolicy, name), specPolicy === SpecPolicy.DEFINE_MANY_MERGED ? proto[name] = createMergedResultFunction(proto[name], property) : specPolicy === SpecPolicy.DEFINE_MANY && (proto[name] = createChainedFunction(proto[name], property))
              } else proto[name] = property, "function" == typeof property && spec.displayName && (proto[name].displayName = spec.displayName + "_" + name)
            }
          }
        }
      }

      function mixStaticSpecIntoComponent(Constructor, statics) {
        if (statics)for (var name in statics) {
          var property = statics[name];
          if (statics.hasOwnProperty(name)) {
            var isReserved = name in RESERVED_SPEC_KEYS;
            invariant(!isReserved, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name);
            var isInherited = name in Constructor;
            invariant(!isInherited, "ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name), Constructor[name] = property
          }
        }
      }

      function mergeIntoWithNoDuplicateKeys(one, two) {
        invariant(one && two && "object" == typeof one && "object" == typeof two, "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");
        for (var key in two)two.hasOwnProperty(key) && (invariant(void 0 === one[key], "mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.", key), one[key] = two[key]);
        return one
      }

      function createMergedResultFunction(one, two) {
        return function() {
          var a = one.apply(this, arguments), b = two.apply(this, arguments);
          if (null == a)return b;
          if (null == b)return a;
          var c = {};
          return mergeIntoWithNoDuplicateKeys(c, a), mergeIntoWithNoDuplicateKeys(c, b), c
        }
      }

      function createChainedFunction(one, two) {
        return function() {
          one.apply(this, arguments), two.apply(this, arguments)
        }
      }

      function bindAutoBindMethod(component, method) {
        var boundMethod = method.bind(component);
        boundMethod.__reactBoundContext = component, boundMethod.__reactBoundMethod = method, boundMethod.__reactBoundArguments = null;
        var componentName = component.constructor.displayName, _bind = boundMethod.bind;
        return boundMethod.bind = function(newThis) {
          for (var args = [], $__0 = 1, $__1 = arguments.length; $__0 < $__1; $__0++)args.push(arguments[$__0]);
          if (newThis !== component && null !== newThis)warning(!1, "bind(): React component methods may only be bound to the component instance. See %s", componentName); else if (!args.length)return warning(!1, "bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s", componentName), boundMethod;
          var reboundMethod = _bind.apply(boundMethod, arguments);
          return reboundMethod.__reactBoundContext = component, reboundMethod.__reactBoundMethod = method, reboundMethod.__reactBoundArguments = args, reboundMethod
        }, boundMethod
      }

      function bindAutoBindMethods(component) {
        for (var autoBindKey in component.__reactAutoBindMap)if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
          var method = component.__reactAutoBindMap[autoBindKey];
          component[autoBindKey] = bindAutoBindMethod(component, ReactErrorUtils.guard(method, component.constructor.displayName + "." + autoBindKey))
        }
      }

      var ReactComponent = _dereq_(34), ReactCurrentOwner = _dereq_(39), ReactElement = _dereq_(57), ReactErrorUtils = _dereq_(60), ReactInstanceMap = _dereq_(67), ReactLifeCycle = _dereq_(68), ReactPropTypeLocations = _dereq_(77), ReactPropTypeLocationNames = _dereq_(76), ReactUpdateQueue = _dereq_(86), assign = _dereq_(27), invariant = _dereq_(135), keyMirror = _dereq_(140), keyOf = _dereq_(141), warning = _dereq_(154), MIXINS_KEY = keyOf({ mixins: null }), SpecPolicy = keyMirror({
        DEFINE_ONCE: null,
        DEFINE_MANY: null,
        OVERRIDE_BASE: null,
        DEFINE_MANY_MERGED: null
      }), injectedMixins = [], ReactClassInterface = {
        mixins: SpecPolicy.DEFINE_MANY,
        statics: SpecPolicy.DEFINE_MANY,
        propTypes: SpecPolicy.DEFINE_MANY,
        contextTypes: SpecPolicy.DEFINE_MANY,
        childContextTypes: SpecPolicy.DEFINE_MANY,
        getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
        getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
        getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
        render: SpecPolicy.DEFINE_ONCE,
        componentWillMount: SpecPolicy.DEFINE_MANY,
        componentDidMount: SpecPolicy.DEFINE_MANY,
        componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
        shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
        componentWillUpdate: SpecPolicy.DEFINE_MANY,
        componentDidUpdate: SpecPolicy.DEFINE_MANY,
        componentWillUnmount: SpecPolicy.DEFINE_MANY,
        updateComponent: SpecPolicy.OVERRIDE_BASE
      }, RESERVED_SPEC_KEYS = {
        displayName: function(Constructor, displayName) {
          Constructor.displayName = displayName
        }, mixins: function(Constructor, mixins) {
          if (mixins)for (var i = 0; i < mixins.length; i++)mixSpecIntoComponent(Constructor, mixins[i])
        }, childContextTypes: function(Constructor, childContextTypes) {
          validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext), Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes)
        }, contextTypes: function(Constructor, contextTypes) {
          validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context), Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes)
        }, getDefaultProps: function(Constructor, getDefaultProps) {
          Constructor.getDefaultProps ? Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps) : Constructor.getDefaultProps = getDefaultProps
        }, propTypes: function(Constructor, propTypes) {
          validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop), Constructor.propTypes = assign({}, Constructor.propTypes, propTypes)
        }, statics: function(Constructor, statics) {
          mixStaticSpecIntoComponent(Constructor, statics)
        }
      }, typeDeprecationDescriptor = {
        enumerable: !1, get: function() {
          var displayName = this.displayName || this.name || "Component";
          return warning(!1, "%s.type is deprecated. Use %s directly to access the class.", displayName, displayName), Object.defineProperty(this, "type", { value: this }), this
        }
      }, ReactClassMixin = {
        replaceState: function(newState, callback) {
          ReactUpdateQueue.enqueueReplaceState(this, newState), callback && ReactUpdateQueue.enqueueCallback(this, callback)
        }, isMounted: function() {
          var owner = ReactCurrentOwner.current;
          null !== owner && (warning(owner._warnedAboutRefsInRender, "%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", owner.getName() || "A component"), owner._warnedAboutRefsInRender = !0);
          var internalInstance = ReactInstanceMap.get(this);
          return internalInstance && internalInstance !== ReactLifeCycle.currentlyMountingInstance
        }, setProps: function(partialProps, callback) {
          ReactUpdateQueue.enqueueSetProps(this, partialProps), callback && ReactUpdateQueue.enqueueCallback(this, callback)
        }, replaceProps: function(newProps, callback) {
          ReactUpdateQueue.enqueueReplaceProps(this, newProps), callback && ReactUpdateQueue.enqueueCallback(this, callback)
        }
      }, ReactClassComponent = function() {
      };
      assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
      var ReactClass = {
        createClass: function(spec) {
          var Constructor = function(props, context) {
            warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or JSX instead. See: http://fb.me/react-legacyfactory"), this.__reactAutoBindMap && bindAutoBindMethods(this), this.props = props, this.context = context, this.state = null;
            var initialState = this.getInitialState ? this.getInitialState() : null;
            "undefined" == typeof initialState && this.getInitialState._isMockFunction && (initialState = null), invariant("object" == typeof initialState && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent"), this.state = initialState
          };
          Constructor.prototype = new ReactClassComponent, Constructor.prototype.constructor = Constructor, injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor)), mixSpecIntoComponent(Constructor, spec), Constructor.getDefaultProps && (Constructor.defaultProps = Constructor.getDefaultProps()), Constructor.getDefaultProps && (Constructor.getDefaultProps.isReactClassApproved = {}), Constructor.prototype.getInitialState && (Constructor.prototype.getInitialState.isReactClassApproved = {}), invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method."), warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", spec.displayName || "A component");
          for (var methodName in ReactClassInterface)Constructor.prototype[methodName] || (Constructor.prototype[methodName] = null);
          Constructor.type = Constructor;
          try {
            Object.defineProperty(Constructor, "type", typeDeprecationDescriptor)
          } catch (x) {
          }
          return Constructor
        }, injection: {
          injectMixin: function(mixin) {
            injectedMixins.push(mixin)
          }
        }
      };
      module.exports = ReactClass
    }, {
      135: 135,
      140: 140,
      141: 141,
      154: 154,
      27: 27,
      34: 34,
      39: 39,
      57: 57,
      60: 60,
      67: 67,
      68: 68,
      76: 76,
      77: 77,
      86: 86
    }],
    34: [function(_dereq_, module, exports) {
      "use strict";
      function ReactComponent(props, context) {
        this.props = props, this.context = context
      }

      var ReactUpdateQueue = _dereq_(86), invariant = _dereq_(135), warning = _dereq_(154);
      ReactComponent.prototype.setState = function(partialState, callback) {
        invariant("object" == typeof partialState || "function" == typeof partialState || null == partialState, "setState(...): takes an object of state variables to update or a function which returns an object of state variables."), warning(null != partialState, "setState(...): You passed an undefined or null state object; instead, use forceUpdate()."), ReactUpdateQueue.enqueueSetState(this, partialState), callback && ReactUpdateQueue.enqueueCallback(this, callback)
      }, ReactComponent.prototype.forceUpdate = function(callback) {
        ReactUpdateQueue.enqueueForceUpdate(this), callback && ReactUpdateQueue.enqueueCallback(this, callback)
      };
      var deprecatedAPIs = {
        getDOMNode: "getDOMNode",
        isMounted: "isMounted",
        replaceProps: "replaceProps",
        replaceState: "replaceState",
        setProps: "setProps"
      }, defineDeprecationWarning = function(methodName, displayName) {
        try {
          Object.defineProperty(ReactComponent.prototype, methodName, {
            get: function() {
              warning(!1, "%s(...) is deprecated in plain JavaScript React classes.", displayName)
            }
          })
        } catch (x) {
        }
      };
      for (var fnName in deprecatedAPIs)deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      module.exports = ReactComponent
    }, { 135: 135, 154: 154, 86: 86 }],
    35: [function(_dereq_, module, exports) {
      "use strict";
      var ReactDOMIDOperations = _dereq_(44), ReactMount = _dereq_(70), ReactComponentBrowserEnvironment = {
        processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
        replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
        unmountIDFromEnvironment: function(rootNodeID) {
          ReactMount.purgeID(rootNodeID)
        }
      };
      module.exports = ReactComponentBrowserEnvironment
    }, { 44: 44, 70: 70 }],
    36: [function(_dereq_, module, exports) {
      "use strict";
      var invariant = _dereq_(135), injected = !1, ReactComponentEnvironment = {
        unmountIDFromEnvironment: null,
        replaceNodeWithMarkupByID: null,
        processChildrenUpdates: null,
        injection: {
          injectEnvironment: function(environment) {
            invariant(!injected, "ReactCompositeComponent: injectEnvironment() can only be called once."), ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment, ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID, ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates, injected = !0
          }
        }
      };
      module.exports = ReactComponentEnvironment
    }, { 135: 135 }],
    37: [function(_dereq_, module, exports) {
      "use strict";
      function getDeclarationErrorAddendum(component) {
        var owner = component._currentElement._owner || null;
        if (owner) {
          var name = owner.getName();
          if (name)return " Check the render method of `" + name + "`."
        }
        return ""
      }

      var ReactComponentEnvironment = _dereq_(36), ReactContext = _dereq_(38), ReactCurrentOwner = _dereq_(39), ReactElement = _dereq_(57), ReactElementValidator = _dereq_(58), ReactInstanceMap = _dereq_(67), ReactLifeCycle = _dereq_(68), ReactNativeComponent = _dereq_(73), ReactPerf = _dereq_(75), ReactPropTypeLocations = _dereq_(77), ReactPropTypeLocationNames = _dereq_(76), ReactReconciler = _dereq_(81), ReactUpdates = _dereq_(87), assign = _dereq_(27), emptyObject = _dereq_(115), invariant = _dereq_(135), shouldUpdateReactComponent = _dereq_(151), warning = _dereq_(154), nextMountID = 1, ReactCompositeComponentMixin = {
        construct: function(element) {
          this._currentElement = element, this._rootNodeID = null, this._instance = null, this._pendingElement = null, this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1, this._renderedComponent = null, this._context = null, this._mountOrder = 0, this._isTopLevel = !1, this._pendingCallbacks = null
        },
        mountComponent: function(rootID, transaction, context) {
          this._context = context, this._mountOrder = nextMountID++, this._rootNodeID = rootID;
          var publicProps = this._processProps(this._currentElement.props), publicContext = this._processContext(this._currentElement._context), Component = ReactNativeComponent.getComponentClassForElement(this._currentElement), inst = new Component(publicProps, publicContext);
          warning(null != inst.render, "%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render` in your component or you may have accidentally tried to render an element whose type is a function that isn't a React component.", Component.displayName || Component.name || "Component"), inst.props = publicProps, inst.context = publicContext, inst.refs = emptyObject, this._instance = inst, ReactInstanceMap.set(inst, this), this._warnIfContextsDiffer(this._currentElement._context, context), warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", this.getName() || "a component"), warning(!inst.propTypes, "propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", this.getName() || "a component"), warning(!inst.contextTypes, "contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", this.getName() || "a component"), warning("function" != typeof inst.componentShouldUpdate, "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", this.getName() || "A component");
          var initialState = inst.state;
          void 0 === initialState && (inst.state = initialState = null), invariant("object" == typeof initialState && !Array.isArray(initialState), "%s.state: must be set to an object or null", this.getName() || "ReactCompositeComponent"), this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1;
          var renderedElement, previouslyMounting = ReactLifeCycle.currentlyMountingInstance;
          ReactLifeCycle.currentlyMountingInstance = this;
          try {
            inst.componentWillMount && (inst.componentWillMount(), this._pendingStateQueue && (inst.state = this._processPendingState(inst.props, inst.context))), renderedElement = this._renderValidatedComponent()
          } finally {
            ReactLifeCycle.currentlyMountingInstance = previouslyMounting
          }
          this._renderedComponent = this._instantiateReactComponent(renderedElement, this._currentElement.type);
          var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
          return inst.componentDidMount && transaction.getReactMountReady().enqueue(inst.componentDidMount, inst), markup
        },
        unmountComponent: function() {
          var inst = this._instance;
          if (inst.componentWillUnmount) {
            var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;
            ReactLifeCycle.currentlyUnmountingInstance = this;
            try {
              inst.componentWillUnmount()
            } finally {
              ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting
            }
          }
          ReactReconciler.unmountComponent(this._renderedComponent), this._renderedComponent = null, this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1, this._pendingCallbacks = null, this._pendingElement = null, this._context = null, this._rootNodeID = null, ReactInstanceMap.remove(inst)
        },
        _setPropsInternal: function(partialProps, callback) {
          var element = this._pendingElement || this._currentElement;
          this._pendingElement = ReactElement.cloneAndReplaceProps(element, assign({}, element.props, partialProps)), ReactUpdates.enqueueUpdate(this, callback)
        },
        _maskContext: function(context) {
          var maskedContext = null;
          if ("string" == typeof this._currentElement.type)return emptyObject;
          var contextTypes = this._currentElement.type.contextTypes;
          if (!contextTypes)return emptyObject;
          maskedContext = {};
          for (var contextName in contextTypes)maskedContext[contextName] = context[contextName];
          return maskedContext
        },
        _processContext: function(context) {
          var maskedContext = this._maskContext(context), Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
          return Component.contextTypes && this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context), maskedContext
        },
        _processChildContext: function(currentContext) {
          var inst = this._instance, childContext = inst.getChildContext && inst.getChildContext();
          if (childContext) {
            invariant("object" == typeof inst.constructor.childContextTypes, "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", this.getName() || "ReactCompositeComponent"), this._checkPropTypes(inst.constructor.childContextTypes, childContext, ReactPropTypeLocations.childContext);
            for (var name in childContext)invariant(name in inst.constructor.childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || "ReactCompositeComponent", name);
            return assign({}, currentContext, childContext)
          }
          return currentContext
        },
        _processProps: function(newProps) {
          var Component = ReactNativeComponent.getComponentClassForElement(this._currentElement);
          return Component.propTypes && this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop), newProps
        },
        _checkPropTypes: function(propTypes, props, location) {
          var componentName = this.getName();
          for (var propName in propTypes)if (propTypes.hasOwnProperty(propName)) {
            var error;
            try {
              invariant("function" == typeof propTypes[propName], "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.", componentName || "React class", ReactPropTypeLocationNames[location], propName), error = propTypes[propName](props, propName, componentName, location)
            } catch (ex) {
              error = ex
            }
            if (error instanceof Error) {
              var addendum = getDeclarationErrorAddendum(this);
              location === ReactPropTypeLocations.prop ? warning(!1, "Failed Composite propType: %s%s", error.message, addendum) : warning(!1, "Failed Context Types: %s%s", error.message, addendum)
            }
          }
        },
        receiveComponent: function(nextElement, transaction, nextContext) {
          var prevElement = this._currentElement, prevContext = this._context;
          this._pendingElement = null, this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext)
        },
        performUpdateIfNecessary: function(transaction) {
          null != this._pendingElement && ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context), (null !== this._pendingStateQueue || this._pendingForceUpdate) && (ReactElementValidator.checkAndWarnForMutatedProps(this._currentElement), this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context))
        },
        _warnIfContextsDiffer: function(ownerBasedContext, parentBasedContext) {
          ownerBasedContext = this._maskContext(ownerBasedContext), parentBasedContext = this._maskContext(parentBasedContext);
          for (var parentKeys = Object.keys(parentBasedContext).sort(), displayName = this.getName() || "ReactCompositeComponent", i = 0; i < parentKeys.length; i++) {
            var key = parentKeys[i];
            warning(ownerBasedContext[key] === parentBasedContext[key], "owner-based and parent-based contexts differ (values: `%s` vs `%s`) for key (%s) while mounting %s (see: http://fb.me/react-context-by-parent)", ownerBasedContext[key], parentBasedContext[key], key, displayName)
          }
        },
        updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
          var inst = this._instance, nextContext = inst.context, nextProps = inst.props;
          prevParentElement !== nextParentElement && (nextContext = this._processContext(nextParentElement._context), nextProps = this._processProps(nextParentElement.props), null != nextUnmaskedContext && this._warnIfContextsDiffer(nextParentElement._context, nextUnmaskedContext), inst.componentWillReceiveProps && inst.componentWillReceiveProps(nextProps, nextContext));
          var nextState = this._processPendingState(nextProps, nextContext), shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          warning("undefined" != typeof shouldUpdate, "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", this.getName() || "ReactCompositeComponent"), shouldUpdate ? (this._pendingForceUpdate = !1, this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext)) : (this._currentElement = nextParentElement, this._context = nextUnmaskedContext, inst.props = nextProps, inst.state = nextState, inst.context = nextContext)
        },
        _processPendingState: function(props, context) {
          var inst = this._instance, queue = this._pendingStateQueue, replace = this._pendingReplaceState;
          if (this._pendingReplaceState = !1, this._pendingStateQueue = null, !queue)return inst.state;
          for (var nextState = assign({}, replace ? queue[0] : inst.state), i = replace ? 1 : 0; i < queue.length; i++) {
            var partial = queue[i];
            assign(nextState, "function" == typeof partial ? partial.call(inst, nextState, props, context) : partial)
          }
          return nextState
        },
        _performComponentUpdate: function(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
          var inst = this._instance, prevProps = inst.props, prevState = inst.state, prevContext = inst.context;
          inst.componentWillUpdate && inst.componentWillUpdate(nextProps, nextState, nextContext), this._currentElement = nextElement, this._context = unmaskedContext, inst.props = nextProps, inst.state = nextState, inst.context = nextContext, this._updateRenderedComponent(transaction, unmaskedContext), inst.componentDidUpdate && transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst)
        },
        _updateRenderedComponent: function(transaction, context) {
          var prevComponentInstance = this._renderedComponent, prevRenderedElement = prevComponentInstance._currentElement, nextRenderedElement = this._renderValidatedComponent();
          if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement))ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context)); else {
            var thisID = this._rootNodeID, prevComponentID = prevComponentInstance._rootNodeID;
            ReactReconciler.unmountComponent(prevComponentInstance), this._renderedComponent = this._instantiateReactComponent(nextRenderedElement, this._currentElement.type);
            var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, context);
            this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup)
          }
        },
        _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {
          ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup)
        },
        _renderValidatedComponentWithoutOwnerOrContext: function() {
          var inst = this._instance, renderedComponent = inst.render();
          return "undefined" == typeof renderedComponent && inst.render._isMockFunction && (renderedComponent = null), renderedComponent
        },
        _renderValidatedComponent: function() {
          var renderedComponent, previousContext = ReactContext.current;
          ReactContext.current = this._processChildContext(this._currentElement._context), ReactCurrentOwner.current = this;
          try {
            renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext()
          } finally {
            ReactContext.current = previousContext, ReactCurrentOwner.current = null
          }
          return invariant(null === renderedComponent || renderedComponent === !1 || ReactElement.isValidElement(renderedComponent), "%s.render(): A valid ReactComponent must be returned. You may have returned undefined, an array or some other invalid object.", this.getName() || "ReactCompositeComponent"), renderedComponent
        },
        attachRef: function(ref, component) {
          var inst = this.getPublicInstance(), refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
          refs[ref] = component.getPublicInstance()
        },
        detachRef: function(ref) {
          var refs = this.getPublicInstance().refs;
          delete refs[ref]
        },
        getName: function() {
          var type = this._currentElement.type, constructor = this._instance && this._instance.constructor;
          return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null
        },
        getPublicInstance: function() {
          return this._instance
        },
        _instantiateReactComponent: null
      };
      ReactPerf.measureMethods(ReactCompositeComponentMixin, "ReactCompositeComponent", {
        mountComponent: "mountComponent",
        updateComponent: "updateComponent",
        _renderValidatedComponent: "_renderValidatedComponent"
      });
      var ReactCompositeComponent = { Mixin: ReactCompositeComponentMixin };
      module.exports = ReactCompositeComponent
    }, {
      115: 115,
      135: 135,
      151: 151,
      154: 154,
      27: 27,
      36: 36,
      38: 38,
      39: 39,
      57: 57,
      58: 58,
      67: 67,
      68: 68,
      73: 73,
      75: 75,
      76: 76,
      77: 77,
      81: 81,
      87: 87
    }],
    38: [
      function(_dereq_, module, exports) {
      "use strict";
      var assign = _dereq_(27), emptyObject = _dereq_(115), warning = _dereq_(154), didWarn = !1, ReactContext = {
        current: emptyObject,
        withContext: function(newContext, scopedCallback) {
          warning(didWarn, "withContext is deprecated and will be removed in a future version. Use a wrapper component with getChildContext instead."), didWarn = !0;
          var result, previousContext = ReactContext.current;
          ReactContext.current = assign({}, previousContext, newContext);
          try {
            result = scopedCallback()
          } finally {
            ReactContext.current = previousContext
          }
          return result
        }
      };
      module.exports = ReactContext
    }, { 115: 115, 154: 154, 27: 27 }],
    39: [function(_dereq_, module, exports) {
      "use strict";
      var ReactCurrentOwner = { current: null };
      module.exports = ReactCurrentOwner
    }, {}],
    40: [function(_dereq_, module, exports) {
      "use strict";
      function createDOMFactory(tag) {
        return ReactElementValidator.createFactory(tag)
      }

      var ReactElementValidator = (_dereq_(57), _dereq_(58)), mapObject = _dereq_(142), ReactDOM = mapObject({
        a: "a",
        abbr: "abbr",
        address: "address",
        area: "area",
        article: "article",
        aside: "aside",
        audio: "audio",
        b: "b",
        base: "base",
        bdi: "bdi",
        bdo: "bdo",
        big: "big",
        blockquote: "blockquote",
        body: "body",
        br: "br",
        button: "button",
        canvas: "canvas",
        caption: "caption",
        cite: "cite",
        code: "code",
        col: "col",
        colgroup: "colgroup",
        data: "data",
        datalist: "datalist",
        dd: "dd",
        del: "del",
        details: "details",
        dfn: "dfn",
        dialog: "dialog",
        div: "div",
        dl: "dl",
        dt: "dt",
        em: "em",
        embed: "embed",
        fieldset: "fieldset",
        figcaption: "figcaption",
        figure: "figure",
        footer: "footer",
        form: "form",
        h1: "h1",
        h2: "h2",
        h3: "h3",
        h4: "h4",
        h5: "h5",
        h6: "h6",
        head: "head",
        header: "header",
        hr: "hr",
        html: "html",
        i: "i",
        iframe: "iframe",
        img: "img",
        input: "input",
        ins: "ins",
        kbd: "kbd",
        keygen: "keygen",
        label: "label",
        legend: "legend",
        li: "li",
        link: "link",
        main: "main",
        map: "map",
        mark: "mark",
        menu: "menu",
        menuitem: "menuitem",
        meta: "meta",
        meter: "meter",
        nav: "nav",
        noscript: "noscript",
        object: "object",
        ol: "ol",
        optgroup: "optgroup",
        option: "option",
        output: "output",
        p: "p",
        param: "param",
        picture: "picture",
        pre: "pre",
        progress: "progress",
        q: "q",
        rp: "rp",
        rt: "rt",
        ruby: "ruby",
        s: "s",
        samp: "samp",
        script: "script",
        section: "section",
        select: "select",
        small: "small",
        source: "source",
        span: "span",
        strong: "strong",
        style: "style",
        sub: "sub",
        summary: "summary",
        sup: "sup",
        table: "table",
        tbody: "tbody",
        td: "td",
        textarea: "textarea",
        tfoot: "tfoot",
        th: "th",
        thead: "thead",
        time: "time",
        title: "title",
        tr: "tr",
        track: "track",
        u: "u",
        ul: "ul",
        var: "var",
        video: "video",
        wbr: "wbr",
        circle: "circle",
        defs: "defs",
        ellipse: "ellipse",
        g: "g",
        line: "line",
        linearGradient: "linearGradient",
        mask: "mask",
        path: "path",
        pattern: "pattern",
        polygon: "polygon",
        polyline: "polyline",
        radialGradient: "radialGradient",
        rect: "rect",
        stop: "stop",
        svg: "svg",
        text: "text",
        tspan: "tspan"
      }, createDOMFactory);
      module.exports = ReactDOM
    }, { 142: 142, 57: 57, 58: 58 }],
    41: [function(_dereq_, module, exports) {
      "use strict";
      var AutoFocusMixin = _dereq_(2), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), keyMirror = _dereq_(140), button = ReactElement.createFactory("button"), mouseListenerNames = keyMirror({
        onClick: !0,
        onDoubleClick: !0,
        onMouseDown: !0,
        onMouseMove: !0,
        onMouseUp: !0,
        onClickCapture: !0,
        onDoubleClickCapture: !0,
        onMouseDownCapture: !0,
        onMouseMoveCapture: !0,
        onMouseUpCapture: !0
      }), ReactDOMButton = ReactClass.createClass({
        displayName: "ReactDOMButton",
        tagName: "BUTTON",
        mixins: [AutoFocusMixin, ReactBrowserComponentMixin],
        render: function() {
          var props = {};
          for (var key in this.props)!this.props.hasOwnProperty(key) || this.props.disabled && mouseListenerNames[key] || (props[key] = this.props[key]);
          return button(props, this.props.children)
        }
      });
      module.exports = ReactDOMButton
    }, { 140: 140, 2: 2, 29: 29, 33: 33, 57: 57 }],
    42: [function(_dereq_, module, exports) {
      "use strict";
      function assertValidProps(props) {
        props && (null != props.dangerouslySetInnerHTML && (invariant(null == props.children, "Can only set one of `children` or `props.dangerouslySetInnerHTML`."), invariant(null != props.dangerouslySetInnerHTML.__html, "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit http://fb.me/react-invariant-dangerously-set-inner-html for more information.")), warning(null == props.innerHTML, "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warning(!props.contentEditable || null == props.children, "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), invariant(null == props.style || "object" == typeof props.style, "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."))
      }

      function putListener(id, registrationName, listener, transaction) {
        warning("onScroll" !== registrationName || isEventSupported("scroll", !0), "This browser doesn't support the `onScroll` event");
        var container = ReactMount.findReactContainerForID(id);
        if (container) {
          var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
          listenTo(registrationName, doc)
        }
        transaction.getPutListenerQueue().enqueuePutListener(id, registrationName, listener)
      }

      function validateDangerousTag(tag) {
        hasOwnProperty.call(validatedTagCache, tag) || (invariant(VALID_TAG_REGEX.test(tag), "Invalid tag: %s", tag), validatedTagCache[tag] = !0)
      }

      function ReactDOMComponent(tag) {
        validateDangerousTag(tag), this._tag = tag, this._renderedChildren = null, this._previousStyleCopy = null, this._rootNodeID = null
      }

      var CSSPropertyOperations = _dereq_(5), DOMProperty = _dereq_(10), DOMPropertyOperations = _dereq_(11), ReactBrowserEventEmitter = _dereq_(30), ReactComponentBrowserEnvironment = _dereq_(35), ReactMount = _dereq_(70), ReactMultiChild = _dereq_(71), ReactPerf = _dereq_(75), assign = _dereq_(27), escapeTextContentForBrowser = _dereq_(116), invariant = _dereq_(135), isEventSupported = _dereq_(136), keyOf = _dereq_(141), warning = _dereq_(154), deleteListener = ReactBrowserEventEmitter.deleteListener, listenTo = ReactBrowserEventEmitter.listenTo, registrationNameModules = ReactBrowserEventEmitter.registrationNameModules, CONTENT_TYPES = {
        string: !0,
        number: !0
      }, STYLE = keyOf({ style: null }), ELEMENT_NODE_TYPE = 1, BackendIDOperations = null, omittedCloseTags = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = {}, hasOwnProperty = {}.hasOwnProperty;
      ReactDOMComponent.displayName = "ReactDOMComponent", ReactDOMComponent.Mixin = {
        construct: function(element) {
          this._currentElement = element
        }, mountComponent: function(rootID, transaction, context) {
          this._rootNodeID = rootID, assertValidProps(this._currentElement.props);
          var closeTag = omittedCloseTags[this._tag] ? "" : "</" + this._tag + ">";
          return this._createOpenTagMarkupAndPutListeners(transaction) + this._createContentMarkup(transaction, context) + closeTag
        }, _createOpenTagMarkupAndPutListeners: function(transaction) {
          var props = this._currentElement.props, ret = "<" + this._tag;
          for (var propKey in props)if (props.hasOwnProperty(propKey)) {
            var propValue = props[propKey];
            if (null != propValue)if (registrationNameModules.hasOwnProperty(propKey))putListener(this._rootNodeID, propKey, propValue, transaction); else {
              propKey === STYLE && (propValue && (propValue = this._previousStyleCopy = assign({}, props.style)), propValue = CSSPropertyOperations.createMarkupForStyles(propValue));
              var markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
              markup && (ret += " " + markup)
            }
          }
          if (transaction.renderToStaticMarkup)return ret + ">";
          var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
          return ret + " " + markupForID + ">"
        }, _createContentMarkup: function(transaction, context) {
          var prefix = "";
          "listing" !== this._tag && "pre" !== this._tag && "textarea" !== this._tag || (prefix = "\n");
          var props = this._currentElement.props, innerHTML = props.dangerouslySetInnerHTML;
          if (null != innerHTML) {
            if (null != innerHTML.__html)return prefix + innerHTML.__html
          } else {
            var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null, childrenToUse = null != contentToUse ? null : props.children;
            if (null != contentToUse)return prefix + escapeTextContentForBrowser(contentToUse);
            if (null != childrenToUse) {
              var mountImages = this.mountChildren(childrenToUse, transaction, context);
              return prefix + mountImages.join("")
            }
          }
          return prefix
        }, receiveComponent: function(nextElement, transaction, context) {
          var prevElement = this._currentElement;
          this._currentElement = nextElement, this.updateComponent(transaction, prevElement, nextElement, context)
        }, updateComponent: function(transaction, prevElement, nextElement, context) {
          assertValidProps(this._currentElement.props), this._updateDOMProperties(prevElement.props, transaction), this._updateDOMChildren(prevElement.props, transaction, context)
        }, _updateDOMProperties: function(lastProps, transaction) {
          var propKey, styleName, styleUpdates, nextProps = this._currentElement.props;
          for (propKey in lastProps)if (!nextProps.hasOwnProperty(propKey) && lastProps.hasOwnProperty(propKey))if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle)lastStyle.hasOwnProperty(styleName) && (styleUpdates = styleUpdates || {}, styleUpdates[styleName] = "");
            this._previousStyleCopy = null
          } else registrationNameModules.hasOwnProperty(propKey) ? deleteListener(this._rootNodeID, propKey) : (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) && BackendIDOperations.deletePropertyByID(this._rootNodeID, propKey);
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey], lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
            if (nextProps.hasOwnProperty(propKey) && nextProp !== lastProp)if (propKey === STYLE)if (nextProp && (nextProp = this._previousStyleCopy = assign({}, nextProp)), lastProp) {
              for (styleName in lastProp)!lastProp.hasOwnProperty(styleName) || nextProp && nextProp.hasOwnProperty(styleName) || (styleUpdates = styleUpdates || {}, styleUpdates[styleName] = "");
              for (styleName in nextProp)nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName] && (styleUpdates = styleUpdates || {}, styleUpdates[styleName] = nextProp[styleName])
            } else styleUpdates = nextProp; else registrationNameModules.hasOwnProperty(propKey) ? putListener(this._rootNodeID, propKey, nextProp, transaction) : (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) && BackendIDOperations.updatePropertyByID(this._rootNodeID, propKey, nextProp)
          }
          styleUpdates && BackendIDOperations.updateStylesByID(this._rootNodeID, styleUpdates)
        }, _updateDOMChildren: function(lastProps, transaction, context) {
          var nextProps = this._currentElement.props, lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null, nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null, lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html, nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html, lastChildren = null != lastContent ? null : lastProps.children, nextChildren = null != nextContent ? null : nextProps.children, lastHasContentOrHtml = null != lastContent || null != lastHtml, nextHasContentOrHtml = null != nextContent || null != nextHtml;
          null != lastChildren && null == nextChildren ? this.updateChildren(null, transaction, context) : lastHasContentOrHtml && !nextHasContentOrHtml && this.updateTextContent(""), null != nextContent ? lastContent !== nextContent && this.updateTextContent("" + nextContent) : null != nextHtml ? lastHtml !== nextHtml && BackendIDOperations.updateInnerHTMLByID(this._rootNodeID, nextHtml) : null != nextChildren && this.updateChildren(nextChildren, transaction, context)
        }, unmountComponent: function() {
          this.unmountChildren(), ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID), ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID), this._rootNodeID = null
        }
      }, ReactPerf.measureMethods(ReactDOMComponent, "ReactDOMComponent", {
        mountComponent: "mountComponent",
        updateComponent: "updateComponent"
      }), assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin), ReactDOMComponent.injection = {
        injectIDOperations: function(IDOperations) {
          ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations
        }
      }, module.exports = ReactDOMComponent
    },
      {
      10: 10,
      11: 11,
      116: 116,
      135: 135,
      136: 136,
      141: 141,
      154: 154,
      27: 27,
      30: 30,
      35: 35,
      5: 5,
      70: 70,
      71: 71,
      75: 75
    }],
    43: [function(_dereq_, module, exports) {
      "use strict";
      var EventConstants = _dereq_(15), LocalEventTrapMixin = _dereq_(25), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), form = ReactElement.createFactory("form"), ReactDOMForm = ReactClass.createClass({
        displayName: "ReactDOMForm",
        tagName: "FORM",
        mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
        render: function() {
          return form(this.props)
        },
        componentDidMount: function() {
          this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, "reset"), this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, "submit")
        }
      });
      module.exports = ReactDOMForm
    }, { 15: 15, 25: 25, 29: 29, 33: 33, 57: 57 }],
    44: [function(_dereq_, module, exports) {
      "use strict";
      var CSSPropertyOperations = _dereq_(5), DOMChildrenOperations = _dereq_(9), DOMPropertyOperations = _dereq_(11), ReactMount = _dereq_(70), ReactPerf = _dereq_(75), invariant = _dereq_(135), setInnerHTML = _dereq_(148), INVALID_PROPERTY_ERRORS = {
        dangerouslySetInnerHTML: "`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.",
        style: "`style` must be set using `updateStylesByID()`."
      }, ReactDOMIDOperations = {
        updatePropertyByID: function(id, name, value) {
          var node = ReactMount.getNode(id);
          invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), "updatePropertyByID(...): %s", INVALID_PROPERTY_ERRORS[name]), null != value ? DOMPropertyOperations.setValueForProperty(node, name, value) : DOMPropertyOperations.deleteValueForProperty(node, name)
        }, deletePropertyByID: function(id, name, value) {
          var node = ReactMount.getNode(id);
          invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name), "updatePropertyByID(...): %s", INVALID_PROPERTY_ERRORS[name]), DOMPropertyOperations.deleteValueForProperty(node, name, value)
        }, updateStylesByID: function(id, styles) {
          var node = ReactMount.getNode(id);
          CSSPropertyOperations.setValueForStyles(node, styles)
        }, updateInnerHTMLByID: function(id, html) {
          var node = ReactMount.getNode(id);
          setInnerHTML(node, html)
        }, updateTextContentByID: function(id, content) {
          var node = ReactMount.getNode(id);
          DOMChildrenOperations.updateTextContent(node, content)
        }, dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {
          var node = ReactMount.getNode(id);
          DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup)
        }, dangerouslyProcessChildrenUpdates: function(updates, markup) {
          for (var i = 0; i < updates.length; i++)updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
          DOMChildrenOperations.processUpdates(updates, markup)
        }
      };
      ReactPerf.measureMethods(ReactDOMIDOperations, "ReactDOMIDOperations", {
        updatePropertyByID: "updatePropertyByID",
        deletePropertyByID: "deletePropertyByID",
        updateStylesByID: "updateStylesByID",
        updateInnerHTMLByID: "updateInnerHTMLByID",
        updateTextContentByID: "updateTextContentByID",
        dangerouslyReplaceNodeWithMarkupByID: "dangerouslyReplaceNodeWithMarkupByID",
        dangerouslyProcessChildrenUpdates: "dangerouslyProcessChildrenUpdates"
      }), module.exports = ReactDOMIDOperations
    }, { 11: 11, 135: 135, 148: 148, 5: 5, 70: 70, 75: 75, 9: 9 }],
    45: [function(_dereq_, module, exports) {
      "use strict";
      var EventConstants = _dereq_(15), LocalEventTrapMixin = _dereq_(25), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), iframe = ReactElement.createFactory("iframe"), ReactDOMIframe = ReactClass.createClass({
        displayName: "ReactDOMIframe",
        tagName: "IFRAME",
        mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
        render: function() {
          return iframe(this.props)
        },
        componentDidMount: function() {
          this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, "load")
        }
      });
      module.exports = ReactDOMIframe
    }, { 15: 15, 25: 25, 29: 29, 33: 33, 57: 57 }],
    46: [function(_dereq_, module, exports) {
      "use strict";
      var EventConstants = _dereq_(15), LocalEventTrapMixin = _dereq_(25), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), img = ReactElement.createFactory("img"), ReactDOMImg = ReactClass.createClass({
        displayName: "ReactDOMImg",
        tagName: "IMG",
        mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],
        render: function() {
          return img(this.props)
        },
        componentDidMount: function() {
          this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, "load"), this.trapBubbledEvent(EventConstants.topLevelTypes.topError, "error")
        }
      });
      module.exports = ReactDOMImg
    }, { 15: 15, 25: 25, 29: 29, 33: 33, 57: 57 }],
    47: [function(_dereq_, module, exports) {
      "use strict";
      function forceUpdateIfMounted() {
        this.isMounted() && this.forceUpdate()
      }

      var AutoFocusMixin = _dereq_(2), DOMPropertyOperations = _dereq_(11), LinkedValueUtils = _dereq_(24), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), ReactMount = _dereq_(70), ReactUpdates = _dereq_(87), assign = _dereq_(27), invariant = _dereq_(135), input = ReactElement.createFactory("input"), instancesByReactID = {}, ReactDOMInput = ReactClass.createClass({
        displayName: "ReactDOMInput",
        tagName: "INPUT",
        mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
        getInitialState: function() {
          var defaultValue = this.props.defaultValue;
          return {
            initialChecked: this.props.defaultChecked || !1,
            initialValue: null != defaultValue ? defaultValue : null
          }
        },
        render: function() {
          var props = assign({}, this.props);
          props.defaultChecked = null, props.defaultValue = null;
          var value = LinkedValueUtils.getValue(this);
          props.value = null != value ? value : this.state.initialValue;
          var checked = LinkedValueUtils.getChecked(this);
          return props.checked = null != checked ? checked : this.state.initialChecked, props.onChange = this._handleChange, input(props, this.props.children)
        },
        componentDidMount: function() {
          var id = ReactMount.getID(this.getDOMNode());
          instancesByReactID[id] = this
        },
        componentWillUnmount: function() {
          var rootNode = this.getDOMNode(), id = ReactMount.getID(rootNode);
          delete instancesByReactID[id]
        },
        componentDidUpdate: function(prevProps, prevState, prevContext) {
          var rootNode = this.getDOMNode();
          null != this.props.checked && DOMPropertyOperations.setValueForProperty(rootNode, "checked", this.props.checked || !1);
          var value = LinkedValueUtils.getValue(this);
          null != value && DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value)
        },
        _handleChange: function(event) {
          var returnValue, onChange = LinkedValueUtils.getOnChange(this);
          onChange && (returnValue = onChange.call(this, event)), ReactUpdates.asap(forceUpdateIfMounted, this);
          var name = this.props.name;
          if ("radio" === this.props.type && null != name) {
            for (var rootNode = this.getDOMNode(), queryRoot = rootNode; queryRoot.parentNode;)queryRoot = queryRoot.parentNode;
            for (var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]'), i = 0, groupLen = group.length; i < groupLen; i++) {
              var otherNode = group[i];
              if (otherNode !== rootNode && otherNode.form === rootNode.form) {
                var otherID = ReactMount.getID(otherNode);
                invariant(otherID, "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                var otherInstance = instancesByReactID[otherID];
                invariant(otherInstance, "ReactDOMInput: Unknown radio button ID %s.", otherID), ReactUpdates.asap(forceUpdateIfMounted, otherInstance)
              }
            }
          }
          return returnValue
        }
      });
      module.exports = ReactDOMInput
    }, { 11: 11, 135: 135, 2: 2, 24: 24, 27: 27, 29: 29, 33: 33, 57: 57, 70: 70, 87: 87 }],
    48: [function(_dereq_, module, exports) {
      "use strict";
      var ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), warning = _dereq_(154), option = ReactElement.createFactory("option"), ReactDOMOption = ReactClass.createClass({
        displayName: "ReactDOMOption",
        tagName: "OPTION",
        mixins: [ReactBrowserComponentMixin],
        componentWillMount: function() {
          warning(null == this.props.selected, "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.")
        },
        render: function() {
          return option(this.props, this.props.children)
        }
      });
      module.exports = ReactDOMOption
    }, { 154: 154, 29: 29, 33: 33, 57: 57 }],
    49: [function(_dereq_, module, exports) {
      "use strict";
      function updateOptionsIfPendingUpdateAndMounted() {
        if (this._pendingUpdate) {
          this._pendingUpdate = !1;
          var value = LinkedValueUtils.getValue(this);
          null != value && this.isMounted() && updateOptions(this, value)
        }
      }

      function selectValueType(props, propName, componentName) {
        if (null == props[propName])return null;
        if (props.multiple) {
          if (!Array.isArray(props[propName]))return new Error("The `" + propName + "` prop supplied to <select> must be an array if `multiple` is true.")
        } else if (Array.isArray(props[propName]))return new Error("The `" + propName + "` prop supplied to <select> must be a scalar value if `multiple` is false.")
      }

      function updateOptions(component, propValue) {
        var selectedValue, i, l, options = component.getDOMNode().options;
        if (component.props.multiple) {
          for (selectedValue = {}, i = 0, l = propValue.length; i < l; i++)selectedValue["" + propValue[i]] = !0;
          for (i = 0, l = options.length; i < l; i++) {
            var selected = selectedValue.hasOwnProperty(options[i].value);
            options[i].selected !== selected && (options[i].selected = selected)
          }
        } else {
          for (selectedValue = "" + propValue, i = 0, l = options.length; i < l; i++)if (options[i].value === selectedValue)return void(options[i].selected = !0);
          options.length && (options[0].selected = !0)
        }
      }

      var AutoFocusMixin = _dereq_(2), LinkedValueUtils = _dereq_(24), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), ReactUpdates = _dereq_(87), assign = _dereq_(27), select = ReactElement.createFactory("select"), ReactDOMSelect = ReactClass.createClass({
        displayName: "ReactDOMSelect",
        tagName: "SELECT",
        mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
        propTypes: { defaultValue: selectValueType, value: selectValueType },
        render: function() {
          var props = assign({}, this.props);
          return props.onChange = this._handleChange, props.value = null, select(props, this.props.children)
        },
        componentWillMount: function() {
          this._pendingUpdate = !1
        },
        componentDidMount: function() {
          var value = LinkedValueUtils.getValue(this);
          null != value ? updateOptions(this, value) : null != this.props.defaultValue && updateOptions(this, this.props.defaultValue)
        },
        componentDidUpdate: function(prevProps) {
          var value = LinkedValueUtils.getValue(this);
          null != value ? (this._pendingUpdate = !1, updateOptions(this, value)) : !prevProps.multiple != !this.props.multiple && (null != this.props.defaultValue ? updateOptions(this, this.props.defaultValue) : updateOptions(this, this.props.multiple ? [] : ""))
        },
        _handleChange: function(event) {
          var returnValue, onChange = LinkedValueUtils.getOnChange(this);
          return onChange && (returnValue = onChange.call(this, event)), this._pendingUpdate = !0, ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this),
                  returnValue
        }
      });
      module.exports = ReactDOMSelect
    }, { 2: 2, 24: 24, 27: 27, 29: 29, 33: 33, 57: 57, 87: 87 }],
    50: [function(_dereq_, module, exports) {
      "use strict";
      function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
        return anchorNode === focusNode && anchorOffset === focusOffset
      }

      function getIEOffsets(node) {
        var selection = document.selection, selectedRange = selection.createRange(), selectedLength = selectedRange.text.length, fromStart = selectedRange.duplicate();
        fromStart.moveToElementText(node), fromStart.setEndPoint("EndToStart", selectedRange);
        var startOffset = fromStart.text.length, endOffset = startOffset + selectedLength;
        return { start: startOffset, end: endOffset }
      }

      function getModernOffsets(node) {
        var selection = window.getSelection && window.getSelection();
        if (!selection || 0 === selection.rangeCount)return null;
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset, currentRange = selection.getRangeAt(0), isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset), rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length, tempRange = currentRange.cloneRange();
        tempRange.selectNodeContents(node), tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
        var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset), start = isTempRangeCollapsed ? 0 : tempRange.toString().length, end = start + rangeLength, detectionRange = document.createRange();
        detectionRange.setStart(anchorNode, anchorOffset), detectionRange.setEnd(focusNode, focusOffset);
        var isBackward = detectionRange.collapsed;
        return { start: isBackward ? end : start, end: isBackward ? start : end }
      }

      function setIEOffsets(node, offsets) {
        var start, end, range = document.selection.createRange().duplicate();
        "undefined" == typeof offsets.end ? (start = offsets.start, end = start) : offsets.start > offsets.end ? (start = offsets.end, end = offsets.start) : (start = offsets.start, end = offsets.end), range.moveToElementText(node), range.moveStart("character", start), range.setEndPoint("EndToStart", range), range.moveEnd("character", end - start), range.select()
      }

      function setModernOffsets(node, offsets) {
        if (window.getSelection) {
          var selection = window.getSelection(), length = node[getTextContentAccessor()].length, start = Math.min(offsets.start, length), end = "undefined" == typeof offsets.end ? start : Math.min(offsets.end, length);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start, start = temp
          }
          var startMarker = getNodeForCharacterOffset(node, start), endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            var range = document.createRange();
            range.setStart(startMarker.node, startMarker.offset), selection.removeAllRanges(), start > end ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range))
          }
        }
      }

      var ExecutionEnvironment = _dereq_(21), getNodeForCharacterOffset = _dereq_(128), getTextContentAccessor = _dereq_(130), useIEOffsets = ExecutionEnvironment.canUseDOM && "selection" in document && !("getSelection" in window), ReactDOMSelection = {
        getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
        setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
      };
      module.exports = ReactDOMSelection
    }, { 128: 128, 130: 130, 21: 21 }],
    51: [function(_dereq_, module, exports) {
      "use strict";
      var DOMPropertyOperations = _dereq_(11), ReactComponentBrowserEnvironment = _dereq_(35), ReactDOMComponent = _dereq_(42), assign = _dereq_(27), escapeTextContentForBrowser = _dereq_(116), ReactDOMTextComponent = function(props) {
      };
      assign(ReactDOMTextComponent.prototype, {
        construct: function(text) {
          this._currentElement = text, this._stringText = "" + text, this._rootNodeID = null, this._mountIndex = 0
        }, mountComponent: function(rootID, transaction, context) {
          this._rootNodeID = rootID;
          var escapedText = escapeTextContentForBrowser(this._stringText);
          return transaction.renderToStaticMarkup ? escapedText : "<span " + DOMPropertyOperations.createMarkupForID(rootID) + ">" + escapedText + "</span>"
        }, receiveComponent: function(nextText, transaction) {
          if (nextText !== this._currentElement) {
            this._currentElement = nextText;
            var nextStringText = "" + nextText;
            nextStringText !== this._stringText && (this._stringText = nextStringText, ReactDOMComponent.BackendIDOperations.updateTextContentByID(this._rootNodeID, nextStringText))
          }
        }, unmountComponent: function() {
          ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID)
        }
      }), module.exports = ReactDOMTextComponent
    }, { 11: 11, 116: 116, 27: 27, 35: 35, 42: 42 }],
    52: [function(_dereq_, module, exports) {
      "use strict";
      function forceUpdateIfMounted() {
        this.isMounted() && this.forceUpdate()
      }

      var AutoFocusMixin = _dereq_(2), DOMPropertyOperations = _dereq_(11), LinkedValueUtils = _dereq_(24), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactElement = _dereq_(57), ReactUpdates = _dereq_(87), assign = _dereq_(27), invariant = _dereq_(135), warning = _dereq_(154), textarea = ReactElement.createFactory("textarea"), ReactDOMTextarea = ReactClass.createClass({
        displayName: "ReactDOMTextarea",
        tagName: "TEXTAREA",
        mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],
        getInitialState: function() {
          var defaultValue = this.props.defaultValue, children = this.props.children;
          null != children && (warning(!1, "Use the `defaultValue` or `value` props instead of setting children on <textarea>."), invariant(null == defaultValue, "If you supply `defaultValue` on a <textarea>, do not pass children."), Array.isArray(children) && (invariant(children.length <= 1, "<textarea> can only have at most one child."), children = children[0]), defaultValue = "" + children), null == defaultValue && (defaultValue = "");
          var value = LinkedValueUtils.getValue(this);
          return { initialValue: "" + (null != value ? value : defaultValue) }
        },
        render: function() {
          var props = assign({}, this.props);
          return invariant(null == props.dangerouslySetInnerHTML, "`dangerouslySetInnerHTML` does not make sense on <textarea>."), props.defaultValue = null, props.value = null, props.onChange = this._handleChange, textarea(props, this.state.initialValue)
        },
        componentDidUpdate: function(prevProps, prevState, prevContext) {
          var value = LinkedValueUtils.getValue(this);
          if (null != value) {
            var rootNode = this.getDOMNode();
            DOMPropertyOperations.setValueForProperty(rootNode, "value", "" + value)
          }
        },
        _handleChange: function(event) {
          var returnValue, onChange = LinkedValueUtils.getOnChange(this);
          return onChange && (returnValue = onChange.call(this, event)), ReactUpdates.asap(forceUpdateIfMounted, this), returnValue
        }
      });
      module.exports = ReactDOMTextarea
    }, { 11: 11, 135: 135, 154: 154, 2: 2, 24: 24, 27: 27, 29: 29, 33: 33, 57: 57, 87: 87 }],
    53: [function(_dereq_, module, exports) {
      "use strict";
      function ReactDefaultBatchingStrategyTransaction() {
        this.reinitializeTransaction()
      }

      var ReactUpdates = _dereq_(87), Transaction = _dereq_(103), assign = _dereq_(27), emptyFunction = _dereq_(114), RESET_BATCHED_UPDATES = {
        initialize: emptyFunction,
        close: function() {
          ReactDefaultBatchingStrategy.isBatchingUpdates = !1
        }
      }, FLUSH_BATCHED_UPDATES = {
        initialize: emptyFunction,
        close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
      }, TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
      assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
        getTransactionWrappers: function() {
          return TRANSACTION_WRAPPERS
        }
      });
      var transaction = new ReactDefaultBatchingStrategyTransaction, ReactDefaultBatchingStrategy = {
        isBatchingUpdates: !1,
        batchedUpdates: function(callback, a, b, c, d) {
          var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
          ReactDefaultBatchingStrategy.isBatchingUpdates = !0, alreadyBatchingUpdates ? callback(a, b, c, d) : transaction.perform(callback, null, a, b, c, d)
        }
      };
      module.exports = ReactDefaultBatchingStrategy
    }, { 103: 103, 114: 114, 27: 27, 87: 87 }],
    54: [function(_dereq_, module, exports) {
      "use strict";
      function autoGenerateWrapperClass(type) {
        return ReactClass.createClass({
          tagName: type.toUpperCase(), render: function() {
            return new ReactElement(type, null, null, null, null, this.props)
          }
        })
      }

      function inject() {
        ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener), ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder), ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles), ReactInjection.EventPluginHub.injectMount(ReactMount), ReactInjection.EventPluginHub.injectEventPluginsByName({
          SimpleEventPlugin: SimpleEventPlugin,
          EnterLeaveEventPlugin: EnterLeaveEventPlugin,
          ChangeEventPlugin: ChangeEventPlugin,
          MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
          SelectEventPlugin: SelectEventPlugin,
          BeforeInputEventPlugin: BeforeInputEventPlugin
        }), ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent), ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent), ReactInjection.NativeComponent.injectAutoWrapper(autoGenerateWrapperClass), ReactInjection.Class.injectMixin(ReactBrowserComponentMixin), ReactInjection.NativeComponent.injectComponentClasses({
          button: ReactDOMButton,
          form: ReactDOMForm,
          iframe: ReactDOMIframe,
          img: ReactDOMImg,
          input: ReactDOMInput,
          option: ReactDOMOption,
          select: ReactDOMSelect,
          textarea: ReactDOMTextarea,
          html: createFullPageComponent("html"),
          head: createFullPageComponent("head"),
          body: createFullPageComponent("body")
        }), ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig), ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig), ReactInjection.EmptyComponent.injectEmptyComponent("noscript"), ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction), ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy), ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex), ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment), ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);
        var url = ExecutionEnvironment.canUseDOM && window.location.href || "";
        if (/[?&]react_perf\b/.test(url)) {
          var ReactDefaultPerf = _dereq_(55);
          ReactDefaultPerf.start()
        }
      }

      var BeforeInputEventPlugin = _dereq_(3), ChangeEventPlugin = _dereq_(7), ClientReactRootIndex = _dereq_(8), DefaultEventPluginOrder = _dereq_(13), EnterLeaveEventPlugin = _dereq_(14), ExecutionEnvironment = _dereq_(21), HTMLDOMPropertyConfig = _dereq_(23), MobileSafariClickEventPlugin = _dereq_(26), ReactBrowserComponentMixin = _dereq_(29), ReactClass = _dereq_(33), ReactComponentBrowserEnvironment = _dereq_(35), ReactDefaultBatchingStrategy = _dereq_(53), ReactDOMComponent = _dereq_(42), ReactDOMButton = _dereq_(41), ReactDOMForm = _dereq_(43), ReactDOMImg = _dereq_(46), ReactDOMIDOperations = _dereq_(44), ReactDOMIframe = _dereq_(45), ReactDOMInput = _dereq_(47), ReactDOMOption = _dereq_(48), ReactDOMSelect = _dereq_(49), ReactDOMTextarea = _dereq_(52), ReactDOMTextComponent = _dereq_(51), ReactElement = _dereq_(57), ReactEventListener = _dereq_(62), ReactInjection = _dereq_(64), ReactInstanceHandles = _dereq_(66), ReactMount = _dereq_(70), ReactReconcileTransaction = _dereq_(80), SelectEventPlugin = _dereq_(89), ServerReactRootIndex = _dereq_(90), SimpleEventPlugin = _dereq_(91), SVGDOMPropertyConfig = _dereq_(88), createFullPageComponent = _dereq_(111);
      module.exports = { inject: inject }
    }, {
      111: 111,
      13: 13,
      14: 14,
      21: 21,
      23: 23,
      26: 26,
      29: 29,
      3: 3,
      33: 33,
      35: 35,
      41: 41,
      42: 42,
      43: 43,
      44: 44,
      45: 45,
      46: 46,
      47: 47,
      48: 48,
      49: 49,
      51: 51,
      52: 52,
      53: 53,
      55: 55,
      57: 57,
      62: 62,
      64: 64,
      66: 66,
      7: 7,
      70: 70,
      8: 8,
      80: 80,
      88: 88,
      89: 89,
      90: 90,
      91: 91
    }],
    55: [function(_dereq_, module, exports) {
      "use strict";
      function roundFloat(val) {
        return Math.floor(100 * val) / 100
      }

      function addValue(obj, key, val) {
        obj[key] = (obj[key] || 0) + val
      }

      var DOMProperty = _dereq_(10), ReactDefaultPerfAnalysis = _dereq_(56), ReactMount = _dereq_(70), ReactPerf = _dereq_(75), performanceNow = _dereq_(146), ReactDefaultPerf = {
        _allMeasurements: [],
        _mountStack: [0],
        _injected: !1,
        start: function() {
          ReactDefaultPerf._injected || ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure), ReactDefaultPerf._allMeasurements.length = 0, ReactPerf.enableMeasure = !0
        },
        stop: function() {
          ReactPerf.enableMeasure = !1
        },
        getLastMeasurements: function() {
          return ReactDefaultPerf._allMeasurements
        },
        printExclusive: function(measurements) {
          measurements = measurements || ReactDefaultPerf._allMeasurements;
          var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
          console.table(summary.map(function(item) {
            return {
              "Component class name": item.componentName,
              "Total inclusive time (ms)": roundFloat(item.inclusive),
              "Exclusive mount time (ms)": roundFloat(item.exclusive),
              "Exclusive render time (ms)": roundFloat(item.render),
              "Mount time per instance (ms)": roundFloat(item.exclusive / item.count),
              "Render time per instance (ms)": roundFloat(item.render / item.count),
              Instances: item.count
            }
          }))
        },
        printInclusive: function(measurements) {
          measurements = measurements || ReactDefaultPerf._allMeasurements;
          var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
          console.table(summary.map(function(item) {
            return {
              "Owner > component": item.componentName,
              "Inclusive time (ms)": roundFloat(item.time),
              Instances: item.count
            }
          })), console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms")
        },
        getMeasurementsSummaryMap: function(measurements) {
          var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, !0);
          return summary.map(function(item) {
            return { "Owner > component": item.componentName, "Wasted time (ms)": item.time, Instances: item.count }
          })
        },
        printWasted: function(measurements) {
          measurements = measurements || ReactDefaultPerf._allMeasurements, console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements)), console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms")
        },
        printDOM: function(measurements) {
          measurements = measurements || ReactDefaultPerf._allMeasurements;
          var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
          console.table(summary.map(function(item) {
            var result = {};
            return result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id, result.type = item.type, result.args = JSON.stringify(item.args), result
          })), console.log("Total time:", ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + " ms")
        },
        _recordWrite: function(id, fnName, totalTime, args) {
          var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
          writes[id] = writes[id] || [], writes[id].push({ type: fnName, time: totalTime, args: args })
        },
        measure: function(moduleName, fnName, func) {
          return function() {
            for (var args = [], $__0 = 0, $__1 = arguments.length; $__0 < $__1; $__0++)args.push(arguments[$__0]);
            var totalTime, rv, start;
            if ("_renderNewRootComponent" === fnName || "flushBatchedUpdates" === fnName)return ReactDefaultPerf._allMeasurements.push({
              exclusive: {},
              inclusive: {},
              render: {},
              counts: {},
              writes: {},
              displayNames: {},
              totalTime: 0
            }), start = performanceNow(), rv = func.apply(this, args), ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start, rv;
            if ("_mountImageIntoNode" === fnName || "ReactDOMIDOperations" === moduleName) {
              if (start = performanceNow(), rv = func.apply(this, args), totalTime = performanceNow() - start, "_mountImageIntoNode" === fnName) {
                var mountID = ReactMount.getID(args[1]);
                ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0])
              } else"dangerouslyProcessChildrenUpdates" === fnName ? args[0].forEach(function(update) {
                var writeArgs = {};
                null !== update.fromIndex && (writeArgs.fromIndex = update.fromIndex), null !== update.toIndex && (writeArgs.toIndex = update.toIndex), null !== update.textContent && (writeArgs.textContent = update.textContent), null !== update.markupIndex && (writeArgs.markup = args[1][update.markupIndex]), ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs)
              }) : ReactDefaultPerf._recordWrite(args[0], fnName, totalTime, Array.prototype.slice.call(args, 1));
              return rv
            }
            if ("ReactCompositeComponent" !== moduleName || "mountComponent" !== fnName && "updateComponent" !== fnName && "_renderValidatedComponent" !== fnName)return func.apply(this, args);
            if ("string" == typeof this._currentElement.type)return func.apply(this, args);
            var rootNodeID = "mountComponent" === fnName ? args[0] : this._rootNodeID, isRender = "_renderValidatedComponent" === fnName, isMount = "mountComponent" === fnName, mountStack = ReactDefaultPerf._mountStack, entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
            if (isRender ? addValue(entry.counts, rootNodeID, 1) : isMount && mountStack.push(0), start = performanceNow(), rv = func.apply(this, args), totalTime = performanceNow() - start, isRender)addValue(entry.render, rootNodeID, totalTime); else if (isMount) {
              var subMountTime = mountStack.pop();
              mountStack[mountStack.length - 1] += totalTime, addValue(entry.exclusive, rootNodeID, totalTime - subMountTime), addValue(entry.inclusive, rootNodeID, totalTime)
            } else addValue(entry.inclusive, rootNodeID, totalTime);
            return entry.displayNames[rootNodeID] = {
              current: this.getName(),
              owner: this._currentElement._owner ? this._currentElement._owner.getName() : "<root>"
            }, rv
          }
        }
      };
      module.exports = ReactDefaultPerf
    }, { 10: 10, 146: 146, 56: 56, 70: 70, 75: 75 }],
    56: [function(_dereq_, module, exports) {
      function getTotalTime(measurements) {
        for (var totalTime = 0, i = 0; i < measurements.length; i++) {
          var measurement = measurements[i];
          totalTime += measurement.totalTime
        }
        return totalTime
      }

      function getDOMSummary(measurements) {
        for (var items = [], i = 0; i < measurements.length; i++) {
          var id, measurement = measurements[i];
          for (id in measurement.writes)measurement.writes[id].forEach(function(write) {
            items.push({ id: id, type: DOM_OPERATION_TYPES[write.type] || write.type, args: write.args })
          })
        }
        return items
      }

      function getExclusiveSummary(measurements) {
        for (var displayName, candidates = {}, i = 0; i < measurements.length; i++) {
          var measurement = measurements[i], allIDs = assign({}, measurement.exclusive, measurement.inclusive);
          for (var id in allIDs)displayName = measurement.displayNames[id].current, candidates[displayName] = candidates[displayName] || {
                    componentName: displayName,
                    inclusive: 0,
                    exclusive: 0,
                    render: 0,
                    count: 0
                  }, measurement.render[id] && (candidates[displayName].render += measurement.render[id]), measurement.exclusive[id] && (candidates[displayName].exclusive += measurement.exclusive[id]), measurement.inclusive[id] && (candidates[displayName].inclusive += measurement.inclusive[id]), measurement.counts[id] && (candidates[displayName].count += measurement.counts[id])
        }
        var arr = [];
        for (displayName in candidates)candidates[displayName].exclusive >= DONT_CARE_THRESHOLD && arr.push(candidates[displayName]);
        return arr.sort(function(a, b) {
          return b.exclusive - a.exclusive
        }), arr
      }

      function getInclusiveSummary(measurements, onlyClean) {
        for (var inclusiveKey, candidates = {}, i = 0; i < measurements.length; i++) {
          var cleanComponents, measurement = measurements[i], allIDs = assign({}, measurement.exclusive, measurement.inclusive);
          onlyClean && (cleanComponents = getUnchangedComponents(measurement));
          for (var id in allIDs)if (!onlyClean || cleanComponents[id]) {
            var displayName = measurement.displayNames[id];
            inclusiveKey = displayName.owner + " > " + displayName.current, candidates[inclusiveKey] = candidates[inclusiveKey] || {
                      componentName: inclusiveKey,
                      time: 0,
                      count: 0
                    }, measurement.inclusive[id] && (candidates[inclusiveKey].time += measurement.inclusive[id]), measurement.counts[id] && (candidates[inclusiveKey].count += measurement.counts[id])
          }
        }
        var arr = [];
        for (inclusiveKey in candidates)candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD && arr.push(candidates[inclusiveKey]);
        return arr.sort(function(a, b) {
          return b.time - a.time
        }), arr
      }

      function getUnchangedComponents(measurement) {
        var cleanComponents = {}, dirtyLeafIDs = Object.keys(measurement.writes), allIDs = assign({}, measurement.exclusive, measurement.inclusive);
        for (var id in allIDs) {
          for (var isDirty = !1, i = 0; i < dirtyLeafIDs.length; i++)if (0 === dirtyLeafIDs[i].indexOf(id)) {
            isDirty = !0;
            break
          }
          !isDirty && measurement.counts[id] > 0 && (cleanComponents[id] = !0)
        }
        return cleanComponents
      }

      var assign = _dereq_(27), DONT_CARE_THRESHOLD = 1.2, DOM_OPERATION_TYPES = {
        _mountImageIntoNode: "set innerHTML",
        INSERT_MARKUP: "set innerHTML",
        MOVE_EXISTING: "move",
        REMOVE_NODE: "remove",
        TEXT_CONTENT: "set textContent",
        updatePropertyByID: "update attribute",
        deletePropertyByID: "delete attribute",
        updateStylesByID: "update styles",
        updateInnerHTMLByID: "set innerHTML",
        dangerouslyReplaceNodeWithMarkupByID: "replace"
      }, ReactDefaultPerfAnalysis = {
        getExclusiveSummary: getExclusiveSummary,
        getInclusiveSummary: getInclusiveSummary,
        getDOMSummary: getDOMSummary,
        getTotalTime: getTotalTime
      };
      module.exports = ReactDefaultPerfAnalysis
    }, { 27: 27 }],
    57: [function(_dereq_, module, exports) {
      "use strict";
      function defineWarningProperty(object, key) {
        Object.defineProperty(object, key, {
          configurable: !1, enumerable: !0, get: function() {
            return this._store ? this._store[key] : null
          }, set: function(value) {
            warning(!1, "Don't set the %s property of the React element. Instead, specify the correct value when initially creating the element.", key), this._store[key] = value
          }
        })
      }

      function defineMutationMembrane(prototype) {
        try {
          var pseudoFrozenProperties = { props: !0 };
          for (var key in pseudoFrozenProperties)defineWarningProperty(prototype, key);
          useMutationMembrane = !0
        } catch (x) {
        }
      }

      var ReactContext = _dereq_(38), ReactCurrentOwner = _dereq_(39), assign = _dereq_(27), warning = _dereq_(154), RESERVED_PROPS = {
        key: !0,
        ref: !0
      }, useMutationMembrane = !1, ReactElement = function(type, key, ref, owner, context, props) {
        this.type = type, this.key = key, this.ref = ref, this._owner = owner, this._context = context, this._store = {
          props: props,
          originalProps: assign({}, props)
        };
        try {
          Object.defineProperty(this._store, "validated", { configurable: !1, enumerable: !1, writable: !0 })
        } catch (x) {
        }
        return this._store.validated = !1, useMutationMembrane ? void Object.freeze(this) : void(this.props = props)
      };
      ReactElement.prototype = { _isReactElement: !0 }, defineMutationMembrane(ReactElement.prototype), ReactElement.createElement = function(type, config, children) {
        var propName, props = {}, key = null, ref = null;
        if (null != config) {
          ref = void 0 === config.ref ? null : config.ref, key = void 0 === config.key ? null : "" + config.key;
          for (propName in config)config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName])
        }
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength)props.children = children; else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
          props.children = childArray
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps)"undefined" == typeof props[propName] && (props[propName] = defaultProps[propName])
        }
        return new ReactElement(type, key, ref, ReactCurrentOwner.current, ReactContext.current, props)
      }, ReactElement.createFactory = function(type) {
        var factory = ReactElement.createElement.bind(null, type);
        return factory.type = type, factory
      }, ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
        var newElement = new ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._owner, oldElement._context, newProps);
        return newElement._store.validated = oldElement._store.validated, newElement
      }, ReactElement.cloneElement = function(element, config, children) {
        var propName, props = assign({}, element.props), key = element.key, ref = element.ref, owner = element._owner;
        if (null != config) {
          void 0 !== config.ref && (ref = config.ref, owner = ReactCurrentOwner.current), void 0 !== config.key && (key = "" + config.key);
          for (propName in config)config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName])
        }
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength)props.children = children; else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
          props.children = childArray
        }
        return new ReactElement(element.type, key, ref, owner, element._context, props)
      }, ReactElement.isValidElement = function(object) {
        var isElement = !(!object || !object._isReactElement);
        return isElement
      }, module.exports = ReactElement
    }, { 154: 154, 27: 27, 38: 38, 39: 39 }],
    58: [function(_dereq_, module, exports) {
      "use strict";
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name)return " Check the render method of `" + name + "`."
        }
        return ""
      }

      function getName(instance) {
        var publicInstance = instance && instance.getPublicInstance();
        if (publicInstance) {
          var constructor = publicInstance.constructor;
          if (constructor)return constructor.displayName || constructor.name || void 0
        }
      }

      function getCurrentOwnerDisplayName() {
        var current = ReactCurrentOwner.current;
        return current && getName(current) || void 0
      }

      function validateExplicitKey(element, parentType) {
        element._store.validated || null != element.key || (element._store.validated = !0, warnAndMonitorForKeyUse('Each child in an array or iterator should have a unique "key" prop.', element, parentType))
      }

      function validatePropertyKey(name, element, parentType) {
        NUMERIC_PROPERTY_REGEX.test(name) && warnAndMonitorForKeyUse("Child objects should have non-numeric keys so ordering is preserved.", element, parentType)
      }

      function warnAndMonitorForKeyUse(message, element, parentType) {
        var ownerName = getCurrentOwnerDisplayName(), parentName = "string" == typeof parentType ? parentType : parentType.displayName || parentType.name, useName = ownerName || parentName, memoizer = ownerHasKeyUseWarning[message] || (ownerHasKeyUseWarning[message] = {});
        if (!memoizer.hasOwnProperty(useName)) {
          memoizer[useName] = !0;
          var parentOrOwnerAddendum = ownerName ? " Check the render method of " + ownerName + "." : parentName ? " Check the React.render call using <" + parentName + ">." : "", childOwnerAddendum = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            var childOwnerName = getName(element._owner);
            childOwnerAddendum = " It was passed a child from " + childOwnerName + "."
          }
          warning(!1, message + "%s%s See http://fb.me/react-warning-keys for more information.", parentOrOwnerAddendum, childOwnerAddendum)
        }
      }

      function validateChildKeys(node, parentType) {
        if (Array.isArray(node))for (var i = 0; i < node.length; i++) {
          var child = node[i];
          ReactElement.isValidElement(child) && validateExplicitKey(child, parentType)
        } else if (ReactElement.isValidElement(node))node._store.validated = !0; else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            if (iteratorFn !== node.entries)for (var step, iterator = iteratorFn.call(node); !(step = iterator.next()).done;)ReactElement.isValidElement(step.value) && validateExplicitKey(step.value, parentType)
          } else if ("object" == typeof node) {
            var fragment = ReactFragment.extractIfFragment(node);
            for (var key in fragment)fragment.hasOwnProperty(key) && validatePropertyKey(key, fragment[key], parentType)
          }
        }
      }

      function checkPropTypes(componentName, propTypes, props, location) {
        for (var propName in propTypes)if (propTypes.hasOwnProperty(propName)) {
          var error;
          try {
            invariant("function" == typeof propTypes[propName], "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.", componentName || "React class", ReactPropTypeLocationNames[location], propName), error = propTypes[propName](props, propName, componentName, location)
          } catch (ex) {
            error = ex
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = !0;
            var addendum = getDeclarationErrorAddendum(this);
            warning(!1, "Failed propType: %s%s", error.message, addendum)
          }
        }
      }

      function warnForPropsMutation(propName, element) {
        var type = element.type, elementName = "string" == typeof type ? type : type.displayName, ownerName = element._owner ? element._owner.getPublicInstance().constructor.displayName : null, warningKey = propName + "|" + elementName + "|" + ownerName;
        if (!warnedPropsMutations.hasOwnProperty(warningKey)) {
          warnedPropsMutations[warningKey] = !0;
          var elementInfo = "";
          elementName && (elementInfo = " <" + elementName + " />");
          var ownerInfo = "";
          ownerName && (ownerInfo = " The element was created by " + ownerName + "."), warning(!1, "Don't set .props.%s of the React component%s. Instead, specify the correct value when initially creating the element.%s", propName, elementInfo, ownerInfo)
        }
      }

      function is(a, b) {
        return a !== a ? b !== b : 0 === a && 0 === b ? 1 / a === 1 / b : a === b
      }

      function checkAndWarnForMutatedProps(element) {
        if (element._store) {
          var originalProps = element._store.originalProps, props = element.props;
          for (var propName in props)props.hasOwnProperty(propName) && (originalProps.hasOwnProperty(propName) && is(originalProps[propName], props[propName]) || (warnForPropsMutation(propName, element), originalProps[propName] = props[propName]))
        }
      }

      function validatePropTypes(element) {
        if (null != element.type) {
          var componentClass = ReactNativeComponent.getComponentClassForElement(element), name = componentClass.displayName || componentClass.name;
          componentClass.propTypes && checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop), "function" == typeof componentClass.getDefaultProps && warning(componentClass.getDefaultProps.isReactClassApproved, "getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")
        }
      }

      var ReactElement = _dereq_(57), ReactFragment = _dereq_(63), ReactPropTypeLocations = _dereq_(77), ReactPropTypeLocationNames = _dereq_(76), ReactCurrentOwner = _dereq_(39), ReactNativeComponent = _dereq_(73), getIteratorFn = _dereq_(126), invariant = _dereq_(135), warning = _dereq_(154), ownerHasKeyUseWarning = {}, loggedTypeFailures = {}, NUMERIC_PROPERTY_REGEX = /^\d+$/, warnedPropsMutations = {}, ReactElementValidator = {
        checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,
        createElement: function(type, props, children) {
          warning(null != type, "React.createElement: type should not be null or undefined. It should be a string (for DOM elements) or a ReactClass (for composite components).");
          var element = ReactElement.createElement.apply(this, arguments);
          if (null == element)return element;
          for (var i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], type);
          return validatePropTypes(element), element
        },
        createFactory: function(type) {
          var validatedFactory = ReactElementValidator.createElement.bind(null, type);
          validatedFactory.type = type;
          try {
            Object.defineProperty(validatedFactory, "type", {
              enumerable: !1, get: function() {
                return warning(!1, "Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", { value: type }), type
              }
            })
          } catch (x) {
          }
          return validatedFactory
        },
        cloneElement: function(element, props, children) {
          for (var newElement = ReactElement.cloneElement.apply(this, arguments), i = 2; i < arguments.length; i++)validateChildKeys(arguments[i], newElement.type);
          return validatePropTypes(newElement), newElement
        }
      };
      module.exports = ReactElementValidator
    }, { 126: 126, 135: 135, 154: 154, 39: 39, 57: 57, 63: 63, 73: 73, 76: 76, 77: 77 }],
    59: [function(_dereq_, module, exports) {
      "use strict";
      function registerNullComponentID(id) {
        nullComponentIDsRegistry[id] = !0
      }

      function deregisterNullComponentID(id) {
        delete nullComponentIDsRegistry[id]
      }

      function isNullComponentID(id) {
        return !!nullComponentIDsRegistry[id]
      }

      var component, ReactElement = _dereq_(57), ReactInstanceMap = _dereq_(67), invariant = _dereq_(135), nullComponentIDsRegistry = {}, ReactEmptyComponentInjection = {
        injectEmptyComponent: function(emptyComponent) {
          component = ReactElement.createFactory(emptyComponent)
        }
      }, ReactEmptyComponentType = function() {
      };
      ReactEmptyComponentType.prototype.componentDidMount = function() {
        var internalInstance = ReactInstanceMap.get(this);
        internalInstance && registerNullComponentID(internalInstance._rootNodeID)
      }, ReactEmptyComponentType.prototype.componentWillUnmount = function() {
        var internalInstance = ReactInstanceMap.get(this);
        internalInstance && deregisterNullComponentID(internalInstance._rootNodeID)
      }, ReactEmptyComponentType.prototype.render = function() {
        return invariant(component, "Trying to return null from a render, but no null placeholder component was injected."), component()
      };
      var emptyElement = ReactElement.createElement(ReactEmptyComponentType), ReactEmptyComponent = {
        emptyElement: emptyElement,
        injection: ReactEmptyComponentInjection,
        isNullComponentID: isNullComponentID
      };
      module.exports = ReactEmptyComponent
    }, { 135: 135, 57: 57, 67: 67 }],
    60: [function(_dereq_, module, exports) {
      "use strict";
      var ReactErrorUtils = {
        guard: function(func, name) {
          return func
        }
      };
      module.exports = ReactErrorUtils
    }, {}],
    61: [function(_dereq_, module, exports) {
      "use strict";
      function runEventQueueInBatch(events) {
        EventPluginHub.enqueueEvents(events), EventPluginHub.processEventQueue()
      }

      var EventPluginHub = _dereq_(17), ReactEventEmitterMixin = {
        handleTopLevel: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);
          runEventQueueInBatch(events)
        }
      };
      module.exports = ReactEventEmitterMixin
    }, { 17: 17 }],
    62: [function(_dereq_, module, exports) {
      "use strict";
      function findParent(node) {
        var nodeID = ReactMount.getID(node), rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID), container = ReactMount.findReactContainerForID(rootID), parent = ReactMount.getFirstReactDOM(container);
        return parent
      }

      function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
        this.topLevelType = topLevelType, this.nativeEvent = nativeEvent, this.ancestors = []
      }

      function handleTopLevelImpl(bookKeeping) {
        for (var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window, ancestor = topLevelTarget; ancestor;)bookKeeping.ancestors.push(ancestor), ancestor = findParent(ancestor);
        for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
          topLevelTarget = bookKeeping.ancestors[i];
          var topLevelTargetID = ReactMount.getID(topLevelTarget) || "";
          ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent)
        }
      }

      function scrollValueMonitor(cb) {
        var scrollPosition = getUnboundedScrollPosition(window);
        cb(scrollPosition)
      }

      var EventListener = _dereq_(16), ExecutionEnvironment = _dereq_(21), PooledClass = _dereq_(28), ReactInstanceHandles = _dereq_(66), ReactMount = _dereq_(70), ReactUpdates = _dereq_(87), assign = _dereq_(27), getEventTarget = _dereq_(125), getUnboundedScrollPosition = _dereq_(131);
      assign(TopLevelCallbackBookKeeping.prototype, {
        destructor: function() {
          this.topLevelType = null, this.nativeEvent = null, this.ancestors.length = 0
        }
      }), PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
      var ReactEventListener = {
        _enabled: !0,
        _handleTopLevel: null,
        WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
        setHandleTopLevel: function(handleTopLevel) {
          ReactEventListener._handleTopLevel = handleTopLevel
        },
        setEnabled: function(enabled) {
          ReactEventListener._enabled = !!enabled
        },
        isEnabled: function() {
          return ReactEventListener._enabled
        },
        trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
          var element = handle;
          return element ? EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType)) : null
        },
        trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
          var element = handle;
          return element ? EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType)) : null
        },
        monitorScrollValue: function(refresh) {
          var callback = scrollValueMonitor.bind(null, refresh);
          EventListener.listen(window, "scroll", callback)
        },
        dispatchEvent: function(topLevelType, nativeEvent) {
          if (ReactEventListener._enabled) {
            var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
            try {
              ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping)
            } finally {
              TopLevelCallbackBookKeeping.release(bookKeeping)
            }
          }
        }
      };
      module.exports = ReactEventListener
    }, { 125: 125, 131: 131, 16: 16, 21: 21, 27: 27, 28: 28, 66: 66, 70: 70, 87: 87 }],
    63: [function(_dereq_, module, exports) {
      "use strict";
      var ReactElement = _dereq_(57), warning = _dereq_(154), fragmentKey = "_reactFragment", didWarnKey = "_reactDidWarn", canWarnForReactFragment = !1;
      try {
        var dummy = function() {
          return 1
        };
        Object.defineProperty({}, fragmentKey, {
          enumerable: !1,
          value: !0
        }), Object.defineProperty({}, "key", { enumerable: !0, get: dummy }), canWarnForReactFragment = !0
      } catch (x) {
      }
      var proxyPropertyAccessWithWarning = function(obj, key) {
        Object.defineProperty(obj, key, {
          enumerable: !0, get: function() {
            return warning(this[didWarnKey], "A ReactFragment is an opaque type. Accessing any of its properties is deprecated. Pass it to one of the React.Children helpers."), this[didWarnKey] = !0, this[fragmentKey][key]
          }, set: function(value) {
            warning(this[didWarnKey], "A ReactFragment is an immutable opaque type. Mutating its properties is deprecated."), this[didWarnKey] = !0, this[fragmentKey][key] = value
          }
        })
      }, issuedWarnings = {}, didWarnForFragment = function(fragment) {
        var fragmentCacheKey = "";
        for (var key in fragment)fragmentCacheKey += key + ":" + typeof fragment[key] + ",";
        var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];
        return issuedWarnings[fragmentCacheKey] = !0, alreadyWarnedOnce
      }, ReactFragment = {
        create: function(object) {
          if ("object" != typeof object || !object || Array.isArray(object))return warning(!1, "React.addons.createFragment only accepts a single object.", object), object;
          if (ReactElement.isValidElement(object))return warning(!1, "React.addons.createFragment does not accept a ReactElement without a wrapper object."), object;
          if (canWarnForReactFragment) {
            var proxy = {};
            Object.defineProperty(proxy, fragmentKey, {
              enumerable: !1,
              value: object
            }), Object.defineProperty(proxy, didWarnKey, { writable: !0, enumerable: !1, value: !1 });
            for (var key in object)proxyPropertyAccessWithWarning(proxy, key);
            return Object.preventExtensions(proxy), proxy
          }
          return object
        }, extract: function(fragment) {
          return canWarnForReactFragment ? fragment[fragmentKey] ? fragment[fragmentKey] : (warning(didWarnForFragment(fragment), "Any use of a keyed object should be wrapped in React.addons.createFragment(object) before being passed as a child."), fragment) : fragment
        }, extractIfFragment: function(fragment) {
          if (canWarnForReactFragment) {
            if (fragment[fragmentKey])return fragment[fragmentKey];
            for (var key in fragment)if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key]))return ReactFragment.extract(fragment)
          }
          return fragment
        }
      };
      module.exports = ReactFragment
    }, { 154: 154, 57: 57 }],
    64: [function(_dereq_, module, exports) {
      "use strict";
      var DOMProperty = _dereq_(10), EventPluginHub = _dereq_(17), ReactComponentEnvironment = _dereq_(36), ReactClass = _dereq_(33), ReactEmptyComponent = _dereq_(59), ReactBrowserEventEmitter = _dereq_(30), ReactNativeComponent = _dereq_(73), ReactDOMComponent = _dereq_(42), ReactPerf = _dereq_(75), ReactRootIndex = _dereq_(83), ReactUpdates = _dereq_(87), ReactInjection = {
        Component: ReactComponentEnvironment.injection,
        Class: ReactClass.injection,
        DOMComponent: ReactDOMComponent.injection,
        DOMProperty: DOMProperty.injection,
        EmptyComponent: ReactEmptyComponent.injection,
        EventPluginHub: EventPluginHub.injection,
        EventEmitter: ReactBrowserEventEmitter.injection,
        NativeComponent: ReactNativeComponent.injection,
        Perf: ReactPerf.injection,
        RootIndex: ReactRootIndex.injection,
        Updates: ReactUpdates.injection
      };
      module.exports = ReactInjection
    }, { 10: 10, 17: 17, 30: 30, 33: 33, 36: 36, 42: 42, 59: 59, 73: 73, 75: 75, 83: 83, 87: 87 }],
    65: [function(_dereq_, module, exports) {
      "use strict";
      function isInDocument(node) {
        return containsNode(document.documentElement, node)
      }

      var ReactDOMSelection = _dereq_(50), containsNode = _dereq_(109), focusNode = _dereq_(119), getActiveElement = _dereq_(121), ReactInputSelection = {
        hasSelectionCapabilities: function(elem) {
          return elem && ("INPUT" === elem.nodeName && "text" === elem.type || "TEXTAREA" === elem.nodeName || "true" === elem.contentEditable)
        }, getSelectionInformation: function() {
          var focusedElem = getActiveElement();
          return {
            focusedElem: focusedElem,
            selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
          }
        }, restoreSelection: function(priorSelectionInformation) {
          var curFocusedElem = getActiveElement(), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
          curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem) && (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem) && ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange), focusNode(priorFocusedElem))
        }, getSelection: function(input) {
          var selection;
          if ("selectionStart" in input)selection = {
            start: input.selectionStart,
            end: input.selectionEnd
          }; else if (document.selection && "INPUT" === input.nodeName) {
            var range = document.selection.createRange();
            range.parentElement() === input && (selection = {
              start: -range.moveStart("character", -input.value.length),
              end: -range.moveEnd("character", -input.value.length)
            })
          } else selection = ReactDOMSelection.getOffsets(input);
          return selection || { start: 0, end: 0 }
        }, setSelection: function(input, offsets) {
          var start = offsets.start, end = offsets.end;
          if ("undefined" == typeof end && (end = start), "selectionStart" in input)input.selectionStart = start, input.selectionEnd = Math.min(end, input.value.length); else if (document.selection && "INPUT" === input.nodeName) {
            var range = input.createTextRange();
            range.collapse(!0), range.moveStart("character", start), range.moveEnd("character", end - start), range.select()
          } else ReactDOMSelection.setOffsets(input, offsets)
        }
      };
      module.exports = ReactInputSelection
    }, { 109: 109, 119: 119, 121: 121, 50: 50 }],
    66: [function(_dereq_, module, exports) {
      "use strict";
      function getReactRootIDString(index) {
        return SEPARATOR + index.toString(36)
      }

      function isBoundary(id, index) {
        return id.charAt(index) === SEPARATOR || index === id.length
      }

      function isValidID(id) {
        return "" === id || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
      }

      function isAncestorIDOf(ancestorID, descendantID) {
        return 0 === descendantID.indexOf(ancestorID) && isBoundary(descendantID, ancestorID.length)
      }

      function getParentID(id) {
        return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : ""
      }

      function getNextDescendantID(ancestorID, destinationID) {
        if (invariant(isValidID(ancestorID) && isValidID(destinationID), "getNextDescendantID(%s, %s): Received an invalid React DOM ID.", ancestorID, destinationID), invariant(isAncestorIDOf(ancestorID, destinationID), "getNextDescendantID(...): React has made an invalid assumption about the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.", ancestorID, destinationID), ancestorID === destinationID)return ancestorID;
        var i, start = ancestorID.length + SEPARATOR_LENGTH;
        for (i = start; i < destinationID.length && !isBoundary(destinationID, i); i++);
        return destinationID.substr(0, i)
      }

      function getFirstCommonAncestorID(oneID, twoID) {
        var minLength = Math.min(oneID.length, twoID.length);
        if (0 === minLength)return "";
        for (var lastCommonMarkerIndex = 0, i = 0; i <= minLength; i++)if (isBoundary(oneID, i) && isBoundary(twoID, i))lastCommonMarkerIndex = i; else if (oneID.charAt(i) !== twoID.charAt(i))break;
        var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
        return invariant(isValidID(longestCommonID), "getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s", oneID, twoID, longestCommonID), longestCommonID
      }

      function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
        start = start || "", stop = stop || "", invariant(start !== stop, "traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.", start);
        var traverseUp = isAncestorIDOf(stop, start);
        invariant(traverseUp || isAncestorIDOf(start, stop), "traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do not have a parent path.", start, stop);
        for (var depth = 0, traverse = traverseUp ? getParentID : getNextDescendantID, id = start; ; id = traverse(id, stop)) {
          var ret;
          if (skipFirst && id === start || skipLast && id === stop || (ret = cb(id, traverseUp, arg)), ret === !1 || id === stop)break;
          invariant(depth++ < MAX_TREE_DEPTH, "traverseParentPath(%s, %s, ...): Detected an infinite loop while traversing the React DOM ID tree. This may be due to malformed IDs: %s", start, stop)
        }
      }

      var ReactRootIndex = _dereq_(83), invariant = _dereq_(135), SEPARATOR = ".", SEPARATOR_LENGTH = SEPARATOR.length, MAX_TREE_DEPTH = 100, ReactInstanceHandles = {
        createReactRootID: function() {
          return getReactRootIDString(ReactRootIndex.createReactRootIndex())
        },
        createReactID: function(rootID, name) {
          return rootID + name
        },
        getReactRootIDFromNodeID: function(id) {
          if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
            var index = id.indexOf(SEPARATOR, 1);
            return index > -1 ? id.substr(0, index) : id
          }
          return null
        },
        traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
          var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
          ancestorID !== leaveID && traverseParentPath(leaveID, ancestorID, cb, upArg, !1, !0), ancestorID !== enterID && traverseParentPath(ancestorID, enterID, cb, downArg, !0, !1)
        },
        traverseTwoPhase: function(targetID, cb, arg) {
          targetID && (traverseParentPath("", targetID, cb, arg, !0, !1), traverseParentPath(targetID, "", cb, arg, !1, !0))
        },
        traverseAncestors: function(targetID, cb, arg) {
          traverseParentPath("", targetID, cb, arg, !0, !1)
        },
        _getFirstCommonAncestorID: getFirstCommonAncestorID,
        _getNextDescendantID: getNextDescendantID,
        isAncestorIDOf: isAncestorIDOf,
        SEPARATOR: SEPARATOR
      };
      module.exports = ReactInstanceHandles
    }, { 135: 135, 83: 83 }],
    67: [function(_dereq_, module, exports) {
      "use strict";
      var ReactInstanceMap = {
        remove: function(key) {
          key._reactInternalInstance = void 0
        }, get: function(key) {
          return key._reactInternalInstance
        }, has: function(key) {
          return void 0 !== key._reactInternalInstance
        }, set: function(key, value) {
          key._reactInternalInstance = value
        }
      };
      module.exports = ReactInstanceMap
    }, {}],
    68: [function(_dereq_, module, exports) {
      "use strict";
      var ReactLifeCycle = { currentlyMountingInstance: null, currentlyUnmountingInstance: null };
      module.exports = ReactLifeCycle
    }, {}],
    69: [function(_dereq_, module, exports) {
      "use strict";
      var adler32 = _dereq_(106), ReactMarkupChecksum = {
        CHECKSUM_ATTR_NAME: "data-react-checksum",
        addChecksumToMarkup: function(markup) {
          var checksum = adler32(markup);
          return markup.replace(">", " " + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">')
        },
        canReuseMarkup: function(markup, element) {
          var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
          existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
          var markupChecksum = adler32(markup);
          return markupChecksum === existingChecksum
        }
      };
      module.exports = ReactMarkupChecksum
    }, { 106: 106 }],
    70: [function(_dereq_, module, exports) {
      "use strict";
      function firstDifferenceIndex(string1, string2) {
        for (var minLen = Math.min(string1.length, string2.length), i = 0; i < minLen; i++)if (string1.charAt(i) !== string2.charAt(i))return i;
        return string1.length === string2.length ? -1 : minLen
      }

      function getReactRootID(container) {
        var rootElement = getReactRootElementInContainer(container);
        return rootElement && ReactMount.getID(rootElement)
      }

      function getID(node) {
        var id = internalGetID(node);
        if (id)if (nodeCache.hasOwnProperty(id)) {
          var cached = nodeCache[id];
          cached !== node && (invariant(!isValid(cached, id), "ReactMount: Two valid but unequal nodes with the same `%s`: %s", ATTR_NAME, id), nodeCache[id] = node)
        } else nodeCache[id] = node;
        return id
      }

      function internalGetID(node) {
        return node && node.getAttribute && node.getAttribute(ATTR_NAME) || ""
      }

      function setID(node, id) {
        var oldID = internalGetID(node);
        oldID !== id && delete nodeCache[oldID], node.setAttribute(ATTR_NAME, id), nodeCache[id] = node
      }

      function getNode(id) {
        return nodeCache.hasOwnProperty(id) && isValid(nodeCache[id], id) || (nodeCache[id] = ReactMount.findReactNodeByID(id)), nodeCache[id]
      }

      function getNodeFromInstance(instance) {
        var id = ReactInstanceMap.get(instance)._rootNodeID;
        return ReactEmptyComponent.isNullComponentID(id) ? null : (nodeCache.hasOwnProperty(id) && isValid(nodeCache[id], id) || (nodeCache[id] = ReactMount.findReactNodeByID(id)), nodeCache[id])
      }

      function isValid(node, id) {
        if (node) {
          invariant(internalGetID(node) === id, "ReactMount: Unexpected modification of `%s`", ATTR_NAME);
          var container = ReactMount.findReactContainerForID(id);
          if (container && containsNode(container, node))return !0
        }
        return !1
      }

      function purgeID(id) {
        delete nodeCache[id]
      }

      function findDeepestCachedAncestorImpl(ancestorID) {
        var ancestor = nodeCache[ancestorID];
        return !(!ancestor || !isValid(ancestor, ancestorID)) && void(deepestNodeSoFar = ancestor)
      }

      function findDeepestCachedAncestor(targetID) {
        deepestNodeSoFar = null, ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
        var foundNode = deepestNodeSoFar;
        return deepestNodeSoFar = null, foundNode
      }

      function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup) {
        var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, emptyObject);
        componentInstance._isTopLevel = !0, ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup)
      }

      function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup) {
        var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
        transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup), ReactUpdates.ReactReconcileTransaction.release(transaction)
      }

      var DOMProperty = _dereq_(10), ReactBrowserEventEmitter = _dereq_(30), ReactCurrentOwner = _dereq_(39), ReactElement = _dereq_(57), ReactElementValidator = _dereq_(58), ReactEmptyComponent = _dereq_(59), ReactInstanceHandles = _dereq_(66), ReactInstanceMap = _dereq_(67), ReactMarkupChecksum = _dereq_(69), ReactPerf = _dereq_(75), ReactReconciler = _dereq_(81), ReactUpdateQueue = _dereq_(86), ReactUpdates = _dereq_(87), emptyObject = _dereq_(115), containsNode = _dereq_(109), getReactRootElementInContainer = _dereq_(129), instantiateReactComponent = _dereq_(134), invariant = _dereq_(135), setInnerHTML = _dereq_(148), shouldUpdateReactComponent = _dereq_(151), warning = _dereq_(154), SEPARATOR = ReactInstanceHandles.SEPARATOR, ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME, nodeCache = {}, ELEMENT_NODE_TYPE = 1, DOC_NODE_TYPE = 9, instancesByReactRootID = {}, containersByReactRootID = {}, rootElementsByReactRootID = {}, findComponentRootReusableArray = [], deepestNodeSoFar = null, ReactMount = {
        _instancesByReactRootID: instancesByReactRootID,
        scrollMonitor: function(container, renderCallback) {
          renderCallback()
        },
        _updateRootComponent: function(prevComponent, nextElement, container, callback) {
          return ReactElementValidator.checkAndWarnForMutatedProps(nextElement), ReactMount.scrollMonitor(container, function() {
            ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement), callback && ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback)
          }), rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container), prevComponent
        },
        _registerComponent: function(nextComponent, container) {
          invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "_registerComponent(...): Target container is not a DOM element."), ReactBrowserEventEmitter.ensureScrollValueMonitoring();
          var reactRootID = ReactMount.registerContainer(container);
          return instancesByReactRootID[reactRootID] = nextComponent, reactRootID
        },
        _renderNewRootComponent: function(nextElement, container, shouldReuseMarkup) {
          warning(null == ReactCurrentOwner.current, "_renderNewRootComponent(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.");
          var componentInstance = instantiateReactComponent(nextElement, null), reactRootID = ReactMount._registerComponent(componentInstance, container);
          return ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup), rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container), componentInstance
        },
        render: function(nextElement, container, callback) {
          invariant(ReactElement.isValidElement(nextElement), "React.render(): Invalid component element.%s", "string" == typeof nextElement ? " Instead of passing an element string, make sure to instantiate it by passing it to React.createElement." : "function" == typeof nextElement ? " Instead of passing a component class, make sure to instantiate it by passing it to React.createElement." : null != nextElement && void 0 !== nextElement.props ? " This may be caused by unintentionally loading two independent copies of React." : "");
          var prevComponent = instancesByReactRootID[getReactRootID(container)];
          if (prevComponent) {
            var prevElement = prevComponent._currentElement;
            if (shouldUpdateReactComponent(prevElement, nextElement))return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();
            ReactMount.unmountComponentAtNode(container)
          }
          var reactRootElement = getReactRootElementInContainer(container), containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);
          if (!containerHasReactMarkup || reactRootElement.nextSibling)for (var rootElementSibling = reactRootElement; rootElementSibling;) {
            if (ReactMount.isRenderedByReact(rootElementSibling)) {
              warning(!1, "render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
              break
            }
            rootElementSibling = rootElementSibling.nextSibling
          }
          var shouldReuseMarkup = containerHasReactMarkup && !prevComponent, component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup).getPublicInstance();
          return callback && callback.call(component), component
        },
        constructAndRenderComponent: function(constructor, props, container) {
          var element = ReactElement.createElement(constructor, props);
          return ReactMount.render(element, container)
        },
        constructAndRenderComponentByID: function(constructor, props, id) {
          var domNode = document.getElementById(id);
          return invariant(domNode, 'Tried to get element with id of "%s" but it is not present on the page.', id), ReactMount.constructAndRenderComponent(constructor, props, domNode)
        },
        registerContainer: function(container) {
          var reactRootID = getReactRootID(container);
          return reactRootID && (reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID)), reactRootID || (reactRootID = ReactInstanceHandles.createReactRootID()), containersByReactRootID[reactRootID] = container, reactRootID
        },
        unmountComponentAtNode: function(container) {
          warning(null == ReactCurrentOwner.current, "unmountComponentAtNode(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate."), invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "unmountComponentAtNode(...): Target container is not a DOM element.");
          var reactRootID = getReactRootID(container), component = instancesByReactRootID[reactRootID];
          return !!component && (ReactMount.unmountComponentFromNode(component, container), delete instancesByReactRootID[reactRootID], delete containersByReactRootID[reactRootID], delete rootElementsByReactRootID[reactRootID], !0)
        },
        unmountComponentFromNode: function(instance, container) {
          for (ReactReconciler.unmountComponent(instance), container.nodeType === DOC_NODE_TYPE && (container = container.documentElement); container.lastChild;)container.removeChild(container.lastChild)
        },
        findReactContainerForID: function(id) {
          var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id), container = containersByReactRootID[reactRootID], rootElement = rootElementsByReactRootID[reactRootID];
          if (rootElement && rootElement.parentNode !== container) {
            invariant(internalGetID(rootElement) === reactRootID, "ReactMount: Root element ID differed from reactRootID.");
            var containerChild = container.firstChild;
            containerChild && reactRootID === internalGetID(containerChild) ? rootElementsByReactRootID[reactRootID] = containerChild : warning(!1, "ReactMount: Root element has been removed from its original container. New container:", rootElement.parentNode)
          }
          return container
        },
        findReactNodeByID: function(id) {
          var reactRoot = ReactMount.findReactContainerForID(id);
          return ReactMount.findComponentRoot(reactRoot, id)
        },
        isRenderedByReact: function(node) {
          if (1 !== node.nodeType)return !1;
          var id = ReactMount.getID(node);
          return !!id && id.charAt(0) === SEPARATOR
        },
        getFirstReactDOM: function(node) {
          for (var current = node; current && current.parentNode !== current;) {
            if (ReactMount.isRenderedByReact(current))return current;
            current = current.parentNode
          }
          return null
        },
        findComponentRoot: function(ancestorNode, targetID) {
          var firstChildren = findComponentRootReusableArray, childIndex = 0, deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
          for (firstChildren[0] = deepestAncestor.firstChild, firstChildren.length = 1; childIndex < firstChildren.length;) {
            for (var targetChild, child = firstChildren[childIndex++]; child;) {
              var childID = ReactMount.getID(child);
              childID ? targetID === childID ? targetChild = child : ReactInstanceHandles.isAncestorIDOf(childID, targetID) && (firstChildren.length = childIndex = 0, firstChildren.push(child.firstChild)) : firstChildren.push(child.firstChild), child = child.nextSibling
            }
            if (targetChild)return firstChildren.length = 0, targetChild
          }
          firstChildren.length = 0, invariant(!1, "findComponentRoot(..., %s): Unable to find element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a <tbody> when using tables, nesting tags like <form>, <p>, or <a>, or using non-SVG elements in an <svg> parent. Try inspecting the child nodes of the element with React ID `%s`.", targetID, ReactMount.getID(ancestorNode))
        },
        _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {
          if (invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), "mountComponentIntoNode(...): Target container is not valid."), shouldReuseMarkup) {
            var rootElement = getReactRootElementInContainer(container);
            if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement))return;
            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
            var diffIndex = firstDifferenceIndex(markup, rootMarkup), difference = " (client) " + markup.substring(diffIndex - 20, diffIndex + 20) + "\n (server) " + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            invariant(container.nodeType !== DOC_NODE_TYPE, "You're trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s", difference), warning(!1, "React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:\n%s", difference)
          }
          invariant(container.nodeType !== DOC_NODE_TYPE, "You're trying to render a component to the document but you didn't use server rendering. We can't do this without using server rendering due to cross-browser quirks. See React.renderToString() for server rendering."), setInnerHTML(container, markup)
        },
        getReactRootID: getReactRootID,
        getID: getID,
        setID: setID,
        getNode: getNode,
        getNodeFromInstance: getNodeFromInstance,
        purgeID: purgeID
      };
      ReactPerf.measureMethods(ReactMount, "ReactMount", {
        _renderNewRootComponent: "_renderNewRootComponent",
        _mountImageIntoNode: "_mountImageIntoNode"
      }), module.exports = ReactMount
    }, {
      10: 10,
      109: 109,
      115: 115,
      129: 129,
      134: 134,
      135: 135,
      148: 148,
      151: 151,
      154: 154,
      30: 30,
      39: 39,
      57: 57,
      58: 58,
      59: 59,
      66: 66,
      67: 67,
      69: 69,
      75: 75,
      81: 81,
      86: 86,
      87: 87
    }],
    71: [function(_dereq_, module, exports) {
      "use strict";
      function enqueueMarkup(parentID, markup, toIndex) {
        updateQueue.push({
          parentID: parentID,
          parentNode: null,
          type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
          markupIndex: markupQueue.push(markup) - 1,
          textContent: null,
          fromIndex: null,
          toIndex: toIndex
        })
      }

      function enqueueMove(parentID, fromIndex, toIndex) {
        updateQueue.push({
          parentID: parentID,
          parentNode: null,
          type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
          markupIndex: null,
          textContent: null,
          fromIndex: fromIndex,
          toIndex: toIndex
        })
      }

      function enqueueRemove(parentID, fromIndex) {
        updateQueue.push({
          parentID: parentID,
          parentNode: null,
          type: ReactMultiChildUpdateTypes.REMOVE_NODE,
          markupIndex: null,
          textContent: null,
          fromIndex: fromIndex,
          toIndex: null
        })
      }

      function enqueueTextContent(parentID, textContent) {
        updateQueue.push({
          parentID: parentID,
          parentNode: null,
          type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
          markupIndex: null,
          textContent: textContent,
          fromIndex: null,
          toIndex: null
        })
      }

      function processQueue() {
        updateQueue.length && (ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue), clearQueue())
      }

      function clearQueue() {
        updateQueue.length = 0, markupQueue.length = 0
      }

      var ReactComponentEnvironment = _dereq_(36), ReactMultiChildUpdateTypes = _dereq_(72), ReactReconciler = _dereq_(81), ReactChildReconciler = _dereq_(31), updateDepth = 0, updateQueue = [], markupQueue = [], ReactMultiChild = {
        Mixin: {
          mountChildren: function(nestedChildren, transaction, context) {
            var children = ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
            this._renderedChildren = children;
            var mountImages = [], index = 0;
            for (var name in children)if (children.hasOwnProperty(name)) {
              var child = children[name], rootID = this._rootNodeID + name, mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
              child._mountIndex = index, mountImages.push(mountImage), index++
            }
            return mountImages
          }, updateTextContent: function(nextContent) {
            updateDepth++;
            var errorThrown = !0;
            try {
              var prevChildren = this._renderedChildren;
              ReactChildReconciler.unmountChildren(prevChildren);
              for (var name in prevChildren)prevChildren.hasOwnProperty(name) && this._unmountChildByName(prevChildren[name], name);
              this.setTextContent(nextContent), errorThrown = !1
            } finally {
              updateDepth--, updateDepth || (errorThrown ? clearQueue() : processQueue())
            }
          }, updateChildren: function(nextNestedChildren, transaction, context) {
            updateDepth++;
            var errorThrown = !0;
            try {
              this._updateChildren(nextNestedChildren, transaction, context), errorThrown = !1
            } finally {
              updateDepth--, updateDepth || (errorThrown ? clearQueue() : processQueue())
            }
          }, _updateChildren: function(nextNestedChildren, transaction, context) {
            var prevChildren = this._renderedChildren, nextChildren = ReactChildReconciler.updateChildren(prevChildren, nextNestedChildren, transaction, context);
            if (this._renderedChildren = nextChildren, nextChildren || prevChildren) {
              var name, lastIndex = 0, nextIndex = 0;
              for (name in nextChildren)if (nextChildren.hasOwnProperty(name)) {
                var prevChild = prevChildren && prevChildren[name], nextChild = nextChildren[name];
                prevChild === nextChild ? (this.moveChild(prevChild, nextIndex, lastIndex), lastIndex = Math.max(prevChild._mountIndex, lastIndex), prevChild._mountIndex = nextIndex) : (prevChild && (lastIndex = Math.max(prevChild._mountIndex, lastIndex), this._unmountChildByName(prevChild, name)), this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context)), nextIndex++
              }
              for (name in prevChildren)!prevChildren.hasOwnProperty(name) || nextChildren && nextChildren.hasOwnProperty(name) || this._unmountChildByName(prevChildren[name], name)
            }
          }, unmountChildren: function() {
            var renderedChildren = this._renderedChildren;
            ReactChildReconciler.unmountChildren(renderedChildren), this._renderedChildren = null
          }, moveChild: function(child, toIndex, lastIndex) {
            child._mountIndex < lastIndex && enqueueMove(this._rootNodeID, child._mountIndex, toIndex)
          }, createChild: function(child, mountImage) {
            enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex)
          }, removeChild: function(child) {
            enqueueRemove(this._rootNodeID, child._mountIndex)
          }, setTextContent: function(textContent) {
            enqueueTextContent(this._rootNodeID, textContent)
          }, _mountChildByNameAtIndex: function(child, name, index, transaction, context) {
            var rootID = this._rootNodeID + name, mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
            child._mountIndex = index, this.createChild(child, mountImage)
          }, _unmountChildByName: function(child, name) {
            this.removeChild(child), child._mountIndex = null
          }
        }
      };
      module.exports = ReactMultiChild
    }, { 31: 31, 36: 36, 72: 72, 81: 81 }],
    72: [function(_dereq_, module, exports) {
      "use strict";
      var keyMirror = _dereq_(140), ReactMultiChildUpdateTypes = keyMirror({
        INSERT_MARKUP: null,
        MOVE_EXISTING: null,
        REMOVE_NODE: null,
        TEXT_CONTENT: null
      });
      module.exports = ReactMultiChildUpdateTypes
    }, { 140: 140 }],
    73: [function(_dereq_, module, exports) {
      "use strict";
      function getComponentClassForElement(element) {
        if ("function" == typeof element.type)return element.type;
        var tag = element.type, componentClass = tagToComponentClass[tag];
        return null == componentClass && (tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag)), componentClass
      }

      function createInternalComponent(element) {
        return invariant(genericComponentClass, "There is no registered component for the tag %s", element.type), new genericComponentClass(element.type, element.props)
      }

      function createInstanceForText(text) {
        return new textComponentClass(text)
      }

      function isTextComponent(component) {
        return component instanceof textComponentClass
      }

      var assign = _dereq_(27), invariant = _dereq_(135), autoGenerateWrapperClass = null, genericComponentClass = null, tagToComponentClass = {}, textComponentClass = null, ReactNativeComponentInjection = {
        injectGenericComponentClass: function(componentClass) {
          genericComponentClass = componentClass
        }, injectTextComponentClass: function(componentClass) {
          textComponentClass = componentClass
        }, injectComponentClasses: function(componentClasses) {
          assign(tagToComponentClass, componentClasses)
        }, injectAutoWrapper: function(wrapperFactory) {
          autoGenerateWrapperClass = wrapperFactory
        }
      }, ReactNativeComponent = {
        getComponentClassForElement: getComponentClassForElement,
        createInternalComponent: createInternalComponent,
        createInstanceForText: createInstanceForText,
        isTextComponent: isTextComponent,
        injection: ReactNativeComponentInjection
      };
      module.exports = ReactNativeComponent
    }, { 135: 135, 27: 27 }],
    74: [function(_dereq_, module, exports) {
      "use strict";
      var invariant = _dereq_(135), ReactOwner = {
        isValidOwner: function(object) {
          return !(!object || "function" != typeof object.attachRef || "function" != typeof object.detachRef)
        }, addComponentAsRefTo: function(component, ref, owner) {
          invariant(ReactOwner.isValidOwner(owner), "addComponentAsRefTo(...): Only a ReactOwner can have refs. This usually means that you're trying to add a ref to a component that doesn't have an owner (that is, was not created inside of another component's `render` method). Try rendering this component inside of a new top-level component which will hold the ref."), owner.attachRef(ref, component)
        }, removeComponentAsRefFrom: function(component, ref, owner) {
          invariant(ReactOwner.isValidOwner(owner), "removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This usually means that you're trying to remove a ref to a component that doesn't have an owner (that is, was not created inside of another component's `render` method). Try rendering this component inside of a new top-level component which will hold the ref."), owner.getPublicInstance().refs[ref] === component.getPublicInstance() && owner.detachRef(ref)
        }
      };
      module.exports = ReactOwner
    }, { 135: 135 }],
    75: [function(_dereq_, module, exports) {
      "use strict";
      function _noMeasure(objName, fnName, func) {
        return func
      }

      var ReactPerf = {
        enableMeasure: !1,
        storedMeasure: _noMeasure,
        measureMethods: function(object, objectName, methodNames) {
          for (var key in methodNames)methodNames.hasOwnProperty(key) && (object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]))
        },
        measure: function(objName, fnName, func) {
          var measuredFunc = null, wrapper = function() {
            return ReactPerf.enableMeasure ? (measuredFunc || (measuredFunc = ReactPerf.storedMeasure(objName, fnName, func)), measuredFunc.apply(this, arguments)) : func.apply(this, arguments)
          };
          return wrapper.displayName = objName + "_" + fnName, wrapper
        },
        injection: {
          injectMeasure: function(measure) {
            ReactPerf.storedMeasure = measure
          }
        }
      };
      module.exports = ReactPerf
    }, {}],
    76: [function(_dereq_, module, exports) {
      "use strict";
      var ReactPropTypeLocationNames = {};
      ReactPropTypeLocationNames = {
        prop: "prop",
        context: "context",
        childContext: "child context"
      }, module.exports = ReactPropTypeLocationNames
    }, {}],
    77: [function(_dereq_, module, exports) {
      "use strict";
      var keyMirror = _dereq_(140), ReactPropTypeLocations = keyMirror({
        prop: null,
        context: null,
        childContext: null
      });
      module.exports = ReactPropTypeLocations
    }, { 140: 140 }],
    78: [function(_dereq_, module, exports) {
      "use strict";
      function createChainableTypeChecker(validate) {
        function checkType(isRequired, props, propName, componentName, location) {
          if (componentName = componentName || ANONYMOUS, null == props[propName]) {
            var locationName = ReactPropTypeLocationNames[location];
            return isRequired ? new Error("Required " + locationName + " `" + propName + "` was not specified in " + ("`" + componentName + "`.")) : null
          }
          return validate(props, propName, componentName, location)
        }

        var chainedCheckType = checkType.bind(null, !1);
        return chainedCheckType.isRequired = checkType.bind(null, !0), chainedCheckType
      }

      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location) {
          var propValue = props[propName], propType = getPropType(propValue);
          if (propType !== expectedType) {
            var locationName = ReactPropTypeLocationNames[location], preciseType = getPreciseType(propValue);
            return new Error("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` " + ("supplied to `" + componentName + "`, expected `" + expectedType + "`."))
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunction.thatReturns(null))
      }

      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location) {
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var locationName = ReactPropTypeLocationNames[location], propType = getPropType(propValue);
            return new Error("Invalid " + locationName + " `" + propName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."))
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location);
            if (error instanceof Error)return error
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function createElementTypeChecker() {
        function validate(props, propName, componentName, location) {
          if (!ReactElement.isValidElement(props[propName])) {
            var locationName = ReactPropTypeLocationNames[location];
            return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected a ReactElement."))
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location) {
          if (!(props[propName] instanceof expectedClass)) {
            var locationName = ReactPropTypeLocationNames[location], expectedClassName = expectedClass.name || ANONYMOUS;
            return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected instance of `" + expectedClassName + "`."))
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function createEnumTypeChecker(expectedValues) {
        function validate(props, propName, componentName, location) {
          for (var propValue = props[propName], i = 0; i < expectedValues.length; i++)if (propValue === expectedValues[i])return null;
          var locationName = ReactPropTypeLocationNames[location], valuesString = JSON.stringify(expectedValues);
          return new Error("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."))
        }

        return createChainableTypeChecker(validate)
      }

      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location) {
          var propValue = props[propName], propType = getPropType(propValue);
          if ("object" !== propType) {
            var locationName = ReactPropTypeLocationNames[location];
            return new Error("Invalid " + locationName + " `" + propName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."))
          }
          for (var key in propValue)if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(propValue, key, componentName, location);
            if (error instanceof Error)return error
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function createUnionTypeChecker(arrayOfTypeCheckers) {
        function validate(props, propName, componentName, location) {
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (null == checker(props, propName, componentName, location))return null
          }
          var locationName = ReactPropTypeLocationNames[location];
          return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`."))
        }

        return createChainableTypeChecker(validate)
      }

      function createNodeChecker() {
        function validate(props, propName, componentName, location) {
          if (!isNode(props[propName])) {
            var locationName = ReactPropTypeLocationNames[location];
            return new Error("Invalid " + locationName + " `" + propName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."))
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location) {
          var propValue = props[propName], propType = getPropType(propValue);
          if ("object" !== propType) {
            var locationName = ReactPropTypeLocationNames[location];
            return new Error("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."))
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (checker) {
              var error = checker(propValue, key, componentName, location);
              if (error)return error
            }
          }
          return null
        }

        return createChainableTypeChecker(validate)
      }

      function isNode(propValue) {
        switch (typeof propValue) {
          case"number":
          case"string":
          case"undefined":
            return !0;
          case"boolean":
            return !propValue;
          case"object":
            if (Array.isArray(propValue))return propValue.every(isNode);
            if (null === propValue || ReactElement.isValidElement(propValue))return !0;
            propValue = ReactFragment.extractIfFragment(propValue);
            for (var k in propValue)if (!isNode(propValue[k]))return !1;
            return !0;
          default:
            return !1
        }
      }

      function getPropType(propValue) {
        var propType = typeof propValue;
        return Array.isArray(propValue) ? "array" : propValue instanceof RegExp ? "object" : propType
      }

      function getPreciseType(propValue) {
        var propType = getPropType(propValue);
        if ("object" === propType) {
          if (propValue instanceof Date)return "date";
          if (propValue instanceof RegExp)return "regexp"
        }
        return propType
      }

      var ReactElement = _dereq_(57), ReactFragment = _dereq_(63), ReactPropTypeLocationNames = _dereq_(76), emptyFunction = _dereq_(114), ANONYMOUS = "<<anonymous>>", elementTypeChecker = createElementTypeChecker(), nodeTypeChecker = createNodeChecker(), ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: elementTypeChecker,
        instanceOf: createInstanceTypeChecker,
        node: nodeTypeChecker,
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker
      };
      module.exports = ReactPropTypes
    }, { 114: 114, 57: 57, 63: 63, 76: 76 }],
    79: [function(_dereq_, module, exports) {
      "use strict";
      function ReactPutListenerQueue() {
        this.listenersToPut = []
      }

      var PooledClass = _dereq_(28), ReactBrowserEventEmitter = _dereq_(30), assign = _dereq_(27);
      assign(ReactPutListenerQueue.prototype, {
        enqueuePutListener: function(rootNodeID, propKey, propValue) {
          this.listenersToPut.push({ rootNodeID: rootNodeID, propKey: propKey, propValue: propValue })
        }, putListeners: function() {
          for (var i = 0; i < this.listenersToPut.length; i++) {
            var listenerToPut = this.listenersToPut[i];
            ReactBrowserEventEmitter.putListener(listenerToPut.rootNodeID, listenerToPut.propKey, listenerToPut.propValue)
          }
        }, reset: function() {
          this.listenersToPut.length = 0
        }, destructor: function() {
          this.reset()
        }
      }), PooledClass.addPoolingTo(ReactPutListenerQueue), module.exports = ReactPutListenerQueue
    }, { 27: 27, 28: 28, 30: 30 }],
    80: [function(_dereq_, module, exports) {
      "use strict";
      function ReactReconcileTransaction() {
        this.reinitializeTransaction(), this.renderToStaticMarkup = !1, this.reactMountReady = CallbackQueue.getPooled(null), this.putListenerQueue = ReactPutListenerQueue.getPooled()
      }

      var CallbackQueue = _dereq_(6), PooledClass = _dereq_(28), ReactBrowserEventEmitter = _dereq_(30), ReactInputSelection = _dereq_(65), ReactPutListenerQueue = _dereq_(79), Transaction = _dereq_(103), assign = _dereq_(27), SELECTION_RESTORATION = {
        initialize: ReactInputSelection.getSelectionInformation,
        close: ReactInputSelection.restoreSelection
      }, EVENT_SUPPRESSION = {
        initialize: function() {
          var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
          return ReactBrowserEventEmitter.setEnabled(!1), currentlyEnabled
        }, close: function(previouslyEnabled) {
          ReactBrowserEventEmitter.setEnabled(previouslyEnabled)
        }
      }, ON_DOM_READY_QUEUEING = {
        initialize: function() {
          this.reactMountReady.reset()
        }, close: function() {
          this.reactMountReady.notifyAll()
        }
      }, PUT_LISTENER_QUEUEING = {
        initialize: function() {
          this.putListenerQueue.reset()
        }, close: function() {
          this.putListenerQueue.putListeners()
        }
      }, TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING], Mixin = {
        getTransactionWrappers: function() {
          return TRANSACTION_WRAPPERS
        }, getReactMountReady: function() {
          return this.reactMountReady
        }, getPutListenerQueue: function() {
          return this.putListenerQueue
        }, destructor: function() {
          CallbackQueue.release(this.reactMountReady), this.reactMountReady = null, ReactPutListenerQueue.release(this.putListenerQueue), this.putListenerQueue = null
        }
      };
      assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin), PooledClass.addPoolingTo(ReactReconcileTransaction), module.exports = ReactReconcileTransaction
    }, { 103: 103, 27: 27, 28: 28, 30: 30, 6: 6, 65: 65, 79: 79 }],
    81: [function(_dereq_, module, exports) {
      "use strict";
      function attachRefs() {
        ReactRef.attachRefs(this, this._currentElement)
      }

      var ReactRef = _dereq_(82), ReactElementValidator = _dereq_(58), ReactReconciler = {
        mountComponent: function(internalInstance, rootID, transaction, context) {
          var markup = internalInstance.mountComponent(rootID, transaction, context);
          return ReactElementValidator.checkAndWarnForMutatedProps(internalInstance._currentElement), transaction.getReactMountReady().enqueue(attachRefs, internalInstance), markup
        }, unmountComponent: function(internalInstance) {
          ReactRef.detachRefs(internalInstance, internalInstance._currentElement), internalInstance.unmountComponent()
        }, receiveComponent: function(internalInstance, nextElement, transaction, context) {
          var prevElement = internalInstance._currentElement;
          if (nextElement !== prevElement || null == nextElement._owner) {
            ReactElementValidator.checkAndWarnForMutatedProps(nextElement);
            var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
            refsChanged && ReactRef.detachRefs(internalInstance, prevElement), internalInstance.receiveComponent(nextElement, transaction, context), refsChanged && transaction.getReactMountReady().enqueue(attachRefs, internalInstance)
          }
        }, performUpdateIfNecessary: function(internalInstance, transaction) {
          internalInstance.performUpdateIfNecessary(transaction)
        }
      };
      module.exports = ReactReconciler
    }, { 58: 58, 82: 82 }],
    82: [function(_dereq_, module, exports) {
      "use strict";
      function attachRef(ref, component, owner) {
        "function" == typeof ref ? ref(component.getPublicInstance()) : ReactOwner.addComponentAsRefTo(component, ref, owner)
      }

      function detachRef(ref, component, owner) {
        "function" == typeof ref ? ref(null) : ReactOwner.removeComponentAsRefFrom(component, ref, owner)
      }

      var ReactOwner = _dereq_(74), ReactRef = {};
      ReactRef.attachRefs = function(instance, element) {
        var ref = element.ref;
        null != ref && attachRef(ref, instance, element._owner)
      }, ReactRef.shouldUpdateRefs = function(prevElement, nextElement) {
        return nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
      }, ReactRef.detachRefs = function(instance, element) {
        var ref = element.ref;
        null != ref && detachRef(ref, instance, element._owner)
      }, module.exports = ReactRef
    }, { 74: 74 }],
    83: [function(_dereq_, module, exports) {
      "use strict";
      var ReactRootIndexInjection = {
        injectCreateReactRootIndex: function(_createReactRootIndex) {
          ReactRootIndex.createReactRootIndex = _createReactRootIndex
        }
      }, ReactRootIndex = { createReactRootIndex: null, injection: ReactRootIndexInjection };
      module.exports = ReactRootIndex
    }, {}],
    84: [function(_dereq_, module, exports) {
      "use strict";
      function renderToString(element) {
        invariant(ReactElement.isValidElement(element), "renderToString(): You must pass a valid ReactElement.");
        var transaction;
        try {
          var id = ReactInstanceHandles.createReactRootID();
          return transaction = ReactServerRenderingTransaction.getPooled(!1), transaction.perform(function() {
            var componentInstance = instantiateReactComponent(element, null), markup = componentInstance.mountComponent(id, transaction, emptyObject);
            return ReactMarkupChecksum.addChecksumToMarkup(markup)
          }, null)
        } finally {
          ReactServerRenderingTransaction.release(transaction)
        }
      }

      function renderToStaticMarkup(element) {
        invariant(ReactElement.isValidElement(element), "renderToStaticMarkup(): You must pass a valid ReactElement.");
        var transaction;
        try {
          var id = ReactInstanceHandles.createReactRootID();
          return transaction = ReactServerRenderingTransaction.getPooled(!0), transaction.perform(function() {
            var componentInstance = instantiateReactComponent(element, null);
            return componentInstance.mountComponent(id, transaction, emptyObject)
          }, null)
        } finally {
          ReactServerRenderingTransaction.release(transaction)
        }
      }

      var ReactElement = _dereq_(57), ReactInstanceHandles = _dereq_(66), ReactMarkupChecksum = _dereq_(69), ReactServerRenderingTransaction = _dereq_(85), emptyObject = _dereq_(115), instantiateReactComponent = _dereq_(134), invariant = _dereq_(135);
      module.exports = { renderToString: renderToString, renderToStaticMarkup: renderToStaticMarkup }
    }, { 115: 115, 134: 134, 135: 135, 57: 57, 66: 66, 69: 69, 85: 85 }],
    85: [function(_dereq_, module, exports) {
      "use strict";
      function ReactServerRenderingTransaction(renderToStaticMarkup) {
        this.reinitializeTransaction(), this.renderToStaticMarkup = renderToStaticMarkup, this.reactMountReady = CallbackQueue.getPooled(null), this.putListenerQueue = ReactPutListenerQueue.getPooled()
      }

      var PooledClass = _dereq_(28), CallbackQueue = _dereq_(6), ReactPutListenerQueue = _dereq_(79), Transaction = _dereq_(103), assign = _dereq_(27), emptyFunction = _dereq_(114), ON_DOM_READY_QUEUEING = {
        initialize: function() {
          this.reactMountReady.reset()
        }, close: emptyFunction
      }, PUT_LISTENER_QUEUEING = {
        initialize: function() {
          this.putListenerQueue.reset()
        }, close: emptyFunction
      }, TRANSACTION_WRAPPERS = [PUT_LISTENER_QUEUEING, ON_DOM_READY_QUEUEING], Mixin = {
        getTransactionWrappers: function() {
          return TRANSACTION_WRAPPERS
        }, getReactMountReady: function() {
          return this.reactMountReady
        }, getPutListenerQueue: function() {
          return this.putListenerQueue
        }, destructor: function() {
          CallbackQueue.release(this.reactMountReady), this.reactMountReady = null, ReactPutListenerQueue.release(this.putListenerQueue), this.putListenerQueue = null
        }
      };
      assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin), PooledClass.addPoolingTo(ReactServerRenderingTransaction), module.exports = ReactServerRenderingTransaction
    }, { 103: 103, 114: 114, 27: 27, 28: 28, 6: 6, 79: 79 }],
    86: [function(_dereq_, module, exports) {
      "use strict";
      function enqueueUpdate(internalInstance) {
        internalInstance !== ReactLifeCycle.currentlyMountingInstance && ReactUpdates.enqueueUpdate(internalInstance)
      }

      function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
        invariant(null == ReactCurrentOwner.current, "%s(...): Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.", callerName);
        var internalInstance = ReactInstanceMap.get(publicInstance);
        return internalInstance ? internalInstance === ReactLifeCycle.currentlyUnmountingInstance ? null : internalInstance : (warning(!callerName, "%s(...): Can only update a mounted or mounting component. This usually means you called %s() on an unmounted component. This is a no-op.", callerName, callerName), null)
      }

      var ReactLifeCycle = _dereq_(68), ReactCurrentOwner = _dereq_(39), ReactElement = _dereq_(57), ReactInstanceMap = _dereq_(67), ReactUpdates = _dereq_(87), assign = _dereq_(27), invariant = _dereq_(135), warning = _dereq_(154), ReactUpdateQueue = {
        enqueueCallback: function(publicInstance, callback) {
          invariant("function" == typeof callback, "enqueueCallback(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable.");
          var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
          return internalInstance && internalInstance !== ReactLifeCycle.currentlyMountingInstance ? (internalInstance._pendingCallbacks ? internalInstance._pendingCallbacks.push(callback) : internalInstance._pendingCallbacks = [callback], void enqueueUpdate(internalInstance)) : null
        }, enqueueCallbackInternal: function(internalInstance, callback) {
          invariant("function" == typeof callback, "enqueueCallback(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable."), internalInstance._pendingCallbacks ? internalInstance._pendingCallbacks.push(callback) : internalInstance._pendingCallbacks = [callback], enqueueUpdate(internalInstance)
        }, enqueueForceUpdate: function(publicInstance) {
          var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "forceUpdate");
          internalInstance && (internalInstance._pendingForceUpdate = !0, enqueueUpdate(internalInstance))
        }, enqueueReplaceState: function(publicInstance, completeState) {
          var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "replaceState");
          internalInstance && (internalInstance._pendingStateQueue = [completeState], internalInstance._pendingReplaceState = !0, enqueueUpdate(internalInstance))
        }, enqueueSetState: function(publicInstance, partialState) {
          var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "setState");
          if (internalInstance) {
            var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
            queue.push(partialState), enqueueUpdate(internalInstance)
          }
        }, enqueueSetProps: function(publicInstance, partialProps) {
          var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "setProps");
          if (internalInstance) {
            invariant(internalInstance._isTopLevel, "setProps(...): You called `setProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created.");
            var element = internalInstance._pendingElement || internalInstance._currentElement, props = assign({}, element.props, partialProps);
            internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props), enqueueUpdate(internalInstance)
          }
        }, enqueueReplaceProps: function(publicInstance, props) {
          var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, "replaceProps");
          if (internalInstance) {
            invariant(internalInstance._isTopLevel, "replaceProps(...): You called `replaceProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created.");
            var element = internalInstance._pendingElement || internalInstance._currentElement;
            internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props), enqueueUpdate(internalInstance)
          }
        }, enqueueElementInternal: function(internalInstance, newElement) {
          internalInstance._pendingElement = newElement, enqueueUpdate(internalInstance)
        }
      };
      module.exports = ReactUpdateQueue
    }, { 135: 135, 154: 154, 27: 27, 39: 39, 57: 57, 67: 67, 68: 68, 87: 87 }],
    87: [function(_dereq_, module, exports) {
      "use strict";
      function ensureInjected() {
        invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy, "ReactUpdates: must inject a reconcile transaction class and batching strategy")
      }

      function ReactUpdatesFlushTransaction() {
        this.reinitializeTransaction(), this.dirtyComponentsLength = null, this.callbackQueue = CallbackQueue.getPooled(), this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled()
      }

      function batchedUpdates(callback, a, b, c, d) {
        ensureInjected(), batchingStrategy.batchedUpdates(callback, a, b, c, d)
      }

      function mountOrderComparator(c1, c2) {
        return c1._mountOrder - c2._mountOrder
      }

      function runBatchedUpdates(transaction) {
        var len = transaction.dirtyComponentsLength;
        invariant(len === dirtyComponents.length, "Expected flush transaction's stored dirty-components length (%s) to match dirty-components array length (%s).", len, dirtyComponents.length), dirtyComponents.sort(mountOrderComparator);
        for (var i = 0; i < len; i++) {
          var component = dirtyComponents[i], callbacks = component._pendingCallbacks;
          if (component._pendingCallbacks = null, ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction), callbacks)for (var j = 0; j < callbacks.length; j++)transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance())
        }
      }

      function enqueueUpdate(component) {
        return ensureInjected(), warning(null == ReactCurrentOwner.current, "enqueueUpdate(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate."), batchingStrategy.isBatchingUpdates ? void dirtyComponents.push(component) : void batchingStrategy.batchedUpdates(enqueueUpdate, component)
      }

      function asap(callback, context) {
        invariant(batchingStrategy.isBatchingUpdates, "ReactUpdates.asap: Can't enqueue an asap callback in a context whereupdates are not being batched."), asapCallbackQueue.enqueue(callback, context), asapEnqueued = !0
      }

      var CallbackQueue = _dereq_(6), PooledClass = _dereq_(28), ReactCurrentOwner = _dereq_(39), ReactPerf = _dereq_(75), ReactReconciler = _dereq_(81), Transaction = _dereq_(103), assign = _dereq_(27), invariant = _dereq_(135), warning = _dereq_(154), dirtyComponents = [], asapCallbackQueue = CallbackQueue.getPooled(), asapEnqueued = !1, batchingStrategy = null, NESTED_UPDATES = {
        initialize: function() {
          this.dirtyComponentsLength = dirtyComponents.length
        }, close: function() {
          this.dirtyComponentsLength !== dirtyComponents.length ? (dirtyComponents.splice(0, this.dirtyComponentsLength), flushBatchedUpdates()) : dirtyComponents.length = 0
        }
      }, UPDATE_QUEUEING = {
        initialize: function() {
          this.callbackQueue.reset()
        }, close: function() {
          this.callbackQueue.notifyAll()
        }
      }, TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
      assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
        getTransactionWrappers: function() {
          return TRANSACTION_WRAPPERS
        }, destructor: function() {
          this.dirtyComponentsLength = null, CallbackQueue.release(this.callbackQueue), this.callbackQueue = null, ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction), this.reconcileTransaction = null
        }, perform: function(method, scope, a) {
          return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a)
        }
      }), PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
      var flushBatchedUpdates = function() {
        for (; dirtyComponents.length || asapEnqueued;) {
          if (dirtyComponents.length) {
            var transaction = ReactUpdatesFlushTransaction.getPooled();
            transaction.perform(runBatchedUpdates, null, transaction), ReactUpdatesFlushTransaction.release(transaction)
          }
          if (asapEnqueued) {
            asapEnqueued = !1;
            var queue = asapCallbackQueue;
            asapCallbackQueue = CallbackQueue.getPooled(), queue.notifyAll(), CallbackQueue.release(queue)
          }
        }
      };
      flushBatchedUpdates = ReactPerf.measure("ReactUpdates", "flushBatchedUpdates", flushBatchedUpdates);
      var ReactUpdatesInjection = {
        injectReconcileTransaction: function(ReconcileTransaction) {
          invariant(ReconcileTransaction, "ReactUpdates: must provide a reconcile transaction class"), ReactUpdates.ReactReconcileTransaction = ReconcileTransaction
        }, injectBatchingStrategy: function(_batchingStrategy) {
          invariant(_batchingStrategy, "ReactUpdates: must provide a batching strategy"), invariant("function" == typeof _batchingStrategy.batchedUpdates, "ReactUpdates: must provide a batchedUpdates() function"), invariant("boolean" == typeof _batchingStrategy.isBatchingUpdates, "ReactUpdates: must provide an isBatchingUpdates boolean attribute"), batchingStrategy = _batchingStrategy
        }
      }, ReactUpdates = {
        ReactReconcileTransaction: null,
        batchedUpdates: batchedUpdates,
        enqueueUpdate: enqueueUpdate,
        flushBatchedUpdates: flushBatchedUpdates,
        injection: ReactUpdatesInjection,
        asap: asap
      };
      module.exports = ReactUpdates
    }, { 103: 103, 135: 135, 154: 154, 27: 27, 28: 28, 39: 39, 6: 6, 75: 75, 81: 81 }],
    88: [function(_dereq_, module, exports) {
      "use strict";
      var DOMProperty = _dereq_(10), MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE, SVGDOMPropertyConfig = {
        Properties: {
          cx: MUST_USE_ATTRIBUTE,
          cy: MUST_USE_ATTRIBUTE,
          d: MUST_USE_ATTRIBUTE,
          dx: MUST_USE_ATTRIBUTE,
          dy: MUST_USE_ATTRIBUTE,
          fill: MUST_USE_ATTRIBUTE,
          fillOpacity: MUST_USE_ATTRIBUTE,
          fontFamily: MUST_USE_ATTRIBUTE,
          fontSize: MUST_USE_ATTRIBUTE,
          fx: MUST_USE_ATTRIBUTE,
          fy: MUST_USE_ATTRIBUTE,
          gradientTransform: MUST_USE_ATTRIBUTE,
          gradientUnits: MUST_USE_ATTRIBUTE,
          markerEnd: MUST_USE_ATTRIBUTE,
          markerMid: MUST_USE_ATTRIBUTE,
          markerStart: MUST_USE_ATTRIBUTE,
          offset: MUST_USE_ATTRIBUTE,
          opacity: MUST_USE_ATTRIBUTE,
          patternContentUnits: MUST_USE_ATTRIBUTE,
          patternUnits: MUST_USE_ATTRIBUTE,
          points: MUST_USE_ATTRIBUTE,
          preserveAspectRatio: MUST_USE_ATTRIBUTE,
          r: MUST_USE_ATTRIBUTE,
          rx: MUST_USE_ATTRIBUTE,
          ry: MUST_USE_ATTRIBUTE,
          spreadMethod: MUST_USE_ATTRIBUTE,
          stopColor: MUST_USE_ATTRIBUTE,
          stopOpacity: MUST_USE_ATTRIBUTE,
          stroke: MUST_USE_ATTRIBUTE,
          strokeDasharray: MUST_USE_ATTRIBUTE,
          strokeLinecap: MUST_USE_ATTRIBUTE,
          strokeOpacity: MUST_USE_ATTRIBUTE,
          strokeWidth: MUST_USE_ATTRIBUTE,
          textAnchor: MUST_USE_ATTRIBUTE,
          transform: MUST_USE_ATTRIBUTE,
          version: MUST_USE_ATTRIBUTE,
          viewBox: MUST_USE_ATTRIBUTE,
          x1: MUST_USE_ATTRIBUTE,
          x2: MUST_USE_ATTRIBUTE,
          x: MUST_USE_ATTRIBUTE,
          y1: MUST_USE_ATTRIBUTE,
          y2: MUST_USE_ATTRIBUTE,
          y: MUST_USE_ATTRIBUTE
        },
        DOMAttributeNames: {
          fillOpacity: "fill-opacity",
          fontFamily: "font-family",
          fontSize: "font-size",
          gradientTransform: "gradientTransform",
          gradientUnits: "gradientUnits",
          markerEnd: "marker-end",
          markerMid: "marker-mid",
          markerStart: "marker-start",
          patternContentUnits: "patternContentUnits",
          patternUnits: "patternUnits",
          preserveAspectRatio: "preserveAspectRatio",
          spreadMethod: "spreadMethod",
          stopColor: "stop-color",
          stopOpacity: "stop-opacity",
          strokeDasharray: "stroke-dasharray",
          strokeLinecap: "stroke-linecap",
          strokeOpacity: "stroke-opacity",
          strokeWidth: "stroke-width",
          textAnchor: "text-anchor",
          viewBox: "viewBox"
        }
      };
      module.exports = SVGDOMPropertyConfig
    }, { 10: 10 }],
    89: [function(_dereq_, module, exports) {
      "use strict";
      function getSelection(node) {
        if ("selectionStart" in node && ReactInputSelection.hasSelectionCapabilities(node))return {
          start: node.selectionStart,
          end: node.selectionEnd
        };
        if (window.getSelection) {
          var selection = window.getSelection();
          return {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
          }
        }
        if (document.selection) {
          var range = document.selection.createRange();
          return {
            parentElement: range.parentElement(),
            text: range.text,
            top: range.boundingTop,
            left: range.boundingLeft
          }
        }
      }

      function constructSelectEvent(nativeEvent) {
        if (mouseDown || null == activeElement || activeElement !== getActiveElement())return null;
        var currentSelection = getSelection(activeElement);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
          lastSelection = currentSelection;
          var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent);
          return syntheticEvent.type = "select", syntheticEvent.target = activeElement, EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent), syntheticEvent
        }
      }

      var EventConstants = _dereq_(15), EventPropagators = _dereq_(20), ReactInputSelection = _dereq_(65), SyntheticEvent = _dereq_(95), getActiveElement = _dereq_(121), isTextInputElement = _dereq_(138), keyOf = _dereq_(141), shallowEqual = _dereq_(150), topLevelTypes = EventConstants.topLevelTypes, eventTypes = {
        select: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onSelect: null }),
            captured: keyOf({ onSelectCapture: null })
          },
          dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
        }
      }, activeElement = null, activeElementID = null, lastSelection = null, mouseDown = !1, SelectEventPlugin = {
        eventTypes: eventTypes,
        extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          switch (topLevelType) {
            case topLevelTypes.topFocus:
              (isTextInputElement(topLevelTarget) || "true" === topLevelTarget.contentEditable) && (activeElement = topLevelTarget, activeElementID = topLevelTargetID, lastSelection = null);
              break;
            case topLevelTypes.topBlur:
              activeElement = null, activeElementID = null, lastSelection = null;
              break;
            case topLevelTypes.topMouseDown:
              mouseDown = !0;
              break;
            case topLevelTypes.topContextMenu:
            case topLevelTypes.topMouseUp:
              return mouseDown = !1, constructSelectEvent(nativeEvent);
            case topLevelTypes.topSelectionChange:
            case topLevelTypes.topKeyDown:
            case topLevelTypes.topKeyUp:
              return constructSelectEvent(nativeEvent)
          }
        }
      };
      module.exports = SelectEventPlugin
    }, { 121: 121, 138: 138, 141: 141, 15: 15, 150: 150, 20: 20, 65: 65, 95: 95 }],
    90: [function(_dereq_, module, exports) {
      "use strict";
      var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53), ServerReactRootIndex = {
        createReactRootIndex: function() {
          return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX)
        }
      };
      module.exports = ServerReactRootIndex
    }, {}],
    91: [function(_dereq_, module, exports) {
      "use strict";
      var EventConstants = _dereq_(15), EventPluginUtils = _dereq_(19), EventPropagators = _dereq_(20), SyntheticClipboardEvent = _dereq_(92), SyntheticEvent = _dereq_(95), SyntheticFocusEvent = _dereq_(96), SyntheticKeyboardEvent = _dereq_(98), SyntheticMouseEvent = _dereq_(99), SyntheticDragEvent = _dereq_(94), SyntheticTouchEvent = _dereq_(100), SyntheticUIEvent = _dereq_(101), SyntheticWheelEvent = _dereq_(102), getEventCharCode = _dereq_(122), invariant = _dereq_(135), keyOf = _dereq_(141), warning = _dereq_(154), topLevelTypes = EventConstants.topLevelTypes, eventTypes = {
        blur: { phasedRegistrationNames: { bubbled: keyOf({ onBlur: !0 }), captured: keyOf({ onBlurCapture: !0 }) } },
        click: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onClick: !0 }),
            captured: keyOf({ onClickCapture: !0 })
          }
        },
        contextMenu: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onContextMenu: !0 }),
            captured: keyOf({ onContextMenuCapture: !0 })
          }
        },
        copy: { phasedRegistrationNames: { bubbled: keyOf({ onCopy: !0 }), captured: keyOf({ onCopyCapture: !0 }) } },
        cut: { phasedRegistrationNames: { bubbled: keyOf({ onCut: !0 }), captured: keyOf({ onCutCapture: !0 }) } },
        doubleClick: {
          phasedRegistrationNames: {
            bubbled: keyOf({
              onDoubleClick: !0
            }), captured: keyOf({ onDoubleClickCapture: !0 })
          }
        },
        drag: { phasedRegistrationNames: { bubbled: keyOf({ onDrag: !0 }), captured: keyOf({ onDragCapture: !0 }) } },
        dragEnd: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onDragEnd: !0 }),
            captured: keyOf({ onDragEndCapture: !0 })
          }
        },
        dragEnter: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onDragEnter: !0 }),
            captured: keyOf({ onDragEnterCapture: !0 })
          }
        },
        dragExit: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onDragExit: !0 }),
            captured: keyOf({ onDragExitCapture: !0 })
          }
        },
        dragLeave: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onDragLeave: !0 }),
            captured: keyOf({ onDragLeaveCapture: !0 })
          }
        },
        dragOver: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onDragOver: !0 }),
            captured: keyOf({ onDragOverCapture: !0 })
          }
        },
        dragStart: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onDragStart: !0 }),
            captured: keyOf({ onDragStartCapture: !0 })
          }
        },
        drop: { phasedRegistrationNames: { bubbled: keyOf({ onDrop: !0 }), captured: keyOf({ onDropCapture: !0 }) } },
        focus: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onFocus: !0 }),
            captured: keyOf({ onFocusCapture: !0 })
          }
        },
        input: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onInput: !0 }),
            captured: keyOf({ onInputCapture: !0 })
          }
        },
        keyDown: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onKeyDown: !0 }),
            captured: keyOf({ onKeyDownCapture: !0 })
          }
        },
        keyPress: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onKeyPress: !0 }),
            captured: keyOf({ onKeyPressCapture: !0 })
          }
        },
        keyUp: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onKeyUp: !0 }),
            captured: keyOf({ onKeyUpCapture: !0 })
          }
        },
        load: { phasedRegistrationNames: { bubbled: keyOf({ onLoad: !0 }), captured: keyOf({ onLoadCapture: !0 }) } },
        error: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onError: !0 }),
            captured: keyOf({ onErrorCapture: !0 })
          }
        },
        mouseDown: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onMouseDown: !0 }),
            captured: keyOf({ onMouseDownCapture: !0 })
          }
        },
        mouseMove: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onMouseMove: !0 }),
            captured: keyOf({ onMouseMoveCapture: !0 })
          }
        },
        mouseOut: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onMouseOut: !0 }),
            captured: keyOf({ onMouseOutCapture: !0 })
          }
        },
        mouseOver: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onMouseOver: !0 }),
            captured: keyOf({ onMouseOverCapture: !0 })
          }
        },
        mouseUp: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onMouseUp: !0 }),
            captured: keyOf({ onMouseUpCapture: !0 })
          }
        },
        paste: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onPaste: !0 }),
            captured: keyOf({ onPasteCapture: !0 })
          }
        },
        reset: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onReset: !0 }),
            captured: keyOf({ onResetCapture: !0 })
          }
        },
        scroll: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onScroll: !0 }),
            captured: keyOf({ onScrollCapture: !0 })
          }
        },
        submit: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onSubmit: !0 }),
            captured: keyOf({ onSubmitCapture: !0 })
          }
        },
        touchCancel: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onTouchCancel: !0 }),
            captured: keyOf({ onTouchCancelCapture: !0 })
          }
        },
        touchEnd: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onTouchEnd: !0 }),
            captured: keyOf({ onTouchEndCapture: !0 })
          }
        },
        touchMove: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onTouchMove: !0 }),
            captured: keyOf({ onTouchMoveCapture: !0 })
          }
        },
        touchStart: {
          phasedRegistrationNames: {
            bubbled: keyOf({ onTouchStart: !0 }),
            captured: keyOf({ onTouchStartCapture: !0 })
          }
        },
        wheel: { phasedRegistrationNames: { bubbled: keyOf({ onWheel: !0 }), captured: keyOf({ onWheelCapture: !0 }) } }
      }, topLevelEventsToDispatchConfig = {
        topBlur: eventTypes.blur,
        topClick: eventTypes.click,
        topContextMenu: eventTypes.contextMenu,
        topCopy: eventTypes.copy,
        topCut: eventTypes.cut,
        topDoubleClick: eventTypes.doubleClick,
        topDrag: eventTypes.drag,
        topDragEnd: eventTypes.dragEnd,
        topDragEnter: eventTypes.dragEnter,
        topDragExit: eventTypes.dragExit,
        topDragLeave: eventTypes.dragLeave,
        topDragOver: eventTypes.dragOver,
        topDragStart: eventTypes.dragStart,
        topDrop: eventTypes.drop,
        topError: eventTypes.error,
        topFocus: eventTypes.focus,
        topInput: eventTypes.input,
        topKeyDown: eventTypes.keyDown,
        topKeyPress: eventTypes.keyPress,
        topKeyUp: eventTypes.keyUp,
        topLoad: eventTypes.load,
        topMouseDown: eventTypes.mouseDown,
        topMouseMove: eventTypes.mouseMove,
        topMouseOut: eventTypes.mouseOut,
        topMouseOver: eventTypes.mouseOver,
        topMouseUp: eventTypes.mouseUp,
        topPaste: eventTypes.paste,
        topReset: eventTypes.reset,
        topScroll: eventTypes.scroll,
        topSubmit: eventTypes.submit,
        topTouchCancel: eventTypes.touchCancel,
        topTouchEnd: eventTypes.touchEnd,
        topTouchMove: eventTypes.touchMove,
        topTouchStart: eventTypes.touchStart,
        topWheel: eventTypes.wheel
      };
      for (var type in topLevelEventsToDispatchConfig)topLevelEventsToDispatchConfig[type].dependencies = [type];
      var SimpleEventPlugin = {
        eventTypes: eventTypes, executeDispatch: function(event, listener, domID) {
          var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
          warning("boolean" != typeof returnValue, "Returning `false` from an event handler is deprecated and will be ignored in a future release. Instead, manually call e.stopPropagation() or e.preventDefault(), as appropriate."), returnValue === !1 && (event.stopPropagation(), event.preventDefault())
        }, extractEvents: function(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {
          var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
          if (!dispatchConfig)return null;
          var EventConstructor;
          switch (topLevelType) {
            case topLevelTypes.topInput:
            case topLevelTypes.topLoad:
            case topLevelTypes.topError:
            case topLevelTypes.topReset:
            case topLevelTypes.topSubmit:
              EventConstructor = SyntheticEvent;
              break;
            case topLevelTypes.topKeyPress:
              if (0 === getEventCharCode(nativeEvent))return null;
            case topLevelTypes.topKeyDown:
            case topLevelTypes.topKeyUp:
              EventConstructor = SyntheticKeyboardEvent;
              break;
            case topLevelTypes.topBlur:
            case topLevelTypes.topFocus:
              EventConstructor = SyntheticFocusEvent;
              break;
            case topLevelTypes.topClick:
              if (2 === nativeEvent.button)return null;
            case topLevelTypes.topContextMenu:
            case topLevelTypes.topDoubleClick:
            case topLevelTypes.topMouseDown:
            case topLevelTypes.topMouseMove:
            case topLevelTypes.topMouseOut:
            case topLevelTypes.topMouseOver:
            case topLevelTypes.topMouseUp:
              EventConstructor = SyntheticMouseEvent;
              break;
            case topLevelTypes.topDrag:
            case topLevelTypes.topDragEnd:
            case topLevelTypes.topDragEnter:
            case topLevelTypes.topDragExit:
            case topLevelTypes.topDragLeave:
            case topLevelTypes.topDragOver:
            case topLevelTypes.topDragStart:
            case topLevelTypes.topDrop:
              EventConstructor = SyntheticDragEvent;
              break;
            case topLevelTypes.topTouchCancel:
            case topLevelTypes.topTouchEnd:
            case topLevelTypes.topTouchMove:
            case topLevelTypes.topTouchStart:
              EventConstructor = SyntheticTouchEvent;
              break;
            case topLevelTypes.topScroll:
              EventConstructor = SyntheticUIEvent;
              break;
            case topLevelTypes.topWheel:
              EventConstructor = SyntheticWheelEvent;
              break;
            case topLevelTypes.topCopy:
            case topLevelTypes.topCut:
            case topLevelTypes.topPaste:
              EventConstructor = SyntheticClipboardEvent
          }
          invariant(EventConstructor, "SimpleEventPlugin: Unhandled event type, `%s`.", topLevelType);
          var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent);
          return EventPropagators.accumulateTwoPhaseDispatches(event), event
        }
      };
      module.exports = SimpleEventPlugin
    }, {
      100: 100,
      101: 101,
      102: 102,
      122: 122,
      135: 135,
      141: 141,
      15: 15,
      154: 154,
      19: 19,
      20: 20,
      92: 92,
      94: 94,
      95: 95,
      96: 96,
      98: 98,
      99: 99
    }],
    92: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticEvent = _dereq_(95), ClipboardEventInterface = {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData
        }
      };
      SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface), module.exports = SyntheticClipboardEvent
    }, { 95: 95 }],
    93: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticEvent = _dereq_(95), CompositionEventInterface = { data: null };
      SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface), module.exports = SyntheticCompositionEvent
    }, { 95: 95 }],
    94: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticMouseEvent = _dereq_(99), DragEventInterface = { dataTransfer: null };
      SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface), module.exports = SyntheticDragEvent
    }, { 99: 99 }],
    95: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        this.dispatchConfig = dispatchConfig, this.dispatchMarker = dispatchMarker, this.nativeEvent = nativeEvent;
        var Interface = this.constructor.Interface;
        for (var propName in Interface)if (Interface.hasOwnProperty(propName)) {
          var normalize = Interface[propName];
          normalize ? this[propName] = normalize(nativeEvent) : this[propName] = nativeEvent[propName]
        }
        var defaultPrevented = null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : nativeEvent.returnValue === !1;
        defaultPrevented ? this.isDefaultPrevented = emptyFunction.thatReturnsTrue : this.isDefaultPrevented = emptyFunction.thatReturnsFalse, this.isPropagationStopped = emptyFunction.thatReturnsFalse
      }

      var PooledClass = _dereq_(28), assign = _dereq_(27), emptyFunction = _dereq_(114), getEventTarget = _dereq_(125), EventInterface = {
        type: null,
        target: getEventTarget,
        currentTarget: emptyFunction.thatReturnsNull,
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function(event) {
          return event.timeStamp || Date.now()
        },
        defaultPrevented: null,
        isTrusted: null
      };
      assign(SyntheticEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event.preventDefault ? event.preventDefault() : event.returnValue = !1, this.isDefaultPrevented = emptyFunction.thatReturnsTrue
        }, stopPropagation: function() {
          var event = this.nativeEvent;
          event.stopPropagation ? event.stopPropagation() : event.cancelBubble = !0, this.isPropagationStopped = emptyFunction.thatReturnsTrue
        }, persist: function() {
          this.isPersistent = emptyFunction.thatReturnsTrue
        }, isPersistent: emptyFunction.thatReturnsFalse, destructor: function() {
          var Interface = this.constructor.Interface;
          for (var propName in Interface)this[propName] = null;
          this.dispatchConfig = null, this.dispatchMarker = null, this.nativeEvent = null
        }
      }), SyntheticEvent.Interface = EventInterface, SyntheticEvent.augmentClass = function(Class, Interface) {
        var Super = this, prototype = Object.create(Super.prototype);
        assign(prototype, Class.prototype), Class.prototype = prototype, Class.prototype.constructor = Class, Class.Interface = assign({}, Super.Interface, Interface), Class.augmentClass = Super.augmentClass, PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler)
      }, PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler), module.exports = SyntheticEvent
    }, { 114: 114, 125: 125, 27: 27, 28: 28 }],
    96: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticUIEvent = _dereq_(101), FocusEventInterface = { relatedTarget: null };
      SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface), module.exports = SyntheticFocusEvent
    }, { 101: 101 }],
    97: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticEvent = _dereq_(95), InputEventInterface = { data: null };
      SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface), module.exports = SyntheticInputEvent
    }, { 95: 95 }],
    98: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticUIEvent = _dereq_(101), getEventCharCode = _dereq_(122), getEventKey = _dereq_(123), getEventModifierState = _dereq_(124), KeyboardEventInterface = {
        key: getEventKey,
        location: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        repeat: null,
        locale: null,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0
        }
      };
      SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface), module.exports = SyntheticKeyboardEvent
    }, { 101: 101, 122: 122, 123: 123, 124: 124 }],
    99: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticUIEvent = _dereq_(101), ViewportMetrics = _dereq_(104), getEventModifierState = _dereq_(124), MouseEventInterface = {
        screenX: null,
        screenY: null,
        clientX: null,
        clientY: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        getModifierState: getEventModifierState,
        button: function(event) {
          var button = event.button;
          return "which" in event ? button : 2 === button ? 2 : 4 === button ? 1 : 0
        },
        buttons: null,
        relatedTarget: function(event) {
          return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement)
        },
        pageX: function(event) {
          return "pageX" in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft
        },
        pageY: function(event) {
          return "pageY" in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop
        }
      };
      SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface), module.exports = SyntheticMouseEvent
    }, { 101: 101, 104: 104, 124: 124 }],
    100: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticUIEvent = _dereq_(101), getEventModifierState = _dereq_(124), TouchEventInterface = {
        touches: null,
        targetTouches: null,
        changedTouches: null,
        altKey: null,
        metaKey: null,
        ctrlKey: null,
        shiftKey: null,
        getModifierState: getEventModifierState
      };
      SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface), module.exports = SyntheticTouchEvent
    }, { 101: 101, 124: 124 }],
    101: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticEvent = _dereq_(95), getEventTarget = _dereq_(125), UIEventInterface = {
        view: function(event) {
          if (event.view)return event.view;
          var target = getEventTarget(event);
          if (null != target && target.window === target)return target;
          var doc = target.ownerDocument;
          return doc ? doc.defaultView || doc.parentWindow : window
        }, detail: function(event) {
          return event.detail || 0
        }
      };
      SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface), module.exports = SyntheticUIEvent
    }, { 125: 125, 95: 95 }],
    102: [function(_dereq_, module, exports) {
      "use strict";
      function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
        SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent)
      }

      var SyntheticMouseEvent = _dereq_(99), WheelEventInterface = {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0
        }, deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0
        }, deltaZ: null, deltaMode: null
      };
      SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface), module.exports = SyntheticWheelEvent
    }, { 99: 99 }],
    103: [function(_dereq_, module, exports) {
      "use strict";
      var invariant = _dereq_(135), Mixin = {
        reinitializeTransaction: function() {
          this.transactionWrappers = this.getTransactionWrappers(), this.wrapperInitData ? this.wrapperInitData.length = 0 : this.wrapperInitData = [], this._isInTransaction = !1
        }, _isInTransaction: !1, getTransactionWrappers: null, isInTransaction: function() {
          return !!this._isInTransaction
        }, perform: function(method, scope, a, b, c, d, e, f) {
          invariant(!this.isInTransaction(), "Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.");
          var errorThrown, ret;
          try {
            this._isInTransaction = !0, errorThrown = !0, this.initializeAll(0), ret = method.call(scope, a, b, c, d, e, f), errorThrown = !1
          } finally {
            try {
              if (errorThrown)try {
                this.closeAll(0)
              } catch (err) {
              } else this.closeAll(0)
            } finally {
              this._isInTransaction = !1
            }
          }
          return ret
        }, initializeAll: function(startIndex) {
          for (var transactionWrappers = this.transactionWrappers, i = startIndex; i < transactionWrappers.length; i++) {
            var wrapper = transactionWrappers[i];
            try {
              this.wrapperInitData[i] = Transaction.OBSERVED_ERROR, this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null
            } finally {
              if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR)try {
                this.initializeAll(i + 1)
              } catch (err) {
              }
            }
          }
        }, closeAll: function(startIndex) {
          invariant(this.isInTransaction(), "Transaction.closeAll(): Cannot close transaction when none are open.");
          for (var transactionWrappers = this.transactionWrappers, i = startIndex; i < transactionWrappers.length; i++) {
            var errorThrown, wrapper = transactionWrappers[i], initData = this.wrapperInitData[i];
            try {
              errorThrown = !0, initData !== Transaction.OBSERVED_ERROR && wrapper.close && wrapper.close.call(this, initData), errorThrown = !1
            } finally {
              if (errorThrown)try {
                this.closeAll(i + 1)
              } catch (e) {
              }
            }
          }
          this.wrapperInitData.length = 0
        }
      }, Transaction = { Mixin: Mixin, OBSERVED_ERROR: {} };
      module.exports = Transaction
    }, { 135: 135 }],
    104: [function(_dereq_, module, exports) {
      "use strict";
      var ViewportMetrics = {
        currentScrollLeft: 0, currentScrollTop: 0, refreshScrollValues: function(scrollPosition) {
          ViewportMetrics.currentScrollLeft = scrollPosition.x, ViewportMetrics.currentScrollTop = scrollPosition.y
        }
      };
      module.exports = ViewportMetrics
    }, {}],
    105: [function(_dereq_, module, exports) {
      "use strict";
      function accumulateInto(current, next) {
        if (invariant(null != next, "accumulateInto(...): Accumulated items must not be null or undefined."), null == current)return next;
        var currentIsArray = Array.isArray(current), nextIsArray = Array.isArray(next);
        return currentIsArray && nextIsArray ? (current.push.apply(current, next), current) : currentIsArray ? (current.push(next), current) : nextIsArray ? [current].concat(next) : [current, next]
      }

      var invariant = _dereq_(135);
      module.exports = accumulateInto
    }, { 135: 135 }],
    106: [function(_dereq_, module, exports) {
      "use strict";
      function adler32(data) {
        for (var a = 1, b = 0, i = 0; i < data.length; i++)a = (a + data.charCodeAt(i)) % MOD, b = (b + a) % MOD;
        return a | b << 16
      }

      var MOD = 65521;
      module.exports = adler32
    }, {}],
    107: [function(_dereq_, module, exports) {
      function camelize(string) {
        return string.replace(_hyphenPattern, function(_, character) {
          return character.toUpperCase()
        })
      }

      var _hyphenPattern = /-(.)/g;
      module.exports = camelize
    }, {}],
    108: [function(_dereq_, module, exports) {
      "use strict";
      function camelizeStyleName(string) {
        return camelize(string.replace(msPattern, "ms-"))
      }

      var camelize = _dereq_(107), msPattern = /^-ms-/;
      module.exports = camelizeStyleName
    }, { 107: 107 }],
    109: [function(_dereq_, module, exports) {
      function containsNode(outerNode, innerNode) {
        return !(!outerNode || !innerNode) && (outerNode === innerNode || !isTextNode(outerNode) && (isTextNode(innerNode) ? containsNode(outerNode, innerNode.parentNode) : outerNode.contains ? outerNode.contains(innerNode) : !!outerNode.compareDocumentPosition && !!(16 & outerNode.compareDocumentPosition(innerNode))))
      }

      var isTextNode = _dereq_(139);
      module.exports = containsNode
    }, { 139: 139 }],
    110: [function(_dereq_, module, exports) {
      function hasArrayNature(obj) {
        return !!obj && ("object" == typeof obj || "function" == typeof obj) && "length" in obj && !("setInterval" in obj) && "number" != typeof obj.nodeType && (Array.isArray(obj) || "callee" in obj || "item" in obj)
      }

      function createArrayFromMixed(obj) {
        return hasArrayNature(obj) ? Array.isArray(obj) ? obj.slice() : toArray(obj) : [obj]
      }

      var toArray = _dereq_(152);
      module.exports = createArrayFromMixed
    }, { 152: 152 }],
    111: [function(_dereq_, module, exports) {
      "use strict";
      function createFullPageComponent(tag) {
        var elementFactory = ReactElement.createFactory(tag), FullPageComponent = ReactClass.createClass({
          tagName: tag.toUpperCase(),
          displayName: "ReactFullPageComponent" + tag,
          componentWillUnmount: function() {
            invariant(!1, "%s tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.", this.constructor.displayName)
          },
          render: function() {
            return elementFactory(this.props)
          }
        });
        return FullPageComponent
      }

      var ReactClass = _dereq_(33), ReactElement = _dereq_(57), invariant = _dereq_(135);
      module.exports = createFullPageComponent
    }, { 135: 135, 33: 33, 57: 57 }],
    112: [function(_dereq_, module, exports) {
      function getNodeName(markup) {
        var nodeNameMatch = markup.match(nodeNamePattern);
        return nodeNameMatch && nodeNameMatch[1].toLowerCase()
      }

      function createNodesFromMarkup(markup, handleScript) {
        var node = dummyNode;
        invariant(!!dummyNode, "createNodesFromMarkup dummy not initialized");
        var nodeName = getNodeName(markup), wrap = nodeName && getMarkupWrap(nodeName);
        if (wrap) {
          node.innerHTML = wrap[1] + markup + wrap[2];
          for (var wrapDepth = wrap[0]; wrapDepth--;)node = node.lastChild
        } else node.innerHTML = markup;
        var scripts = node.getElementsByTagName("script");
        scripts.length && (invariant(handleScript, "createNodesFromMarkup(...): Unexpected <script> element rendered."), createArrayFromMixed(scripts).forEach(handleScript));
        for (var nodes = createArrayFromMixed(node.childNodes); node.lastChild;)node.removeChild(node.lastChild);
        return nodes
      }

      var ExecutionEnvironment = _dereq_(21), createArrayFromMixed = _dereq_(110), getMarkupWrap = _dereq_(127), invariant = _dereq_(135), dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null, nodeNamePattern = /^\s*<(\w+)/;
      module.exports = createNodesFromMarkup
    }, { 110: 110, 127: 127, 135: 135, 21: 21 }],
    113: [function(_dereq_, module, exports) {
      "use strict";
      function dangerousStyleValue(name, value) {
        var isEmpty = null == value || "boolean" == typeof value || "" === value;
        if (isEmpty)return "";
        var isNonNumeric = isNaN(value);
        return isNonNumeric || 0 === value || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name] ? "" + value : ("string" == typeof value && (value = value.trim()), value + "px")
      }

      var CSSProperty = _dereq_(4), isUnitlessNumber = CSSProperty.isUnitlessNumber;
      module.exports = dangerousStyleValue
    }, { 4: 4 }],
    114: [function(_dereq_, module, exports) {
      function makeEmptyFunction(arg) {
        return function() {
          return arg
        }
      }

      function emptyFunction() {
      }

      emptyFunction.thatReturns = makeEmptyFunction, emptyFunction.thatReturnsFalse = makeEmptyFunction(!1), emptyFunction.thatReturnsTrue = makeEmptyFunction(!0), emptyFunction.thatReturnsNull = makeEmptyFunction(null), emptyFunction.thatReturnsThis = function() {
        return this
      }, emptyFunction.thatReturnsArgument = function(arg) {
        return arg
      }, module.exports = emptyFunction
    }, {}],
    115: [function(_dereq_, module, exports) {
      "use strict";
      var emptyObject = {};
      Object.freeze(emptyObject), module.exports = emptyObject
    }, {}],
    116: [function(_dereq_, module, exports) {
      "use strict";
      function escaper(match) {
        return ESCAPE_LOOKUP[match]
      }

      function escapeTextContentForBrowser(text) {
        return ("" + text).replace(ESCAPE_REGEX, escaper)
      }

      var ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      }, ESCAPE_REGEX = /[&><"']/g;
      module.exports = escapeTextContentForBrowser
    }, {}],
    117: [function(_dereq_, module, exports) {
      "use strict";
      function findDOMNode(componentOrElement) {
        var owner = ReactCurrentOwner.current;
        return null !== owner && (warning(owner._warnedAboutRefsInRender, "%s is accessing getDOMNode or findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", owner.getName() || "A component"), owner._warnedAboutRefsInRender = !0), null == componentOrElement ? null : isNode(componentOrElement) ? componentOrElement : ReactInstanceMap.has(componentOrElement) ? ReactMount.getNodeFromInstance(componentOrElement) : (invariant(null == componentOrElement.render || "function" != typeof componentOrElement.render, "Component (with keys: %s) contains `render` method but is not mounted in the DOM", Object.keys(componentOrElement)), void invariant(!1, "Element appears to be neither ReactComponent nor DOMNode (keys: %s)", Object.keys(componentOrElement)))
      }

      var ReactCurrentOwner = _dereq_(39), ReactInstanceMap = _dereq_(67), ReactMount = _dereq_(70), invariant = _dereq_(135), isNode = _dereq_(137), warning = _dereq_(154);
      module.exports = findDOMNode
    }, { 135: 135, 137: 137, 154: 154, 39: 39, 67: 67, 70: 70 }],
    118: [function(_dereq_, module, exports) {
      "use strict";
      function flattenSingleChildIntoContext(traverseContext, child, name) {
        var result = traverseContext, keyUnique = !result.hasOwnProperty(name);
        warning(keyUnique, "flattenChildren(...): Encountered two children with the same key, `%s`. Child keys must be unique; when two children share a key, only the first child will be used.", name), keyUnique && null != child && (result[name] = child)
      }

      function flattenChildren(children) {
        if (null == children)return children;
        var result = {};
        return traverseAllChildren(children, flattenSingleChildIntoContext, result), result
      }

      var traverseAllChildren = _dereq_(153), warning = _dereq_(154);
      module.exports = flattenChildren
    }, { 153: 153, 154: 154 }],
    119: [function(_dereq_, module, exports) {
      "use strict";
      function focusNode(node) {
        try {
          node.focus()
        } catch (e) {
        }
      }

      module.exports = focusNode
    }, {}],
    120: [function(_dereq_, module, exports) {
      "use strict";
      var forEachAccumulated = function(arr, cb, scope) {
        Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr)
      };
      module.exports = forEachAccumulated
    }, {}],
    121: [function(_dereq_, module, exports) {
      function getActiveElement() {
        try {
          return document.activeElement || document.body
        } catch (e) {
          return document.body
        }
      }

      module.exports = getActiveElement
    }, {}],
    122: [function(_dereq_, module, exports) {
      "use strict";
      function getEventCharCode(nativeEvent) {
        var charCode, keyCode = nativeEvent.keyCode;
        return "charCode" in nativeEvent ? (charCode = nativeEvent.charCode, 0 === charCode && 13 === keyCode && (charCode = 13)) : charCode = keyCode, charCode >= 32 || 13 === charCode ? charCode : 0
      }

      module.exports = getEventCharCode
    }, {}],
    123: [function(_dereq_, module, exports) {
      "use strict";
      function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key)return key
        }
        if ("keypress" === nativeEvent.type) {
          var charCode = getEventCharCode(nativeEvent);
          return 13 === charCode ? "Enter" : String.fromCharCode(charCode)
        }
        return "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : ""
      }

      var getEventCharCode = _dereq_(122), normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      module.exports = getEventKey
    }, { 122: 122 }],
    124: [function(_dereq_, module, exports) {
      "use strict";
      function modifierStateGetter(keyArg) {
        var syntheticEvent = this, nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState)return nativeEvent.getModifierState(keyArg);
        var keyProp = modifierKeyToProp[keyArg];
        return !!keyProp && !!nativeEvent[keyProp]
      }

      function getEventModifierState(nativeEvent) {
        return modifierStateGetter
      }

      var modifierKeyToProp = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      module.exports = getEventModifierState
    }, {}],
    125: [function(_dereq_, module, exports) {
      "use strict";
      function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        return 3 === target.nodeType ? target.parentNode : target
      }

      module.exports = getEventTarget
    }, {}],
    126: [function(_dereq_, module, exports) {
      "use strict";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if ("function" == typeof iteratorFn)return iteratorFn
      }

      var ITERATOR_SYMBOL = "function" == typeof Symbol && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      module.exports = getIteratorFn
    }, {}],
    127: [function(_dereq_, module, exports) {
      function getMarkupWrap(nodeName) {
        return invariant(!!dummyNode, "Markup wrapping node not initialized"), markupWrap.hasOwnProperty(nodeName) || (nodeName = "*"), shouldWrap.hasOwnProperty(nodeName) || ("*" === nodeName ? dummyNode.innerHTML = "<link />" : dummyNode.innerHTML = "<" + nodeName + "></" + nodeName + ">", shouldWrap[nodeName] = !dummyNode.firstChild), shouldWrap[nodeName] ? markupWrap[nodeName] : null
      }

      var ExecutionEnvironment = _dereq_(21), invariant = _dereq_(135), dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement("div") : null, shouldWrap = {
        circle: !0,
        defs: !0,
        ellipse: !0,
        g: !0,
        line: !0,
        linearGradient: !0,
        path: !0,
        polygon: !0,
        polyline: !0,
        radialGradient: !0,
        rect: !0,
        stop: !0,
        text: !0
      }, selectWrap = [1, '<select multiple="true">', "</select>"], tableWrap = [1, "<table>", "</table>"], trWrap = [3, "<table><tbody><tr>", "</tr></tbody></table>"], svgWrap = [1, "<svg>", "</svg>"], markupWrap = {
        "*": [1, "?<div>", "</div>"],
        area: [1, "<map>", "</map>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        param: [1, "<object>", "</object>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        optgroup: selectWrap,
        option: selectWrap,
        caption: tableWrap,
        colgroup: tableWrap,
        tbody: tableWrap,
        tfoot: tableWrap,
        thead: tableWrap,
        td: trWrap,
        th: trWrap,
        circle: svgWrap,
        defs: svgWrap,
        ellipse: svgWrap,
        g: svgWrap,
        line: svgWrap,
        linearGradient: svgWrap,
        path: svgWrap,
        polygon: svgWrap,
        polyline: svgWrap,
        radialGradient: svgWrap,
        rect: svgWrap,
        stop: svgWrap,
        text: svgWrap
      };
      module.exports = getMarkupWrap
    }, { 135: 135, 21: 21 }],
    128: [function(_dereq_, module, exports) {
      "use strict";
      function getLeafNode(node) {
        for (; node && node.firstChild;)node = node.firstChild;
        return node
      }

      function getSiblingNode(node) {
        for (; node;) {
          if (node.nextSibling)return node.nextSibling;
          node = node.parentNode
        }
      }

      function getNodeForCharacterOffset(root, offset) {
        for (var node = getLeafNode(root), nodeStart = 0, nodeEnd = 0; node;) {
          if (3 === node.nodeType) {
            if (nodeEnd = nodeStart + node.textContent.length, nodeStart <= offset && nodeEnd >= offset)return {
              node: node,
              offset: offset - nodeStart
            };
            nodeStart = nodeEnd
          }
          node = getLeafNode(getSiblingNode(node))
        }
      }

      module.exports = getNodeForCharacterOffset
    }, {}],
    129: [function(_dereq_, module, exports) {
      "use strict";
      function getReactRootElementInContainer(container) {
        return container ? container.nodeType === DOC_NODE_TYPE ? container.documentElement : container.firstChild : null
      }

      var DOC_NODE_TYPE = 9;
      module.exports = getReactRootElementInContainer
    }, {}],
    130: [function(_dereq_, module, exports) {
      "use strict";
      function getTextContentAccessor() {
        return !contentKey && ExecutionEnvironment.canUseDOM && (contentKey = "textContent" in document.documentElement ? "textContent" : "innerText"), contentKey
      }

      var ExecutionEnvironment = _dereq_(21), contentKey = null;
      module.exports = getTextContentAccessor
    }, { 21: 21 }],
    131: [function(_dereq_, module, exports) {
      "use strict";
      function getUnboundedScrollPosition(scrollable) {
        return scrollable === window ? {
          x: window.pageXOffset || document.documentElement.scrollLeft,
          y: window.pageYOffset || document.documentElement.scrollTop
        } : { x: scrollable.scrollLeft, y: scrollable.scrollTop }
      }

      module.exports = getUnboundedScrollPosition
    }, {}],
    132: [function(_dereq_, module, exports) {
      function hyphenate(string) {
        return string.replace(_uppercasePattern, "-$1").toLowerCase()
      }

      var _uppercasePattern = /([A-Z])/g;
      module.exports = hyphenate
    }, {}],
    133: [function(_dereq_, module, exports) {
      "use strict";
      function hyphenateStyleName(string) {
        return hyphenate(string).replace(msPattern, "-ms-")
      }

      var hyphenate = _dereq_(132), msPattern = /^ms-/;
      module.exports = hyphenateStyleName
    }, { 132: 132 }],
    134: [function(_dereq_, module, exports) {
      "use strict";
      function isInternalComponentType(type) {
        return "function" == typeof type && "function" == typeof type.prototype.mountComponent && "function" == typeof type.prototype.receiveComponent
      }

      function instantiateReactComponent(node, parentCompositeType) {
        var instance;
        if (null !== node && node !== !1 || (node = ReactEmptyComponent.emptyElement), "object" == typeof node) {
          var element = node;
          warning(element && ("function" == typeof element.type || "string" == typeof element.type), "Only functions or strings can be mounted as React components."), instance = parentCompositeType === element.type && "string" == typeof element.type ? ReactNativeComponent.createInternalComponent(element) : isInternalComponentType(element.type) ? new element.type(element) : new ReactCompositeComponentWrapper
        } else"string" == typeof node || "number" == typeof node ? instance = ReactNativeComponent.createInstanceForText(node) : invariant(!1, "Encountered invalid React node of type %s", typeof node);
        return warning("function" == typeof instance.construct && "function" == typeof instance.mountComponent && "function" == typeof instance.receiveComponent && "function" == typeof instance.unmountComponent, "Only React Components can be mounted."), instance.construct(node), instance._mountIndex = 0, instance._mountImage = null, instance._isOwnerNecessary = !1, instance._warnedAboutRefsInRender = !1, Object.preventExtensions && Object.preventExtensions(instance), instance
      }

      var ReactCompositeComponent = _dereq_(37), ReactEmptyComponent = _dereq_(59), ReactNativeComponent = _dereq_(73), assign = _dereq_(27), invariant = _dereq_(135), warning = _dereq_(154), ReactCompositeComponentWrapper = function() {
      };
      assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, { _instantiateReactComponent: instantiateReactComponent }), module.exports = instantiateReactComponent
    }, { 135: 135, 154: 154, 27: 27, 37: 37, 59: 59, 73: 73 }],
    135: [function(_dereq_, module, exports) {
      "use strict";
      var invariant = function(condition, format, a, b, c, d, e, f) {
        if (void 0 === format)throw new Error("invariant requires an error message argument");
        if (!condition) {
          var error;
          if (void 0 === format)error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
            var args = [a, b, c, d, e, f], argIndex = 0;
            error = new Error("Invariant Violation: " + format.replace(/%s/g, function() {
                      return args[argIndex++]
                    }))
          }
          throw error.framesToPop = 1, error
        }
      };
      module.exports = invariant
    }, {}],
    136: [function(_dereq_, module, exports) {
      "use strict";
      function isEventSupported(eventNameSuffix, capture) {
        if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document))return !1;
        var eventName = "on" + eventNameSuffix, isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;"), isSupported = "function" == typeof element[eventName]
        }
        return !isSupported && useHasFeature && "wheel" === eventNameSuffix && (isSupported = document.implementation.hasFeature("Events.wheel", "3.0")), isSupported
      }

      var useHasFeature, ExecutionEnvironment = _dereq_(21);
      ExecutionEnvironment.canUseDOM && (useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0), module.exports = isEventSupported
    }, { 21: 21 }],
    137: [function(_dereq_, module, exports) {
      function isNode(object) {
        return !(!object || !("function" == typeof Node ? object instanceof Node : "object" == typeof object && "number" == typeof object.nodeType && "string" == typeof object.nodeName))
      }

      module.exports = isNode
    }, {}],
    138: [function(_dereq_, module, exports) {
      "use strict";
      function isTextInputElement(elem) {
        return elem && ("INPUT" === elem.nodeName && supportedInputTypes[elem.type] || "TEXTAREA" === elem.nodeName)
      }

      var supportedInputTypes = {
        color: !0,
        dateTime: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      };
      module.exports = isTextInputElement
    }, {}],
    139: [function(_dereq_, module, exports) {
      function isTextNode(object) {
        return isNode(object) && 3 == object.nodeType
      }

      var isNode = _dereq_(137);
      module.exports = isTextNode
    }, { 137: 137 }],
    140: [function(_dereq_, module, exports) {
      "use strict";
      var invariant = _dereq_(135), keyMirror = function(obj) {
        var key, ret = {};
        invariant(obj instanceof Object && !Array.isArray(obj), "keyMirror(...): Argument must be an object.");
        for (key in obj)obj.hasOwnProperty(key) && (ret[key] = key);
        return ret
      };
      module.exports = keyMirror
    }, { 135: 135 }],
    141: [function(_dereq_, module, exports) {
      var keyOf = function(oneKeyObj) {
        var key;
        for (key in oneKeyObj)if (oneKeyObj.hasOwnProperty(key))return key;
        return null
      };
      module.exports = keyOf
    }, {}],
    142: [function(_dereq_, module, exports) {
      "use strict";
      function mapObject(object, callback, context) {
        if (!object)return null;
        var result = {};
        for (var name in object)hasOwnProperty.call(object, name) && (result[name] = callback.call(context, object[name], name, object));
        return result
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      module.exports = mapObject
    }, {}],
    143: [function(_dereq_, module, exports) {
      "use strict";
      function memoizeStringOnly(callback) {
        var cache = {};
        return function(string) {
          return cache.hasOwnProperty(string) || (cache[string] = callback.call(this, string)), cache[string]
        }
      }

      module.exports = memoizeStringOnly
    }, {}],
    144: [function(_dereq_, module, exports) {
      "use strict";
      function onlyChild(children) {
        return invariant(ReactElement.isValidElement(children), "onlyChild must be passed a children with exactly one child."), children
      }

      var ReactElement = _dereq_(57), invariant = _dereq_(135);
      module.exports = onlyChild
    }, { 135: 135, 57: 57 }],
    145: [function(_dereq_, module, exports) {
      "use strict";
      var performance, ExecutionEnvironment = _dereq_(21);
      ExecutionEnvironment.canUseDOM && (performance = window.performance || window.msPerformance || window.webkitPerformance), module.exports = performance || {}
    }, { 21: 21 }],
    146: [function(_dereq_, module, exports) {
      var performance = _dereq_(145);
      performance && performance.now || (performance = Date);
      var performanceNow = performance.now.bind(performance);
      module.exports = performanceNow
    }, { 145: 145 }],
    147: [function(_dereq_, module, exports) {
      "use strict";
      function quoteAttributeValueForBrowser(value) {
        return '"' + escapeTextContentForBrowser(value) + '"'
      }

      var escapeTextContentForBrowser = _dereq_(116);
      module.exports = quoteAttributeValueForBrowser
    }, { 116: 116 }],
    148: [function(_dereq_, module, exports) {
      "use strict";
      var ExecutionEnvironment = _dereq_(21), WHITESPACE_TEST = /^[ \r\n\t\f]/, NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/, setInnerHTML = function(node, html) {
        node.innerHTML = html
      };
      if ("undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction && (setInnerHTML = function(node, html) {
                MSApp.execUnsafeLocalFunction(function() {
                  node.innerHTML = html
                })
              }), ExecutionEnvironment.canUseDOM) {
        var testElement = document.createElement("div");
        testElement.innerHTML = " ", "" === testElement.innerHTML && (setInnerHTML = function(node, html) {
          if (node.parentNode && node.parentNode.replaceChild(node, node), WHITESPACE_TEST.test(html) || "<" === html[0] && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = "\ufeff" + html;
            var textNode = node.firstChild;
            1 === textNode.data.length ? node.removeChild(textNode) : textNode.deleteData(0, 1)
          } else node.innerHTML = html
        })
      }
      module.exports = setInnerHTML
    }, { 21: 21 }],
    149: [function(_dereq_, module, exports) {
      "use strict";
      var ExecutionEnvironment = _dereq_(21), escapeTextContentForBrowser = _dereq_(116), setInnerHTML = _dereq_(148), setTextContent = function(node, text) {
        node.textContent = text
      };
      ExecutionEnvironment.canUseDOM && ("textContent" in document.documentElement || (setTextContent = function(node, text) {
        setInnerHTML(node, escapeTextContentForBrowser(text))
      })), module.exports = setTextContent
    }, { 116: 116, 148: 148, 21: 21 }],
    150: [function(_dereq_, module, exports) {
      "use strict";
      function shallowEqual(objA, objB) {
        if (objA === objB)return !0;
        var key;
        for (key in objA)if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key]))return !1;
        for (key in objB)if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key))return !1;
        return !0
      }

      module.exports = shallowEqual
    }, {}],
    151: [function(_dereq_, module, exports) {
      "use strict";
      function shouldUpdateReactComponent(prevElement, nextElement) {
        if (null != prevElement && null != nextElement) {
          var prevType = typeof prevElement, nextType = typeof nextElement;
          if ("string" === prevType || "number" === prevType)return "string" === nextType || "number" === nextType;
          if ("object" === nextType && prevElement.type === nextElement.type && prevElement.key === nextElement.key) {
            var ownersMatch = prevElement._owner === nextElement._owner, prevName = null, nextName = null, nextDisplayName = null;
            return ownersMatch || (null != prevElement._owner && null != prevElement._owner.getPublicInstance() && null != prevElement._owner.getPublicInstance().constructor && (prevName = prevElement._owner.getPublicInstance().constructor.displayName), null != nextElement._owner && null != nextElement._owner.getPublicInstance() && null != nextElement._owner.getPublicInstance().constructor && (nextName = nextElement._owner.getPublicInstance().constructor.displayName), null != nextElement.type && null != nextElement.type.displayName && (nextDisplayName = nextElement.type.displayName), null != nextElement.type && "string" == typeof nextElement.type && (nextDisplayName = nextElement.type), "string" == typeof nextElement.type && "input" !== nextElement.type && "textarea" !== nextElement.type || (null != prevElement._owner && prevElement._owner._isOwnerNecessary === !1 || null != nextElement._owner && nextElement._owner._isOwnerNecessary === !1) && (null != prevElement._owner && (prevElement._owner._isOwnerNecessary = !0), null != nextElement._owner && (nextElement._owner._isOwnerNecessary = !0), warning(!1, "<%s /> is being rendered by both %s and %s using the same key (%s) in the same place. Currently, this means that they don't preserve state. This behavior should be very rare so we're considering deprecating it. Please contact the React team and explain your use case so that we can take that into consideration.", nextDisplayName || "Unknown Component", prevName || "[Unknown]", nextName || "[Unknown]", prevElement.key))), ownersMatch
          }
        }
        return !1
      }

      var warning = _dereq_(154);
      module.exports = shouldUpdateReactComponent
    }, { 154: 154 }],
    152: [function(_dereq_, module, exports) {
      function toArray(obj) {
        var length = obj.length;
        if (invariant(!Array.isArray(obj) && ("object" == typeof obj || "function" == typeof obj), "toArray: Array-like object expected"), invariant("number" == typeof length, "toArray: Object needs a length property"), invariant(0 === length || length - 1 in obj, "toArray: Object should have keys for indices"), obj.hasOwnProperty)try {
          return Array.prototype.slice.call(obj)
        } catch (e) {
        }
        for (var ret = Array(length), ii = 0; ii < length; ii++)ret[ii] = obj[ii];
        return ret
      }

      var invariant = _dereq_(135);
      module.exports = toArray
    }, { 135: 135 }],
    153: [function(_dereq_, module, exports) {
      "use strict";
      function userProvidedKeyEscaper(match) {
        return userProvidedKeyEscaperLookup[match]
      }

      function getComponentKey(component, index) {
        return component && null != component.key ? wrapUserProvidedKey(component.key) : index.toString(36)
      }

      function escapeUserProvidedKey(text) {
        return ("" + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper)
      }

      function wrapUserProvidedKey(key) {
        return "$" + escapeUserProvidedKey(key)
      }

      function traverseAllChildrenImpl(children, nameSoFar, indexSoFar, callback, traverseContext) {
        var type = typeof children;
        if ("undefined" !== type && "boolean" !== type || (children = null), null === children || "string" === type || "number" === type || ReactElement.isValidElement(children))return callback(traverseContext, children, "" === nameSoFar ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, indexSoFar), 1;
        var child, nextName, nextIndex, subtreeCount = 0;
        if (Array.isArray(children))for (var i = 0; i < children.length; i++)child = children[i], nextName = ("" !== nameSoFar ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i), nextIndex = indexSoFar + subtreeCount, subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext); else {
          var iteratorFn = getIteratorFn(children);
          if (iteratorFn) {
            var step, iterator = iteratorFn.call(children);
            if (iteratorFn !== children.entries)for (var ii = 0; !(step = iterator.next()).done;)child = step.value, nextName = ("" !== nameSoFar ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, ii++), nextIndex = indexSoFar + subtreeCount, subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext); else for (warning(didWarnAboutMaps, "Using Maps as children is not yet fully supported. It is an experimental feature that might be removed. Convert it to a sequence / iterable of keyed ReactElements instead."), didWarnAboutMaps = !0; !(step = iterator.next()).done;) {
              var entry = step.value;
              entry && (child = entry[1], nextName = ("" !== nameSoFar ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0), nextIndex = indexSoFar + subtreeCount, subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext))
            }
          } else if ("object" === type) {
            invariant(1 !== children.nodeType, "traverseAllChildren(...): Encountered an invalid child; DOM elements are not valid children of React components.");
            var fragment = ReactFragment.extract(children);
            for (var key in fragment)fragment.hasOwnProperty(key) && (child = fragment[key], nextName = ("" !== nameSoFar ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0), nextIndex = indexSoFar + subtreeCount, subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext))
          }
        }
        return subtreeCount
      }

      function traverseAllChildren(children, callback, traverseContext) {
        return null == children ? 0 : traverseAllChildrenImpl(children, "", 0, callback, traverseContext)
      }

      var ReactElement = _dereq_(57), ReactFragment = _dereq_(63), ReactInstanceHandles = _dereq_(66), getIteratorFn = _dereq_(126), invariant = _dereq_(135), warning = _dereq_(154), SEPARATOR = ReactInstanceHandles.SEPARATOR, SUBSEPARATOR = ":", userProvidedKeyEscaperLookup = {
        "=": "=0",
        ".": "=1",
        ":": "=2"
      }, userProvidedKeyEscapeRegex = /[=.:]/g, didWarnAboutMaps = !1;
      module.exports = traverseAllChildren
    }, { 126: 126, 135: 135, 154: 154, 57: 57, 63: 63, 66: 66 }],
    154: [function(_dereq_, module, exports) {
      "use strict";
      var emptyFunction = _dereq_(114), warning = emptyFunction;
      warning = function(condition, format) {
        for (var args = [], $__0 = 2, $__1 = arguments.length; $__0 < $__1; $__0++)args.push(arguments[$__0]);
        if (void 0 === format)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
        if (format.length < 10 || /^[s\W]*$/.test(format))throw new Error("The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + format);
        if (0 !== format.indexOf("Failed Composite propType: ") && !condition) {
          var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                    return args[argIndex++]
                  });
          console.warn(message);
          try {
            throw new Error(message)
          } catch (x) {
          }
        }
      }, module.exports = warning
    }, { 114: 114 }]
  }, {}, [1])(1)
}), Array.prototype.every || (Array.prototype.every = function(callbackfn, thisArg) {
  "use strict";
  var T, k;
  if (null === this)throw new TypeError("this is null or not defined");
  var O = Object(this), len = O.length >>> 0;
  if ("function" != typeof callbackfn)throw new TypeError;
  for (arguments.length > 1 && (T = thisArg), k = 0; k < len;) {
    var kValue;
    if (k in O) {
      kValue = O[k];
      var testResult = callbackfn.call(T, kValue, k, O);
      if (!testResult)return !1
    }
    k++
  }
  return !0
}), Array.prototype.filter || (Array.prototype.filter = function(fun) {
  "use strict";
  if (void 0 === this || null === this)throw new TypeError;
  var t = Object(this), len = t.length >>> 0;
  if ("function" != typeof fun)throw new TypeError;
  for (var res = [], thisArg = arguments.length >= 2 ? arguments[1] : void 0, i = 0; i < len; i++)if (i in t) {
    var val = t[i];
    fun.call(thisArg, val, i, t) && res.push(val)
  }
  return res
}), Array.prototype.find || (Array.prototype.find = function(predicate) {
  "use strict";
  if (null == this)throw new TypeError("Array.prototype.find called on null or undefined");
  if ("function" != typeof predicate)throw new TypeError("predicate must be a function");
  for (var value, list = Object(this), length = list.length >>> 0, thisArg = arguments[1], i = 0; i < length; i++)if (value = list[i], predicate.call(thisArg, value, i, list))return value
}), Array.from || (Array.from = function() {
  var toStr = Object.prototype.toString, isCallable = function(fn) {
    return "function" == typeof fn || "[object Function]" === toStr.call(fn)
  }, toInteger = function(value) {
    var number = Number(value);
    return isNaN(number) ? 0 : 0 !== number && isFinite(number) ? (number > 0 ? 1 : -1) * Math.floor(Math.abs(number)) : number
  }, maxSafeInteger = Math.pow(2, 53) - 1, toLength = function(value) {
    var len = toInteger(value);
    return Math.min(Math.max(len, 0), maxSafeInteger)
  };
  return function(arrayLike) {
    var C = this, items = Object(arrayLike);
    if (null == arrayLike)throw new TypeError("Array.from requires an array-like object - not null or undefined");
    var T, mapFn = arguments.length > 1 ? arguments[1] : void 0;
    if ("undefined" != typeof mapFn) {
      if (!isCallable(mapFn))throw new TypeError("Array.from: when provided, the second argument must be a function");
      arguments.length > 2 && (T = arguments[2])
    }
    for (var kValue, len = toLength(items.length), A = isCallable(C) ? Object(new C(len)) : new Array(len), k = 0; k < len;)kValue = items[k], mapFn ? A[k] = "undefined" == typeof T ? mapFn(kValue, k) : mapFn.call(T, kValue, k) : A[k] = kValue, k += 1;
    return A.length = len, A
  }
}()), Object.assign || Object.defineProperty(Object, "assign", {
  enumerable: !1,
  configurable: !0,
  writable: !0,
  value: function(target, firstSource) {
    "use strict";
    if (void 0 === target || null === target)throw new TypeError("Cannot convert first argument to object");
    for (var to = Object(target), i = 1; i < arguments.length; i++) {
      var nextSource = arguments[i];
      if (void 0 !== nextSource && null !== nextSource)for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
        var nextKey = keysArray[nextIndex], desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey])
      }
    }
    return to
  }
}), Object.keys || (Object.keys = function() {
  "use strict";
  var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable("toString"), dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], dontEnumsLength = dontEnums.length;
  return function(obj) {
    if ("object" != typeof obj && ("function" != typeof obj || null === obj))throw new TypeError("Object.keys called on non-object");
    var prop, i, result = [];
    for (prop in obj)hasOwnProperty.call(obj, prop) && result.push(prop);
    if (hasDontEnumBug)for (i = 0; i < dontEnumsLength; i++)hasOwnProperty.call(obj, dontEnums[i]) && result.push(dontEnums[i]);
    return result
  }
}());
var xy = {};
xy._version = "5.9.1", xy.gameClass = GameClass, xy.res = {}, xy.resourcePreloadingArray = [], xy.resourceLoader = function(game, locale) {
  "use strict";
  var gameRes = {
    gameLogo: "game-logo-big.png?rev_grd2a927ccd0ae8c97515cdc5e182e1e67",
    loadingImage: "loading-image.png?rev_gr54928892ad7fced9d4f0df45f4b8dc4b",
    loadingAnimation: "loading.gif?rev_gr93c18d4cd6fc5bf762bc886cdf7921c6",
    loadingAnimationForCover: "loading-sand-watch.gif?rev_gr86539e88244d27479aa59a0be1c74c71",
    textureButtonDefault: "textures/metal_texture.png?rev_gr501a805dc59e6bdbc3ae925ccf6627d7",
    textureButtonDefaultHover: "textures/metal_texture_hover.png?rev_grccecb3384e5c201a555271a246ae2527",
    textureBackBG: "textures/wood_texture.png?rev_gr0d9c2712018b55e9e202e82a17057057",
    textureFrontBG: "textures/wood_light_texture.png?rev_gr2381818f2b72d3f9be607a538d5a1b75",
    textureFrontBGHover: "textures/wood_light_texture_hover.png?rev_gr896adc99f5bf13a23552e164f748e3b9",
    textureFrontBGDisabled: "textures/wood_light_texture_disabled.png?rev_gr2b888db860980c5a228a4149dd1e66de",
    textureCanvasImages: "textures/textures-canvas.png?rev_gre825da286ad12f993b2d59351fd4524b",
    textureCanvasPlist: "textures/textures-canvas.plist?rev_gr201ef00052d2a91855106e43c2b49bb7",
    textureOuterBorderTop: "textures/border_top.png?rev_gr465fc8355c1e3e510a5fcaafe80f452e",
    textureOuterBorderBottom: "textures/border_bottom.png?rev_gr960a4a75093b83ba7d2052eabae9aa0c",
    textureOuterBorderLeft: "textures/border_left.png?rev_gr85578f608d1124c8e52374edf7eb1ff6",
    textureOuterBorderRight: "textures/border_right.png?rev_gr1c060486ab034bba3bf2ea1c2691d0d0",
    textureOuterBorderCornerTL: "textures/border_corner.png?rev_gr3cd0d441442f70bcef2b4640aeb1f4e9",
    textureOuterBorderCornerTR: "textures/border_corner.png?rev_gr3cd0d441442f70bcef2b4640aeb1f4e9",
    textureOuterBorderCornerBL: "textures/border_corner.png?rev_gr3cd0d441442f70bcef2b4640aeb1f4e9",
    textureOuterBorderCornerBR: "textures/border_corner.png?rev_gr3cd0d441442f70bcef2b4640aeb1f4e9",
    textureInnerBorderTop: "textures/inner_frame_horizontal_t.png?rev_gr66b8e58a43fea7e8d65bf38df5b8a5b4",
    textureInnerBorderBottom: "textures/inner_frame_horizontal_b.png?rev_gr49950f0aaf66949f3c277c7769d0c41c",
    textureInnerBorderLeft: "textures/inner_frame_vertical_l.png?rev_gr291bc1966c46496bcbda956d8af2fb30",
    textureInnerBorderRight: "textures/inner_frame_vertical_r.png?rev_gr291bc1966c46496bcbda956d8af2fb30",
    textureInnerBorderCornerTL: "textures/inner_frame_corner_tl.png?rev_grf1cda3556e65e69521e185b610e987e0",
    textureInnerBorderCornerTR: "textures/inner_frame_corner_tr.png?rev_gr7bc40029fbd8be2a0403d736e0fa2d51",
    textureInnerBorderCornerBL: "textures/inner_frame_corner_bl.png?rev_grb5bde941446fe3618b7eb41be7bd1c35",
    textureInnerBorderCornerBR: "textures/inner_frame_corner_br.png?rev_gr01d7c880be87366a93f56a02255dcc53",
    textureHeadline: "textures/headline.png?rev_gr67e30f3bf52a764508053d6570ed4bb3",
    mapImages: "map/map.png?rev_grb12cf3af619a292f7079e9813ea96fd8",
    mapPlist: "map/map.plist?rev_grb4bde8bb3576c55561e9c335432ac9b3",
    mapAnimationHabitatUnderAttackImages: "map/habitat-under-attack.png?rev_gr319aa59f21deb24eba4a96f9565be053",
    mapAnimationHabitatUnderAttackPlist: "map/habitat-under-attack.plist?rev_grb35970b28fb93b6839d613a49c21a1d3",
    tutorialImages: "tutorial/tutorial.png?rev_grbdec3b4e2c0649bc60299e5f0d8eb8e7",
    tutorialPlist: "tutorial/tutorial.plist?rev_grd9d23768a37ac6d5ca949c22ede706c2",
    habitat0Images: "scene-habitat/scene-habitat-0-full-hd.png?rev_grf11704a4af50bb804673262efb75eedc",
    habitat0Plist: "scene-habitat/scene-habitat-0-full-hd.plist?rev_gra4b00cb052c31bb1039cc3a8a945b3f4",
    habitat0AnimationImages: "scene-habitat/scene-habitat-0-animation-full-hd.png?rev_grcb74f7b89adf926f194e34ffd969a477",
    habitat0AnimationPlist: "scene-habitat/scene-habitat-0-animation-full-hd.plist?rev_gree0dc5b8636d017c6c9492999316ee51",
    habitat2Images: "scene-habitat/scene-habitat-2-full-hd.png?rev_gr37e00185ec3a5920002b576cf4879453",
    habitat2Plist: "scene-habitat/scene-habitat-2-full-hd.plist?rev_gr8c31452eeffe478df71d640583bc82f6",
    habitat2AnimationImages: "scene-habitat/scene-habitat-2-animation-full-hd.png?rev_grd7aca0bf7f3425c1c4fa45b650827223",
    habitat2AnimationPlist: "scene-habitat/scene-habitat-2-animation-full-hd.plist?rev_grfc484d91c36a9d8e42aa23ac0568628f",
    buttonRedBig: "buttons/big_button.jpg?rev_gr3d4e9e37f619c8b38e068149e07607d3",
    buttonRedBigHover: "buttons/big_button_hover.jpg?rev_gr98ac8b97fbca99e45db344d5a1ca82fb",
    loginBackgroundImage: "login-background.jpg?rev_gr300a41c7510a1b53c3cefac065911cb3",
    iconFlagsImages: "icons/flags.png?rev_gr723923a6edab2b80380da088cdd87a19",
    iconResourcesImages: "icons/resources.png?rev_gr5168ce3f0ea2e2e0ca01f31feb30306c",
    iconBuildingsImages: "icons/buildings.png?rev_gr18f6179f1ff58727b028d0cd31ba4787",
    iconGameWhite: "icons/all_games_icons_white.png?rev_grac634750d73b7e64ce01db5e77a674c6",
    iconGameBlack: "icons/all_games_icons_black.png?rev_graa8fead97fda9df7e4b84bbab451f9fe",
    iconGameColored: "icons/colored_games_icons.png?rev_grbecf86597b891d02fb60aa6e4d20546e",
    iconControlImages: "icons/controls.png?rev_gr483cb2dc0e9d41fa0e43e79ec494c46f",
    iconAllianceRelationsImages: "icons/alliance-relationship.png?rev_gr2f5b5d6e119f86f8ae4ab93ce6df1f94",
    iconAlliancePermissionImages: "icons/alliance-permission.png?rev_gr859ff4a8bab0578c7305f07acec5ce05",
    iconMenuSelectableImages: "icons/menu-selectable.png?rev_grfb68d030758e626602a7a4e12daa2ad6",
    iconMissionsIcon: "icons/missions.png?rev_gr076e6d320e84b229c0e77fb40bd7ac07",
    iconKnowledgeImages: "icons/knowledges_icon_set.png?rev_gr3114ae2c3ac161286490fdddf724ac4a",
    iconUnitsImages: "units/units-icon-set.png?rev_gr04cf2c7636716ce108c2ed8d3cc31a45",
    iconUnitsBlackImages: "units/units-icon-set-black.png?rev_grc9a2d4660517ee634d0fc36b13b08f06",
    mainUnitsImages: "units/units-set.png?rev_gr57a99c7e60820bde6fe696e21897e784",
    iconEventListImages: "event/event-list.png?rev_grdd9f744a730321082e8c58c61e634b01",
    eventPopUpImages: "event/event-pop-up.png?rev_grcca03de5c29831eec6bee1fe4f586176",
    eventPopUpRepeatedHorizontallyImages: "event/event-pop-up-repeated-horizontally.png?rev_grbfc22cf4b7fa4829b36e0a578f5296a4",
    eventPopUpRepeatedVerticallyImages: "event/event-pop-up-repeated-vertically.png?rev_gr8f5c1d807b635bc59e230ab767847e02",
    eventPopUpImagesImages: "event/event-pop-up-images.png?rev_gr5a364000369f5691110bfffaa4f9d0c3",
    eventPopUpSpecificIconsImages: "event/event-pop-up-specific-icons.png?rev_grfdc9d447fda0c1a4e4f1bb94625bbc42",
    eventPopUpButtonsImages: "event/event-pop-up-buttons.png?rev_gr40801e46c1c694efd28a3c43da871bd1"
  }, gameMusic = {
    musicTheme01: "lnk1.mp3?res_m9f21d6f10aefdd507c11b815c2a0255d",
    musicTheme02: "lnk2.mp3?res_me38c399c80b6b9cb0e78bba43bb94a56",
    musicTheme03: "lnk3.mp3?res_m52de320f538de57b7819ca8168206827",
    habitatTheme01: "LNK_Atmo_Burg_Var1.mp3?res_mab3a18a1e74d61c9995f65e934201077",
    habitatTheme02: "LNK_Atmo_Burg_Var2.mp3?res_mbc4a0966043f40e2ca940284348d3b24",
    habitatTheme03: "LNK_Atmo_Burg_Var3.mp3?res_mbe63b4694b94c3d2e92580244abb4d5c",
    mapTheme01: "LNK_Atmo_Karte_1.mp3?res_m7de4297d9a1ee218214cd7fb15784fc8",
    mapTheme02: "LNK_Atmo_Karte_2.mp3?res_mce378bd034a1023515a5ccde07696f49",
    sxfKeep: "LNK_SilberTauschen.mp3?res_m248e96103e19777cd6073f21177ba128",
    sfxLumberjack: "LNK_Holzfaeller.mp3?res_maf9c4451efd2daf6e2ff93acde53d37f",
    sfxQuarry: "LNK_Steinbruch.mp3?res_m1a193e660053c01f1d042ce307630b49",
    sfxOremine: "LNK_Erzmine.mp3?res_m05518308acb2aeb43e6484b2472e74e4",
    sfxForge: "LNK_Zeughaus.mp3?res_mc551e9480de4b563fe065c123ab3d9c9",
    sfxFarm: "LNK_Bauernhof.mp3?res_mfdd33cb84b0e8a5f35ed096c5b2ed8d2",
    sfxMarket: "LNK_Markt.mp3?res_m33b612b7fa89e9a9b1aab3698922b707",
    sfxLibrary: "LNK_Bibliothek.mp3?res_m6017ae17c710e71907df78b11b51aba8",
    sfxArsenal: "LNK_Angreifen.mp3?res_m88aebd25c391341d6d9802f4549deb4a",
    sfxWall: "LNK_Wehranlage.mp3?res_m82a8b4509dcec0bf3d82696c4c0807c9",
    sfxTavern: "LNK_Taverne.mp3?res_mbda5791ff38551509859b33cb740c59a",
    sfxActionAttack: "LNK_Burg_Erobern.mp3?res_mcc4c97876b6f27b539f2cd8338eb1263"
  }, gameTheme = { themeMain: "theme-main.json?res_t5fa69e23de16e5a5a6da586bef2fa369" }, gameLocalization = {
    localizationMain: "main",
    localizationEvent: "event"
  }, folderGame = "res/graphics/" + game + "/", folderMusic = "res/sound/" + game + "/", folderTheme = "res/theme/" + game + "/", folderLocalization = "res/internationalization/" + game + "/";
  Object.keys(xy.res).forEach(function(resKey) {
    xy.resourcePreloadingArray.push(xy.res[resKey])
  }), Object.keys(gameRes).forEach(function(gameResKey) {
    var resourceUrl = folderGame + gameRes[gameResKey];
    xy.res[gameResKey] = resourceUrl, xy.resourcePreloadingArray.push(resourceUrl)
  }), Object.keys(gameTheme).forEach(function(themeKey) {
    var resourceUrl = folderTheme + gameTheme[themeKey];
    xy.res[themeKey] = resourceUrl, xy.resourcePreloadingArray.push(resourceUrl)
  }), Object.keys(gameMusic).forEach(function(musicKey) {
    var resourceUrl = folderMusic + gameMusic[musicKey];
    xy.res[musicKey] = resourceUrl, xy.resourcePreloadingArray.push(resourceUrl)
  }), xy.res.internationalizationPath = {}, xy.res.internationalizationFingerprinnt = "?res_ib0aac4228268c439b84d282d1fb327d9", Object.keys(gameLocalization).forEach(function(key) {
    xy.res[key] = folderLocalization + gameLocalization[key] + "/" + locale + ".json" + xy.res.internationalizationFingerprinnt, xy.res.internationalizationPath[key] = folderLocalization + gameLocalization[key] + "/", xy.resourcePreloadingArray.push(xy.res[key])
  })
}, xy.dStaticInjector = {
  resources: {}, set: function(key, argsArray) {
    "use strict";
    xy.dStaticInjector.resources[key] = argsArray
  }
}, xy.dNames = {
  gameInstance: "game-instance",
  componentsEngine: "components-engine",
  graphicEngine: { mainDirector: "graphic-engine.main-director" },
  services: {
    log: "services.service-log",
    parserBPList: "services.service-parser-b-p-list",
    sortable: "services.service-sortable",
    httpRequest: "services.service-http-request",
    loader: "services.service-loader",
    groupable: "services.service-groupable",
    network: "services.network",
    internationalization: "services.internationalization",
    resourcesManager: "services.resources-manager",
    musicManager: "services.music-manager",
    gameDataManager: "services.game-data-manager",
    sessionUpdateSchedule: "services.session-update-schedule",
    keyboardManager: "services.keyboard-manager",
    eventManager: "services.event-manager",
    worldSettings: "services.world-settings",
    theme: "services.theme-instance",
    storage: "services.storage",
    analytics: "services.analytics"
  },
  utils: {
    dateTime: "utils.date-time",
    network: "utils.network",
    object: "utils.object",
    moving: "utils.moving",
    oop: "utils.oop",
    screen: "utils.screen",
    string: "utils.string",
    converter: "utils.converter",
    number: "utils.number"
  },
  settings: { gameConstant: "settings.game-constant", gameDynamic: "settings.game-dynamic" },
  mixins: {
    delegate: "mixins.delegate",
    dialogHandlers: "mixins.dialog-handlers",
    setOption: "mixins.set-option",
    linkMethod: "mixins.link-method",
    menuComponentHandlers: "mixin.menu-component-handlers",
    menuComponentTimer: "mixin.menu-component-timer",
    menuComponentArrivalDate: "mixin.menu-component-arrival-date",
    menuSearchBarHandlers: "mixin.menu-search-bar-handlers",
    menuHabitatFilteringHandlers: "mixin.menu-habitat-filtering-handlers",
    menuAllianceInvitation: "mixin.menu-alliance-invitation",
    tableToggleAllHandler: "mixin.table-toggle-all-handler"
  },
  factories: { game: "factories.game" },
  components: {
    rendererLoadingGame: "component.renderer-loading-game",
    rendererRequestPending: "component.renderer-request-pending",
    containerWindowBox: "component.container-window-box",
    dialogAlert: "component.dialog-alert",
    dialogDialog: "component.dialog-dialog",
    dialogNotEnoughSource: "component.dialog-not-enough-source",
    containerBorderedBox: "component.container-bordered-box",
    borderOuter: "component.border-outer",
    borderInner: "component.border-inner",
    tabular: "component.tabular",
    tabularRow: "component.tabular-row",
    tabularRowHeader: "component.tabular-row-header",
    tabularCell: "component.tabular-cell",
    toggleAllTabularHeader: "component.toggle-all-tabular-header",
    changeGroupingDirectionTabularHeader: "component.change-grouping-direction-tabular-header",
    habitatTypesTabularHeader: "component.habitat-types-tabular-header",
    alertTooltip: "component.alert-tooltip",
    button: "component.button",
    buttonMain: "component.button-main",
    buttonBordered: "component.button-bordered",
    buttonForBars: "component.button-for-bars",
    buttonPageListing: "component.button-page-listing",
    inputSubject: "component.input-subject",
    inputContent: "component.input-content",
    inputTextField: "component.input-text-field",
    inputTextFieldWithValidation: "component.input-text-field-with-validation",
    inputTextTabularCell: "component.input-text--tabular-cell",
    dropdownLanguage: "component.dropdown-language",
    dropdownLanguageItem: "component.dropdown-language-item",
    listTitleMain: "component.list-title-main",
    listTitleDefault: "component.list-title-default",
    icon: "component.icon",
    allianceMenuElement: "component.alliance-menu-element",
    allianceInvitationMenuElement: "component.alliance-invitation-menu-element",
    allianceHabitatReservationsMenuElement: "component.alliance-habitat-reservations-menu-element",
    habitatMenuElement: "component.habitat-menu-element",
    habitatTabularCell: "component.habitat-tabular-cell",
    habitatAnnexMenuElement: "component.habitat-annex-menu-element",
    widgetHabitatOverview: "component.widget-habitat-overview",
    widgetHabitatMassExchange: "component.widget-habitat-mass-exchange",
    widgetHabitatAmount: "component.widget-habitat-amount",
    missionTabularCell: "component.mission-tabular-cell",
    habitatUpgradesConstructUpgradeCenter: "component.habitat-upgrade-construct-upgrade-center",
    habitatUpgradesExpandUpgradeCenter: "component.habitat-upgrade-expand-upgrade-center",
    habitatUpgradesConstructUpgrade: "component.habitat-upgrade-construct-upgrade",
    habitatUpgradesExpandedList: "component.habitat-upgrade-expanded-list",
    habitatUpgradesExpandingList: "component.habitat-upgrade-expanding-list",
    habitatUpgradesHabitatsForExpansion: "component.habitat-upgrade-habitats-for-expansion",
    transitsSummary: "component.transit-summary",
    transitList: "component.transit-list",
    transitListEntry: "component.transit-list-entry",
    transitTabularCell: "component.transit-tabular-cell",
    transitMenuSendSpyButton: "component.transit-menu-send-spy-button",
    transitMenuSendResourcesButton: "component.transit-menu-send-resources-button",
    transitMenuAttackButton: "component.transit-menu-attack-button",
    transitMenuSupportButton: "component.transit-menu-support-button",
    transitExternalListButton: "component.transit-external-list-button",
    unitIconAmount: "component.unit-icon-amount",
    unitsListLocalDefenders: "component.unit-list-local-defenders",
    unitsListLocalAttackers: "component.unit-list-local-attackers",
    unitsListAttackersInForeignerHabitat: "component.units-list-attackers-in-foreigner-habitat",
    unitsListExternalAttackers: "component.unit-list-external-attackers",
    unitsListExternalDefenders: "component.unit-list-external-defenders",
    unitsListReturnFromHabitat: "component.unit-list-return-from-habitat",
    unitTabularCell: "component.unit-tabular-cell",
    unitInProgressTabularCell: "component.unit-in-progress-tabular-cell",
    resourceIconAmount: "component.resource-icon-amount",
    resourceProgressBar: "component.resource-progress-bar",
    tapBarHabitatType: "component.tap-bar-habitat-types",
    menuSection: "component.menu-section",
    menuSectionContent: "component.menu-section-content",
    menuBottomBarMain: "component.menu-bottom-bar-main",
    menuTitleBarMain: "component.menu-title-bar-main",
    menuListTitleBasic: "component.menu-list-title-basic",
    menuListTextBasic: "component.menu-list-text-basic",
    menuListElementBasic: "component.menu-list-element-basic",
    menuListElementButtonAction: "component.menu-list-element-button-action",
    menuListButtonBasic: "component.menu-list-button-basic",
    menuListButtonDisplayLink: "component.menu-list-button-display-link",
    menuSearchBar: "component.menu-search-bar",
    menuTapBar: "component.menu-tap-bar",
    menuTapBarButton: "component.menu-tap-bar-button",
    menuTapBarReportSwitcher: "component.menu-tap-bar-report-switcher",
    message: "component.message",
    messageDiscussionEntry: "component.message-discussion-entry",
    messageDiscussionMemberChange: "component.message-discussion-member-change",
    messageForumEntry: "component.message-forum-entry",
    widgetAllianceRelationBadge: "component.widget-alliance-relation-badge",
    widgetAlliancePermissionBadges: "component.widget-alliance-permission-badges",
    widgetAlliancePermissionList: "component.widget-alliance-permission-list",
    widgetAllianceInvitation: "component.widget-alliance-invitation",
    widgetContentText: "component.widget-content-text",
    widgetBatchResourcesUnits: "component.widget-batch-resources-units",
    widgetUnitsList: "component.widget-units-list",
    widgetResourcesList: "component.widget-resources-list",
    widgetRangeSlider: "component.widget-range-slider",
    widgetRangeSliderDivider: "component.widget-range-slider-divider",
    widgetRename: "component.widget-rename",
    widgetTimeDurationPicker: "component.widget-time-duration-picker",
    widgetTimeDelay: "component.widget-time-delay",
    widgetTimePicker: "component.widget-time-picker",
    widgetDateTimePicker: "component.widget-date-time-picker",
    widgetSupportBridgeRound: "component.widget-support-bridge-round",
    buildingWidgetTradeRates: "component.widget-trade-rates",
    buildingUpgradesList: "component.building-upgrades-list",
    buildingUpgradesEntry: "component.building-upgrades-entry",
    buildingTabularCell: "component.building-tabular-cell",
    buildingInProgressTabularCell: "component.building-in-progress--tabular-cell",
    overviewWidgetConstructCost: "component.widget-construct-cost",
    overviewWidgetBattleAbilityList: "component.widget-battle-ability-list",
    overviewWidgetTreasureChest: "component.widget-treasure-chest",
    overviewWidgetMovementWithLastFormation: "component.widget-movement-with-last-formation",
    overviewWidgetResourcesInHabitat: "component.overview-resources-in-habitat",
    protectionWidgetNoobProtectionTeleportButton: "component.protection-widget-noob-protection-teleport-button",
    protectionWidgetAttackProtectionButton: "component.protection-widget-attack-protection-button",
    protectionWidgetVacationButton: "component.protection-widget-vacation-button"
  },
  core: {
    coreClass: "core.core-class",
    coreError: "core.core-error",
    graphicalEngineDirector: "core.graphical-engine-director",
    graphicalEngineAnimation: "core.graphical-engine-animation",
    graphicalEngineFrameManager: "core.graphical-engine-frame-manager",
    graphicalEngineMapCanvasBuffer: "core.graphical-engine-map-canvas-buffer",
    graphicalEngineNode: "core.graphical-engine-node",
    controller: "core.controller",
    controllerElement: "core.controller-element",
    controllerElementGlobalOverview: "core.controller-element-global-overview",
    controllerElementMenu: "core.controller-element-menu",
    controllerCanvas: "core.controller-canvas",
    dataSource: "core.data-source",
    model: "core.model",
    modelInProgress: "core.model-in-progress",
    modelBuff: "core.model-buff",
    modelBuffActive: "core.model-buff-active",
    modelDefaultSettings: "core.model-default-settings",
    modelHabitatBasic: "core.model-habitat-basic",
    modelAutomaticConquestPointTradingSettings: "core.model-automatic-conquest-point-trading-settings",
    modelHabitatGame: "core.model-habitat-game",
    modelHabitatMap: "core.model-habitat-map",
    modelHabitatReservation: "core.model-habitat-reservation",
    modelPlayer: "core.model-player",
    modelAlliance: "core.model-alliance",
    modelAllianceClash: "core.model-alliance-clash",
    modelAllianceRelation: "core.model-alliance-relation",
    modelAllianceSharing: "core.model-alliance-sharing",
    modelAllianceFeedReport: "core.model-alliance-feed-report",
    modelEventTrackable: "core.model-event-trackable",
    modelEventTracking: "core.model-event-tracking",
    modelEventClientInfo: "core.model-event-client-info",
    modelUnit: "core.model-unit",
    modelUnitInProgress: "core.model-unit-in-progress",
    modelBuilding: "core.model-building",
    modelBuildingUpgrade: "core.model-building-upgrade",
    modelTransit: "core.model-transit",
    modelHabitatUnit: "core.model-habitat-unit",
    modelMessage: "core.model-message",
    modelForumThread: "core.model-message-thread",
    modelForumThreadMessage: "core.model-message-thread-message",
    modelMessageDiscussionEntry: "core.model-message-discussion-entry",
    modelMessageDiscussionMemberChange: "core.model-message-discussion-memberChange",
    modelReport: "core.model-report",
    modelMission: "core.model-mission",
    modelMissionInProgress: "core.model-mission-in-progress",
    modelKnowledge: "core.model-knowledge",
    modelKnowledgeInProgress: "core.model-knowledge-in-progress",
    modelModifier: "core.model-modifier",
    modelHabitatUpgrade: "core.model-habitat-upgrade",
    modelHabitatUpgradeInProgress: "core.model-habitat-upgrade-in-progress",
    modelSupportBridge: "core.model-support-bridge",
    modelResource: "core.model-resource",
    collection: "core.collection",
    collectionAlliances: "core.collection-alliances",
    collectionAllianceReport: "core.collection-alliance-reports",
    collectionBuildings: "core.collection-buildings",
    collectionBuffs: "core.collection-buffs",
    collectionHabitats: "core.collection-habitats",
    collectionMessages: "core.collection-messages",
    collectionPlayers: "core.collection-players",
    collectionEvents: "core.collection-events",
    collectionUnits: "core.collection-units",
    collectionTransits: "core.collection-transits",
    collectionReports: "core.collection-reports",
    collectionForums: "core.collection-forums",
    collectionMissions: "core.collection-missions",
    collectionKnowledges: "core.collection-knowledges",
    collectionModifiers: "core.collection-modifiers",
    collectionHabitatUpgradesConstruction: "core.collection-habitat-upgrades-construction",
    collectionRankCache: "core.collection-rank-cache",
    collectionMassFunctionsCache: "core.collection-mass-functions-cache",
    collectionDataSource: "core.collection-data-source",
    collectionDataSourceTransits: "core.collection-data-source-transits",
    presenterElement: "core.presenter-element",
    presenterElementGlobalOverview: "core.presenter-element-global-overview",
    presenterElementMenu: "core.presenter-element-menu",
    presenterElementMenuRoot: "core.presenter-element-menu-root",
    presenterElementMenuDrillDown: "core.presenter-element-menu-drill-down",
    presenterGraphicEngine: "core.presenter-graphic-engine",
    serviceClassResourcesManager: "core.service-class-resources-manager",
    serviceClassGameDataManager: "core.service-class-game-data-manager",
    serviceClassInternationalization: "core.service-class-internationalization",
    serviceClassKeyboardManager: "core.service-class-keyboard-manager",
    serviceClassEventManager: "core.service-class-event-manager",
    serviceClassMusicManager: "core.service-class-music-manager",
    serviceClassNetwork: "core.service-class-network",
    serviceClassSessionUpdateSchedule: "core.service-class-session-update-schedule",
    serviceClassTheme: "core.service-class-theme",
    serviceClassWorldSettings: "core.service-class-world-settings",
    serviceClassLocalStorage: "core.service-class-local-storage",
    serviceClassAnalytics: "core.service-class-analytics"
  },
  game: {
    sceneLogin: {
      name: "sceneLogin",
      controller: "scene-login.controller",
      dataSource: "scene-login.data-source",
      presenter: "scene-login.presenter",
      component: "scene-login.component"
    },
    sceneChooseWorld: {
      name: "sceneChooseWorld",
      controller: "choose-world-scene.controller",
      dataSource: "choose-world-scene.data-source",
      presenter: "choose-world-scene.presenter",
      component: "choose-world-scene.component",
      componentWorldButton: "choose-world-scene.component-world-button"
    },
    sceneNewPlayerInWorld: {
      name: "sceneNewPlayerInWorld",
      controller: "scene-new-player-in-world.controller",
      dataSource: "scene-new-player-in-world.data-source",
      presenter: "scene-new-player-in-world.presenter",
      component: "scene-new-player-in-world.component"
    },
    sceneGame: {
      name: "sceneGame",
      controller: "scene-game.controller",
      dataSource: "scene-game.data-source",
      presenter: "scene-game.presenter",
      componentTopBar: "scene-game.component-top-bar",
      componentBottomBar: "scene-game.component-bottom-bar",
      componentToggleBar: "scene-game.component-toggle-bar"
    },
    sceneHabitat: {
      name: "sceneHabitat",
      controller: "scene-habitat.controller",
      dataSource: "scene-habitat.data-source",
      presenter: "scene-habitat.presenter",
      componentHabitatBuffer: "scene-habitat.component-buffer"
    },
    sceneMapGame: {
      name: "sceneMapGame",
      controller: "scene-map-game.controller",
      dataSource: "scene-map-game.data-source",
      presenter: "scene-map-game.presenter",
      componentMapBuffer: "scene-map-game.component-map-buffer",
      componentMapArrow: "scene-map-game.component-map-arrow",
      componentMapLocalTile: "scene-map-game.component-map-local-tile"
    },
    sceneMapPolitical: {
      name: "sceneMapPolitical",
      controller: "scene-map-political.controller",
      dataSource: "scene-map-political.data-source",
      presenter: "scene-map-political.presenter",
      componentMapBuffer: "scene-map-political.component-map-buffer"
    },
    sceneGlobalUnitOverview: {
      name: "sceneGlobalUnitOverview",
      controller: "scene-global-unit-overview.controller",
      dataSource: "scene-global-unit-overview.data-source",
      presenter: "scene-global-unit-overview.presenter",
      component: "scene-global-unit-overview.component",
      componentTableDefending: "scene-global-unit-overview.component-table-defending",
      componentTableTransits: "scene-global-unit-overview.component-table-transits",
      componentTableMissions: "scene-global-unit-overview.component-table-missions",
      componentTableGeneralCase: "scene-global-unit-overview.component-table-general-case"
    },
    sceneGlobalBuildingOverview: {
      name: "sceneGlobalBuildingOverview",
      controller: "scene-global-building-overview.controller",
      dataSource: "scene-global-building-overview.data-source",
      presenter: "scene-global-building-overview.presenter",
      component: "scene-global-building-overview.component",
      componentTableBuildings: "scene-global-building-overview.component-table-buildings"
    },
    sceneGlobalRecruitmentOverview: {
      name: "sceneGlobalRecruitmentOverview",
      controller: "scene-global-recruitment-overview.controller",
      dataSource: "scene-global-recruitment-overview.data-source",
      presenter: "scene-global-recruitment-overview.presenter",
      component: "scene-global-recruitment-overview.component",
      componentTableUnits: "scene-global-recruitment-overview.component-table-units"
    },
    menuMessages: {
      name: "menuMessages",
      controller: "menu-messages.controller",
      dataSource: "menu-messages.data-source",
      presenter: "menu-messages.presenter",
      component: "menu-messages.component"
    },
    menuMessagesNew: {
      name: "menuMessagesNew",
      controller: "menu-messages-new.controller",
      dataSource: "menu-messages-new.data-source",
      presenter: "menu-messages-new.presenter",
      component: "menu-messages-new.component"
    },
    menuMessagesThread: {
      name: "menuMessagesThread",
      controller: "menu-messages-thread.controller",
      dataSource: "menu-messages-thread.data-source",
      presenter: "menu-messages-thread.presenter",
      component: "menu-messages-thread.component"
    },
    menuReports: {
      name: "menuReports",
      controller: "menu-reports.controller",
      dataSource: "menu-reports.data-source",
      presenter: "menu-reports.presenter",
      component: "menu-reports.component"
    },
    menuReportsOverview: {
      name: "menuReportsOverview",
      controller: "menu-reports-overview.controller",
      dataSource: "menu-reports-overview.data-source",
      presenter: "menu-reports-overview.presenter",
      component: "menu-reports-overview.component"
    },
    menuReportsSettings: {
      name: "menuReportsSettings",
      controller: "menu-reports-settings.controller",
      dataSource: "menu-reports-settings.data-source",
      presenter: "menu-reports-settings.presenter",
      component: "menu-reports-settings.component"
    },
    menuForum: {
      name: "menuForum",
      controller: "menu-forum.controller",
      dataSource: "menu-forum.data-source",
      presenter: "menu-forum.presenter",
      component: "menu-forum.component"
    },
    menuForumThread: {
      name: "menuForumThread",
      controller: "menu-forum-thread.controller",
      dataSource: "menu-forum-thread.data-source",
      presenter: "menu-forum-thread.presenter",
      component: "menu-forum-thread.component"
    },
    menuPlayerProfile: {
      name: "menuPlayerProfile",
      controller: "menu-player-profile.controller",
      dataSource: "menu-player-profile.data-source",
      presenter: "menu-player-profile.presenter",
      component: "menu-player-profile.component"
    },
    menuPlayerProfileExternal: {
      name: "menuPlayerProfileExternal",
      controller: "menu-player-profile-external.controller",
      dataSource: "menu-player-profile-external.data-source",
      presenter: "menu-player-profile-external.presenter",
      component: "menu-player-profile-external.component"
    },
    menuPlayersList: {
      name: "menuPlayersList",
      controller: "menu-players-list.controller",
      dataSource: "menu-players-list.data-source",
      presenter: "menu-players-list.presenter",
      component: "menu-players-list.component"
    },
    menuRank: {
      name: "menuRank",
      controller: "menu-rank.controller",
      dataSource: "menu-rank.data-source",
      presenter: "menu-rank.presenter",
      component: "menu-rank.component"
    },
    menuRankModeChooser: {
      name: "menuRankModeChooser",
      controller: "menu-rank-mode-chooser.controller",
      dataSource: "menu-rank-mode-chooser.data-source",
      presenter: "menu-rank-mode-chooser.presenter",
      component: "menu-rank-mode-chooser.component"
    },
    menuSearch: {
      name: "menuSearch",
      controller: "menu-search.controller",
      dataSource: "menu-search.data-source",
      presenter: "menu-search.presenter",
      component: "menu-search.component"
    },
    menuEvent: {
      name: "menuEvent",
      controller: "menu-event.controller",
      dataSource: "menu-event.data-source",
      presenter: "menu-event.presenter",
      component: "menu-event.component",
      componentListEntry: "menu-event.component-list-entry"
    },
    menuHabitatsList: {
      name: "menuHabitatsList",
      controller: "menu-habitats-list.controller",
      dataSource: "menu-habitats-list.data-source",
      presenter: "menu-habitats-list.presenter",
      component: "menu-habitats-list.component"
    },
    menuHabitatOverview: {
      name: "menuHabitatOverview",
      controller: "menu-habitat-overview.controller",
      dataSource: "menu-habitat-overview.data-source",
      presenter: "menu-habitat-overview.presenter",
      component: "menu-habitat-overview.component"
    },
    menuHabitatTransitsListOverview: {
      name: "menuHabitatTransitsListOverview",
      controller: "menu-habitat-transits-list-overview.controller",
      dataSource: "menu-habitat-transits-list-overview.data-source",
      presenter: "menu-habitat-transits-list-overview.presenter",
      component: "menu-habitat-transits-list-overview.component"
    },
    menuHabitatSendUnitsResources: {
      name: "menuHabitatSendUnitsResources",
      controller: "menu-habitat-send-units-resources.controller",
      dataSource: "menu-habitat-send-units-resources.data-source",
      presenter: "menu-habitat-send-units-resources.presenter",
      component: "menu-habitat-send-units-resources.component"
    },
    menuHabitatSendSpy: {
      name: "menuHabitatSendSpy",
      controller: "menu-habitat-send-spy.controller",
      dataSource: "menu-habitat-send-spy.data-source",
      presenter: "menu-habitat-send-spy.presenter",
      component: "menu-habitat-send-spy.component"
    },
    menuHabitatSortingChooser: {
      name: "menuHabitatSortingChooser",
      controller: "menu-habitat-sorting-chooser.controller",
      dataSource: "menu-habitat-sorting-chooser.data-source",
      presenter: "menu-habitat-sorting-chooser.presenter",
      component: "menu-habitat-sorting-chooser.component"
    },
    menuAllianceClashes: {
      name: "menuAllianceClashes",
      controller: "menu-alliance-clashes.controller",
      dataSource: "menu-alliance-clashes.data-source",
      presenter: "menu-alliance-clashes.presenter",
      component: "menu-alliance-clashes.component"
    },
    menuAllianceProfile: {
      name: "menuAllianceProfile",
      controller: "menu-alliance-profile-external.controller",
      dataSource: "menu-alliance-profile-external.data-source",
      presenter: "menu-alliance-profile-external.presenter",
      component: "menu-alliance-profile-external.component"
    },
    menuAllianceDescription: {
      name: "menuAllianceDescription",
      controller: "menu-alliance-description.controller",
      dataSource: "menu-alliance-description.data-source",
      presenter: "menu-alliance-description.presenter",
      component: "menu-alliance-description.component"
    },
    menuAllianceManagement: {
      name: "menuAllianceManagement",
      controller: "menu-alliance-management.controller",
      dataSource: "menu-alliance-management.data-source",
      presenter: "menu-alliance-management.presenter",
      componentNoAlliance: "menu-alliance-management.component-no-alliance",
      componentInAlliance: "menu-alliance-management.component-in-alliance"
    },
    menuAllianceRightsSettings: {
      name: "menuAllianceRightsSettings",
      controller: "menu-alliance-rights-settings.controller",
      dataSource: "menu-alliance-rights-settings.data-source",
      presenter: "menu-alliance-rights-settings.presenter",
      component: "menu-alliance-rights-settings.component"
    },
    menuAllianceFeed: {
      name: "menuAllianceFeed",
      controller: "menu-alliance-feed.controller",
      dataSource: "menu-alliance-feed.data-source",
      presenter: "menu-alliance-feed.presenter",
      component: "menu-alliance-feed.component"
    },
    menuAllianceFeedOverview: {
      name: "menuAllianceFeedOverview",
      controller: "menu-alliance-feed-overview.controller",
      dataSource: "menu-alliance-feed-overview.data-source",
      presenter: "menu-alliance-feed-overview.presenter",
      component: "menu-alliance-feed-overview.component"
    },
    menuAllianceFeedSettings: {
      name: "menuAllianceFeedSettings",
      controller: "menu-alliance-feed-settings.controller",
      dataSource: "menu-alliance-feed-settings.data-source",
      presenter: "menu-alliance-feed-settings.presenter",
      component: "menu-alliance-feed-settings.component"
    },
    menuAllianceInvitations: {
      name: "menuAllianceInvitations",
      controller: "menu-alliance-innovations.controller",
      dataSource: "menu-alliance-innovations.data-source",
      presenter: "menu-alliance-innovations.presenter",
      component: "menu-alliance-innovations.component"
    },
    menuAllianceDiplomacy: {
      name: "menuAllianceDiplomacy",
      controller: "menu-alliance-diplomacy.controller",
      dataSource: "menu-alliance-diplomacy.data-source",
      presenter: "menu-alliance-diplomacy.presenter",
      component: "menu-alliance-diplomacy.component"
    },
    menuAllianceDiplomacySettings: {
      name: "menuAllianceDiplomacySettings",
      controller: "menu-alliance-diplomacy-settings.controller",
      dataSource: "menu-alliance-diplomacy-settings.data-source",
      presenter: "menu-alliance-diplomacy-settings.presenter",
      component: "menu-alliance-diplomacy-settings.component"
    },
    menuAllianceHabitatReservation: {
      name: "menuAllianceHabitatReservation",
      controller: "menu-alliance-habitat-reservation.controller",
      dataSource: "menu-alliance-habitat-reservation.data-source",
      presenter: "menu-alliance-habitat-reservation.presenter",
      component: "menu-alliance-habitat-reservation.component"
    },
    menuAllianceHabitatReservationOverview: {
      name: "menuAllianceHabitatReservationOverview",
      controller: "menu-alliance-habitat-reservation-overview.controller",
      dataSource: "menu-alliance-habitat-reservation-overview.data-source",
      presenter: "menu-alliance-habitat-reservation-overview.presenter",
      component: "menu-alliance-habitat-reservation-overview.component"
    },
    menuAllianceHabitatReservationSettings: {
      name: "menuAllianceHabitatReservationSettings",
      controller: "menu-alliance-habitat-reservation-settings.controller",
      dataSource: "menu-alliance-habitat-reservation-settings.data-source",
      presenter: "menu-alliance-habitat-reservation-settings.presenter",
      component: "menu-alliance-habitat-reservation-settings.component"
    },
    menuBuildingChooser: {
      name: "menuBuildingChooser",
      controller: "menu-building-chooser.controller",
      dataSource: "menu-building-chooser.data-source",
      presenter: "menu-building-chooser.presenter",
      component: "menu-building-chooser.component"
    },
    menuBuildingsList: {
      name: "menuBuildingsList",
      controller: "menu-buildings-list.controller",
      dataSource: "menu-buildings-list.data-source",
      presenter: "menu-buildings-list.presenter",
      component: "menu-buildings-list.component"
    },
    menuBuildingOverview: {
      name: "menuBuildingOverview",
      controller: "menu-building-overview.controller",
      dataSource: "menu-building-overview.data-source",
      presenter: "menu-building-overview.presenter",
      component: "menu-building-overview.component",
      componentBuffEntry: "menu-building-overview.component-buff-entry",
      componentMissions: "menu-building-overview.component-missions",
      componentMissionsEntry: "menu-building-overview.component-missions-entry",
      componentKnowledges: "menu-building-overview.component-knowledges",
      componentKnowledgeEntry: "menu-building-overview.component-knowledge-entry",
      componentKnowledgeInProgressEntry: "menu-building-overview.component-knowledge-in-progress-entry",
      componentHabitatUpgradeConstruction: "menu-building-overview.component-habitat-upgrade-construction",
      componentRecruitmentInProgressList: "menu-building-overview.component-recruitment-in-progress-list",
      componentRecruitmentInProgressEntry: "menu-building-overview.component-recruitment-in-progress-entry",
      componentNobleExchange: "menu-building-overview.component-noble-exchange",
      componentResourcesExchange: "menu-building-overview.component-resources-exchange",
      componentResourcesStorage: "menu-building-overview.component-resources-storage",
      componentRefill: "menu-building-overview.component-refill"
    },
    menuBuildingUpgrades: {
      name: "menuBuildingUpgrades",
      controller: "menu-building-upgrades.controller",
      dataSource: "menu-building-upgrades.data-source",
      presenter: "menu-building-upgrades.presenter",
      component: "menu-building-upgrades.component",
      componentLevelEntry: "menu-building-upgrades.component-level-entry"
    },
    menuTransitOverview: {
      name: "menuTransitOverview",
      controller: "menu-transit-overview.controller",
      dataSource: "menu-transit-overview.data-source",
      presenter: "menu-transit-overview.presenter",
      component: "menu-transit-overview.component"
    },
    menuKnowledgeChooser: {
      name: "menuKnowledgeChooser",
      controller: "menu-knowledge-chooser.controller",
      dataSource: "menu-knowledge-chooser.data-source",
      presenter: "menu-knowledge-chooser.presenter",
      component: "menu-knowledge-chooser.component"
    },
    menuKnowledgeOverview: {
      name: "menuKnowledgeOverview",
      controller: "menu-knowledge-overview.controller",
      dataSource: "menu-knowledge-overview.data-source",
      presenter: "menu-knowledge-overview.presenter",
      component: "menu-knowledge-overview.component"
    },
    menuMissionOverview: {
      name: "menuMissionOverview",
      controller: "menu-mission-overview.controller",
      dataSource: "menu-mission-overview.data-source",
      presenter: "menu-mission-overview.presenter",
      component: "menu-mission-overview.component"
    },
    menuAllianceSharing: {
      name: "menuAllianceSharing",
      controller: "menu-alliance-sharing.controller",
      dataSource: "menu-alliance-sharing.data-source",
      presenter: "menu-alliance-sharing.presenter",
      component: "menu-alliance-sharing.component"
    },
    menuUnitList: {
      name: "menuUnitList",
      controller: "menu-unit-list.controller",
      dataSource: "menu-unit-list.data-source",
      presenter: "menu-unit-list.presenter",
      component: "menu-unit-list.component"
    },
    menuUnitAttackersLocal: {
      name: "menuUnitAttackersLocal",
      controller: "menu-unit-attackers-local.controller",
      dataSource: "menu-unit-attackers-local.data-source",
      presenter: "menu-unit-attackers-local.presenter",
      component: "menu-unit-attackers-local.component"
    },
    menuUnitsAttackersExternal: {
      name: "menuUnitsAttackersExternal",
      controller: "menu-units-attackers-external.controller",
      dataSource: "menu-units-attackers-external.data-source",
      presenter: "menu-units-attackers-external.presenter",
      component: "menu-units-attackers-external.component"
    },
    menuUnitsDefendersLocal: {
      name: "menuUnitsDefendersLocal",
      controller: "menu-units-defenders-local.controller",
      dataSource: "menu-units-defenders-local.data-source",
      presenter: "menu-units-defenders-local.presenter",
      component: "menu-units-defenders-local.component"
    },
    menuUnitsDefendersExternal: {
      name: "menuUnitsDefendersExternal",
      controller: "menu-units-defending-external.controller",
      dataSource: "menu-units-defending-external.data-source",
      presenter: "menu-units-defending-external.presenter",
      component: "menu-units-defending-external.component"
    },
    menuUnitsDisband: {
      name: "menuUnitsDisband",
      controller: "menu-units-disband.controller",
      dataSource: "menu-units-disband.data-source",
      presenter: "menu-units-disband.presenter",
      component: "menu-units-disband.component"
    },
    menuUnitOverview: {
      name: "menuUnitOverview",
      controller: "menu-unit-overview.controller",
      dataSource: "menu-unit-overview.data-source",
      presenter: "menu-unit-overview.presenter",
      component: "menu-unit-overview.component"
    },
    menuUnitConstruction: {
      name: "menuUnitConstruction",
      controller: "menu-unit-construction.controller",
      dataSource: "menu-unit-construction.data-source",
      presenter: "menu-unit-construction.presenter",
      component: "menu-unit-construction.component"
    },
    menuUnitsMassSendBack: {
      name: "menuUnitsMassSendBack",
      controller: "menu-units-mass-send-back.controller",
      dataSource: "menu-units-mass-send-back.data-source",
      presenter: "menu-units-mass-send-back.presenter",
      component: "menu-units-mass-send-back.component"
    },
    menuUnitChooser: {
      name: "menuUnitChooser",
      controller: "menu-unit-chooser.controller",
      dataSource: "menu-unit-chooser.data-source",
      presenter: "menu-unit-chooser.presenter",
      component: "menu-unit-chooser.component"
    },
    menuResourcesExchangeableList: {
      name: "menuResourcesExchangeableList",
      controller: "menu-resources-exchangeable-list.controller",
      dataSource: "menu-resources-exchangeable-list.data-source",
      presenter: "menu-resources-exchangeable-list.presenter",
      component: "menu-resources-exchangeable-list.component"
    },
    menuResourcesMarket: {
      name: "menuResourcesMarket",
      controller: "menu-resources-market.controller",
      dataSource: "menu-resources-market.data-source",
      presenter: "menu-resources-market.presenter",
      component: "menu-resources-market.component"
    },
    menuResourcesNobleMarket: {
      name: "menuResourcesNobleMarket",
      controller: "menu-resources-noble-market.controller",
      dataSource: "menu-resources-noble-market.data-source",
      presenter: "menu-resources-noble-market.presenter",
      component: "menu-resources-noble-market.component"
    },
    menuHabitatUpgradeConstruction: {
      name: "menuHabitatUpgradeConstruction",
      controller: "menu-habitat-upgrade-construction.controller",
      dataSource: "menu-habitat-upgrade-construction.data-source",
      presenter: "menu-habitat-upgrade-construction.presenter",
      component: "menu-habitat-upgrade-construction.component"
    },
    menuMassFunctionList: {
      name: "menuMassFunctionList",
      controller: "menu-mass-function-list.controller",
      dataSource: "menu-mass-function-list.data-source",
      presenter: "menu-mass-function-list.presenter",
      component: "menu-mass-function-list.component"
    },
    menuMassFunctionMissions: {
      name: "menuMassFunctionMissions",
      controller: "menu-mass-function-missions.controller",
      dataSource: "menu-mass-function-missions.data-source",
      presenter: "menu-mass-function-missions.presenter",
      component: "menu-mass-function-missions.component"
    },
    menuMassFunctionBuildings: {
      name: "menuMassFunctionBuildings",
      controller: "menu-mass-function-buildings.controller",
      dataSource: "menu-mass-function-buildings.data-source",
      presenter: "menu-mass-function-buildings.presenter",
      component: "menu-mass-function-buildings.component"
    },
    menuMassFunctionRecruitment: {
      name: "menuMassFunctionRecruitment",
      controller: "menu-mass-function-recruitment.controller",
      dataSource: "menu-mass-function-recruitment.data-source",
      presenter: "menu-mass-function-recruitment.presenter",
      component: "menu-mass-function-recruitment.component"
    },
    menuMassFunctionKnowledge: {
      name: "menuMassFunctionKnowledge",
      controller: "menu-mass-function-knowledge.controller",
      dataSource: "menu-mass-function-knowledge.data-source",
      presenter: "menu-mass-function-knowledge.presenter",
      component: "menu-mass-function-knowledge.component"
    },
    menuMassFunctionRestock: {
      name: "menuMassFunctionRestock",
      controller: "menu-mass-function-restock.controller",
      dataSource: "menu-mass-function-restock.data-source",
      presenter: "menu-mass-function-restock.presenter",
      component: "menu-mass-function-restock.component"
    },
    menuMassFunctionRiseBuffs: {
      name: "menuMassFunctionRiseBuffs",
      controller: "menu-mass-function-rise-buffs.controller",
      dataSource: "menu-mass-function-rise-buffs.data-source",
      presenter: "menu-mass-function-rise-buffs.presenter",
      component: "menu-mass-function-rise-buffs.component"
    },
    menuMassFunctionExchange: {
      name: "menuMassFunctionExchange",
      controller: "menu-mass-function-exchange.controller",
      dataSource: "menu-mass-function-exchange.data-source",
      presenter: "menu-mass-function-exchange.presenter",
      component: "menu-mass-function-exchange.component"
    },
    menuMassFunctionSilverMerchant: {
      name: "menuMassFunctionSilverMerchant",
      controller: "menu-mass-function-silver-merchant.controller",
      dataSource: "menu-mass-function-silver-merchant.data-source",
      presenter: "menu-mass-function-silver-merchant.presenter",
      component: "menu-mass-function-silver-merchant.component"
    },
    menuArrivalTimeFinder: {
      name: "menuArrivalTimeFinder",
      controller: "menu-arrival-time-finder.controller",
      dataSource: "menu-arrival-time-finder.data-source",
      presenter: "menu-arrival-time-finder.presenter",
      component: "menu-arrival-time-finder.component"
    },
    menuArrivalTimeSettings: {
      name: "menuArrivalTimeSettings",
      controller: "menu-arrival-time-settings.controller",
      dataSource: "menu-arrival-time-settings.data-source",
      presenter: "menu-arrival-time-settings.presenter",
      component: "menu-arrival-time-settings.component"
    },
    menuSupportBridge: {
      name: "menuSupportBridge",
      controller: "menu-support-bridge.controller",
      dataSource: "menu-support-bridge.data-source",
      presenter: "menu-support-bridge.presenter",
      component: "menu-support-bridge.component"
    },
    menuSupportBridgeSettings: {
      name: "menuSupportBridgeSettings",
      controller: "menu-support-bridge-settings.controller",
      dataSource: "menu-support-bridge-settings.data-source",
      presenter: "menu-support-bridge-settings.presenter",
      component: "menu-support-bridge-settings.component"
    },
    menuExternalIFrameInjection: {
      name: "menuExternalIFrameInjection",
      controller: "menu-external-i-frame-injection.controller",
      dataSource: "menu-external-i-frame-injection.data-source",
      presenter: "menu-external-i-frame-injection.presenter",
      component: "menu-external-i-frame-injection.component"
    },
    menuGameSettings: {
      name: "menuGameSettings",
      controller: "menu-game-settings.controller",
      dataSource: "menu-game-settings.data-source",
      presenter: "menu-game-settings.presenter",
      component: "menu-game-settings.component"
    },
    menuGameSettingsMusic: {
      name: "menuGameSettingsMusic",
      controller: "menu-game-settings-music.controller",
      dataSource: "menu-game-settings-music.data-source",
      presenter: "menu-game-settings-music.presenter",
      component: "menu-game-settings-music.component"
    },
    popUpTutorial: {
      name: "popUpTutorial",
      controller: "pop-up-tutorial.controller",
      dataSource: "pop-up-tutorial.data-source",
      presenter: "pop-up-tutorial.presenter",
      component: "pop-up-tutorial.component",
      componentCover: "pop-up-tutorial.component-cover"
    },
    popUpEvent: {
      name: "popUpEvent",
      controller: "pop-up-event.controller",
      dataSource: "pop-up-event.data-source",
      presenter: "pop-up-event.presenter",
      component: "pop-up-event.component"
    }
  }
}, xy.eNames = {
  core: {
    isPendingModeOn: "core.is-pending-mode-on",
    pendingModeOn: "core.pending-mode-on",
    pendingModeOff: "core.pending-mode-off",
    networkHardRequestFail: "core.network-hard-request-fail",
    networkSoftRequestFail: "core.network-soft-request-fail",
    isCurrentWorld: "core.is-current-world",
    displayModelLink: "core.display-model-link",
    clearModelLink: "core.clear-model-link",
    onTimerEnd: "core.on-timer-end"
  },
  eventSceneLogin: {
    formSubmit: "scene-login.form-submit",
    successLogin: "scene-login.success-login",
    failLogin: "scene-login.fail-login",
    changeLanguage: "scene-login.change-language"
  },
  sceneChooseWorld: {
    drawWithWorldsListData: "choose-world-scene.draw-with-worlds-list-data",
    onTimersUpdate: "choose-world-scene.on-timers-update",
    onWorldIsChosen: "choose-world-scene.on-world-is-chosen",
    onNewWorldIsChosen: "choose-world-scene.on-new-world-is-chosen"
  },
  sceneNewPlayerInWorld: {
    dataIsReady: "scene-new-player-in-world.data-is-ready",
    onNickSubmit: "scene-new-player-in-world.on-nick-submit",
    onSuccessCreating: "scene-new-player-in-world.on-success-creating",
    onCancelCreating: "scene-new-player-in-world.on-cancel-creating"
  },
  sceneGame: {
    onWorldIsConnected: "scene-game.on-world-is-connected",
    onOpenClickBarButton: "scene-game.on-open-click-bar-button",
    onCloseClickBarButton: "scene-game.on-close-click-bar-button",
    onHabitatChooserArrowClick: "scene-game.on-habitat-chooser-arrow-click",
    onSwitchWorldEvent: "scene-game.on-switch-world-event",
    onLogoutEvent: "scene-game.on-logout-event",
    openHabitatOverview: "scene-game.open-habitat-overview",
    requireSessionUpdate: "scene-game.require-session-update",
    openBuildingOverview: "scene-game.open-building-overview",
    onNewSceneChoosing: "scene-game.on-new-scene-choosing",
    cacheCenterMapCoordinates: "scene-game.cache-center-map-coordinates",
    centerMapByCurrentHabitatCoordinates: "scene-game.center-map-by-current-habitat-coordinates",
    centerMapByCoordinates: "scene-game.center-map-by-coordinates",
    updateMap: "scene-game.update-map",
    onKeyboardMoveMap: "scene-game.on-keyboard-move-map",
    onKeyboardSetSceneMode: "scene-game.on-keyboard-set-scene-mode",
    onCanvasDrawn: "scene-game.on-canvas-drawn",
    needMoreGold: "scene-game.need-more.gold",
    goToWebShop: "scene-game.go-to-webshop",
    onPickHabitatFromHabitatList: "scene-game.on-pick-habitat-from-habitat-list",
    requestBuildingObjectToHighlight: "scene-game.request-building-object-to-highlight"
  },
  sceneHabitat: {
    dataIsReady: "scene-habitat.on-data-is-ready",
    onClickOnHabitat: "scene-habitat.on-click-on-habitat"
  },
  sceneMapGame: {
    moveMapCenterToCoordinates: "scene-map.move-map-center-to-coordinates",
    onMapDataIsPrepared: "scene-map.on-map-data-is-prepared",
    onClickOnMap: "scene-map.on-click-on-map",
    onMapBoarderReached: "scene-map-game.on-map-boarder-reached",
    onKeyboardMoveMap: "scene-map-game.on-keyboard-move-map"
  },
  sceneMapPolitical: {
    moveMapCenterToCoordinates: "scene-map-political.move-map-center-to-coordinates",
    onMapDataIsPrepared: "scene-map-political.on-map-data-is-prepared",
    onClickOnMap: "scene-map-political.on-click-on-map",
    onMapBoarderReached: "scene-map-political.on-map-boarder-reached",
    onKeyboardMoveMap: "scene-map-political.on-keyboard-move-map"
  },
  eventSceneGlobalOverview: {
    globalOverviewIsDrawn: "event-scene-global-overview.is-drawn",
    releasePendingMode: "event-scene-global-overview.release-pending-mode"
  },
  eventSceneGlobalUnitOverview: {
    tableIsLoaded: "event-scene-global-unit-overview.table-is-loaded",
    dataIsReady: "event-scene-global-unit-overview.data-is-ready",
    switchCurrentTab: "event-scene-global-unit-overview.switch-current-tub",
    switchGroupingDirection: "event-scene-global-unit-overview.switch-grouping-direction",
    sendForeignerDefendersBack: "event-scene-global-unit-overview.send-foreigner-defenders-back",
    callAttackersBack: "event-scene-global-unit-overview.call-attackers-back"
  },
  eventSceneGlobalBuildingOverview: {
    tableIsLoaded: "event-scene-global-building-overview.table-is-loaded",
    dataIsReady: "event-scene-global-building-overview.data-is-ready",
    switchCurrentMode: "event-scene-global-building-overview.switch-current-mode"
  },
  eventSceneGlobalRecruitmentOverview: {
    tableIsLoaded: "event-scene-global-building-overview.table-is-loaded",
    dataIsReady: "event-scene-global-recruitment-overview.data-is-ready",
    switchCurrentMode: "event-scene-global-recruitment-overview.switch-current-mode"
  },
  menu: {
    openNextView: "menu.open-next-view",
    openPrevView: "menu.open-prev-view",
    closeViewUpToRoot: "menu.close-view-up-to-root",
    closeViewUpToSelf: "menu.close-view-up-to-self",
    updateOnRoot: "menu.update-on-root",
    onDataExpired: "menu.on-data-expired",
    onDataError: "menu.on-error",
    onTimerEnd: "menu.on-timer-end",
    onRefreshCall: "menu.on-refresh-call"
  },
  menuMessages: {
    dataIsReady: "menu-message.data-is-ready",
    deleteMessages: "menu-message.delete-messages",
    deleteAllMessages: "menu-message.delete-all-messages"
  },
  menuMessagesNew: {
    dataIsReady: "menu-message-new.data-is-ready",
    onMessageSubmit: "menu-message.on-message-submit",
    sent: "menu-message-new.sent"
  },
  menuMessagesRecipientsList: {
    dataIsReady: "menu-message-recipients-list.data-is-ready",
    addRecipients: "menu-message-recipients-list.add-recipients",
    onAddedRecipients: "menu-message-recipient-list.on-added-recipient"
  },
  menuMessagesThread: {
    dataIsReady: "menu-message-thread.data-is-ready",
    deleteMessage: "menu-message-thread.delete-message",
    sendMessage: "menu-message-thread.send-message",
    deleteRecipients: "menu-message-thread.delete-recipients",
    deleteAllRecipients: "menu-message-thread.delete-all-recipients",
    addRecipients: "menu-message-thread.add-recipients",
    onRecipientWereManaged: "menu-message-thread.on-recipients-were-managed"
  },
  menuReports: {
    dataIsAvailable: "menu-reports.data-is-available",
    deleteReports: "menu-reports.delete-reports",
    deleteAllReports: "menu-reports.delete-all-reports",
    setCurrentReportGroup: "menu-reports.set-current-report-group"
  },
  eventsMenuReportsOverview: {
    deleteReportsOverview: "events-menu-reports-overview.delete-reports",
    copyReportLink: "events-menu-reports-overview.copy-report-link",
    publishReport: "events-menu-reports-overview.publish-report",
    publishReportClick: "events-menu-reports-overview.publish-report-click",
    unPublishReportClick: "events-menu-reports-overview.un-publish-report-click",
    switchReport: "events-menu-reports-overview.switch-report"
  },
  menuReportsSettings: {
    saveReportsSettings: "menu-reports-settings.save-reports-settings",
    onSavedSettings: "menu-reports-settings.on-saved-settings"
  },
  menuForum: {
    dataIsAvailable: "menu-forum.data-is-available",
    dataIsReady: "menu-forum.data-is-ready",
    deleteThreads: "menu-forum.delete-threads",
    deleteAllThreads: "menu-forum.delete-all-threads",
    onThreadCreated: "menu-forum.on-thread-created"
  },
  menuForumThread: {
    dataIsAvailable: "menu-forum-thread.data-is-available",
    deleteThread: "menu-forum-thread.delete-reports",
    deleteForumMessages: "menu-forum-thread.delete-forum-messages",
    changeThreadStatus: "menu-forum-thread.change-thread-status"
  },
  menuPlayerProfile: {
    dataIsReady: "menu-player-profile.data-is-ready",
    errorOnRenaming: "menu-player-profile.error-on-renaming",
    updateNickName: "menu-player-profile.update-nick-name",
    onStartVacationClick: "menu-player-profile.on-start-vacation-click",
    onProtectionShieldClick: "menu-player-profile.on-protection-shield-click"
  },
  menuRank: {
    dataIsReady: "menu-rank.data-is-ready",
    setNewRankType: "menu-rank.set-new-rank-type",
    changeRankingPage: "menu-rank.change-ranking-page",
    runSearch: "menu-rank.run-search"
  },
  menuRankModeChooser: { dataIsReady: "menu-rank-mode-chooser.data-is-ready" },
  menuSearch: { dataIsReady: "menu-search.data-is-ready", runSearch: "menu-search.run-search" },
  menuPlayerProfileExternal: {
    dataIsReady: "menu-player-profile-external.data-is-ready",
    sendInvitationToPlayer: "menu-player-profile-external.send-invitation-to-player",
    cancelInvitationToPlayer: "menu-player-profile-external.cancel-invitation-to-player",
    dismissPlayer: "menu-player-profile-external.dismiss-player",
    acceptApplicant: "menu-player-profile-external.accept-applicant-player",
    rejectApplicant: "menu-player-profile-external.reject-applicant-player",
    onApplicationStatusChanged: "menu-player-profile-external.on-application-status-changed",
    changeSortingDirection: "menu-player-profile-external.changeSortingDirection"
  },
  menuPlayersList: {
    dataIsReady: "menu-player-list.data-is-ready",
    setSortingFunction: "menu-player-list.set-sorting-function"
  },
  menuAllianceProfile: {
    dataIsAvailable: "menu-alliance-profile-external.data-is-available",
    updateNickName: "menu-alliance-profile-external.update-nick-name",
    acceptAllianceSharing: "menu-alliance-profile-external.accept-alliance-sharing",
    deleteAllianceSharing: "menu-alliance-profile-external.delete-alliance-sharing",
    applyToAlliance: "menu-alliance-profile-external.apply-to-alliance",
    revokeApplicationToAlliance: "menu-alliance-profile-external.revoke-application-to-alliance"
  },
  menuAllianceDescription: {
    updateDescription: "menu-alliance-description.update-description",
    onUpdatedDescription: "menu-alliance-description.on-updated-description"
  },
  menuAllianceManagement: {
    createNewAlliance: "menu-alliance-management.create-new-alliance",
    acceptAllianceInvitation: "menu-alliance-management.accept-alliance-invitation",
    rejectAllianceInvitation: "menu-alliance-management.reject-alliance-invitation",
    leaveAlliance: "menu-alliance-management.leave-alliance",
    disbandAlliance: "menu-alliance-management.disband-alliance"
  },
  menuAllianceRightsSettings: {
    saveRightsSettings: "menu-reports-settings.save-rights-settings",
    onPermissionSet: "menu-reports-settings.on-permission-set"
  },
  menuAllianceFeed: { dataIsAvailable: "menu-alliance-feed.data-is-available" },
  menuAllianceFeedSettings: {
    dataIsReady: "menu-alliance-feed-settings.data-is-available",
    onSavedSettings: "menu-alliance-feed-settings.on-saved-settings",
    saveReportsSettings: "menu-alliance-feed-settings.save-reports-settings"
  },
  menuAllianceInvitations: { changeCurrentMode: "menu-alliance-invitations.change-current-mode" },
  menuAllianceClashes: {
    dataIsAvailable: "menu-alliance-clashes.data-is-available",
    changeCurrentMode: "menu-alliance-clashes.change-current-mode"
  },
  menuAllianceDiplomacy: {
    dataIsAvailable: "menu-alliance-diplomacy.data-is-available",
    deleteReports: "menu-alliance-diplomacy.delete-reports",
    setCurrentReportGroup: "menu-alliance-diplomacy.set-current-report-group"
  },
  menuAllianceDiplomacySettings: {
    saveNewDiplomacy: "menu-alliance-diplomacy-settings.save-new-diplomacy",
    onSavedDiplomacy: "menu-alliance-diplomacy-settings.on-saved-diplomacy"
  },
  menuAllianceHabitatReservation: {
    setGroupingMode: "menu-alliance-habitat-reservation.set-grouping-mode",
    deleteReservation: "menu-alliance-habitat-reservation.delete-reservation",
    deleteAllReservations: "menu-alliance-habitat-reservation.delete-all-reservations",
    acceptReservation: "menu-alliance-habitat-reservation.accept-reservation",
    rejectReservation: "menu-alliance-habitat-reservation.reject-reservation"
  },
  menuAllianceHabitatReservationOverview: {
    dataIsReady: "menu-alliance-habitat-reservation-overview.data-is-ready",
    acceptReservation: "menu-alliance-habitat-reservation-overview.accept-reservation",
    rejectReservation: "menu-alliance-habitat-reservation-overview.reject-reservation",
    deleteReservation: "menu-alliance-habitat-reservation-overview.delete-reservation",
    withdrawReservation: "menu-alliance-habitat-reservation-overview.withdraw-reservation"
  },
  menuAllianceHabitatReservationSettings: {
    saveSettings: "menu-alliance-habitat-reservation-settings.save-settings",
    onSavedSettings: "menu-alliance-habitat-reservation-settings.on-saved-settings"
  },
  menuAllianceSharing: { shareWithAlliance: "menu-alliance-sharing.share-with-alliance" },
  menuBuildingsChooser: {
    dataIsReady: "menu-buildings-list.data-is-ready",
    onTabSwitch: "menu-buildings-list.on-tab-switch"
  },
  menuBuildingsList: {
    dataIsReady: "menu-buildings-list.data-is-ready",
    speedUpUpgrade: "menu-buildings-list.speed-up-upgrade",
    completeAllUpgrades: "menu-buildings-list.complete-all-upgrades",
    upgradeBuilding: "menu-buildings-list.upgrade-building"
  },
  menuBuildingOverview: {
    dataIsReady: "menu-building-overview.data-is-ready",
    refillStock: "menu-building-overview.refill-stock",
    riseBuff: "menu-building-overview.rise-buff",
    researchStart: "menu-building-overview.research-start",
    researchSpeedUp: "menu-building-overview.research-speed-up",
    missionStart: "menu-building-overview.mission-start",
    multiMissionStart: "menu-building-overview.multi-mission-start",
    missionSpeedUp: "menu-building-overview.mission-speed-up",
    missionCancel: "menu-building-overview.mission-cancel",
    unitRecruitmentStart: "menu-building-overview.unit-recruitment-start",
    changeNameForHabitat: "menu-building-overview.change-name-for-habitat"
  },
  menuBuildingUpgrades: { dataIsReady: "menuBuildingUpgrades.data-is-ready" },
  menuHabitatsList: {
    dataIsReady: "menu-habitats-list.data-is-ready",
    onResortHabitat: "menu-habitats-list.on-resort-habitat",
    onChangeSortingDirection: "menu-habitats-list.on-change-sorting-direction"
  },
  menuHabitatOverview: {
    dataIsReady: "menu-habitat-overview.data-is-ready",
    setHabitatActive: "menu-habitat-overview.set-habitat-as-current",
    switchHighlightForHabitat: "menu-habitat-overview.switch-highlight-for-habitat",
    reserveHabitat: "menu-habitat-overview.reserve-habitat",
    withdrawReservation: "menu-habitat-overview.withdraw-reservation",
    doMovementWithLastFormation: "menu-habitat-overview.do-movement-with-last-formation",
    annexHabitat: "menu-habitat-overview.annex-habitat",
    relocateHabitat: "menu-habitat-overview.relocate-habitat"
  },
  eventHabitatTransitListOverview: { dataIsReady: "event-habitat-transit-list-overview.data-is-ready" },
  menuHabitatSortingChooser: {
    dataIsReady: "menu-habitat-sorting-chooser.data-is-ready",
    setNewSorting: "menu-habitat-sorting-chooser.set-new-sorting",
    sortingSetHandler: "menu-habitat-sorting-chooser.sorting-set-handler"
  },
  menuHabitatSendUnitsResources: {
    dataIsReady: "menu-habitat-send-units-resources.data-is-ready",
    startAttack: "menu-habitat-send-units-resources.start-attack",
    sendSupport: "menu-habitat-send-units-resources.send-support",
    sendResources: "menu-habitat-send-units-resources.send-resources",
    synchronizeAttack: "menu-habitat-send-units-resources.synchronize-attack",
    synchronizeSupport: "menu-habitat-send-units-resources.synchronize-support"
  },
  menuHabitatSendSpy: { dataIsReady: "menu-habitat-send-spy.data-is-ready", sendSpy: "menu-habitat-send-spy.send-spy" },
  menuTransitOverview: {
    dataIsReady: "menu-transit-overview.data-is-ready",
    publishInAllianceClash: "menu-transit-overview.publish-in-alliance-clash",
    callForHelpInAlliance: "menu-transit-overview.call-for-help-in-alliance",
    speedUpTransit: "menu-transit-overview.speed-up-transit"
  },
  menuUnitChooser: {
    dataIsReady: "menu-unit-chooser-habitat-sorting.data-is-ready",
    onUnitChoose: "menu-unit-chooser-habitat-sorting.on-unit-choose"
  },
  menuUnitList: { dataIsReady: "menu-unit-list.data-is-ready" },
  menuUnitDisband: { dataIsReady: "menu-unit-disband.data-is-ready", disbandUnits: "menu-unit-disband.disband-units" },
  menuUnitConstruction: {
    construct: "menu-unit-construction.construct",
    speedUpRecruitment: "menu-unit-construction.speed-up-recruitment",
    completeAllRecruitment: "menu-unit-construction.complete-all-recruitment"
  },
  menuUnitsMassSendBack: {
    dataIsReady: "menu-units-mass-send-back.data-is-ready",
    sendAllUnitsBack: "menu-units-mass-send-back.send-all-units-back",
    onSendAllUnitsBack: "menu-units-mass-send-back.on-send-all-units-back"
  },
  menuUnitDefenderLocal: {
    dataIsReady: "menu-unit-defenders-local.data-is-ready",
    sendUnitsBack: "menu-unit-defenders-local.send-units-back"
  },
  menuUnitAttackersLocal: {
    dataIsReady: "menu-unit-attacker-local.data-is-ready",
    publishInAllianceClash: "menu-unit-attacker-local.publish-in-alliance-clash"
  },
  menuUnitDefendersExternal: {
    dataIsReady: "menu-unit-defenders-external.data-is-ready",
    recallUnits: "menu-unit-defenders-external.recall-units"
  },
  menuUnitAttackersExternal: {
    dataIsReady: "menu-unit-attackers-external.data-is-ready",
    recallUnits: "menu-unit-attackers-external.recall-units",
    publishInAllianceClash: "menu-unit-attackers-external.publish-in-alliance-clash"
  },
  menuResourcesMarket: { tradeResource: "menu-resources-market.trade-resource" },
  menuResourcesNobleMarket: {
    dataIsReady: "menu-resources-noble-market.data-is-ready",
    tradeResource: "menu-resources-noble-market.trade-resource"
  },
  menuHabitatUpgradeConstruction: {
    dataIsReady: "menu-habitat-upgrade-construction.data-is-ready",
    buildHabitatUpgradeCenter: "menu-habitat-upgrade-construction.build-fortress-center",
    buildHabitatUpgrade: "menu-habitat-upgrade-construction.build-fortress",
    linkToHabitatCenter: "menu-habitat-upgrade-construction.link-to-habitat-center",
    upgradeProgressSpeedUp: "menu-habitat-upgrade-construction.upgrade-progress-speed-up",
    cancelExpand: "menu-habitat-upgrade-construction.cancel-expand"
  },
  menuKnowledgeChooser: {
    dataIsReady: "menu-knowledge-list.data-is-ready",
    onTabSwitch: "menu-knowledge-list.on-tab-switch"
  },
  menuArrivalTimeFinder: {
    dataIsReady: "menu-arrival-time-finder.data-is-ready",
    onTabSwitch: "menu-arrival-time-finder.on-tab-switch",
    setMode: "menu-arrival-time-finder.set-mode",
    setUnitPK: "menu-arrival-time-finder.set-unit-primary-key",
    setActionKey: "menu-arrival-time-finder.set-action-key",
    getUnitPK: "menu-arrival-time-finder.get-unit-primary-key",
    getActionKey: "menu-arrival-time-finder.get-action-key",
    setTransportTime: "menu-arrival-time-finder.set-transport-time",
    setArrivalDate: "menu-arrival-time-finder.set-arrival-date",
    setCurrentHabitat: "menu-arrival-time-finder.set-current-habitat"
  },
  menuArrivalTimeSettings: {
    dataIsReady: "menu-arrival-time-settings.data-is-ready",
    onActionChoose: "menu-arrival-time-settings.on-action-choose",
    onUnitChoose: "menu-arrival-time-settings.on-unit-choose"
  },
  menuMassFunctionRestock: {
    dataIsReady: "menu-mass-function-restock.data-is-ready",
    fillUp: "menu-mass-function-restock.fill-up"
  },
  eventMassFunctionSilverMerchant: {
    dataIsReady: "event-mass-function-silver-merchant.data-is-ready",
    activate: "event-mass-function-silver-merchant.activated",
    setTime: "event-mass-function-silver-merchant.set-time",
    saveSelection: "event-mass-function-silver-merchant.save-selection",
    showSystemPopUp: "event-mass-function-silver-merchant.show-system-pop-up",
    showAdvicePopUp1: "event-mass-function-silver-merchant.show-advice-pop-up-one",
    showAdvicePopUp2: "event-mass-function-silver-merchant.show-advice-pop-up-two"
  },
  eventGameSettingsMusic: { changeMusicSettingsObject: "event-game-settings-music.change-music-object" },
  menuMassFunctionRiseBuffs: {
    dataIsReady: "menu-mass-function-rise-buffs.data-is-ready",
    riseUp: "menu-mass-function-rise-buffs.rise-up"
  },
  menuMassFunctionExchange: {
    dataIsReady: "menu-mass-function-exchange.data-is-ready",
    barter: "menu-mass-function-exchange.barter"
  },
  menuMassFunctionMissions: {
    dataIsReady: "menu-mass-function-missions.data-is-ready",
    runMissions: "menu-mass-function-missions.runMissions",
    speedUpAllMissions: "menu-mass-function-missions.speedUpAllMissions",
    cancelAllMissions: "menu-mass-function-missions.cancelAllMissions"
  },
  menuMassFunctionBuildings: {
    dataIsReady: "menu-mass-function-buildings.data-is-ready",
    runConstructions: "menu-mass-function-buildings.run-construction",
    reduceTimeAllBuildingConstructions: "menu-mass-function-buildings.reduce-time-all-building-construction"
  },
  menuMassFunctionRecruitment: {
    dataIsReady: "menu-mass-function-recruitment.data-is-ready",
    runRecruitment: "menu-mass-function-recruitment.runRecruitment",
    reduceTimeAllUnitsConstructions: "menu-mass-function-recruitment.reduce-time-all-units-construction",
    onTabSwitch: "menu-mass-function-recruitment.on-tab-switch"
  },
  menuMassFunctionKnowledge: {
    dataIsReady: "menu-mass-function-knowledge.data-is-ready",
    conductResearch: "menu-mass-function-recruitment.conduct-research",
    reduceTimeAllResearches: "menu-mass-function-recruitment.reduce-time-all-researches"
  },
  menuSupportBridge: {
    dataIsReady: "menu-support-bridge.data-is-ready",
    publish: "menu-support-bridge.publish",
    unPublish: "menu-support-bridge.un-publish",
    shareClash: "menu-support-bridge.share-clash",
    calculateTransits: "menu-support-bridge.calculate-transits",
    saveChanges: "menu-support-bridge.save-changes"
  },
  menuSupportBridgeSettings: {
    saveSupportBridgeSettings: "menu-support-bridge-settings.data-is-ready",
    onSavedSupportBridgeSettings: "menu-support-bridge-settings.publish"
  },
  menuEvent: { dataIsReady: "menu-event.data-is-ready", onSetRewardedHabitat: "menu-event.on-set-rewarded-habitat" },
  eventPopUpTutorial: {
    dataIsReady: "event-pop-up-tutorial.data-is-ready",
    onCanceled: "event-pop-up-tutorial.on-canceled",
    showCover: "event-pop-up-tutorial.showCover",
    onDataError: "event-pop-up-tutorial.data-error",
    acceptTutorialRewards: "event-pop-up-tutorial.accept-tutorial-rewards",
    acceptTutorialStep: "event-pop-up-tutorial.accept-tutorial-step",
    declineTutorialStep: "event-pop-up-tutorial.decline-tutorial-step"
  },
  popUpEvent: {
    popUp: "pop-up-event.pop-up",
    onClickButton: "pop-up-event.on-click-button",
    onDestroy: "pop-up-event.destroy",
    actions: { skip: 10001, dismiss: 10002, openLink: 10003, start: 10004, accept: 10005 }
  },
  eventListeners: {
    delayedIdentifiers: {
      "building--upgrade--call-completed": !0,
      "building--speedup--call-completed": !0,
      "building--finish--call-completed": !0
    },
    identifier: {
      tutorialButtonOkClick: "tutorial-button-ok-click",
      menuCloseButtonClick: "menu-close-button-click",
      menuBackButtonClick: "menu-back-button-click",
      menuHabitatOverviewFreeHabitatOpened: "menu-habitat-overview--free-habitat--opened",
      menuAttackHabitatOpened: "menu-attack-habitat--opened",
      rangeSliderIncreaseButtonClick: "range-slider-increase-value--button-click",
      rangeSliderSetValue: "range-slider-set-value",
      rangeSliderAcceptButtonClick: "range-slider--accept-value--button-click",
      habitatSceneClickOnBuilding: "habitat-scene--click-on-building",
      transitAttackTransitStarted: "transit--attack-transit--started",
      buildingUpgradeCallCompleted: "building--upgrade--call-completed",
      buildingSpeedUpCallCompleted: "building--speedup--call-completed",
      buildingFinishCallCompleted: "building--finish--call-completed",
      sceneSwitchToGlobalOverviewsScene: "scene--switch-to-global-overviews-scene",
      sceneSwitchToHabitatScene: "scene--switch-to-habitat-scene",
      sceneSwitchToMapGameScene: "scene--switch-to-map-game-scene",
      sceneSwitchToMapPoliticalScene: "scene--switch-to-map-political-scene",
      changesInMusicSettingsObject: "game-settings.changes-in-music-object"
    },
    googleAnalyticsIdentifiers: {
      worldIndexViewed: "scene-choose-world--world-index-viewed",
      worldChosen: "scene-new-player-in-world--world-chosen",
      fillFormNickname: "scene-new-player-in-world--fill-form-nickname",
      nicknameChosen: "scene-new-player-in-world--nickname-chosen"
    },
    matAnalyticsIdentifiers: {
      thirteenPointsEarned: "thirteen-points-earned",
      twentyPointsEarned: "twenty-points-earned"
    }
  },
  dataListeners: {
    dataEntity: {
      gameData: "data-listeners.game-data",
      messages: "data-listeners.messages",
      habitat: "data-listeners.habitat",
      habitatReservation: "data-listeners.habitat-reservation",
      resources: "data-listeners.resources",
      bottomBar: "data-listeners.bottom-bar",
      player: "data-listeners.player",
      alliance: "data-listeners.alliance",
      allianceClashes: "data-listeners.alliance-clashes",
      report: "data-listeners.report",
      allianceReport: "data-listeners.alliance-report",
      forum: "data-listeners.forum",
      rank: "data-listeners.rank",
      transitsCache: "data-listeners-transits-cache"
    },
    dataIdentifiers: {
      updated: "data-identifiers-updated",
      flushed: "data-identifiers-flushed",
      received: "data-identifiers.received",
      habitatsSorted: "data-identifier.habitat-sorted",
      sessionUpdate: "data-identifier.session-update",
      startTutorialEvent: "data-identifier.game-events.start-tutorial-event",
      newPendingEvent: "data-identifier.game-events.new-pending-event",
      setRewardedHabitatAction: "data-identifier.set-rewarded-habitat-action",
      setCurrentHabitat: "data-identifier.set-current-habitat",
      setExtraResources: "data-identifier.top-bar-extra-resources",
      setInitialHabitatAction: "data-identifier.set-initial-habitat-action",
      changesInHighlighting: "data-identifier.change-in-highlighting",
      lostAllHabitats: "data-identifier.lost-all-habitats"
    }
  }
}, xy.DomElements = {
  gameCanvasContainer: "canvas-wrapper",
  gameCanvas: "game-canvas",
  gameFrame: "game-frame",
  gameMenuRoot: "menu-section-general-container",
  gameMenuDrillDown: "menu-section-drill-container",
  gameGlobalOverview: "game-global-overview",
  gameBarTop: "game-bar-top",
  gameBarTopContainerClass: "bar-top--content",
  gameBarBottom: "game-bar-bottom",
  gameBarBottomContainerClass: "bar-bottom--content",
  gameBarToggle: "game-bar-toggle",
  gameOverLayer: "game-over-layer",
  gameTutorialOverLayerContainer: "game-tutorial-over-layer-container",
  gameTutorialOverLayer: "game-layer--tutorial-cover",
  gamePopUpLayer: "game-pop-up-layer",
  gameDialogLayer: "game-dialog-layer"
}, xy.dStaticInjector.set(xy.dNames.settings.gameConstant, {
  REQUEST_MODE: { POST: "POST", GET: "GET" },
  CLIENT_COMMAND_ACTION: {
    showDialog: 1,
    callCallbackAndUpdateSession: 3,
    updateSession: 2,
    noSession: 5,
    logout: 4,
    clearCache: 8
  },
  LOCALIZATION_TYPE: { MAIN: 1, EVENT: 2 },
  DEFAULT_LANGUAGE: "en",
  AVAILABLE_LANGUAGES: {
    ar: { name: "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", flag: "SA" },
    da: { name: "Dansk", flag: "" },
    de: { name: "Deutsch", flag: "DE" },
    el: { name: "Î•Î»Î»Î·Î½Î¹ÎºÎ¬", flag: "GR" },
    en: { name: "English", flag: "UK" },
    es: { name: "EspaÃ±ol", flag: "ES" },
    fa: { name: "Farsi", flag: "" },
    fr: { name: "FranÃ§ais", flag: "FR" },
    id: { name: "Indonesian", flag: "ID" },
    it: { name: "Italiano", flag: "IT" },
    ja: { name: "æ—¥æœ¬èªž", flag: "JP" },
    ko: { name: "í•œêµ­ì–´", flag: "KR" },
    ms: { name: "Malay", flag: "" },
    nl: { name: "Dutch", flag: "NL" },
    pl: { name: "Polski", flag: "PL" },
    pt: { name: "PortuguÃªs", flag: "PT" },
    ru: { name: "Ð ÑƒÑÑÐºÐ¸Ð¹", flag: "RU" },
    sv: { name: "Svenska", flag: "SE" },
    th: { name: "à¹„à¸—à¸¢", flag: "TH" },
    tr: { name: "TÃ¼rkÃ§e", flag: "TR" },
    vi: { name: "Tiáº¿ng Viá»‡t", flag: "VN" },
    "zh-cn": { name: "ä¸­æ–‡", flag: "CN" },
    "zh-trad": { name: "æ­£é«”å­—", flag: "HK" }
  },
  QUERY_PARAM_NAMES: { LOGIN: "n", PASSWORD: "hsp", WORD_ID: "w", FACEBOOK_TOKEN: "fat", GOOGLE_TOKEN: "gat" },
  WORLD_STATUS: { ONLINE: 3 },
  SCENE_MODE: {
    HABITAT: 1,
    MAP: 2,
    POLITICAL_MAP: 3,
    GLOBAL_UNIT_OVERVIEW: 4,
    GLOBAL_BUILDING_OVERVIEW: 5,
    GLOBAL_RECRUITMENT_OVERVIEW: 6
  },
  GLOBAL_OVERVIEW_MODE: { UNITS: 1, BUILDING: 2, RECRUITMENT: 3 },
  GLOBAL_UNIT_OVERVIEW_MODE: {
    LOCAL_DEFENDERS: 1,
    EXTERNAL_DEFENDERS: 2,
    IN_TRANSIT: 3,
    ON_MISSION: 4,
    MY_TROOPS_IN_ATTACK: 5,
    OFFENDERS: 6
  },
  GROUPING_DIRECTION_MODE: { IN_TARGET: 1, OUT_TARGET: 2 },
  HABITAT_RESERVATION_GROUPING_MODE: { DATE: 0, PLAYER: 1, OWN: 2 },
  HABITAT_RESERVATION_GROUPING_NAME: { 0: "Date", 1: "PlayerSegmentTitle", 2: "Own" },
  HABITAT_RESERVATION_STATUS: { REQUESTED: 0, ACCEPTED: 1, REJECTED: 2 },
  HABITAT_RESERVATION_SETTINGS: { MIN_RESERVATION_AMOUNT: 1 },
  HABITAT_TYPE: { CITY: 4, CITY_CENTER: 3, FORTRESS: 2, FORTRESS_CENTER: 1, CASTLE: 0 },
  HABITAT_UPGRADE_TYPE: {
    FORTRESS_CENTER: 1,
    FORTRESS_EXPANSION: 2,
    FORTRESS: 3,
    CITY_CENTER: 11,
    CITY_EXPANSION: 12,
    CITY: 13
  },
  HABITAT_UPGRADE_MODE: { FORTRESS: "fortress", CITY: "city" },
  UPGRADE_DURATION_THRESHOLD: .5,
  CACHE_LIFE_TIME: 6e6,
  DATE_CLIENT_DELAY: 3e3,
  COVER_DELAY: 500,
  COUNTDOWN_TIMER: 1e3,
  EVENT_DEADLINE_UPDATE_INTERVAL: 1e3,
  EVENT_RE_HANDLE_LIMIT: 7,
  NEXT_DIALOG_SCHEDULE_INTERVAL: 200,
  SESSION_UPDATE_SCHEDULE_MIN_DELAY_SECONDS: 20,
  SESSION_UPDATE_SCHEDULE_INTERVAL: 3e4,
  SESSION_UPDATE_SCHEDULE_STATUS: { UPDATE: 1, CONTINUE: 2, STOP_TIMER: 3 },
  SET_CURRENT_HABITAT_EVENT: { NEXT: "right", PREV: "left" },
  BATTLE_TYPE: { OWN_HABITAT: 0, EXTERNAL_UNITS_TO_DEFENSE: 1, ATTACKER: 2 },
  SORTING_HABITAT_FUNCTION: {
    ALPHABET: "Alphabetical",
    POINTS: "Points",
    CONQUER_RESOURCE: "ConquerResource",
    UNITS: "Units",
    DISTANCE: "Distance",
    UNDER_ATTACK: "Attacks"
  },
  SORTING_HABITAT_DIRECTION: { 0: "Sort ascending", 1: "Sort descending" },
  SORTING_HABITAT_CHOOSER_MODE: { EXTERNAL_PLAYER: 1 },
  SORTING_HABITAT_CHOOSER_LIST: { 1: ["Distance", "Alphabetical", "Points"] },
  SORTING_HABITAT_BY_UNIT_KEYS: { ALL_UNITS: -100, FARMERS: -200 },
  SORTING_PLAYERS_FUNCTION: { POINTS: "Points", ALPHABET: "A to Z", RIGHTS: "Permission" },
  SORTING_PLAYERS_FUNCTION_ORDER: ["POINTS", "ALPHABET", "RIGHTS"],
  ALLIANCE_MANAGEMENT_MODE: { NO_ALLIANCE: 0, IN_ALLIANCE: 1 },
  ALLIANCE_PERMISSION: {
    ALL: -1,
    INVITE_PLAYER: 1,
    DISMISS_PLAYER: 2,
    MODERATE_FORUM: 4,
    MASS_MAIL: 8,
    DIPLOMATIC_RELATIONS: 16,
    PLAYER_PERMISSIONS: 32,
    DISBAND_ALLIANCE: 64,
    MAX: 127
  },
  ALLIANCE_RELATIONSHIPS: {
    VASSAL: 3,
    ALLY: 2,
    NAP: 1,
    NEUTRAL: 0,
    ENEMY: -1,
    ALL: -2,
    MEMBER: 4,
    PLAYER: -1e3,
    RENEGADE: -2e3
  },
  ALLIANCE_INVITATIONS_MODE: { INVITATIONS: 0, APPLICATIONS: 1 },
  ALLIANCE_CLASHES_TYPE: { DEFENSE: 0, ATTACK: 1 },
  ENTITY: { NONE: 0, BUILDING: 1, UNIT: 2, KNOWLEDGE: 3, RESOURCE: 4 },
  PLAYERS_LIST_MODE: {
    SIMPLE: 0,
    ALLIANCE_MEMBERS_LIST: 1,
    MASS_MAIL_COMPOSE: 2,
    MASS_MAIL_OVERVIEW_RECIPIENTS: 3,
    MASS_MAIL_ADD_RECIPIENTS: 4,
    MASS_MAIL_DELETE_RECIPIENTS: 5
  },
  REPORT_GROUP: { DEFENSE: 1, ATTACK: 2, TRANSPORT: 3, KNOWLEDGE: 4, MISSION: 5, SPY: 6 },
  REPORT_GROUP_NAME: {
    1: "Defense Report",
    2: "Battle Report",
    3: "Transit Report",
    4: "Knowledge researched report",
    5: "Mission Report",
    6: "Spy Report"
  },
  REPORT_TYPE: {
    ATTACK_WARNING: 1,
    MISSION_FINISHED: 2,
    KNOWLEDGE_RESEARCHED: 3,
    TRANSIT_RETURNED: 6,
    SPY_FINISHED: 7,
    BATTLE_ROUND_FINISHED: 8,
    LOST_FOREIGN_DEFENDER: 9,
    CONQUEST_FAILED: 10,
    CONQUEST: 11,
    SPY_CAPTURED: 13,
    DELIVERED_RESOURCES: 14,
    DELIVERED_DEFENSE: 15,
    CASTLE_LOST: 16,
    BATTLE_TYPE: { OFFENDER: 2, HOME: 0, DEFENDER: 1 }
  },
  ALLIANCE_REPORT_TYPE: {
    INVITATION_SENT: 1,
    INVITATION_ACCEPTED: 2,
    INVITATION_DECLINED: 3,
    PLAYER_DISMISSED: 4,
    RIGHTS_CHANGED: 5,
    MEMBER_LEAVE_ALLIANCE: 6,
    ALLIANCE_STATUS_CHANGED: 7,
    APPLICATION_SENT: 8,
    APPLICATION_ACCEPTED: 9,
    APPLICATION_REJECTED: 10,
    CASTLE_CONQUERED: 11,
    CASTLE_LOST: 12,
    NEW_RANK: 13
  },
  TRANSIT_TYPE: {
    DEFENSE: 0,
    DEFENSE_RETURN: 1,
    ATTACK: 2,
    ATTACK_RETURN: 3,
    TRANSPORT: 4,
    TRANSPORT_RETURN: 5,
    SPY: 6,
    SPY_RETURN: 7,
    TRANSITING: [0, 2, 4, 6],
    RETURNING: [1, 3, 5, 7],
    0: "Defense",
    1: "DefenseReturn",
    2: "Attack",
    3: "AttackReturn",
    4: "Transport",
    5: "TransportReturn",
    6: "Spy",
    7: "SpyReturn"
  },
  BUFF_TYPE: { RESOURCES: 3, 3: "Resources" },
  RANKS: { REQUEST_SIZE: 50, SCROLL_DIRECTION: { PAGE_UP: -1, PAGE_DOWN: 1, FIRST_PAGE: 0 } },
  RANKING_MODE: { PLAYER: 1, PLAYER_SEARCH: 2, ALLIANCE: 3, ALLIANCE_SEARCH: 4 },
  RANKING_CATEGORIES_NAMES: {
    category_player_points: "Points",
    category_player_castles_conquered: "Castles captured",
    category_alliance_points: "Points",
    category_alliance_castles_conquered: "Castles captured"
  },
  RANKING_TYPES_DESCRIPTION_NAMES: {
    player_rank: "%d Points",
    player_castles_conquered: "%ld castles",
    player_points_growth_last_30_days: "%d Points",
    player_castles_conquered_last_30_days: "%ld castles",
    alliance_rank: "%d Points",
    alliance_castles_conquered: "%ld castles",
    alliance_points_growth_last_30_days: "%d Points",
    alliance_castles_conquered_last_30_days: "%ld castles",
    alliance_points_average: "%d Points"
  },
  SEARCH_MODE: { PLAYER: 1, ALLIANCE: 2 },
  SEND_UNITS_RESOURCES_MODE: { ATTACK: 1, SUPPORT: 2, SEND_RESOURCES: 3, ATTACK_SYNC: 4, SUPPORT_SYNC: 5 },
  MODIFIER_TYPE: {
    BUILD_COST: 0,
    BUILD_SPEED: 1,
    AMOUNT_STORE: 2,
    AMOUNT_GENERATE: 3,
    OFFENSE: 4,
    DEFENSE: 5,
    MOVEMENT_SPEED: 6
  },
  RESOURCE_EXCHANGEABLE_LIST_MODE: { MASS_EXCHANGE: 0 },
  UNIT_CHOOSER_LIST_MODE: { HABITAT_SORTING: 0, MASS_EXCHANGE: 1, MASS_RECRUIT: 2 },
  UNIT_REDUCE_TIME_CONSTRUCTION_MODE: { SPEED_UP: 0, COMPLETE: 1 },
  KNOWLEDGE_CHOOSER_LIST_MODE: { MASS_KNOWLEDGE: 0 },
  KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE: { SPEED_UP: 0, COMPLETE: 1 },
  TRANSIT_SUMMARY_TYPE: { OUTGOING: "outgoing", INCOMING: "incoming" },
  BUILDING_CHOOSER_LIST_MODE: { MASS_BUILDING: 0 },
  BUILDING_CHOOSER_LIST_TAB_MODE: { HABITAT_TYPE_O: 0, HABITAT_TYPE_2: 2, HABITAT_TYPE_4: 4 },
  BUILDING_REDUCE_TIME_CONSTRUCTION_MODE: { SPEED_UP: 0, COMPLETE: 1 },
  ARRIVAL_CALCULATOR_TAB_MODE: { ARRIVAL_TIME: 0, TRANSPORT_TIME: 2 },
  ARRIVAL_DEFAULT_TIME: "00:00:00",
  ARRIVAL_CALCULATOR_ACTION_MODES: {
    OWN_MODE: 1,
    FOREIGNER_MODE: 2,
    RENEGADE_MODE: 3,
    PROTECTED_FROM_ATTACK: 4,
    PROTECTED_FULL: 5
  },
  ARRIVAL_CALCULATOR_ACTIONS: { 1: "Attack", 2: "Defend Habitat", 3: "Send Resources" },
  ARRIVAL_CALCULATOR_POSSIBLE_ACTION: { 1: [2, 3], 2: [1, 2, 3], 3: [1], 4: [2, 3], 5: [3] },
  SERVER_ERRORS: { NO_TRANSIT: "No such transit." },
  PATTERNS: {
    INTERNAL_LINK: /(l\+k|lkxmas):\/\/[A-Za-z0-9=?&,;]+[&0-9]+/gim,
    EXTERNAL_LINK: /(http)s*:\/{2}[A-Za-z0-9=?&,;.\/\?\=\-\_\%\#\+]{2,}/gim,
    NEW_LINE: /\\n|\n|\n\r/g,
    GET_ALLIANCE_FROM_LINK: /alliance\?([0-9]+)&([0-9]+)/g,
    GET_PLAYER_FROM_LINK: /player\?([0-9]+)&([0-9]+)/g,
    GET_COORDINATES_FROM_LINK: /coordinates\?([0-9]+),([0-9]+)&([0-9]+)/g,
    GET_REPORT_FROM_LINK: /report\?([0-9]+)&([0-9]+)&([0-9]+)/g,
    GET_SUPPORT_BRIDGE_FROM_LINK: /bridge\?([0-9]+)&([A-Za-z0-9]+)&([0-9]+)/g,
    GET_TIME_FROM_INPUT_STRING: /([0-9]{1,2}):([0-9]{1,2})/g
  },
  SUPPORT_BRIDGE: { VISIBLE_ROUNDS: 30 },
  MANUAL_DELAY_TRANSIT: { DEFAULT_PERCENTAGE: 10, MIN_LONGEST_DELAY: 360, MAX_LONGEST_DELAY: 7200 },
  VACATION_SHIELD_STATUS: { UNAVAILABLE: 0, AVAILABLE: 1, ACTIVE: 2, STARTING: 3 },
  PROTECTION_SHIELD_STATUS: { UNAVAILABLE: 0, AVAILABLE: 1, ACTIVE: 2, COOLDOWN: 3 },
  MAX_MASS_RECRUITMENT_LIMIT_DEFAULT: 1e4,
  MAX_MASS_SILVER_MERCHANT_RE_SCHEDULE_LIMIT_DEFAULT: 6,
  NEW_MESSAGE_MODE: { CREATE: 1, REPLY_DISCUSSION: 2, POST_IN_FORUM: 3, REPLY_FORUM: 4 },
  MESSAGE_MEMBER_CHANGE_ACTION: { ADD: 0, DELETE: 1 },
  MIN_LENGTH_CONTENT: 1,
  MIN_LENGTH_SUBJECT: 1,
  MAX_LENGTH_MENU_TITLE: 25,
  MAX_LENGTH_HABITAT_NAME_TITLE: 20,
  CHARACTER_SIZE: 10,
  SCENE_MAP_Z_LEVELS: { MAP: 0, MAP_WAR_ANIMATION: 10, MAP_LABEL_ANIMATION: 20, NAVIGATION_ARROW: 100 },
  ANIMATION_SPEED: 80,
  ANIMATION_GAP: 30,
  ANIMATION_BUILDING_POSSIBILITY: .4,
  COMPONENTS_REFS: {
    FORUM: { CONTAINER: "menuForumThreadComponent", TARGET: "lastForumThreadMessage" },
    MESSAGES: { CONTAINER: "menuMessageComponent", TARGET: "lastReadMessage" },
    ARRIVAL_TIME_FINDER: { CONTAINER: "menuArrivalTimeFinderComponent", TARGET: "bestChoiceCastle" },
    HABITATS_LIST: { CONTAINER: "menuHabitatsListComponent" },
    GLOBAL_OVERVIEW: { CONTAINER: "globalOverviewListComponent" },
    RANK: { CONTAINER: "menuRankComponent", TARGET: "ownRankPosition" },
    MASS_FUNCTIONS: { CONTAINER: "menuMassFunctionComponent" }
  },
  BAN_TYPE: { WARNING: 1, TEMPORARY_DISABLED: 2, COMPLETE_INHIBITED: 3 },
  MASS_FUNCTIONS: {
    SILVER_MERCHANT: 0,
    RESTOCK: 1,
    RISE_BUFFS: 2,
    EXCHANGE: 3,
    KNOWLEDGE: 4,
    MISSIONS: 5,
    RECRUITMENT: 6,
    BUILDINGS: 7
  },
  MAX_ACTIVE_ITEMS_RENDER_AMOUNT: { MASS_RECRUITMENT: 10 },
  SEND_ALL_UNITS_BACK: {
    RETURN_LOCAL_DEFENDERS: 1,
    RECALL_LOCAL_DEFENDERS: 2,
    RECALL_EXTERNAL_DEFENDERS: 3,
    RECALL_EXTERNAL_ATTACKERS: 4,
    RECALL_LOCAL_ATTACKERS: 5
  },
  LAST_FORMATION_MODE: { ATTACK: 0, SUPPORT: 1, SEND_RESOURCE: 2, SEND_SPY: 3 },
  MAP: { MOVE_STEP: 20 },
  MUSIC: { DEFAULT_VOLUME: 5 },
  SFX: { DEFAULT_VALUE: 5 },
  MEDIA_TYPE: { MUSIC: 1, SFX: 2, ATMOSPHERE: 3 },
  TABLE: { ROWS_LIMIT: 300 },
  PREMIUM_RESOURCE: "premium",
  KEYBOARD_KEYS: {
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_LEFT_SAFARI: "Left",
    ARROW_RIGHT_SAFARI: "Right",
    KEY_W: "KeyW",
    KEY_A: "KeyA",
    KEY_S: "KeyS",
    KEY_D: "KeyD",
    KEY_W_SAFARI_S: 87,
    KEY_A_SAFARI_S: 65,
    KEY_S_SAFARI_S: 83,
    KEY_D_SAFARI_S: 68,
    KEY_W_SAFARI: 119,
    KEY_A_SAFARI: 97,
    KEY_S_SAFARI: 115,
    KEY_D_SAFARI: 100,
    KEY_SCENE_HABITAT: "Digit1",
    KEY_SCENE_MAP_GAME: "Digit2",
    KEY_SCENE_MAP_POLITICAL: "Digit3",
    KEY_SCENE_HABITAT_SAFARI: 49,
    KEY_SCENE_MAP_GAME_SAFARI: 50,
    KEY_SCENE_MAP_POLITICAL_SAFARI: 51
  },
  DEFAULT_MUSIC_SETTINGS_OBJECT: {
    musicStateIsOn: !0, musicVolume: 50,
    sfxStateIsOn: !0, sfxVolume: 50
  },
  GOOGLE_ANALYTICS: { CLIENT_ID: "UA-31210962-1", EVENT_GROUP: "registration-tracking" },
  MAT_ANALYTICS: {
    URL: "http://launch1.co/serve?action=conversion",
    SITE_ID: "8642",
    ADVERTISER_ID: "3066",
    EVENT_GROUP_ID: { thirteenPointsEarned: "1844658966", twentyPointsEarned: "1844658967" }
  }
}), xy.dStaticInjector.set(xy.dNames.settings.gameDynamic, { DISABLE_ANIMATION: !1 }), xy.dStaticInjector.set(xy.dNames.mixins.delegate, {
  notify: function(event, data, options) {
    "use strict";
    if (this[event])return this[event](data, options);
    if (this.controller)return this.controller[event] ? this.controller[event](data, options) : this.controller.notify(event, data, options);
    throw new Error("Element does not have a controller!")
  }
}), xy.dStaticInjector.set(xy.dNames.mixins.dialogHandlers, [xy.dNames.componentsEngine, xy.dNames.gameInstance, xy.dNames.settings.gameConstant, function(componentEngine, gameInstance, settingsGameConstant) {
  "use strict";
  return {
    getInitialState: function() {
      return { alertStatus: " in" }
    }, onCloseAlert: function(event) {
      event.preventDefault();
      var cover = gameInstance.injector.get(xy.dNames.components.rendererRequestPending);
      cover.done(), componentEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gameDialogLayer))
    }, onSubmitAlert: function(event) {
      this.props.settings.callback && this.props.settings.context && this.props.settings.callback.call(this.props.settings.context, event), this.setState({ alertStatus: "" }, null), this.onCloseAlert(event)
    }, onSubmitDialog: function(button, event) {
      switch (event.preventDefault(), this.setState({ alertStatus: "" }, null), button) {
        case"ok":
          this.props.settings.callbackSuccess && setTimeout(function() {
            this.props.settings.callbackSuccess()
          }.bind(this), settingsGameConstant.NEXT_DIALOG_SCHEDULE_INTERVAL);
          break;
        case"cancel":
          this.props.settings.callbackCancel && this.props.settings.callbackCancel()
      }
      this.onCloseAlert(event)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.mixins.setOption, {
  addRequired: function(name) {
    "use strict";
    this.__required || (this.__required = {}), this.__required[name] = !0
  }, setOptions: function(options) {
    "use strict";
    var option, opt = options || {};
    Object.assign(this, opt);
    for (option in this.__required)if (this.__required.hasOwnProperty(option) && !this[option])throw new Error("Properties " + option + " has to be initialized with value")
  }, updateOptions: function(options) {
    "use strict";
    var opt = options || {};
    Object.assign(this, opt)
  }
}), xy.dStaticInjector.set(xy.dNames.mixins.linkMethod, {
  linkMethod: function() {
    "use strict";
    this.forLinking && this.forLinking.forEach(function(linkObject) {
      this[linkObject.methodName] = linkObject.resourceClass.prototype[linkObject.methodName].bind(this)
    }, this), this.forLinking && this.forLinking.forEach(function(linkObject) {
      this[linkObject.methodName] = linkObject.resourceClass.prototype[linkObject.methodName].bind(this)
    }, this)
  }
}), xy.dStaticInjector.set(xy.dNames.mixins.menuComponentHandlers, [xy.dNames.componentsEngine, xy.dNames.gameInstance, xy.dNames.settings.gameConstant, xy.dNames.services.theme, function(componentsEngine, gameInstance, settingsGameConstant, servicesTheme) {
  "use strict";
  return {
    handlerNextClick: function(data, event) {
      event && (event.preventDefault(), event.stopPropagation()), data.options = data.options || {}, data.options.isClickOnRoot = this.props.settingsTitle.isRoot, data.options.localizedNameOfPreviousView = this.props.settingsTitle.localizedTitle, this.props.presenter.notify(xy.eNames.menu.openNextView, data.next, data.options)
    }, handlerTitleLeftButtonClick: function(event) {
      event && event.preventDefault(), this.props.settingsTitle.isRoot ? this.handlerCloseButtonClick() : this.handlerPrevClick()
    }, handlerPrevClick: function() {
      this.props.presenter.notify(xy.eNames.menu.openPrevView)
    }, handlerCloseButtonClick: function() {
      this.props.presenter.notify(xy.eNames.sceneGame.onCloseClickBarButton)
    }, handlerCenterMap: function(habitat, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.sceneGame.centerMapByCoordinates, {
        mapX: habitat.mapX,
        mapY: habitat.mapY
      })
    }, refreshMenu: function() {
      this.props.presenter.notify(xy.eNames.menu.onRefreshCall)
    }, handlerOpenWebShopClick: function() {
      this.props.presenter.notify(xy.eNames.sceneGame.goToWebShop)
    }, emptyEvent: function(btnName, event) {
      event.preventDefault(), console.warn("You have to implement " + btnName)
    }, onGetModelLinkClick: function(object, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.core.displayModelLink, object), this.setState({ activeModelLinkClicker: this.state.activeModelLinkClicker + 1 }, null)
    }, clearActiveModelLink: function() {
      this.props.presenter.notify(xy.eNames.core.clearModelLink)
    }, addFAQButton: function(sectionComponentSettings, faqUrl) {
      var lang = gameInstance.getGameLanguage();
      return sectionComponentSettings.iconRight = "controls menu-info", sectionComponentSettings.iconRightOnClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: servicesTheme.themeSettings.faqLinks.baseURL + faqUrl + "&l=" + lang }
      }), sectionComponentSettings
    }, onGameLinkClick: function(link, event) {
      event.preventDefault(), event.stopPropagation();
      var matchesArray;
      return settingsGameConstant.PATTERNS.GET_PLAYER_FROM_LINK.lastIndex = 0, settingsGameConstant.PATTERNS.GET_PLAYER_FROM_LINK.test(link) === !0 ? (settingsGameConstant.PATTERNS.GET_PLAYER_FROM_LINK.lastIndex = 0, matchesArray = settingsGameConstant.PATTERNS.GET_PLAYER_FROM_LINK.exec(link), void(this.props.presenter.notify(xy.eNames.core.isCurrentWorld, +matchesArray[2]) && this.handlerNextClick({
        next: xy.dNames.game.menuPlayerProfileExternal.name,
        options: { playerId: +matchesArray[1] }
      }, event))) : (settingsGameConstant.PATTERNS.GET_COORDINATES_FROM_LINK.lastIndex = 0, settingsGameConstant.PATTERNS.GET_COORDINATES_FROM_LINK.test(link) === !0 ? (settingsGameConstant.PATTERNS.GET_COORDINATES_FROM_LINK.lastIndex = 0, matchesArray = settingsGameConstant.PATTERNS.GET_COORDINATES_FROM_LINK.exec(link), void(this.props.presenter.notify(xy.eNames.core.isCurrentWorld, +matchesArray[3]) && this.props.presenter.notify(xy.eNames.sceneGame.centerMapByCoordinates, {
        mapX: +matchesArray[1],
        mapY: +matchesArray[2]
      }))) : (settingsGameConstant.PATTERNS.GET_REPORT_FROM_LINK.lastIndex = 0, settingsGameConstant.PATTERNS.GET_REPORT_FROM_LINK.test(link) === !0 ? (settingsGameConstant.PATTERNS.GET_REPORT_FROM_LINK.lastIndex = 0, matchesArray = settingsGameConstant.PATTERNS.GET_REPORT_FROM_LINK.exec(link), void(this.props.presenter.notify(xy.eNames.core.isCurrentWorld, +matchesArray[3]) && this.handlerNextClick({
        next: xy.dNames.game.menuReportsOverview.name,
        options: { isReportExternal: !0, reportId: +matchesArray[1], habitatId: +matchesArray[2] }
      }, event))) : (settingsGameConstant.PATTERNS.GET_ALLIANCE_FROM_LINK.lastIndex = 0, settingsGameConstant.PATTERNS.GET_ALLIANCE_FROM_LINK.test(link) === !0 ? (settingsGameConstant.PATTERNS.GET_ALLIANCE_FROM_LINK.lastIndex = 0, matchesArray = settingsGameConstant.PATTERNS.GET_ALLIANCE_FROM_LINK.exec(link), void(this.props.presenter.notify(xy.eNames.core.isCurrentWorld, +matchesArray[2]) && this.handlerNextClick({
        next: xy.dNames.game.menuAllianceProfile.name,
        options: { allianceId: +matchesArray[1] }
      }, event))) : (settingsGameConstant.PATTERNS.GET_SUPPORT_BRIDGE_FROM_LINK.lastIndex = 0, settingsGameConstant.PATTERNS.GET_SUPPORT_BRIDGE_FROM_LINK.test(link) === !0 ? (settingsGameConstant.PATTERNS.GET_SUPPORT_BRIDGE_FROM_LINK.lastIndex = 0, matchesArray = settingsGameConstant.PATTERNS.GET_SUPPORT_BRIDGE_FROM_LINK.exec(link), void(this.props.presenter.notify(xy.eNames.core.isCurrentWorld, +matchesArray[3]) && this.handlerNextClick({
        next: xy.dNames.game.menuSupportBridge.name,
        options: { habitatId: +matchesArray[1], key: matchesArray[2] }
      }, event))) : void console.log("Unknown link format")))))
    }, scrollToTop: function(container) {
      var containerNode = componentsEngine.findDOMNode(this.refs[container]);
      containerNode && (containerNode.scrollTop = 0)
    }, scrollToMenuElement: function(options) {
      var containersPaddingTop, containerNode = componentsEngine.findDOMNode(this.refs[options.container]), targetNode = componentsEngine.findDOMNode(this.refs[options.target]);
      if (containerNode && targetNode) {
        try {
          containersPaddingTop = getComputedStyle(containerNode).getPropertyValue("padding-top")
        } catch (e) {
          containersPaddingTop = containerNode.currentStyle.paddingTop
        }
        containersPaddingTop = Math.round(containersPaddingTop.replace("px", "")), containerNode.scrollTop = targetNode.offsetTop - containersPaddingTop
      }
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.mixins.menuComponentTimer, [xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(utilsDateTime, settingsGameConstant, servicesInternationalization) {
  "use strict";
  return {
    countDownTimer: 0, updateStateOnFinishedTimer: function() {
      this.setState({ expired: !0 }, null)
    }, onTimerFinished: function() {
      if (this.updateStateOnFinishedTimer(), this.props.settings.customOnTimerFinishedCallBack)this.props.settings.customOnTimerFinishedCallBack(); else {
        var initialThis = this.props.settings.initialComponent;
        initialThis.props.presenter.notify(xy.eNames.core.onTimerEnd)
      }
    }, getInitialState: function() {
      return this.constructState(this.props)
    }, tick: function() {
      var state = this.state, remain = utilsDateTime.remainTimeInSeconds(state.timer);
      remain > 0 ? this.setState({ remainTimeString: utilsDateTime.remainTime(state.timer, !0) }, function() {
        this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)
      }.bind(this)) : this.setState({ remainTimeString: servicesInternationalization.localize("Finished") }, function() {
        this.onTimerFinished()
      }.bind(this))
    }, componentWillReceiveProps: function(newProps) {
      this.setState(this.constructState(newProps), null)
    }, componentWillUnmount: function() {
      this.countDownTimer && clearTimeout(this.countDownTimer)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.mixins.menuComponentArrivalDate, [function() {
  "use strict";
  return {
    onArrivalDateSubmit: function(date) {
      this.setState({ changedArrivalDate: date }, null)
    }, onArrivalDateReset: function(date) {
      this.setState({ changedArrivalDate: date }, null)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.mixins.menuSearchBarHandlers, [function() {
  "use strict";
  return {
    updateSearchQuery: function(event) {
      var newString = event.currentTarget.value;
      this.setState({ searchQueryString: newString }, null)
    }, onSearchFieldFocus: function() {
      this.setState({ showIcon: !1 }, null)
    }, onSearchFieldBlur: function() {
      this.state.searchQueryString || this.setState({ showIcon: !0 }, null)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.mixins.menuAllianceInvitation, [function() {
  "use strict";
  return {
    onAcceptAllianceInvitationClick: function(allianceId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceManagement.acceptAllianceInvitation, { allianceId: allianceId })
    }, onRejectAllianceInvitationClick: function(allianceId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceManagement.rejectAllianceInvitation, { allianceId: allianceId })
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.mixins.tableToggleAllHandler, [function() {
  "use strict";
  return {
    onExtendClick: function(habitatId) {
      var newExtendedHabitats = this.state.extendedHabitats;
      newExtendedHabitats[habitatId] = !newExtendedHabitats[habitatId], this.setState({ extendedHabitats: newExtendedHabitats }, null)
    }, onExtendAllClick: function() {
      var habitatsList = this.props.settings.extendableHabitats, newExtendedHabitats = {};
      habitatsList.forEach(function(habitatId) {
        newExtendedHabitats[habitatId] = !0
      }), this.setState({ extendedHabitats: newExtendedHabitats }, null)
    }, onCollapseAllClick: function() {
      this.setState({ extendedHabitats: {} }, null)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.converter, [xy.dNames.utils.dateTime, function(utilsDateTime) {
  "use strict";
  return {
    toNumber: function(input) {
      return +input
    }, toBoolean: function(input) {
      return !(!input || "false" === input)
    }, toDate: function(input) {
      return utilsDateTime.prepareDate(input)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.dateTime, [xy.dNames.settings.gameConstant, xy.dNames.services.log, function(settingsGameConstant, servicesLog) {
  "use strict";
  return {
    timeGap: null, worldDawn: null, worldDusk: null, setTimeGap: function(date) {
      if ("number" == typeof date && (date = new Date(date)), "string" == typeof date && (date = new Date(date)), !(date instanceof Date))throw new Error("error", "Passed not a Date to getLocaleDateTimeString method of Date util");
      var now = new Date;
      this.timeGap = now.getTime() - date.getTime()
    }, prepareDate: function(date) {
      if ("number" == typeof date && (date = new Date(date)), "string" == typeof date && (date = new Date(date)), !(date instanceof Date))throw new Error("error", "Passed not a Date to getLocaleDateTimeString method of Date util");
      var millisecondTime = date.getTime() + this.timeGap + settingsGameConstant.DATE_CLIENT_DELAY;
      return new Date(millisecondTime)
    }, getDayCycle: function(date) {
      return date = date || new Date, this.isNight({ time: date }) ? "Night" : "Day"
    }, isNight: function(options) {
      options = options || {};
      var worldDawn = options.worldDawn || this.worldDawn, worldDusk = options.worldDusk || this.worldDusk, worldDawnInSeconds = this.getTimeInSeconds(worldDawn), worldDuskInSeconds = this.getTimeInSeconds(worldDusk), timeInSeconds = this.getTimeInSeconds(options.time);
      return worldDawnInSeconds < worldDuskInSeconds ? timeInSeconds < worldDawnInSeconds || timeInSeconds > worldDuskInSeconds : timeInSeconds < worldDawnInSeconds && timeInSeconds > worldDuskInSeconds
    }, getDateHTML5InputFormat: function(date) {
      var m, d, stringDate = "";
      return date instanceof Date || (date = new Date), stringDate += date.getFullYear() + "-", m = date.getMonth() + 1, m < 10 && (m = "0" + m), stringDate += m + "-", d = date.getDate(), d < 10 && (d = "0" + d), stringDate += d
    }, getTimeHTML5InputFormat: function(date) {
      var h, m, stringDate = "";
      return date instanceof Date || (date = new Date), h = date.getHours(), h < 10 && (h = "0" + h), stringDate += h + ":", m = date.getMinutes(), m < 10 && (m = "0" + m), stringDate += m
    }, getLocaleDateTimeString: function(date) {
      return date.toLocaleString()
    }, getLocaleDateString: function(date) {
      return date.toLocaleDateString()
    }, getLocaleTimeString: function(date) {
      return date.toLocaleTimeString()
    }, getTimeInSeconds: function(date) {
      return 3600 * date.getHours() + 60 * date.getMinutes() + date.getSeconds()
    }, getSortableDateString: function(date) {
      var day = date.getDate(), month = date.getMonth() + 1, year = date.getFullYear();
      return day < 10 && (day = "0" + day), month < 10 && (month = "0" + month), year.toString() + month.toString() + day.toString()
    }, getFormatedDateString: function(date) {
      var day = date.getDate(), month = date.getMonth() + 1, year = date.getFullYear();
      return day < 10 && (day = "0" + day), month < 10 && (month = "0" + month), day + "." + month + "." + year
    }, getFormatedDateTimeString: function(date) {
      var day = date.getDate(), month = date.getMonth() + 1, year = date.getFullYear(), hours = date.getHours(), minutes = date.getMinutes();
      return day < 10 && (day = "0" + day), month < 10 && (month = "0" + month), hours < 10 && (hours = "0" + hours), minutes < 10 && (minutes = "0" + minutes), day + "." + month + "." + year + " " + hours + ":" + minutes
    }, remainTime: function(date, showSeconds) {
      if (!(date && date instanceof Date))return servicesLog("warn", "Bad/No date given for util.remainTime method"), "";
      var sec = this.remainTimeInSeconds(date);
      return this.secondsToTimeString(sec, showSeconds)
    }, remainTimeInSeconds: function(date) {
      if (!(date && date instanceof Date))return 0;
      var now = new Date, temp = date.getTime() - now.getTime();
      return temp / 1e3 | 0
    }, isDatePassed: function(date) {
      var now = new Date, temp = date.getTime() - now.getTime();
      return temp <= 0
    }, passedTimeInSeconds: function(date) {
      var now = new Date, temp = now.getTime() - date.getTime();
      return temp / 1e3 | 0
    }, secondsToTimeString: function(sec, showSeconds) {
      var hourString, minuteString, secondString, hours = parseInt(sec / 3600, 10), minutes = parseInt((sec - 3600 * hours) / 60, 10), seconds = sec - 3600 * hours - 60 * minutes, sHour = "h", sMin = "m", sDay = "d";
      if (seconds < 0 && (seconds = 0), minutes < 0 && (minutes = 0), hours < 0 && (hours = 0), showSeconds)return hourString = hours < 10 ? "0" + hours : hours, minuteString = minutes < 10 ? "0" + minutes : minutes, secondString = seconds < 10 ? "0" + seconds : seconds, [hourString, minuteString, secondString].join(":");
      if (0 === hours)return minutes < 1 ? "< 1" + sMin : minutes + sMin;
      if (hours > 24) {
        var days = hours / 24 << 0, remainingHours = hours - 24 * days;
        return days + sDay + " " + remainingHours + sHour
      }
      return hours + sHour + " " + minutes + sMin
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.network, [xy.dNames.utils.object, function(utilsObject) {
  "use strict";
  var Utf8 = {
    encode: function(strUni) {
      var strUtf = strUni.replace(/[\u0080-\u07ff]/g, function(c) {
        var cc = c.charCodeAt(0);
        return String.fromCharCode(192 | cc >> 6, 128 | 63 & cc)
      });
      return strUtf = strUtf.replace(/[\u0800-\uffff]/g, function(c) {
        var cc = c.charCodeAt(0);
        return String.fromCharCode(224 | cc >> 12, 128 | cc >> 6 & 63, 128 | 63 & cc)
      })
    }, decode: function(strUtf) {
      var strUni = strUtf.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function(c) {
        var cc = (15 & c.charCodeAt(0)) << 12 | (63 & c.charCodeAt(1)) << 6 | 63 & c.charCodeAt(2);
        return String.fromCharCode(cc)
      });
      return strUni = strUni.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function(c) {
        var cc = (31 & c.charCodeAt(0)) << 6 | 63 & c.charCodeAt(1);
        return String.fromCharCode(cc)
      })
    }
  }, Sha256 = {
    hash: function(msg, utf8encode) {
      utf8encode = !utf8encode || utf8encode, utf8encode && (msg = Utf8.encode(msg));
      var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], H = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
      msg += String.fromCharCode(128);
      var i, j, l = msg.length / 4 + 2, N = Math.ceil(l / 16), M = new Array(N);
      for (i = 0; i < N; i += 1)for (M[i] = new Array(16), j = 0; j < 16; j += 1)M[i][j] = msg.charCodeAt(64 * i + 4 * j) << 24 | msg.charCodeAt(64 * i + 4 * j + 1) << 16 | msg.charCodeAt(64 * i + 4 * j + 2) << 8 | msg.charCodeAt(64 * i + 4 * j + 3);
      M[N - 1][14] = 8 * (msg.length - 1) / Math.pow(2, 32), M[N - 1][14] = Math.floor(M[N - 1][14]), M[N - 1][15] = 8 * (msg.length - 1) & 4294967295;
      var a, b, c, d, e, f, g, h, t, T1, T2, W = new Array(64);
      for (i = 0; i < N; i += 1) {
        for (t = 0; t < 16; t += 1)W[t] = M[i][t];
        for (t = 16; t < 64; t += 1)W[t] = Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16] & 4294967295;
        for (a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7], t = 0; t < 64; t += 1)T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t], T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c), h = g, g = f, f = e, e = d + T1 & 4294967295, d = c, c = b, b = a, a = T1 + T2 & 4294967295;
        H[0] = H[0] + a & 4294967295, H[1] = H[1] + b & 4294967295, H[2] = H[2] + c & 4294967295, H[3] = H[3] + d & 4294967295, H[4] = H[4] + e & 4294967295, H[5] = H[5] + f & 4294967295, H[6] = H[6] + g & 4294967295, H[7] = H[7] + h & 4294967295
      }
      return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7])
    }, ROTR: function(n, x) {
      return x >>> n | x << 32 - n
    }, Sigma0: function(x) {
      return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x)
    }, Sigma1: function(x) {
      return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x)
    }, sigma0: function(x) {
      return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ x >>> 3
    }, sigma1: function(x) {
      return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ x >>> 10
    }, Ch: function(x, y, z) {
      return x & y ^ ~x & z
    }, Maj: function(x, y, z) {
      return x & y ^ x & z ^ y & z
    }, toHexStr: function(n) {
      var v, i, s = "";
      for (i = 7; i >= 0; i -= 1)v = n >>> 4 * i & 15, s += v.toString(16);
      return s
    }
  };
  return {
    arrayToQueryString: function(array, options) {
      var i, temp, stringBuffer = [], length = array.length;
      if (!length)return "()";
      var result = "(";
      for (i = 0; i < length; i += 1)temp = utilsObject.isPlainObject(array[i]) ? this.dictionaryToQueryString(array[i], options) : options && options.noStringFlag || isNaN(array[i]) === !1 ? array[i] : '"' + array[i] + '"', stringBuffer.push(temp);
      return result += stringBuffer.join(), options && options.trailingCommaFlag && (result += ","), result += ")"
    }, dictionaryToQueryString: function(object, options) {
      var localOptions = { trailingCommaFlag: !0, noStringFlag: !1 };
      Object.assign(localOptions, options);
      var key, result, stringBuffer = [];
      result = "{";
      for (key in object)object.hasOwnProperty(key) && (stringBuffer.push(key + "="), object[key] instanceof Array ? stringBuffer.push(this.arrayToQueryString(object[key], localOptions)) : utilsObject.isEmpty(object[key]) ? stringBuffer.push(object[key]) : stringBuffer.push(this.dictionaryToQueryString(object[key], localOptions)), stringBuffer.push(";"));
      return result += stringBuffer.join(""), result += "}"
    }, getParamsFromURL: function(url) {
      url = url || window.location.href;
      for (var match, result = {}, regex = /[?&]([^=]+)(=([^&]+)|&|$)/g; null !== (match = regex.exec(url));)result[match[1]] = match[3];
      return result
    }, objectToURIString: function(data) {
      var key, paramString = "", count = 0, val = "";
      for (key in data)data.hasOwnProperty(key) && (val = data[key] instanceof Array ? this.arrayToQueryString(data[key]) : data[key], count > 0 && (paramString += "&"), paramString += encodeURIComponent(key) + "=" + encodeURIComponent(val), count += 1);
      return paramString
    }, hash: function(str) {
      return Sha256.hash(str)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.object, [function() {
  "use strict";
  return {
    isPlainObject: function(objectCandidate) {
      return "object" == typeof objectCandidate && Array.isArray(objectCandidate) === !1 && null !== objectCandidate
    }, isEmpty: function(object, required) {
      if (!object || "string" == typeof object || !isNaN(object))return !0;
      if (object instanceof Array)throw new Error("An array passed instead Object");
      var i, len, key;
      if (required) {
        for (i = 0, len = required.length; i < len; i += 1)if (!object[required[i]])return !0
      } else for (key in object)if (object.hasOwnProperty(key))return !1;
      return !0
    }, length: function(object) {
      var key, length = 0;
      for (key in object)object.hasOwnProperty(key) && (length += 1);
      return length
    }, effectiveLength: function(object) {
      var key, length = 0;
      for (key in object)object.hasOwnProperty(key) && object[key] && (length += 1);
      return length
    }, getUniqueSignatureOfObject: function(object) {
      var key, result = [], length = 0;
      for (key in object) {
        if (length > 3)break;
        if (object.hasOwnProperty(key) && object[key])switch (typeof object[key]) {
          case"string":
            result.push(object[key]), length += 1;
            break;
          case"number":
            result.push(object[key]), length += 1;
            break;
          default:
            object[key].hasOwnProperty("primaryKey") && (result.push(object[key].primaryKey), length += 1), object[key].hasOwnProperty("id") && (result.push(object[key].id), length += 1)
        }
      }
      return result.join("")
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.oop, [function() {
  "use strict";
  return {
    extend: function(child, parent) {
      return parent = parent || {}, Object.assign(child, parent), child.prototype = Object.create(parent.prototype), child.prototype.constructor = child, child.__super__ = parent.prototype, child
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.screen, [function() {
  "use strict";
  return {
    ppi: null, convertPx2Pt: function(px) {
      return 0
    }, updateWidth: function() {
      this.updatePPI()
    }, updatePPI: function() {
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.string, [xy.dNames.settings.gameConstant, function(settingsGameConstant) {
  "use strict";
  var formats = {
    b: function(val) {
      return parseInt(val, 10).toString(2)
    }, c: function(val) {
      return String.fromCharCode(parseInt(val, 10))
    }, d: function(val) {
      return parseInt(val, 10)
    }, u: function(val) {
      return Math.abs(val)
    }, f: function(val, p) {
      return p = parseInt(p, 10), val = parseFloat(val), isNaN(p && val) ? NaN : p && val.toFixed(p) || val
    }, o: function(val) {
      return parseInt(val, 10).toString(8)
    }, s: function(val) {
      return val
    }, "@": function(val) {
      return val
    }, x: function(val) {
      return parseInt(val, 10).toString(16).toLowerCase()
    }, X: function(val) {
      return parseInt(val, 10).toString(16).toUpperCase()
    }
  }, re = /%(\d*)([%bcdufos@xX])/g, dispatch = function(data) {
    if (1 === data.length && "object" == typeof data[0])return data = data[0], function(match, lbl, fmt, off, str) {
      return formats[fmt](data[lbl])
    };
    var idx = -1;
    return function(match, lbl, fmt, off, str) {
      return "%" === fmt ? "%" : (idx += 1, formats[fmt](data[idx]))
    }
  };
  return {
    sprintf: function(argv) {
      argv instanceof Array || (argv = [].slice.call(arguments));
      var format = argv.shift();
      1 === argv.length && argv[0] instanceof Array && (argv = argv[0]), format = format.replace(/(%ld|%l@|%0\.1f|%1\$0\.1f)/g, "%1@"), format = format.replace(/\$(@|d|s|ld%|ld)/g, "@");
      var i, tempFormat = format.match(/%\d+(@|d)/g), tempNumberArgv = [], number = -1, reg = "", arg = 0;
      if (tempFormat) {
        for (i = 0; i < tempFormat.length; i += 1)number = parseInt(tempFormat[i].match(/\d/), 10), tempNumberArgv.push(number), reg = new RegExp(tempFormat[i]), number -= 1, arg = argv[number], format = format.replace(reg, arg);
        for (i = 0; i < tempNumberArgv.length; i += 1)argv.splice(tempNumberArgv[i] - 1)
      }
      return format.replace(re, dispatch(argv))
    }, vsprintf: function(format, data) {
      return format.replace(re, dispatch(data))
    }, getRegExp: function(type) {
      var regExp;
      switch (type) {
        case"email":
          regExp = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
          break;
        case"not-empty":
          regExp = /.+/;
          break;
        case"at-least-5":
          regExp = /.{5}/;
          break;
        default:
          throw new Error("Trying to get not specified RegExp for " + type)
      }
      return regExp
    }, isValid: function(value, rule) {
      var isVerified = !0, validationRegExp = this.getRegExp(rule);
      return validationRegExp.test(value) || (isVerified = !1), isVerified
    }, getUniqueKeyString: function() {
      var rand1 = Math.random(), rand2 = Math.random(), now = new Date;
      return "key-" + rand1 + now.getTime() + rand2
    }, sanitize: function(string) {
      return "string" != typeof string ? string : string.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")
    }, getHTMLOfString: function(string, context) {
      var PATTERNS = settingsGameConstant.PATTERNS, isReplicableWithInternalLink = !1, isReplaceableWithExternalLink = !1, isReplaceableWithNewLine = !1, splitter = "<?splitter?>", text = string;
      PATTERNS.EXTERNAL_LINK.test(text) && (isReplaceableWithExternalLink = !0), PATTERNS.INTERNAL_LINK.test(text) && (isReplicableWithInternalLink = !0), PATTERNS.NEW_LINE.test(text) && (isReplaceableWithNewLine = !0);
      var result = [text], splitAndAddReactElementsForInternalLinks = function(pattern, array) {
        var newResultArray = [];
        return array.forEach(function(splittingString) {
          if ("string" != typeof splittingString)return void newResultArray.push(splittingString);
          var reactObjects = [];
          splittingString = splittingString.replace(pattern, function(match, p1, offset) {
            return reactObjects.push(React.createElement("span", {
              className: "game-link",
              onClick: context.onGameLinkClick.bind(context, match),
              key: "link-" + offset
            }, match)), splitter
          }), splittingString = " " + splittingString + " ";
          var i, splitArray = splittingString.split(splitter), len = splitArray.length;
          for (" " !== splitArray[0] && newResultArray.push(splitArray[0].substr(1)), newResultArray.push(reactObjects[0]), i = 1; i < len - 1; i += 1)newResultArray.push(splitArray[i]), newResultArray.push(reactObjects[i]);
          splitArray[i] && " " !== splitArray[i] && newResultArray.push(splitArray[i].substr(0, splitArray[i].length - 1))
        }), newResultArray
      }, splitAndAddReactElementsForNewLines = function(pattern, array) {
        var newResultArray = [];
        return array.forEach(function(splittingString) {
          if ("string" != typeof splittingString)return void newResultArray.push(splittingString);
          var reactObjects = [];
          splittingString = splittingString.replace(pattern, function(match, offset) {
            return reactObjects.push(React.createElement("br", { key: "new-line-" + offset + Math.random() })), splitter
          }), splittingString = " " + splittingString + " ";
          var i, splitArray = splittingString.split(splitter), len = splitArray.length;
          for (" " !== splitArray[0] && newResultArray.push(splitArray[0].substr(1)), newResultArray.push(reactObjects[0]), i = 1; i < len - 1; i += 1)newResultArray.push(splitArray[i]), newResultArray.push(reactObjects[i]);
          splitArray[i] && " " !== splitArray[i] && newResultArray.push(splitArray[i].substr(0, splitArray[i].length - 1))
        }), newResultArray
      }, splitAndAddReactElementsForExternalLinks = function(pattern, array) {
        var newResultArray = [];
        return array.forEach(function(splittingString) {
          if ("string" != typeof splittingString)return void newResultArray.push(splittingString);
          var reactObjects = [];
          splittingString = splittingString.replace(pattern, function(match, p1, offset) {
            var url = match;
            return p1 && p1.indexOf("http") !== -1 || (url = "//" + url), reactObjects.push(React.createElement("a", {
              className: "game-link",
              href: url,
              target: "_blank",
              key: "link-" + offset
            }, match)), splitter
          }), splittingString = " " + splittingString + " ";
          var i, splitArray = splittingString.split(splitter), len = splitArray.length;
          for (" " !== splitArray[0] && newResultArray.push(splitArray[0].substr(1)), newResultArray.push(reactObjects[0]), i = 1; i < len - 1; i += 1)newResultArray.push(splitArray[i]), newResultArray.push(reactObjects[i]);
          splitArray[i] && " " !== splitArray[i] && newResultArray.push(splitArray[i].substr(0, splitArray[i].length - 1))
        }), newResultArray
      };
      return isReplaceableWithExternalLink && context && (result = splitAndAddReactElementsForExternalLinks(PATTERNS.EXTERNAL_LINK, result)), isReplicableWithInternalLink && context && (result = splitAndAddReactElementsForInternalLinks(PATTERNS.INTERNAL_LINK, result)), isReplaceableWithNewLine && (result = splitAndAddReactElementsForNewLines(PATTERNS.NEW_LINE, result)), result
    }, getStringWithValidLength: function(string, validLength) {
      string = string || "";
      var replacementString = "...";
      return string.length > validLength && (string = string.substr(0, validLength - replacementString.length) + replacementString), string
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.moving, [xy.dNames.services.gameDataManager, function(servicesGameDataManager) {
  "use strict";
  return {
    getArrivalTime: function(unitsDictionary, options) {
      var now = new Date, transportationTime = this.getTransportationTime(unitsDictionary, options);
      return now.setSeconds(now.getSeconds() + transportationTime), now
    }, getArrivalTimeOfUnit: function(modeledUnit, options) {
      var transportationTime, abilitiesWithModifiers, now = new Date, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
      return abilitiesWithModifiers = currentHabitat.applyModifiers({
        targetObject: "Unit",
        movementSpeed: modeledUnit.secondsPerField
      }), transportationTime = abilitiesWithModifiers.movementSpeed * options.distance, now.setSeconds(now.getSeconds() + transportationTime), now
    }, getTransportationTime: function(unitsDictionary, options) {
      var slowestUnitSpeed, distance = options.distance || null;
      return slowestUnitSpeed = !unitsDictionary && options.spySpeed ? options.spySpeed : this.getSlowestUnitSpeed(unitsDictionary), distance * slowestUnitSpeed | 0
    }, getSlowestUnitSpeed: function(unitDictionary) {
      var unitPK, unitModel, abilitiesWithModifiers, longestTimePerField = 0, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
      for (unitPK in unitDictionary)unitDictionary.hasOwnProperty(unitPK) && unitDictionary[unitPK] > 0 && (unitModel = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPK }), abilitiesWithModifiers = currentHabitat.applyModifiers({
        targetObject: "Unit",
        movementSpeed: unitModel.secondsPerField
      }), abilitiesWithModifiers.movementSpeed > longestTimePerField && (longestTimePerField = abilitiesWithModifiers.movementSpeed));
      return longestTimePerField
    }, massExchangeLoad: function(options) {
      var totalCapacity, tempResourceDictionary, totalLoaded, barterAmount, unitDictionary = options.unitDictionary;
      if (totalCapacity = this.computeUnitsCapacity(unitDictionary, options.exchangeableResource), tempResourceDictionary = this.fillUnitsCapacity({
                availableResources: options.availableResources,
                totalCapacity: totalCapacity
              }), totalLoaded = this.computeTotalResourcesLoaded(tempResourceDictionary), totalLoaded < totalCapacity) {
        var unitPK, unitModel;
        for (unitPK in unitDictionary)unitDictionary.hasOwnProperty(unitPK) && (unitModel = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPK }), unitDictionary[unitPK] = (totalLoaded / unitModel.storeAmount | 0) + 1)
      }
      return barterAmount = this.getExpectedAmountOfExchangesResource({
        availableResources: options.availableResources,
        resourceDictionary: tempResourceDictionary
      }), { barterAmount: barterAmount, resourceDictionary: tempResourceDictionary, unitDictionary: unitDictionary }
    }, computeUnitsCapacity: function(unitDictionary, exchangeResources) {
      var unitPK, unitModel, capacity = 0;
      for (unitPK in unitDictionary)unitDictionary.hasOwnProperty(unitPK) && (unitModel = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPK }), capacity += unitModel.storeAmount * unitDictionary[unitPK]);
      return capacity
    }, computeTotalResourcesLoaded: function(resourceDictionary) {
      var resourceId, loaded = 0;
      for (resourceId in resourceDictionary)resourceDictionary.hasOwnProperty(resourceId) && (loaded += resourceDictionary[resourceId]);
      return loaded
    }, computeTotalNobleResourcesLoaded: function(resourceDictionary, premiumAvailableResourceObject) {
      var resourceId, loaded = 0;
      for (resourceId in resourceDictionary)resourceDictionary.hasOwnProperty(resourceId) && (loaded += resourceDictionary[resourceId] * premiumAvailableResourceObject.exchangeRate);
      return loaded
    }, fillUnitsCapacity: function(options) {
      var newResourceDictionary = {};
      if (!options.totalCapacity || options.totalCapacity <= 0)return newResourceDictionary;
      var availableResourcesAmount, totalResourcesAmount = 0, filledResourceAmount = 0;
      return options.availableResources.forEach(function(object) {
        totalResourcesAmount += object.amount
      }), 0 === totalResourcesAmount ? newResourceDictionary : (options.availableResources.forEach(function(object) {
        var ratio, resourceAmount, mode;
        ratio = object.amount / totalResourcesAmount, resourceAmount = options.totalCapacity * ratio | 0, resourceAmount > object.amount && (resourceAmount = object.amount), mode = resourceAmount % object.exchangeRate, resourceAmount -= mode, resourceAmount <= 0 && (resourceAmount = 0), filledResourceAmount += resourceAmount, newResourceDictionary[object.resourceId] = 0 | resourceAmount
      }), availableResourcesAmount = totalResourcesAmount > options.totalCapacity ? options.totalCapacity : totalResourcesAmount, availableResourcesAmount > filledResourceAmount && options.availableResources.forEach(function(object) {
        newResourceDictionary[object.resourceId] + object.exchangeRate < object.amount && filledResourceAmount + object.exchangeRate <= availableResourcesAmount && (newResourceDictionary[object.resourceId] += object.exchangeRate, filledResourceAmount += object.exchangeRate)
      }), newResourceDictionary)
    }, getExpectedAmountOfExchangesResource: function(options) {
      var wantedResourceAmount = 0;
      return options.availableResources.forEach(function(object) {
        options.resourceDictionary[object.resourceId] && (wantedResourceAmount += options.resourceDictionary[object.resourceId] / object.exchangeRate)
      }), wantedResourceAmount
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.utils.number, [function() {
  "use strict";
  var suffixes = ["", "k", "M", "B"];
  return {
    roundGaussian: function(float) {
      var epsilon = .001, integerPart = 0 | float, recurringPart = float - integerPart;
      return integerPart === float ? integerPart : recurringPart < .5 - epsilon ? integerPart : recurringPart > .5 + epsilon ? integerPart + 1 : integerPart % 2 === 0 ? integerPart : integerPart + 1
    }, shortWithSuffixes: function(number) {
      var suffixIndex = 0;
      if (number > 99999) {
        for (; number > 1e3;)number = this.roundGaussian(number), number /= 1e3, suffixIndex += 1;
        return number.toFixed(1) + suffixes[suffixIndex]
      }
      return number.toString()
    }, getRandomIntFromRange: function(min, max) {
      var r = Math.random();
      return parseInt(r * (max - min) + min)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.factories.game, [xy.dNames.gameInstance, xy.dNames.services.log, function(gameInstance, servicesLog) {
  "use strict";
  return {
    create: function(name, parentController, data, options) {
      try {
        var container, presenterName, controllerName, dataSourceName, Presenter, Controller, DataSource;
        container = xy.dNames.game[name], presenterName = container.presenter, controllerName = container.controller, dataSourceName = container.dataSource, Presenter = gameInstance.injector.get(presenterName), Controller = gameInstance.injector.get(controllerName), DataSource = gameInstance.injector.get(dataSourceName), parentController = parentController || null;
        var ds, p, c;
        return ds = new DataSource, p = new Presenter, c = new Controller({
          dataSource: ds,
          presenter: p,
          controller: parentController,
          initialData: data,
          initialOptions: options
        }), ds.controller = c, p.controller = c, c
      } catch (e) {
        servicesLog("error", "Can not create game element " + name), servicesLog("debug", e)
      }
    }, omit: function(object) {
      console.log(object)
    }
  }
}]), xy.dStaticInjector.set(xy.dNames.core.coreClass, [xy.dNames.mixins.delegate, xy.dNames.mixins.setOption, xy.dNames.mixins.linkMethod, xy.dNames.utils.string, function(mixinsDelegate, mixinsSetOption, mixinsLinkMethod, utilsString) {
  "use strict";
  function CoreCoreClass(options) {
    Object.assign(this, mixinsDelegate), Object.assign(this, mixinsSetOption), Object.assign(this, mixinsLinkMethod), this.instanceId = utilsString.getUniqueKeyString(), this.setOptions(options), this.linkMethod()
  }

  return CoreCoreClass
}]), xy.dStaticInjector.set(xy.dNames.core.coreError, [xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.services.log, function(CoreCoreClass, utilsOop, servicesLog) {
  "use strict";
  function CoreCoreError(options) {
    this.message = "", CoreCoreError.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CoreCoreError, CoreCoreClass), CoreCoreError.prototype.debug = function() {
    servicesLog("warn", this.message), servicesLog("debug", this)
  }, CoreCoreError
}]), xy.dStaticInjector.set(xy.dNames.core.graphicalEngineDirector, [xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.settings.gameDynamic, function(coreCoreClass, utilsOop, utilsObject, settingsGameConstant, settingsGameDynamic) {
  "use strict";
  function CoreDirector(options) {
    CoreDirector.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CoreDirector, coreCoreClass), CoreDirector.prototype.init = function(options) {
    this.animationTimer = 0, this.isFullWindow = options.isFullWindow, this.canvasId = options.canvasId, this.cloneCanvas(), this.prevFrameDrawTimeMilliseconds = 0
  }, CoreDirector.prototype.cloneCanvas = function() {
    var canvas = document.getElementById(this.canvasId), newCanvas = canvas.cloneNode(!0);
    return canvas.parentNode.replaceChild(newCanvas, canvas), this.canvas = newCanvas, this.ctx = this.canvas.getContext("2d"), !0
  }, CoreDirector.prototype.clearScene = function() {
    var width = window.innerWidth, height = window.innerHeight;
    this.animationTimer && (window.cancelAnimationFrame(this.animationTimer), this.animationTimer = null, this.drawingIsInProgress = !0), this.releasePresenter() && this.ctx.clearRect(0, 0, width, height)
  }, CoreDirector.prototype.releasePresenter = function() {
    var children, child, z, childInstanceId;
    if (this.presenter) {
      children = this.presenter.children;
      for (z in children)if (children.hasOwnProperty(z)) {
        child = children[z];
        for (childInstanceId in child)child.hasOwnProperty(childInstanceId) && child[childInstanceId].enableEvents && child[childInstanceId].removeEvents()
      }
      this.presenter.isDrawn = !1
    }
    return this.cloneCanvas()
  }, CoreDirector.prototype.playScene = function(presenter) {
    var children, child, z, childInstanceId;
    if (this.animationTimer && (window.cancelAnimationFrame(this.animationTimer), this.animationTimer = null, this.drawingIsInProgress = !1), this.releasePresenter()) {
      presenter.isDrawn = !0, children = presenter.children;
      for (z in children)if (children.hasOwnProperty(z)) {
        child = children[z];
        for (childInstanceId in child)child.hasOwnProperty(childInstanceId) && child[childInstanceId].enableEvents && child[childInstanceId].initEvents(this.canvas)
      }
      this.presenter = presenter, this.__draw()
    }
  }, CoreDirector.prototype.renew = function() {
    this.presenter && this.presenter.isDrawn && (this.animationTimer && (window.cancelAnimationFrame(this.animationTimer), this.animationTimer = null, this.drawingIsInProgress = !1), this.__draw())
  }, CoreDirector.prototype.__animationStep = function() {
    var t = (new Date).getTime();
    this.animationIdentifier && t - this.prevFrameDrawTimeMilliseconds >= settingsGameConstant.ANIMATION_SPEED ? this.__draw() : this.animationIdentifier = window.requestAnimationFrame(this.__animationStep.bind(this))
  }, CoreDirector.prototype.__draw = function() {
    var sync = !0;
    if (this.presenter && this.presenter.isDrawn && !this.drawingIsInProgress) {
      this.drawingIsInProgress = !0, this.animationFlag = !1;
      var child, z, childInstanceId, node, children = this.presenter.children;
      for (z in children)if (children.hasOwnProperty(z)) {
        child = children[z];
        for (childInstanceId in child)child.hasOwnProperty(childInstanceId) && (node = child[childInstanceId], sync = this.__addOnCanvas(node), sync = !0, (node.isAnimationVisible || node.isAnimation) && (this.animationFlag = !0))
      }
      !settingsGameDynamic.DISABLE_ANIMATION && this.animationFlag && sync && (this.prevFrameDrawTimeMilliseconds = (new Date).getTime(), this.__animationStep()), this.drawingIsInProgress = !1
    }
  }, CoreDirector.prototype.__addOnCanvas = function(node) {
    var width = window.innerWidth, height = window.innerHeight, image = node.buffer;
    if (!image)return node.render({ context: this.ctx, width: width, height: height });
    node.isAnimation && node.drawNextFrame(), width > node.size.width && (width = node.size.width), height > node.size.height && (height = node.size.height);
    var screenX = node.screenX || 0, screenY = node.screenY || 0;
    return this.ctx.drawImage(image, node.x, node.y, width, height, screenX, screenY, width, height)
  }, CoreDirector.prototype.__constructBufferWithChildren = function(node) {
    var canvas, ctx, sync, children, childrenAtZ, child, z, childInstanceId, imageToDraw;
    canvas = document.createElement("canvas"), canvas.width = node.size.width, canvas.height = node.size.height, ctx = canvas.getContext("2d"), sync = ctx.drawImage(node.buffer, 0, 0), children = node.children;
    for (z in children)if (children.hasOwnProperty(z)) {
      childrenAtZ = children[z];
      for (childInstanceId in childrenAtZ)childrenAtZ.hasOwnProperty(childInstanceId) && (child = childrenAtZ[childInstanceId], utilsObject.effectiveLength(child.children) ? imageToDraw = this.__constructBufferWithChildren(child) : (child.isAnimation && (this.animationFlag = !0, sync = child.drawNextFrame()), imageToDraw = child.buffer), sync = ctx.drawImage(imageToDraw, child.x, child.y), sync = !0)
    }
    if (sync)return canvas
  }, CoreDirector
}]), xy.dStaticInjector.set(xy.dNames.core.graphicalEngineFrameManager, [xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.services.log, function(coreCoreClass, utilsOop, servicesLog) {
  "use strict";
  function CoreGraphicalEngineFrameManager(options) {
    CoreGraphicalEngineFrameManager.__super__.constructor.call(this, options), this.flush()
  }

  return utilsOop.extend(CoreGraphicalEngineFrameManager, coreCoreClass), CoreGraphicalEngineFrameManager.prototype.addFrames = function(options) {
    this.images[options.imageName] = options.image, this.frames.hasOwnProperty(options.imageName) || (this.frames[options.imageName] = {}), options.framesData.forEach(function(object) {
      var frameName, frameSettingsSting, matches, parsingRegExp = /\{\{(\d{1,4})\,(\d{1,4})\}\,\{(\d{1,4})\,(\d{1,4})\}\}/g;
      for (frameName in object.frames)if (object.frames.hasOwnProperty(frameName)) {
        frameSettingsSting = object.frames[frameName].frame || object.frames[frameName].textureRect, parsingRegExp.lastIndex = 0, matches = parsingRegExp.exec(frameSettingsSting);
        try {
          this.frames[options.imageName][frameName] = {
            x: +matches[1],
            y: +matches[2],
            width: +matches[3],
            height: +matches[4]
          }
        } catch (eX) {
          servicesLog("warn", eX)
        }
      }
    }, this)
  }, CoreGraphicalEngineFrameManager.prototype.flush = function() {
    this.images = {}, this.frames = {}
  }, CoreGraphicalEngineFrameManager.prototype.getFrame = function(options) {
    return this.images[options.imageName] && this.frames[options.imageName][options.frameName] ? {
      image: this.images[options.imageName],
      xOrigin: this.frames[options.imageName][options.frameName].x,
      yOrigin: this.frames[options.imageName][options.frameName].y,
      width: this.frames[options.imageName][options.frameName].width,
      height: this.frames[options.imageName][options.frameName].height
    } : null
  }, CoreGraphicalEngineFrameManager
}]), xy.dStaticInjector.set(xy.dNames.core.graphicalEngineMapCanvasBuffer, [xy.dNames.core.graphicalEngineNode, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(CoreGraphicalEngineNode, utilsOop, settingsGameConstant, servicesLog) {
  "use strict";
  function CoreGraphicalEngineMapCanvasBuffer(options) {
    CoreGraphicalEngineMapCanvasBuffer.__super__.constructor.call(this, options), this.buffer = null, this.tileOffset = null, this.gameCoordinates = {}, this.fullUpdateOnMoveOrUpdate = !1, this.enableEvents = !0, this.eventInitialized = !1, this.mouseDown = !1, this.draging = !1
  }

  return utilsOop.extend(CoreGraphicalEngineMapCanvasBuffer, CoreGraphicalEngineNode), CoreGraphicalEngineMapCanvasBuffer.prototype.update = function(data) {
    this.fullUpdateOnMoveOrUpdate = !0, this.__drawMap(data)
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.getClosestVisibleMapTile = function(gameCoordinates) {
    var topY, bottomY, closestY, screenY, leftX, rightX, closestX, screenX, origin = this.gameCoordinates.origin, screenHeight = window.innerHeight, screenWidth = window.innerWidth, isVisibleY = !1, isVisibleX = !1, offsetY = this.mapThemeSettings.arrowSettings.gapY, offsetX = 0;
    if (topY = origin.mapY + ((this.y + offsetY) / this.tileMap.height | 0), bottomY = origin.mapY + ((this.y - offsetY + screenHeight) / this.tileMap.height | 0), topY > gameCoordinates.mapY ? (closestY = topY, screenY = "min") : bottomY < gameCoordinates.mapY ? (closestY = bottomY, screenY = "max") : (screenY = "none", closestY = gameCoordinates.mapY, isVisibleY = !0), gameCoordinates.mapY % 2 && (offsetX = this.tileMap.widthOodOffset), leftX = origin.mapX + ((this.x - offsetX) / this.tileMap.width | 0), rightX = origin.mapX + ((this.x - offsetX + screenWidth) / this.tileMap.width | 0), leftX > gameCoordinates.mapX ? (closestX = leftX, screenX = "min") : rightX < gameCoordinates.mapX ? (closestX = rightX, screenX = "max") : (screenX = "none", closestX = gameCoordinates.mapX, isVisibleX = !0), isVisibleY && isVisibleX)return null;
    var minDistance = this.computeDistanceBetweenGameCoordinates(gameCoordinates, { mapX: closestX, mapY: closestY });
    return { mapX: closestX, mapY: closestY, screenXCase: screenX, screenYCase: screenY, distance: minDistance }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.computeDistanceBetweenGameCoordinates = function(a, b) {
    var distance, xA, yA, xB, yB, deltaX, deltaY;
    return xB = 0 | b.mapX, yB = 0 | b.mapY, 1 & yB && (xB += .5), yA = a.mapY, xA = a.mapX, 1 & yA && (xA += .5), deltaX = Math.abs(xA - xB), deltaY = Math.abs(yA - yB), distance = .5 * deltaY >= deltaX ? deltaY : .5 * deltaY + deltaX
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.setMapCenter = function(gameCoordinates) {
    if (!gameCoordinates)return void servicesLog("warn", "Can't set new map center, game coordinates are missing");
    var halfScreenSize, offsetFromOriginInTiles, newX, newY, origin = this.gameCoordinates.origin;
    offsetFromOriginInTiles = {
      x: gameCoordinates.mapX - origin.mapX,
      y: gameCoordinates.mapY - origin.mapY
    }, newX = offsetFromOriginInTiles.x * this.tileMap.width, newY = offsetFromOriginInTiles.y * this.tileMap.height, gameCoordinates.mapY % 2 && (newX += this.tileMap.widthOodOffset), halfScreenSize = {
      width: window.innerWidth / 2 | 0,
      height: window.innerHeight / 2 | 0
    }, newX -= halfScreenSize.width, newY -= halfScreenSize.height, this.tileOffset && (newX += this.tileOffset.x, newY += this.tileOffset.y), this.setPosition(newX, newY), this.presenter.onMapMove(gameCoordinates)
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.getMapCenter = function() {
    var mapCenter, centerX = window.innerWidth / 2 | 0, centerY = window.innerHeight / 2 | 0;
    return mapCenter = this.convertScreenCoordinatesToGameCoordinates({ x: centerX, y: centerY }, { setTileOffset: !0 })
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.convertScreenCoordinatesToGameCoordinates = function(screenCoordinates, options) {
    var bufferCoordinates;
    return bufferCoordinates = this.convertScreenCoordinatesToNodeCoordinates(screenCoordinates), this.convertBufferCoordinatesToGameCoordinates(bufferCoordinates, options)
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.convertGameCoordinatesToScreenCoordinates = function(gameCoordinates) {
    var bufferCoordinates;
    return bufferCoordinates = this.convertGameCoordinatesToBufferCoordinates(gameCoordinates), this.convertNodeCoordinatesToScreenCoordinates(bufferCoordinates)
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.convertBufferCoordinatesToGameCoordinates = function(coordinates, options) {
    options = options || {};
    var mapX, mapY, origin = this.gameCoordinates.origin, xOffset = 0;
    return mapY = coordinates.y / this.tileMap.height | 0, mapY += origin.mapY, mapY % 2 && (xOffset = this.tileMap.widthOodOffset), mapX = (coordinates.x - xOffset) / this.tileMap.width | 0, mapX += origin.mapX, options.setTileOffset && (this.tileOffset = {
      x: (coordinates.x - xOffset) % this.tileMap.width,
      y: coordinates.y % this.tileMap.height
    }), { mapX: mapX, mapY: mapY }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.convertGameCoordinatesToBufferCoordinates = function(gameCoordinates) {
    var offsetFromOriginInTiles, x, y, origin = this.gameCoordinates.origin;
    return offsetFromOriginInTiles = {
      x: gameCoordinates.mapX - origin.mapX,
      y: gameCoordinates.mapY - origin.mapY
    }, x = offsetFromOriginInTiles.x * this.tileMap.width, y = offsetFromOriginInTiles.y * this.tileMap.height, gameCoordinates.mapY % 2 && (x += this.tileMap.widthOodOffset), {
      x: x,
      y: y
    }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.initEvents = function(target) {
    this.eventInitialized || (this.eventInitialized = !0, this.__initMouseEvents(target))
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.removeEvents = function() {
    this.eventInitialized = !1
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__initMouseEvents = function(target) {
    target.addEventListener("mousedown", this.__mouseMouseDownEventHandler.bind(this)), target.addEventListener("mouseup", this.__mouseMouseUpEventHandler.bind(this)), target.addEventListener("mouseleave", this.__mouseMouseLeaveEventHandler.bind(this)), target.addEventListener("mousemove", this.__mouseMouseMoveEventHandler.bind(this)), target.addEventListener("touchstart", this.__touchDownEventHandler.bind(this)), target.addEventListener("touchend", this.__mouseMouseUpEventHandler.bind(this)), target.addEventListener("touchleave", this.__mouseMouseLeaveEventHandler.bind(this)), target.addEventListener("touchcancel", this.__mouseMouseLeaveEventHandler.bind(this)), target.addEventListener("touchmove", this.__touchMoveEventHandler.bind(this))
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__mouseMouseDownEventHandler = function(e) {
    this.mouseDown = !0, this.lastSceenX = e.screenX, this.lastSceenY = e.screenY
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__touchDownEventHandler = function(e) {
    this.mouseDown = !0;
    var touchEvent = e.targetTouches[0];
    this.lastSceenX = touchEvent.screenX, this.lastSceenY = touchEvent.screenY
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__mouseMouseLeaveEventHandler = function() {
    this.mouseDown = !1, this.draging = !1
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__mouseMouseUpEventHandler = function(e) {
    if (this.mouseDown || e.isTutorialFake)if (this.mouseDown = !1, this.draging)this.draging = !1; else {
      var bufferCoordinates, gameCoordinates, mouseX = e.clientX, mouseY = e.clientY;
      bufferCoordinates = this.convertScreenCoordinatesToNodeCoordinates({
        x: mouseX,
        y: mouseY
      }), gameCoordinates = this.convertBufferCoordinatesToGameCoordinates(bufferCoordinates), this.presenter.onMapClick(gameCoordinates)
    }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__mouseMouseMoveEventHandler = function(e) {
    var x, y;
    if (this.mouseDown) {
      this.draging = !0;
      var movementX = e.movementX || e.screenX - this.lastSceenX, movementY = e.movementY || e.screenY - this.lastSceenY;
      x = this.x - movementX, y = this.y - movementY, this.__setNewMapPosition(x, y) && (this.lastSceenX = e.screenX, this.lastSceenY = e.screenY)
    }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__touchMoveEventHandler = function(e) {
    var x, y;
    if (this.mouseDown) {
      this.draging = !0, e.preventDefault();
      var touchEvent = e.targetTouches[0], screenX = touchEvent.screenX, screenY = touchEvent.screenY, movementX = touchEvent.screenX - (this.lastSceenX || screenX), movementY = touchEvent.screenY - (this.lastSceenY || screenY);
      x = this.x - movementX, y = this.y - movementY, this.__setNewMapPosition(x, y) && (this.lastSceenX = screenX, this.lastSceenY = screenY)
    }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.moveMapByKeyboard = function(options) {
    switch (options.key) {
      case settingsGameConstant.KEYBOARD_KEYS.KEY_W:
        this.__setNewMapPosition(this.x, this.y - settingsGameConstant.MAP.MOVE_STEP);
        break;
      case settingsGameConstant.KEYBOARD_KEYS.KEY_A:
        this.__setNewMapPosition(this.x - settingsGameConstant.MAP.MOVE_STEP, this.y);
        break;
      case settingsGameConstant.KEYBOARD_KEYS.KEY_S:
        this.__setNewMapPosition(this.x, this.y + settingsGameConstant.MAP.MOVE_STEP);
        break;
      case settingsGameConstant.KEYBOARD_KEYS.KEY_D:
        this.__setNewMapPosition(this.x + settingsGameConstant.MAP.MOVE_STEP, this.y)
    }
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__setNewMapPosition = function(x, y) {
    var newMapCenter, borderOffset, xMax, yMax;
    return borderOffset = this.borderOffset, xMax = x + window.innerWidth + borderOffset, yMax = y + window.innerHeight + borderOffset, x <= borderOffset || y <= borderOffset || xMax >= this.size.width || yMax >= this.size.height ? (newMapCenter = this.getMapCenter(), this.presenter.onMapBorderReached(newMapCenter), !1) : (this.x = x, this.y = y, newMapCenter = this.getMapCenter(), this.presenter.onMapMove(newMapCenter), !0)
  }, CoreGraphicalEngineMapCanvasBuffer.prototype.__drawMap = function() {
    return servicesLog("warn", "you have to implement CoreGraphicalEngineMapCanvasBuffer.prototype.__drawMap in your child class"), null
  }, CoreGraphicalEngineMapCanvasBuffer
}]), xy.dStaticInjector.set(xy.dNames.core.graphicalEngineNode, [xy.dNames.core.coreClass, xy.dNames.core.graphicalEngineFrameManager, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.resourcesManager, function(coreCoreClass, CoreGraphicalEngineFrameManager, utilsOop, servicesLog, servicesResourcesManager) {
  "use strict";
  function CoreGraphicalEngineNode(options) {
    CoreGraphicalEngineNode.__super__.constructor.call(this, options), this.x = 0, this.y = 0, this.size = {
      width: 0,
      height: 0
    }, this.nodeOnScreenOffset = {
      x: 0,
      y: 0
    }, this.buffer = null, this.enableEvents = !1, this.rotationRadians = null, this.children = {}, this.isAnimation = !1
  }

  return utilsOop.extend(CoreGraphicalEngineNode, coreCoreClass), CoreGraphicalEngineNode.prototype.init = function(options) {
    Object.assign(this, options), this.noBufferInitialisation || this.__initBufferCanvas()
  }, CoreGraphicalEngineNode.prototype.__initBufferCanvas = function() {
    this.buffer = document.createElement("canvas"), this.canvasContext = this.buffer.getContext("2d")
  }, CoreGraphicalEngineNode.prototype.__clear = function() {
    this.rotationRadians = null, this.canvasContext = this.canvasContext || this.buffer.getContext("2d"), this.canvasContext.clearRect(0, 0, this.size.width, this.size.height)
  }, CoreGraphicalEngineNode.prototype.setSize = function(width, height) {
    this.size.width = width, this.size.height = height
  }, CoreGraphicalEngineNode.prototype.setPosition = function(x, y) {
    this.x = x, this.y = y
  }, CoreGraphicalEngineNode.prototype.movePosition = function(deltaX, deltaY) {
    deltaX = deltaX || 0, deltaY = deltaY || 0, this.x += deltaX, this.y += deltaY
  }, CoreGraphicalEngineNode.prototype.setScreenPosition = function(screenX, screenY) {
    this.screenX = screenX, this.screenY = screenY
  }, CoreGraphicalEngineNode.prototype.moveScreenPosition = function(deltaX, deltaY) {
    deltaX = deltaX || 0, deltaY = deltaY || 0, this.screenX += deltaX, this.screenY += deltaY
  }, CoreGraphicalEngineNode.prototype.convertScreenCoordinatesToNodeCoordinates = function(coordinates) {
    var bufferCoordinates;
    return bufferCoordinates = {
      x: coordinates.x + this.x - this.nodeOnScreenOffset.x,
      y: coordinates.y + this.y - this.nodeOnScreenOffset.y
    }, { x: 0 | bufferCoordinates.x, y: 0 | bufferCoordinates.y }
  }, CoreGraphicalEngineNode.prototype.convertNodeCoordinatesToScreenCoordinates = function(nodeCoordinates) {
    return { x: nodeCoordinates.x - this.x | 0, y: nodeCoordinates.y - this.y | 0 }
  }, CoreGraphicalEngineNode.prototype.addChild = function(child, options) {
    options = options || {};
    var z = options.z || 0;
    this.children.hasOwnProperty(z) || (this.children[z] = {}), this.children[z][child.instanceId] = child
  }, CoreGraphicalEngineNode.prototype.initEvents = function(target) {
    servicesLog("warn", "initEvents interface have to be implemented in node's class")
  }, CoreGraphicalEngineNode.prototype.removeEvents = function() {
    servicesLog("warn", "removeEvents interface have to be implemented in node's class")
  }, CoreGraphicalEngineNode.prototype.initFramesManager = function() {
    this.frameManager = new CoreGraphicalEngineFrameManager
  }, CoreGraphicalEngineNode.prototype.addImageFrames = function(options) {
    this.frameManager || this.initFramesManager();
    var image = servicesResourcesManager.getResourcesValue(options.image), framesData = servicesResourcesManager.getResourcesValue(options.framesData);
    this.frameManager.addFrames({ image: image, imageName: options.frameSetName, framesData: framesData })
  }, CoreGraphicalEngineNode.prototype.getImageFromFrame = function(options) {
    var canvas, ctx, frame = options.frame || this.frameManager.getFrame({
              imageName: options.imageName,
              frameName: options.frameName
            });
    return canvas = document.createElement("canvas"), frame ? (canvas.width = frame.width, canvas.height = frame.height, ctx = canvas.getContext("2d"), ctx.drawImage(frame.image, frame.xOrigin, frame.yOrigin, frame.width, frame.height, 0, 0, frame.width, frame.height)) : servicesLog("warn", "Frame can't be found image: " + options.imageName + " frame:" + options.frameName), canvas
  }, CoreGraphicalEngineNode.prototype.addImageFrame = function(options, ctx) {
    options = options || {};
    var ratio = options.scaleRatio || 1, offsetX = options.offsetX || 0, offsetY = options.offsetY || 0, frame = options.frame || this.frameManager.getFrame({
              imageName: options.imageName,
              frameName: options.frameName
            });
    if (frame) {
      var width = frame.width * ratio, height = frame.height * ratio, x = options.x * ratio + offsetX, y = options.y * ratio + offsetY;
      return ctx.drawImage(frame.image, frame.xOrigin, frame.yOrigin, frame.width, frame.height, x, y, width, height), {
        x: x,
        y: y,
        width: width,
        height: height
      }
    }
    servicesLog("warn", "Frame can't be found image: " + options.imageName + " frame:" + options.frameName)
  }, CoreGraphicalEngineNode.prototype.drawNextFrame = function() {
    servicesLog("warn", 'You have to implement "interface" drawNextFrame in animation node!')
  }, CoreGraphicalEngineNode.prototype.render = function() {
    servicesLog("warn", 'You have to implement "interface" render in actual node if you don\'t use final buffer! for that node')
  }, CoreGraphicalEngineNode
}]), xy.dStaticInjector.set(xy.dNames.core.graphicalEngineAnimation, [xy.dNames.core.graphicalEngineNode, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, function(CoreGraphicalEngineNode, utilsOop, settingsGameConstant) {
  "use strict";
  function CoreGraphicalEngineAnimation(options) {
    CoreGraphicalEngineAnimation.__super__.constructor.call(this, options), this.animationSettings = null, this.isAnimation = !0, this.currentFrame = 0, this.framesLength = 0, this.frameName = null, this.imagesFrameSet = null, this.animationSpeed = settingsGameConstant.ANIMATION_SPEED, this.lastDrawing = 0
  }

  return utilsOop.extend(CoreGraphicalEngineAnimation, CoreGraphicalEngineNode), CoreGraphicalEngineAnimation.prototype.setAnimationSpeed = function(animationSpeed) {
    this.animationSpeed = animationSpeed
  }, CoreGraphicalEngineAnimation.prototype.setFrameSet = function(options) {
    this.initFramesManager(), this.addImageFrames({
      image: options.image,
      frameSetName: options.frameSetName,
      framesData: options.framesData
    }), this.frameSetName = options.frameSetName
  }, CoreGraphicalEngineAnimation.prototype.setFrames = function(options) {
    options = options || {}, this.animationSettings = null, options.animationSettings && (this.animationSettings = options.animationSettings), options.initialFrame + 1 > 0 && (this.currentFrame = options.initialFrame), this.frameName = options.name, this.framesLength = options.framesLength
  }, CoreGraphicalEngineAnimation.prototype.setFramesFromImageArray = function(options) {
    options.initialFrame + 1 > 0 && (this.currentFrame = options.initialFrame), this.imagesFrameSet = options.imagesArray, this.framesLength = options.imagesArray.length
  }, CoreGraphicalEngineAnimation.prototype.getFrameByIndex = function(frameIndex) {
    var frameNumber, frame;
    return frameNumber = frameIndex >= this.framesLength ? 0 : frameIndex, this.animationSettings && (this.animationSettings.initialFrame = frameNumber), this.frameSetName && this.frameName ? frame = this.frameManager.getFrame({
      imageName: this.frameSetName,
      frameName: this.frameName + frameNumber
    }) : this.imagesFrameSet && (frame = {
      image: this.imagesFrameSet[frameNumber],
      xOrigin: 0,
      yOrigin: 0,
      width: this.size.width,
      height: this.size.height
    }), frame
  }, CoreGraphicalEngineAnimation.prototype.getCurrentFrame = function() {
    return this.getFrameByIndex(this.currentFrame)
  }, CoreGraphicalEngineAnimation.prototype.getNextFrame = function() {
    var frameNumber = this.currentFrame + 1;
    return frameNumber = frameNumber >= this.framesLength ? 0 : frameNumber, this.currentFrame = frameNumber, this.getFrameByIndex(frameNumber)
  }, CoreGraphicalEngineAnimation.prototype.drawNextFrame = function() {
    return this.canDrawNextFrame() && (this.__clear(), this.addImageFrame({
      frame: this.getNextFrame(),
      x: 0,
      y: 0
    }, this.canvasContext)), !0
  }, CoreGraphicalEngineAnimation.prototype.canDrawNextFrame = function() {
    var lastDrawing = this.lastDrawing, now = (new Date).getTime();
    return now - lastDrawing >= this.animationSpeed && (this.lastDrawing = now, !0)
  }, CoreGraphicalEngineAnimation
}]), xy.dStaticInjector.set(xy.dNames.core.controller, [xy.dNames.gameInstance, xy.dNames.factories.game, xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.gameDataManager, xy.dNames.services.keyboardManager, xy.dNames.services.eventManager, xy.dNames.services.internationalization, xy.dNames.components.rendererRequestPending, function(gameInstance, factoriesGame, CoreCoreClass, utilsOop, settingsGameConstant, servicesLog, servicesGameDataManager, servicesKeyboardManager, servicesEventManager, servicesInternationalization, ComponentsRendererRequestPending) {
  "use strict";
  function CoreController(options) {
    CoreController.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CoreController, CoreCoreClass), CoreController.prototype.start = function() {
    this.registerAllDataListeners(), this.runScene()
  }, CoreController.prototype.destroy = function() {
    this.deRegisterAllDataListeners(), this.presenter.clear()
  }, CoreController.prototype.showDialogAlert = function(settings) {
    var alert = gameInstance.injector.get(xy.dNames.components.dialogAlert);
    alert.show(settings), this[xy.eNames.core.pendingModeOn]({ isForce: !0 })
  }, CoreController.prototype.showDialogDialog = function(settings) {
    var dialog = gameInstance.injector.get(xy.dNames.components.dialogDialog);
    dialog.show(settings), this[xy.eNames.core.pendingModeOn]({ isForce: !0 })
  }, CoreController.prototype.showDialogNotEnoughSource = function(settings) {
    var dialogNotEnoughSource = gameInstance.injector.get(xy.dNames.components.dialogNotEnoughSource);
    dialogNotEnoughSource.show(settings), this[xy.eNames.core.pendingModeOn]({ isForce: !0 })
  }, CoreController.prototype.showNextScene = function(sceneName) {
    this.startController(sceneName, this)
  }, CoreController.prototype.showSubScene = function(sceneName, data, options) {
    return this.startController(sceneName, this, data, options)
  }, CoreController.prototype.startController = function(name, parent, data, options) {
    var controller = factoriesGame.create(name, parent, data, options);
    return controller.start(), controller
  }, CoreController.prototype.registerAllDataListeners = function() {
    void 0 !== this.dataListneners && this.dataListneners.forEach(function(listener) {
      servicesGameDataManager.registerDataUpdateListener(listener)
    }, this)
  }, CoreController.prototype.deRegisterAllDataListeners = function() {
    void 0 !== this.dataListneners && this.dataListneners.forEach(function(listener) {
      servicesGameDataManager.removeDataUpdateListener(listener)
    }, this)
  }, CoreController.prototype.registerAllKeyboardListeners = function() {
    void 0 !== this.keyboardListneners && this.keyboardListneners.forEach(function(listener) {
      servicesKeyboardManager.registerKeyboardListener(listener)
    }, this)
  }, CoreController.prototype.registerAllEventListeners = function() {
    void 0 !== this.clientEventListneners && this.clientEventListneners.forEach(function(listener) {
      servicesEventManager.registerEventListener(listener)
    }, this)
  }, CoreController.prototype.deRegisterAllKeyboardListeners = function() {
    void 0 !== this.keyboardListneners && this.keyboardListneners.forEach(function(listener) {
      servicesKeyboardManager.removeKeyboardListener(listener)
    }, this)
  }, CoreController.prototype.deRegisterAllEventListeners = function() {
    void 0 !== this.clientEventListneners && this.clientEventListneners.forEach(function(listener) {
      servicesEventManager.deRegisterEventListener(listener)
    }, this)
  }, CoreController.prototype.openUrlInNewTab = function(url) {
    if (url && "string" == typeof url) {
      var win = window.open(url, "_blank");
      if (win)win.focus(); else {
        var settings = {
          title: servicesInternationalization.localize("Error"),
          text: servicesInternationalization.localize("Please allow popups for this website")
        };
        this.showDialogAlert(settings)
      }
    }
  }, CoreController.prototype[xy.eNames.core.networkHardRequestFail] = function() {
    var settings;
    settings = navigator.onLine ? {
      title: servicesInternationalization.localize("Error"),
      text: servicesInternationalization.localize("We are currently under maintenance. Please try again later!")
    } : {
      title: servicesInternationalization.localize("No Internet Connection"),
      text: servicesInternationalization.localize("Please check your internet connection and then try again. Feel free to contact our support if the problem persists: https://xyrality.helpshift.com/")
    }, this.showDialogAlert(settings)
  }, CoreController.prototype[xy.eNames.core.networkSoftRequestFail] = function(data, options) {
    var settings, clientCommand = data.clientCommand || !1, CONST = settingsGameConstant.CLIENT_COMMAND_ACTION;
    if (clientCommand)switch (settings = {
      title: servicesInternationalization.localize("Error"),
      text: clientCommand.isLocalized ? clientCommand.message : servicesInternationalization.localize(clientCommand.message)
    }, clientCommand.action) {
      case CONST.showDialog:
        this.showDialogAlert(settings);
        break;
      case CONST.updateSession:
        clientCommand.message && this.showDialogAlert(settings), this.dataSource.doSessionUpdate();
        break;
      case CONST.callCallbackAndUpdateSession:
        clientCommand && this.showDialogAlert(settings), "function" == typeof options.callBack && options.callBack.call(this.dataSource, data), this.dataSource.doSessionUpdate();
        break;
      case CONST.logout:
      case CONST.noSession:
        clientCommand.message && this.showDialogAlert(settings), this.notify(xy.eNames.sceneGame.onLogoutEvent);
        break;
      case CONST.clearCache:
        servicesLog("warn", "client command handler need to be implemented"), servicesLog("debug", data);
        break;
      default:
        servicesLog("debug", data), servicesLog("warn", "unknown client command")
    } else settings = {
      title: servicesInternationalization.localize("Error"),
      text: data.localized || servicesInternationalization.localize(data.error)
    }, this.showDialogAlert(settings)
  }, CoreController.prototype[xy.eNames.core.isPendingModeOn] = function() {
    return ComponentsRendererRequestPending.isPendingMode()
  }, CoreController.prototype[xy.eNames.core.pendingModeOn] = function(options) {
    ComponentsRendererRequestPending.progress(options || {})
  }, CoreController.prototype[xy.eNames.core.pendingModeOff] = function() {
    ComponentsRendererRequestPending.done()
  }, CoreController.prototype[xy.eNames.core.isCurrentWorld] = function(worldId) {
    if (worldId === servicesGameDataManager.settings.worldId)return !0;
    var settings = {
      title: servicesInternationalization.localize("Error"),
      text: servicesInternationalization.localize("Link related to other world, can not be opened")
    };
    return this.showDialogAlert(settings), !1
  }, CoreController.prototype[xy.eNames.core.displayModelLink] = function(object) {
    servicesGameDataManager.setActiveModelLink(object)
  }, CoreController.prototype[xy.eNames.core.clearModelLink] = function() {
    servicesGameDataManager.clearActiveModelLink()
  }, CoreController
}]), xy.dStaticInjector.set(xy.dNames.core.controllerElement, [xy.dNames.core.controller, xy.dNames.utils.oop, function(CoreController, utilsOop) {
  "use strict";
  function CoreControllerElementScene(options) {
    CoreControllerElementScene.__super__.constructor.call(this, options), this.isActive = !1, this.localizedName = ""
  }

  return utilsOop.extend(CoreControllerElementScene, CoreController), CoreControllerElementScene.prototype.runScene = function(data) {
    this.presenter.draw(data)
  }, CoreControllerElementScene.prototype.isVisible = function() {
    return this.isActive || !1
  }, CoreControllerElementScene.prototype.activate = function() {
    this.isActive = !0
  }, CoreControllerElementScene.prototype.deActivate = function() {
    this.isActive = !1
  }, CoreControllerElementScene
}]), xy.dStaticInjector.set(xy.dNames.core.controllerCanvas, [xy.dNames.core.controller, xy.dNames.utils.oop, xy.dNames.services.log, function(CoreController, utilsOop, servicesLog) {
  "use strict";
  function CoreControllerEngineScene(options) {
    CoreControllerEngineScene.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CoreControllerEngineScene, CoreController), CoreControllerEngineScene.prototype.runScene = function() {
    servicesLog("warn", "PLease implement method runScene"), servicesLog("debug", this)
  }, CoreControllerEngineScene.prototype.destroy = function() {
    servicesLog("log", "PLease implement method destroy"), servicesLog("debug", this)
  }, CoreControllerEngineScene
}]), xy.dStaticInjector.set(xy.dNames.core.controllerElementMenu, [xy.dNames.core.controllerElement, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(CoreControllerElement, utilsOop, utilsObject, settingsGameConstant, servicesLog) {
  "use strict";
  function CoreControllerElementMenu(options) {
    CoreControllerElementMenu.__super__.constructor.call(this, options), this.isRoot = !1, this.isDelayedChildrenLoading = !1, this.isRestart = !1, this.children = {}, this.activeKey = null, this.localizedNameOfPreviousView = "", this.localUpdateInterval = !1, this.initialOptions && (this.isRoot = this.initialOptions.isRoot, this.localizedNameOfPreviousView = this.initialOptions.localizedNameOfPreviousView)
  }

  return utilsOop.extend(CoreControllerElementMenu, CoreControllerElement), CoreControllerElementMenu.prototype.isVisible = function() {
    return this.isActive || this.isRoot || !1
  }, CoreControllerElementMenu.prototype.start = function(options) {
    return options = options || {}, this.activate(), this.registerAllDataListeners(), this.presenter.init(), this.setLocalizedName && this.setLocalizedName(), this.prepareDataForDraw(), this.reRunLocalUpdate(), options.isRestart && (this.isRestart = !0), !this.isDelayedChildrenLoading && options.isRestart && this.restoreLastInStack(), !0
  }, CoreControllerElementMenu.prototype.destroy = function(softPresenterClear) {
    if (this.stopLocalUpdate(), this.deRegisterAllDataListeners(), softPresenterClear || this.presenter.clear(), this.activeKey && this.children[this.activeKey]) {
      var len = this.children[this.activeKey].length;
      len && this.children[this.activeKey][len - 1].destroy()
    }
    this.children = {}
  }, CoreControllerElementMenu.prototype.hide = function() {
    if (this.stopLocalUpdate(!0), this.deRegisterAllDataListeners(), this.deActivate(), this.presenter.clear(), this.activeKey && this.children[this.activeKey]) {
      var len = this.children[this.activeKey].length;
      len && this.children[this.activeKey][len - 1].hide()
    }
    return !0
  }, CoreControllerElementMenu.prototype.scheduleLocalUpdate = function(f, isForced) {
    this.localUpdateFunction = f, isForced && this.localUpdateInterval && clearTimeout(this.localUpdateInterval), this.localUpdateInterval = setTimeout(function() {
      this.localUpdateInterval = !1, this.isVisible() && f()
    }.bind(this), settingsGameConstant.SESSION_UPDATE_SCHEDULE_INTERVAL)
  }, CoreControllerElementMenu.prototype.reRunLocalUpdate = function() {
    this.localUpdateFunction && this.scheduleLocalUpdate(this.localUpdateFunction, !0)
  }, CoreControllerElementMenu.prototype.stopLocalUpdate = function(isSoftStop) {
    try {
      isSoftStop || (this.localUpdateFunction = null), clearTimeout(this.localUpdateInterval)
    } catch (e) {
      servicesLog("warn", e)
    }
  }, CoreControllerElementMenu.prototype.showNextMenu = function(viewName, options) {
    return this.isRoot ? this.startController(viewName, options.parent || this, null, options) : void this.controller.notify("showNextMenu", viewName, options)
  }, CoreControllerElementMenu.prototype.restoreLastInStack = function() {
    if (this.isRoot) {
      var lastInStack, lastIndex = this.children[this.activeKey] instanceof Array ? this.children[this.activeKey].length - 1 : -1;
      return lastIndex > -1 && (lastInStack = this.children[this.activeKey][lastIndex], lastInStack.start(), !0)
    }
    return this.controller.notify("restoreLastInStack")
  }, CoreControllerElement.prototype[xy.eNames.menu.onDataError] = function(exception) {
    servicesLog("warn", "Current menu closed cause of data error"), exception.debug ? exception.debug() : servicesLog("debug", exception), this[xy.eNames.menu.openPrevView]()
  }, CoreControllerElement.prototype[xy.eNames.menu.onDataExpired] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, CoreControllerElementMenu.prototype[xy.eNames.menu.openPrevView] = function() {
    if (this.isRoot) {
      if (this.children[this.activeKey]) {
        var currentMenuView = this.children[this.activeKey].pop();
        currentMenuView.destroy(this.restoreLastInStack())
      }
    } else this.controller.notify(xy.eNames.menu.openPrevView)
  }, CoreControllerElementMenu.prototype[xy.eNames.menu.closeViewUpToSelf] = function(options) {
    if (this.isRoot) {
      var i, childMenuView, nextToNotifierMenuView, a = this.children[this.activeKey] || [], len = a.length, proceed = !1, newChildrenQueue = [];
      for (i = 0; i < len; i += 1)if (childMenuView = a[i], newChildrenQueue.push(childMenuView), childMenuView.instanceId === options.key) {
        proceed = !0, nextToNotifierMenuView = a[i + 1];
        break
      }
      proceed ? (this.children[this.activeKey] = newChildrenQueue, nextToNotifierMenuView instanceof CoreControllerElementMenu && nextToNotifierMenuView.destroy(this.restoreLastInStack())) : this[xy.eNames.menu.closeViewUpToRoot]()
    } else this.controller.notify(xy.eNames.menu.closeViewUpToSelf, options)
  }, CoreControllerElementMenu.prototype[xy.eNames.menu.closeViewUpToRoot] = function() {
    if (this.isRoot) {
      if (this.children[this.activeKey] && this.children[this.activeKey].length) {
        var firstMenuView = this.children[this.activeKey].pop();
        this.children[this.activeKey] = [], firstMenuView.destroy()
      }
    } else this.controller.notify(xy.eNames.menu.closeViewUpToRoot)
  }, CoreControllerElementMenu.prototype[xy.eNames.menu.updateOnRoot] = function() {
    if (this.isRoot) {
      this.prepareDataForDraw();
      var lastInStack, lastIndex = this.children[this.activeKey] instanceof Array ? this.children[this.activeKey].length - 1 : -1;
      lastIndex > -1 && (lastInStack = this.children[this.activeKey][lastIndex], lastInStack.prepareDataForDraw())
    } else this.controller.notify(xy.eNames.menu.updateOnRoot)
  }, CoreControllerElementMenu.prototype[xy.eNames.menu.openNextView] = function(nextDrillDownMenuName, options) {
    options = options || {}, options.parent || (options.parent = this);
    var activeKey = nextDrillDownMenuName + "-" + utilsObject.getUniqueSignatureOfObject(options);
    if (this.isRoot) {
      var nextDrillDownMenu;
      this.activeKey && this.children[this.activeKey] && this.children[this.activeKey].length > 0 && this.children[this.activeKey][this.children[this.activeKey].length - 1].deActivate(), options.isClickOnRoot ? this.children[this.activeKey] && 0 !== this.children[this.activeKey].length && this.activeKey !== activeKey ? this.activeKey && this.activeKey !== activeKey ? (this.activeKey = activeKey, this.children[this.activeKey] && this.children[this.activeKey].length ? this.restoreLastInStack() : (nextDrillDownMenu = this.showNextMenu(nextDrillDownMenuName, options), this.children[this.activeKey] = [], this.children[this.activeKey].push(nextDrillDownMenu))) : this.restoreLastInStack() : (this.activeKey = activeKey, nextDrillDownMenu = this.showNextMenu(nextDrillDownMenuName, options), this.children[this.activeKey] = [], this.children[this.activeKey].push(nextDrillDownMenu)) : (nextDrillDownMenu = this.showNextMenu(nextDrillDownMenuName, options), this.children[this.activeKey].push(nextDrillDownMenu))
    } else this.controller.notify(xy.eNames.menu.openNextView, nextDrillDownMenuName, options)
  }, CoreControllerElementMenu.prototype[xy.eNames.menu.onRefreshCall] = function() {
    this.prepareDataForDraw()
  }, CoreControllerElementMenu
}]), xy.dStaticInjector.set(xy.dNames.core.controllerElementGlobalOverview, [xy.dNames.core.controllerElement, xy.dNames.utils.oop, function(CoreControllerElement, utilsOop) {
  "use strict";
  function CoreControllerElementGlobalOverview(options) {
    this.flagPendingModeOn = !1, CoreControllerElementGlobalOverview.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CoreControllerElementGlobalOverview, CoreControllerElement), CoreControllerElementGlobalOverview.prototype.start = function() {
    return this.presenter.init(), this.activate(), this.registerAllDataListeners(), this.requestPendingMode(), !0
  }, CoreControllerElementGlobalOverview.prototype.hide = function() {
    return this.deRegisterAllDataListeners(), this.deActivate(), this.presenter.clear(), !0
  }, CoreControllerElementGlobalOverview.prototype.shutDown = function() {
    return this.deRegisterAllDataListeners(), this.deActivate(), !0
  }, CoreControllerElementGlobalOverview.prototype.requestPendingMode = function() {
    this.flagPendingModeOn || (this.flagPendingModeOn = !0, this[xy.eNames.core.pendingModeOn]({ callback: this.prepareDataForDraw.bind(this) }))
  }, CoreControllerElementGlobalOverview.prototype[xy.eNames.eventSceneGlobalOverview.releasePendingMode] = function() {
    this.flagPendingModeOn && (this[xy.eNames.core.pendingModeOff](), this.flagPendingModeOn = !1, this.notify(xy.eNames.eventSceneGlobalOverview.globalOverviewIsDrawn))
  }, CoreControllerElementGlobalOverview
}]), xy.dStaticInjector.set(xy.dNames.core.presenterElement, [xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.componentsEngine, function(CoreClass, utilsOop, servicesLog, componentsEngine) {
  "use strict";
  function CorePresenterElementMenu(options) {
    CorePresenterElementMenu.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CorePresenterElementMenu, CoreClass), CorePresenterElementMenu.prototype.init = function() {
    servicesLog("warn", "You have to implement init method for your element presenter")
  }, CorePresenterElementMenu.prototype.clear = function() {
    var el = document.getElementById(this.domElement);
    el && componentsEngine.unmountComponentAtNode(el)
  }, CorePresenterElementMenu
}]), xy.dStaticInjector.set(xy.dNames.core.presenterGraphicEngine, [xy.dNames.core.graphicalEngineNode, xy.dNames.utils.oop, xy.dNames.graphicEngine.mainDirector, xy.dNames.services.log, function(CoreGraphicalEngineNode, utilsOop, graphicEngineMainDirector, servicesLog) {
  "use strict";
  function CorePresenterGraphicEngine(options) {
    CorePresenterGraphicEngine.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CorePresenterGraphicEngine, CoreGraphicalEngineNode), CorePresenterGraphicEngine.prototype.runScene = function() {
    servicesLog("warn", "runScene interface have to be implemented in presenter't class")
  }, CorePresenterGraphicEngine.prototype.clearScene = function() {
    graphicEngineMainDirector.clearScene()
  }, CorePresenterGraphicEngine
}]), xy.dStaticInjector.set(xy.dNames.core.presenterElementMenu, [xy.dNames.core.presenterElement, xy.dNames.utils.oop, function(CorePresenterElement, utilsOop) {
  "use strict";
  function CorePresenterElementMenu(options) {
    CorePresenterElementMenu.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CorePresenterElementMenu, CorePresenterElement), CorePresenterElementMenu.prototype.init = function() {
    this.domElement = this.controller.isRoot ? xy.DomElements.gameMenuRoot : xy.DomElements.gameMenuDrillDown
  }, CorePresenterElementMenu
}]), xy.dStaticInjector.set(xy.dNames.core.presenterElementGlobalOverview, [xy.dNames.core.presenterElement, xy.dNames.utils.oop, function(CorePresenterElement, utilsOop) {
  "use strict";
  function CorePresenterElementGlobalOverview(options) {
    CorePresenterElementGlobalOverview.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CorePresenterElementGlobalOverview, CorePresenterElement), CorePresenterElementGlobalOverview.prototype.init = function() {
    this.domElement = xy.DomElements.gameGlobalOverview
  }, CorePresenterElementGlobalOverview
}]), xy.dStaticInjector.set(xy.dNames.core.dataSource, [xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.network, xy.dNames.services.gameDataManager, function(CoreCoreClass, utilsOop, servicesLog, servicesNetwork, servicesGameDataManager) {
  "use strict";
  function CoreDataSource(options) {
    CoreDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(CoreDataSource, CoreCoreClass), CoreDataSource.prototype.sessionUpdate = function(data) {
    servicesLog("warn", "CoreDataSource.sessionUpdate" + data), servicesLog("debug", data)
  }, CoreDataSource.prototype.requestCallBack = function(status, data, options) {
    servicesLog("log", "response"), servicesLog("log", data);
    var callBack = "function" == typeof options.callBack ? options.callBack : this.sessionUpdate;
    switch (this.notify(xy.eNames.core.pendingModeOff), status) {
      case"success":
        callBack.call(this, data, options);
        break;
      case"soft-fail":
        this.notify(xy.eNames.core.networkSoftRequestFail, data, options), options.errorCallBack && options.errorCallBack.call(this, data, options);
        break;
      default:
        this.notify(xy.eNames.core.networkHardRequestFail)
    }
  }, CoreDataSource.prototype.request = function(params, action, options) {
    this.notify(xy.eNames.core.pendingModeOn), options = options || {}, options.dataSource = this, servicesNetwork.request(params, action, options)
  }, CoreDataSource.prototype.doSessionUpdate = function(params) {
    params = params || {
              isReconnect: !1,
              doRecheckLogin: !1
            }, this.request(params, "SessionAction/update", { callBack: this.handleSessionUpdateResponse })
  }, CoreDataSource.prototype.handleSessionUpdateResponse = function(data) {
    servicesGameDataManager.receiveGameData(data)
  }, CoreDataSource
}]), xy.dStaticInjector.set(xy.dNames.core.model, [xy.dNames.core.coreClass, xy.dNames.utils.oop, function(CoreCoreClass, utilsOop) {
  "use strict";
  function CoreModel(options) {
    CoreModel.__super__.constructor.call(this, options), this.convertToCorrectDataType(), void 0 !== this.finalisation && this.finalisation()
  }

  return utilsOop.extend(CoreModel, CoreCoreClass), CoreModel.prototype.convertToCorrectDataType = function() {
    var key;
    for (key in this.correctDataType)this.correctDataType.hasOwnProperty(key) && this[key] && (this[key] = this.correctDataType[key](this[key]))
  }, CoreModel.prototype.update = function(newData) {
    Object.assign(this, newData), this.convertToCorrectDataType(), void 0 !== this.finalisation && this.finalisation()
  }, CoreModel
}]), xy.dStaticInjector.set(xy.dNames.core.modelInProgress, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, function(CoreModel, utilsOop, utilsDateTime, settingsGameConstant) {
  "use strict";
  function ModelInProgress(options) {
    ModelInProgress.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelInProgress, CoreModel), ModelInProgress.prototype.isLessThanHalfConstructionTimeRemain = function() {
    if (settingsGameConstant.UPGRADE_DURATION_THRESHOLD >= this.durationFactor)return !0;
    var remainTimeBeforeComplete = utilsDateTime.remainTimeInSeconds(this.complete), constructionTimeInSeconds = this.durationInSeconds, remainTimeBeforeStart = remainTimeBeforeComplete - constructionTimeInSeconds;
    return remainTimeBeforeStart < 0 && (remainTimeBeforeStart = 0), remainTimeBeforeComplete < constructionTimeInSeconds / 2 + remainTimeBeforeStart
  }, ModelInProgress.prototype.wasSpeedUp = function() {
    return settingsGameConstant.UPGRADE_DURATION_THRESHOLD >= this.durationFactor
  }, ModelInProgress.prototype.doesHalfTimeOfConstructionPassNormally = function() {
    var noSpeedUp = settingsGameConstant.UPGRADE_DURATION_THRESHOLD < this.durationFactor, remainTimeBeforeComplete = utilsDateTime.remainTimeInSeconds(this.complete), constructionTimeInSeconds = this.durationInSeconds, remainTimeBeforeStart = remainTimeBeforeComplete - constructionTimeInSeconds;
    return remainTimeBeforeStart < 0 && (remainTimeBeforeStart = 0), noSpeedUp && remainTimeBeforeComplete < constructionTimeInSeconds / 2 + remainTimeBeforeStart
  }, ModelInProgress
}]), xy.dStaticInjector.set(xy.dNames.core.modelAlliance, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.string, xy.dNames.services.theme, xy.dNames.services.network, function(CoreModel, utilsOop, utilsConverter, utilsString, servicesTheme, servicesNetwork) {
  "use strict";
  function ModelAlliance(options) {
    this.updated = !1, this.allianceAplicants = {}, ModelAlliance.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelAlliance, CoreModel), ModelAlliance.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    points: utilsConverter.toNumber,
    pointsAverage: utilsConverter.toNumber,
    rank: utilsConverter.toNumber,
    rankAverage: utilsConverter.toNumber,
    settingDurationOfPlayerHabitatReservation: utilsConverter.toNumber,
    settingNumberOfPlayerHabitatReservation: utilsConverter.toNumber
  }, ModelAlliance.prototype.finalisation = function() {
    if (this.isPeripheral && (this.cachedAt = new Date), this.invitedPlayerArray) {
      var i, len = this.invitedPlayerArray.length;
      for (i = 0; i < len; i += 1)this.invitedPlayerArray[i] = +this.invitedPlayerArray[i]
    }
    this.extractAllianceApplicants()
  }, ModelAlliance.prototype.extractAllianceApplicants = function() {
    this.allianceAplicants = {}, this.applicantArray && this.applicantArray.length && this.applicantArray.forEach(function(playerId) {
      this.allianceAplicants[playerId] = !0
    }, this)
  }, ModelAlliance.prototype.getLink = function() {
    return utilsString.sprintf(servicesTheme.themeSettings.linksFormat.alliance, this.id, servicesNetwork.worldId)
  }, ModelAlliance
}]), xy.dStaticInjector.set(xy.dNames.core.modelAllianceClash, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.sessionUpdateSchedule, xy.dNames.services.worldSettings, function(CoreModel, utilsOop, utilsConverter, utilsDateTime, settingsGameConstant, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelAllianceClashTransit(options) {
    this.isBattle = !1, ModelAllianceClashTransit.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelAllianceClashTransit, CoreModel), ModelAllianceClashTransit.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    affectedHabitat: utilsConverter.toNumber,
    battleType: utilsConverter.toNumber,
    eventDate: utilsConverter.toDate,
    isBattle: utilsConverter.toBoolean
  }, ModelAllianceClashTransit.prototype.finalisation = function() {
    this.eventDate && servicesSessionUpdateSchedule.scheduleDate(this.eventDate)
  }, ModelAllianceClashTransit
}]), xy.dStaticInjector.set(xy.dNames.core.modelAllianceRelation, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelAllianceRelation(options) {
    ModelAllianceRelation.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelAllianceRelation, CoreModel), ModelAllianceRelation.prototype.correctDataType = {
    relationship: utilsConverter.toNumber,
    targetAlliance: utilsConverter.toNumber
  }, ModelAllianceRelation
}]), xy.dStaticInjector.set(xy.dNames.core.modelAllianceFeedReport, [xy.dNames.gameInstance, xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.utils.converter, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(gameInstance, CoreModel, utilsOop, utilsDateTime, utilsConverter, servicesInternationalization, servicesTheme, settingsGameConstant) {
  "use strict";
  function ModelAllianceFeedReport(options) {
    this.isRead = !1, this.title = "", this.description = "", this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager), ModelAllianceFeedReport.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelAllianceFeedReport, CoreModel), ModelAllianceFeedReport.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    alliance: utilsConverter.toNumber,
    receivingPlayer: utilsConverter.toNumber,
    sendingPlayer: utilsConverter.toNumber,
    type: utilsConverter.toNumber,
    date: utilsConverter.toDate
  }, ModelAllianceFeedReport.prototype.finalisation = function() {
    this.prepareTitle()
  }, ModelAllianceFeedReport.prototype.prepareTitle = function() {
    var description, subType, reqEntity, themeSettings = servicesTheme.themeSettings, title = themeSettings.featureAllianceNewsFeed.types[this.type];
    switch (this.type) {
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.NEW_RANK:
        this.title = servicesInternationalization.localize(title);
        var oldRank = +this.variables.oldRankingPosition, newRank = +this.variables.newRankingPosition, iconType = oldRank > newRank ? "13.1" : "13.2";
        this.icon = themeSettings.imagesClassNames.featureAllianceNewsFeed[iconType], this.description = utilsDateTime.getLocaleDateTimeString(this.date) + " - " + servicesInternationalization.localize("New rank (%@)", newRank);
        break;
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.CASTLE_LOST:
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.CASTLE_CONQUERED:
        reqEntity = this.servicesGameDataManager.playersCollection.getPlayer(this.sendingPlayer), this.title = reqEntity ? reqEntity.nick : "", subType = this.type + "." + this.variables.capturedHabitat.publicHabitatType, description = themeSettings.featureAllianceNewsFeed.types[subType], this.icon = themeSettings.imagesClassNames.featureAllianceNewsFeed[subType], this.description = utilsDateTime.getLocaleDateTimeString(this.date) + " - " + servicesInternationalization.localize(description);
        break;
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.ALLIANCE_STATUS_CHANGED:
        this.title = this.variables.alliance.name, description = themeSettings.featureAllianceNewsFeed.types[this.type], this.icon = themeSettings.imagesClassNames.featureAllianceNewsFeed[this.type], this.description = utilsDateTime.getLocaleDateTimeString(this.date) + " - " + servicesInternationalization.localize(description);
        break;
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.INVITATION_SENT:
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.PLAYER_DISMISSED:
      case settingsGameConstant.ALLIANCE_REPORT_TYPE.RIGHTS_CHANGED:
        reqEntity = this.servicesGameDataManager.playersCollection.getPlayer(this.receivingPlayer), this.title = reqEntity ? reqEntity.nick : "", description = themeSettings.featureAllianceNewsFeed.types[this.type], this.icon = themeSettings.imagesClassNames.featureAllianceNewsFeed[this.type], this.description = utilsDateTime.getLocaleDateTimeString(this.date) + " - " + servicesInternationalization.localize(description);
        break;
      default:
        reqEntity = this.servicesGameDataManager.playersCollection.getPlayer(this.sendingPlayer), this.title = reqEntity ? reqEntity.nick : "", description = themeSettings.featureAllianceNewsFeed.types[this.type], this.icon = themeSettings.imagesClassNames.featureAllianceNewsFeed[this.type], this.description = utilsDateTime.getLocaleDateTimeString(this.date) + " - " + servicesInternationalization.localize(description)
    }
  }, ModelAllianceFeedReport
}]), xy.dStaticInjector.set(xy.dNames.core.modelAllianceSharing, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelAllianceSharing(options) {
    ModelAllianceSharing.__super__.constructor.call(this, options), this.targetAlliance = null
  }

  return utilsOop.extend(ModelAllianceSharing, CoreModel), ModelAllianceSharing.prototype.correctDataType = {
    accepted: utilsConverter.toBoolean,
    destinationAlliance: utilsConverter.toNumber,
    sourceAlliance: utilsConverter.toNumber,
    type: utilsConverter.toNumber
  }, ModelAllianceSharing
}]), xy.dStaticInjector.set(xy.dNames.core.modelAutomaticConquestPointTradingSettings, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, function(CoreModel, utilsOop, utilsConverter, utilsDateTime) {
  "use strict";
  function ModelAutomaticConquestPointTradingSettings(options) {
    this.habitatArray = [], ModelAutomaticConquestPointTradingSettings.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelAutomaticConquestPointTradingSettings, CoreModel), ModelAutomaticConquestPointTradingSettings.prototype.correctDataType = {
    nextTradeTime: utilsConverter.toDate,
    activatedUntil: utilsConverter.toDate,
    playerGold: utilsConverter.toNumber
  }, ModelAutomaticConquestPointTradingSettings.prototype.getActiveStatus = function() {
    return this.activatedUntil && utilsDateTime.remainTimeInSeconds(this.activatedUntil)
  }, ModelAutomaticConquestPointTradingSettings.prototype.areAllSelectedHabitatSaved = function(selectedHabitats) {
    var habitatIdKey, storedHabitats = {};
    this.habitatArray.forEach(function(habitatId) {
      storedHabitats[habitatId] = !0
    }, this);
    for (habitatIdKey in selectedHabitats)if (selectedHabitats.hasOwnProperty(habitatIdKey) && selectedHabitats[habitatIdKey] && !storedHabitats[habitatIdKey])return !1;
    return !0
  }, ModelAutomaticConquestPointTradingSettings
}]), xy.dStaticInjector.set(xy.dNames.core.modelBuff, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreModel, utilsOop, utilsConverter, utilsDateTime, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function ModelBuff(options) {
    ModelBuff.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelBuff, CoreModel), ModelBuff.prototype.correctDataType = {
    primaryKey: utilsConverter.toNumber,
    order: utilsConverter.toNumber,
    goldAmount: utilsConverter.toNumber,
    lifetimeInSeconds: utilsConverter.toNumber,
    percentageInt: utilsConverter.toNumber,
    percentageScale: utilsConverter.toNumber,
    type: utilsConverter.toNumber
  }, ModelBuff.prototype.finalisation = function() {
    this.icon = "icon-game icon-Buff" + settingsGameConstant.BUFF_TYPE[this.type];
    var rowPercent = this.percentageInt / Math.pow(10, this.percentageScale - 2);
    switch (this.percent = rowPercent > 100 ? rowPercent - 100 : rowPercent, this.identifier) {
      case"ResourceProductionFortress":
      case"ResourceProduction":
        this.title = servicesInternationalization.localize(this.identifier + "-benefit", this.percent);
        break;
      default:
        this.title = servicesInternationalization.localize(this.identifier)
    }
    this.humanTimeDuration = utilsDateTime.secondsToTimeString(this.lifetimeInSeconds, !0)
  }, ModelBuff
}]), xy.dStaticInjector.set(xy.dNames.core.modelBuffActive, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.sessionUpdateSchedule, function(CoreModel, utilsOop, utilsConverter, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelBuffActive(options) {
    ModelBuffActive.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelBuffActive, CoreModel), ModelBuffActive.prototype.correctDataType = {
    buffId: utilsConverter.toNumber,
    expirationDate: utilsConverter.toDate
  }, ModelBuffActive.prototype.finalisation = function() {
    this.expirationDate && servicesSessionUpdateSchedule.scheduleDate(this.expirationDate)
  }, ModelBuffActive
}]), xy.dStaticInjector.set(xy.dNames.core.modelDefaultSettings, [xy.dNames.core.model, xy.dNames.utils.oop, function(CoreModel, utilsOop) {
  "use strict";
  function ModelDefaultSettings(options) {
    ModelDefaultSettings.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelDefaultSettings, CoreModel), ModelDefaultSettings.prototype.finalisation = function() {
    this.castingSettings()
  }, ModelDefaultSettings.prototype.castingSettings = function() {
    var key;
    for (key in this)if (this.hasOwnProperty(key) && "string" == typeof this[key])switch (this[key]) {
      case"true":
        this[key] = !0;
        break;
      case"false":
        this[key] = !1;
        break;
      default:
        this[key] && !isNaN(+this[key]) && (this[key] = +this[key])
    }
  }, ModelDefaultSettings
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatBasic, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.string, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.network, xy.dNames.services.worldSettings, function(CoreModel, utilsOop, utilsString, settingsGameConstant, servicesTheme, servicesNetwork, servicesWorldSettings) {
  "use strict";
  function ModelHabitatBasic(options) {
    ModelHabitatBasic.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatBasic, CoreModel), ModelHabitatBasic.prototype.setPossibleNextBattleDate = function() {
    if (this.nextBattleDate)this.possibleNextBattleDate = new Date(this.nextBattleDate.getTime()); else if (this.servicesGameDataManager.habitatsCollection.isHabitatUnderAttack(this.id) && this.habitatTransitArray instanceof Array) {
      var nextBattleDate = 0;
      this.habitatTransitArray.forEach(function(transitPrimaryKey) {
        var modeledTransit = this.servicesGameDataManager.transitsCollection.getTransit(transitPrimaryKey);
        modeledTransit && modeledTransit.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK && (!nextBattleDate || nextBattleDate > modeledTransit.destinationETA) && (nextBattleDate = new Date(modeledTransit.destinationETA.getTime()))
      }, this), this.possibleNextBattleDate = nextBattleDate
    }
  }, ModelHabitatBasic.prototype.updateDistanceToActiveHabitat = function(activeHabitatPosition) {
    this.distanceToActiveHabitat = this.computeDistanceBetweenHabitats(activeHabitatPosition)
  }, ModelHabitatBasic.prototype.computeDistanceBetweenHabitats = function(habitatBPosition) {
    var distance, xA, yA, xB, yB, deltaX, deltaY;
    return habitatBPosition = habitatBPosition || {}, xB = 0 | habitatBPosition.mapX, yB = 0 | habitatBPosition.mapY, 1 & yB && (xB += .5), yA = this.mapY, xA = this.mapX, 1 & yA && (xA += .5), deltaX = Math.abs(xA - xB), deltaY = Math.abs(yA - yB), distance = .5 * deltaY >= deltaX ? deltaY : .5 * deltaY + deltaX
  }, ModelHabitatBasic.prototype.isAnotherHabitatToFarAway = function(distanceToAnotherHabitat) {
    var transitDistanceMultiplier = servicesWorldSettings.settings.transitDistanceMultiplier || 1, isDistanceLimitSet = servicesWorldSettings.isDistanceLimited();
    return isDistanceLimitSet && transitDistanceMultiplier * distanceToAnotherHabitat > this.points
  }, ModelHabitatBasic.prototype.getLink = function() {
    return utilsString.sprintf(servicesTheme.themeSettings.linksFormat.habitat, this.mapX, this.mapY, servicesNetwork.worldId)
  }, ModelHabitatBasic
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatGame, [xy.dNames.gameInstance, xy.dNames.core.modelHabitatBasic, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.utils.converter, xy.dNames.utils.number, xy.dNames.settings.gameConstant, xy.dNames.services.sessionUpdateSchedule, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.services.log, function(gameInstance, CoreModelHabitatBasic, utilsOop, utilsObject, utilsConverter, utilsNumber, settingsGameConstant, servicesSessionUpdateSchedule, servicesInternationalization, servicesTheme, servicesWorldSettings, servicesLog) {
  "use strict";
  function ModelHabitatGame(options) {
    this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager), this.isOwnByPlayer = !1, this.isRenegade = !0, this.modifierList = null, this.cachedModifers = {}, this.possibleBuffsIds = [], this.cachedBuffs = {}, this.mapX = 0, this.mapY = 0, ModelHabitatGame.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatGame, CoreModelHabitatBasic), ModelHabitatGame.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    alliance: utilsConverter.toNumber,
    publicHabitatType: utilsConverter.toNumber,
    habitatType: utilsConverter.toNumber,
    points: utilsConverter.toNumber,
    mapX: utilsConverter.toNumber,
    mapY: utilsConverter.toNumber,
    player: utilsConverter.toNumber,
    restockResourcesCoolDown: utilsConverter.toNumber,
    transitCount: utilsConverter.toNumber,
    nextBattleDate: utilsConverter.toDate,
    nextTransitArrivalDate: utilsConverter.toDate,
    nextLegalRestockDate: utilsConverter.toDate,
    noobProtectionEndDate: utilsConverter.toDate
  }, ModelHabitatGame.prototype.finalisation = function() {
    if (!this.name) {
      var freeName = servicesTheme.themeSettings.habitat.emptyNameByHabitatType[this.habitatType || this.publicHabitatType];
      this.name = servicesInternationalization.localize(freeName) + " " + this.id
    }
    this.player && (this.isRenegade = !1), this.isPeripheral && (this.cachedAt = new Date), this.nextTransitArrivalDate && servicesSessionUpdateSchedule.scheduleDate(this.nextTransitArrivalDate), this.possibleNextBattleDate = 0, this.setPossibleNextBattleDate(), this.nextBattleDate && servicesSessionUpdateSchedule.scheduleDate(this.nextBattleDate), this.habitatKnowledgeIdArray instanceof Array && (this.habitatKnowledgesSet = {}, this.habitatKnowledgeIdArray.forEach(function(knowledgePK) {
      this.habitatKnowledgesSet[knowledgePK] = !0
    }, this)), this.extractModifiersList(), this.extractBuffsList(), this.extractMissionsList(), this.extractAvailableForResearchKnowledgeSet(), this.extractAvailableUnitsForRecruitment()
  }, ModelHabitatGame.prototype.extractAvailableForResearchKnowledgeSet = function() {
    var known = {};
    this.habitatKnowledgeIdArray && this.habitatKnowledgeIdArray.forEach(function(knowledgePK) {
      known[knowledgePK] = !0
    }, this);
    var possibleKnowledgeSet = {}, addToPossibleKnowledge = function(knowledgePK) {
      known[knowledgePK] || (possibleKnowledgeSet[knowledgePK] = !0)
    };
    this.habitatBuildingKeyArray && this.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var modeledBuilding = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingPK });
      modeledBuilding && modeledBuilding.knowledgeFactoryArray instanceof Array && modeledBuilding.knowledgeFactoryArray.length && modeledBuilding.knowledgeFactoryArray.forEach(addToPossibleKnowledge)
    }, this), this.possibleKnowledgeSet = possibleKnowledgeSet
  }, ModelHabitatGame.prototype.extractMissionsList = function() {
    var missionsIds = [], missionsDictionary = {}, addToMissionsIdsList = function(id) {
      missionsDictionary[id] = !0
    };
    this.habitatBuildingKeyArray && this.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var modeledBuilding = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingPK });
      modeledBuilding && modeledBuilding.missionFactoryArray instanceof Array && modeledBuilding.missionFactoryArray.length && modeledBuilding.missionFactoryArray.forEach(addToMissionsIdsList)
    }, this);
    var mId;
    for (mId in missionsDictionary)missionsDictionary.hasOwnProperty(mId) && missionsIds.push(mId);
    this.possibleMissionsIds = missionsIds
  }, ModelHabitatGame.prototype.extractBuffsList = function() {
    var buffIds = [], buffsDictionary = {}, addToBuffIdsList = function(id) {
      buffsDictionary[id] = !0
    };
    this.habitatBuildingKeyArray && this.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var modeledBuilding = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingPK });
      modeledBuilding && modeledBuilding.buffFactoryArray instanceof Array && modeledBuilding.buffFactoryArray.length && modeledBuilding.buffFactoryArray.forEach(addToBuffIdsList)
    }, this);
    var buffId;
    for (buffId in buffsDictionary)buffsDictionary.hasOwnProperty(buffId) && buffIds.push(buffId);
    this.possibleBuffsIds = buffIds
  }, ModelHabitatGame.prototype.extractModifiersList = function() {
    var modifiersPK = [], addToModifierList = function(modifierPK) {
      modifiersPK.push(modifierPK)
    };
    this.habitatKnowledgeIdArray && this.habitatKnowledgeIdArray.forEach(function(knowledgePK) {
      var modeledKnowledge = this.servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: knowledgePK });
      modeledKnowledge && modeledKnowledge.modifierArray && modeledKnowledge.modifierArray.forEach(addToModifierList)
    }, this), this.habitatBuildingKeyArray && this.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var modeledBuilding = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingPK });
      modeledBuilding && modeledBuilding.modifierArray && modeledBuilding.modifierArray.forEach(addToModifierList)
    }, this), modifiersPK.length && (this.modifierList = modifiersPK)
  }, ModelHabitatGame.prototype.extractAvailableUnitsForRecruitment = function() {
    var addUnitToAvailableForRecruitUnits = function(unitPK) {
      this.servicesGameDataManager.unitsCollection.addAvailableForRecruitUnitPrimaryKey(unitPK)
    };
    this.habitatBuildingKeyArray && this.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var modeledBuilding = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingPK });
      modeledBuilding && modeledBuilding.unitFactoryArray instanceof Array && modeledBuilding.unitFactoryArray.forEach(addUnitToAvailableForRecruitUnits, this)
    }, this)
  }, ModelHabitatGame.prototype.canHabitatAffordUpgrade = function(upgrade) {
    if (!upgrade)return !1;
    var hasEnoughResources = this.hasEnoughResources(upgrade.buildResourceDictionary);
    if (!hasEnoughResources)return !1;
    var humanNeeded, upgradeOf, humanResourceId = servicesTheme.themeSettings.resources.humanResourceId, humanHave = this.habitatResourceDictionary[humanResourceId].storeAmount - this.habitatResourceDictionary[humanResourceId].amount;
    if (upgrade.volumeResource === humanResourceId && upgrade.volumeAmount && (humanNeeded = upgrade.volumeAmount, upgrade.hasOwnProperty("upgradeOf") && (upgradeOf = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: upgrade.upgradeOf }), humanNeeded -= upgradeOf.volumeAmount || 0), humanHave < humanNeeded))return !1;
    if (upgrade.requiredKnowledgeArray instanceof Array) {
      var areAllKnowledgeResearched = this.areAllKnowledgeResearched(upgrade.requiredKnowledgeArray);
      if (!areAllKnowledgeResearched)return !1
    }
    return !0
  }, ModelHabitatGame.prototype.hasEnoughResources = function(requiredResourceDictionary) {
    var resourceId, correctAmount, humanResourceId = servicesTheme.themeSettings.resources.humanResourceId;
    for (resourceId in requiredResourceDictionary)if (requiredResourceDictionary.hasOwnProperty(resourceId) && (correctAmount = humanResourceId === +resourceId ? this.habitatResourceDictionary[resourceId].storeAmount - this.habitatResourceDictionary[resourceId].amount : this.habitatResourceDictionary[resourceId].amount, correctAmount < requiredResourceDictionary[resourceId]))return !1;
    return !0
  }, ModelHabitatGame.prototype.hasEnoughUnits = function(requiredUnitsDictionary) {
    var unitId, correctAmount, unitAmountObject = this.servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
      habitatId: this.id,
      habitatUnitArray: this.localHabitatUnitArray
    });
    for (unitId in requiredUnitsDictionary)if (requiredUnitsDictionary.hasOwnProperty(unitId) && (correctAmount = unitAmountObject[unitId] || 0, correctAmount < requiredUnitsDictionary[unitId]))return !1;
    return !0
  }, ModelHabitatGame.prototype.getMissingResourcesMessage = function(requiredResourceDictionary) {
    var resourceId, text = "";
    for (resourceId in requiredResourceDictionary)if (requiredResourceDictionary.hasOwnProperty(resourceId) && this.habitatResourceDictionary[resourceId].amount < requiredResourceDictionary[resourceId]) {
      text = servicesInternationalization.localize("Required") + ": " + requiredResourceDictionary[resourceId] + " " + servicesInternationalization.localize(servicesTheme.themeSettings.resources[resourceId]);
      break
    }
    return text
  }, ModelHabitatGame.prototype.areAllKnowledgeResearched = function(requiredKnowledgeArray) {
    var areAllKnowledgeResearched = !1;
    return requiredKnowledgeArray instanceof Array && (areAllKnowledgeResearched = requiredKnowledgeArray.every(function(knowledgePK) {
      return this.habitatKnowledgesSet[knowledgePK]
    }, this)), areAllKnowledgeResearched
  }, ModelHabitatGame.prototype.areAllPossibleKnowledgeResearched = function() {
    var size = this.habitatKnowledgeIdArray.length, allPossibleKnowledgeNumber = servicesTheme.themeSettings.knowledges.maxAmount[settingsGameConstant.HABITAT_TYPE.CASTLE];
    return this.publicHabitatType === settingsGameConstant.HABITAT_TYPE.FORTRESS && (allPossibleKnowledgeNumber += servicesTheme.themeSettings.knowledges.maxAmount[settingsGameConstant.HABITAT_TYPE.FORTRESS]), this.publicHabitatType === settingsGameConstant.HABITAT_TYPE.CITY && (allPossibleKnowledgeNumber += servicesTheme.themeSettings.knowledges.maxAmount[settingsGameConstant.HABITAT_TYPE.CITY]), size >= allPossibleKnowledgeNumber
  }, ModelHabitatGame.prototype.canHabitatRunStudyOnKnowledge = function(knowledge) {
    if (!this.possibleKnowledgeSet[knowledge.primaryKey])return !1;
    var inProgressKnowledgeSet = {};
    return this.habitatKnowledgeOrderArray && this.habitatKnowledgeOrderArray.forEach(function(knowledgeIsInProgressId) {
      var modeledKnowledgeIsInProgress = this.servicesGameDataManager.knowledgesCollection.getKnowledgeInProgress(knowledgeIsInProgressId);
      inProgressKnowledgeSet[modeledKnowledgeIsInProgress.knowledgeId] = !0
    }, this), !inProgressKnowledgeSet[knowledge.primaryKey] && this.canHabitatAffordUpgrade(knowledge)
  }, ModelHabitatGame.prototype.areAllPossibleBuildingUpgraded = function() {
    var buildingsCollection = this.servicesGameDataManager.buildingsCollection, maxLevels = buildingsCollection.buildingsMaxLevel;
    return this.habitatBuildingKeyArray.every(function(buildingPK) {
      var modeledBuilding = buildingsCollection.getBuilding({ primaryKey: buildingPK });
      return modeledBuilding.level === maxLevels[modeledBuilding.classIdentifier]
    })
  }, ModelHabitatGame.prototype.whatMissingInHabitatToAffordMission = function(mission, options) {
    var missionId, unitAmountObject = this.servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
      habitatId: this.id,
      habitatUnitArray: this.localHabitatUnitArray
    }), extraResources = {}, extraUnits = {}, addMissionsCostToExtraCost = function(localMission) {
      var localResourceId;
      for (localResourceId in localMission.resourceConsumption)localMission.resourceConsumption.hasOwnProperty(localResourceId) && (extraResources.hasOwnProperty(localResourceId) || (extraResources[localResourceId] = 0), extraResources[localResourceId] += localMission.resourceConsumption[localResourceId]);
      var LocalUnitId;
      for (LocalUnitId in localMission.unitConsumption)localMission.unitConsumption.hasOwnProperty(LocalUnitId) && (extraUnits.hasOwnProperty(LocalUnitId) || (extraUnits[LocalUnitId] = 0), extraUnits[LocalUnitId] += localMission.unitConsumption[LocalUnitId])
    };
    if (options.multiSelectionMode)for (missionId in options.previouslySelected)options.previouslySelected.hasOwnProperty(missionId) && options.previouslySelected[missionId] && addMissionsCostToExtraCost(options.previouslySelected[missionId]);
    var resourceId, extraResourceAmount;
    for (resourceId in mission.resourceConsumption)if (mission.resourceConsumption.hasOwnProperty(resourceId) && (extraResourceAmount = extraResources[resourceId] || 0, this.habitatResourceDictionary[resourceId].amount < mission.resourceConsumption[resourceId] + extraResourceAmount))return settingsGameConstant.ENTITY.RESOURCE;
    var unitId, extraUnitAmount;
    for (unitId in mission.unitConsumption)if (mission.unitConsumption.hasOwnProperty(unitId) && (extraUnitAmount = extraUnits[unitId] || 0, !unitAmountObject[unitId] || unitAmountObject[unitId] < mission.unitConsumption[unitId] + extraUnitAmount))return settingsGameConstant.ENTITY.UNIT;
    return settingsGameConstant.ENTITY.NONE
  }, ModelHabitatGame.prototype.unitRecruitmentInHabitat = function(unit) {
    var ownLocalUnits = this.servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
      habitatId: this.id,
      habitatUnitArray: this.localHabitatUnitArray
    }), result = {
      missingKnowledge: null,
      currentAmount: ownLocalUnits[unit.primaryKey] || 0,
      amountPossible: 0
    }, missingKnowledgePk = null;
    if (unit.requiredKnowledgeArray instanceof Array && (unit.requiredKnowledgeArray.every(function(knowledgePK) {
              return !!this.habitatKnowledgesSet[knowledgePK] || (missingKnowledgePk = knowledgePK, !1)
            }, this), missingKnowledgePk))return result.missingKnowledge = this.servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: missingKnowledgePk }), result;
    var resourceId, possibleForRecruitment, humanResourceId = servicesTheme.themeSettings.resources.humanResourceId, maxForRecruitment = (this.habitatResourceDictionary[humanResourceId].storeAmount - this.habitatResourceDictionary[humanResourceId].amount) / unit.volumeAmount | 0;
    for (resourceId in unit.buildResourceDictionary)unit.buildResourceDictionary.hasOwnProperty(resourceId) && (possibleForRecruitment = this.habitatResourceDictionary[resourceId].amount / unit.buildResourceDictionary[resourceId] | 0, possibleForRecruitment < maxForRecruitment && (maxForRecruitment = possibleForRecruitment));
    return result.amountPossible = maxForRecruitment, result
  }, ModelHabitatGame.prototype.canHabitatProduceUnit = function(unit) {
    var canHabitatProduceUnitOfType = !1, requestedUnitPk = unit.primaryKey;
    return this.habitatBuildingKeyArray.forEach(function(buildingPk) {
      var building = this.servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingPk });
      building.unitFactoryArray && building.unitFactoryArray instanceof Array && building.unitFactoryArray.every(function(unitPk) {
        return requestedUnitPk !== unitPk || (canHabitatProduceUnitOfType = !0, !1)
      }, this)
    }, this), canHabitatProduceUnitOfType
  }, ModelHabitatGame.prototype.applyModifiers = function(options) {
    var modifier, data = {
      battleAbility: {},
      generateResource: {}
    }, joinMultipliers = "multiply" === servicesWorldSettings.settings.battleSystemValues.modifierOperator ? function(oldP, newP) {
      return oldP * newP
    } : function(oldP, newP) {
      return oldP + newP
    };
    if (!this.cachedModifers[options.targetObject] && this.modifierList instanceof Array && (modifier = {}, this.modifierList.forEach(function(modifierPK) {
              var modeledModifier = this.servicesGameDataManager.modifiersCollection.getModifier({ primaryKey: modifierPK }), isTargetCorrect = modeledModifier.targetArray.indexOf(options.targetObject) > -1, corpsType = "all";
              if ("string" == typeof modeledModifier.corps && modeledModifier.corps && (corpsType = modeledModifier.corps), modifier.hasOwnProperty("movementSpeed") || (modifier.movementSpeed = 1), modifier.hasOwnProperty("generateResource") || (modifier.generateResource = 1), modifier.hasOwnProperty(corpsType) || (modifier[corpsType] = {
                        defense: 1,
                        offense: 1
                      }), isTargetCorrect) {
                var modifierFloat = modeledModifier.percentageInt / Math.pow(10, modeledModifier.percentageScale);
                switch (modeledModifier.type) {
                  case settingsGameConstant.MODIFIER_TYPE.OFFENSE:
                    modifier[corpsType].offense = joinMultipliers(modifier[corpsType].defense, modifierFloat);
                    break;
                  case settingsGameConstant.MODIFIER_TYPE.DEFENSE:
                    modifier[corpsType].defense = joinMultipliers(modifier[corpsType].defense, modifierFloat);
                    break;
                  case settingsGameConstant.MODIFIER_TYPE.MOVEMENT_SPEED:
                    modifier.movementSpeed = joinMultipliers(modifier.movementSpeed, modifierFloat);
                    break;
                  case settingsGameConstant.MODIFIER_TYPE.AMOUNT_GENERATE:
                    modifier.generateResource = joinMultipliers(modifier.generateResource, modifierFloat)
                }
              }
            }, this), this.cachedModifers[options.targetObject] = modifier), !utilsObject.isEmpty(options.rawData) && this.cachedModifers[options.targetObject]) {
      var defenseModifier = 1, offenseModifier = 1;
      this.cachedModifers[options.targetObject].hasOwnProperty("all") && (offenseModifier = this.cachedModifers[options.targetObject].all.offense, defenseModifier = this.cachedModifers[options.targetObject].all.defense), options.corps && this.cachedModifers[options.targetObject].hasOwnProperty(options.corps) && (offenseModifier = joinMultipliers(offenseModifier, this.cachedModifers[options.targetObject][options.corps].offense), defenseModifier = joinMultipliers(defenseModifier, this.cachedModifers[options.targetObject][options.corps].defense));
      var corpsKey;
      for (corpsKey in options.rawData)options.rawData.hasOwnProperty(corpsKey) && (data.battleAbility.hasOwnProperty(corpsKey) || (data.battleAbility[corpsKey] = {
        defense: options.rawData[corpsKey].defense,
        offense: options.rawData[corpsKey].offense
      }), 1 !== offenseModifier && (data.battleAbility[corpsKey].offense = utilsNumber.roundGaussian(data.battleAbility[corpsKey].offense * offenseModifier)), 1 !== defenseModifier && (data.battleAbility[corpsKey].defense = utilsNumber.roundGaussian(data.battleAbility[corpsKey].defense * defenseModifier)))
    }
    if (options.movementSpeed && (data.hasOwnProperty("movementSpeed") || (data.movementSpeed = options.movementSpeed), 1 !== this.cachedModifers[options.targetObject].movementSpeed && (data.movementSpeed = utilsNumber.roundGaussian(data.movementSpeed * this.cachedModifers[options.targetObject].movementSpeed))), !utilsObject.isEmpty(options.generateResource)) {
      var resourceId;
      for (resourceId in options.generateResource)options.generateResource.hasOwnProperty(resourceId) && (data.generateResource.hasOwnProperty(resourceId) || (data.generateResource[resourceId] = options.generateResource[resourceId]), 1 !== this.cachedModifers[options.targetObject].generateResource && (data.generateResource[resourceId] = utilsNumber.roundGaussian(data.generateResource[resourceId] * this.cachedModifers[options.targetObject].generateResource)))
    }
    return data
  }, ModelHabitatGame.prototype.applyBuffs = function(options) {
    var buffs, activeBuffs = this.getActiveBuffs(), data = { generateResource: {} };
    if (!this.cachedBuffs[options.targetObject] && !utilsObject.isEmpty(activeBuffs)) {
      buffs = {};
      var buffPK;
      for (buffPK in activeBuffs)if (activeBuffs.hasOwnProperty(buffPK)) {
        var modeledBuff = this.servicesGameDataManager.buffsCollection.getBuff({ primaryKey: buffPK }), isTargetCorrect = modeledBuff.targetArray.indexOf(options.targetObject) > -1;
        if (buffs.hasOwnProperty("generateResource") || (buffs.generateResource = 1), isTargetCorrect) {
          var buffModifierFloat = modeledBuff.percentageInt / Math.pow(10, modeledBuff.percentageScale);
          switch (modeledBuff.type) {
            case settingsGameConstant.BUFF_TYPE.RESOURCES:
              buffs.generateResource = buffs.generateResource * buffModifierFloat
          }
        }
        this.cachedBuffs[options.targetObject] = buffs
      }
    }
    if (!utilsObject.isEmpty(options.generateResource)) {
      var resourceId;
      for (resourceId in options.generateResource)options.generateResource.hasOwnProperty(resourceId) && (data.generateResource.hasOwnProperty(resourceId) || (data.generateResource[resourceId] = options.generateResource[resourceId]), this.cachedBuffs[options.targetObject] && 1 !== this.cachedBuffs[options.targetObject].generateResource && (data.generateResource[resourceId] = utilsNumber.roundGaussian(data.generateResource[resourceId] * this.cachedBuffs[options.targetObject].generateResource)))
    }
    return data
  }, ModelHabitatGame.prototype.getRestockResourceAmount = function() {
    var amount = 0;
    return servicesTheme.themeSettings.resources.refillable.forEach(function(type) {
      var resource = this.habitatResourceDictionary[type];
      amount += resource.storeAmount - resource.amount
    }, this), amount
  }, ModelHabitatGame.prototype.getFreeSpaceForResource = function(options) {
    var resource = this.habitatResourceDictionary[options.resourceId];
    return resource.storeAmount - resource.amount
  }, ModelHabitatGame.prototype.canRefill = function() {
    var legalRestockDatePassed = !0, now = new Date;
    return this.nextLegalRestockDate && (legalRestockDatePassed = now > this.nextLegalRestockDate), legalRestockDatePassed && this.getRestockResourceAmount() > 0
  }, ModelHabitatGame.prototype.getActiveBuffs = function() {
    var result = {};
    return this.habitatBuffArray instanceof Array && this.habitatBuffArray.forEach(function(habitatsBuffId) {
      var modeledHabitatsBuff = this.servicesGameDataManager.buffsCollection.getHabitatsBuff({ id: habitatsBuffId });
      modeledHabitatsBuff && (result[modeledHabitatsBuff.buffId] = modeledHabitatsBuff)
    }, this), result
  }, ModelHabitatGame.prototype.getPossibleBuffs = function() {
    var possibleBuffs = [];
    return this.possibleBuffsIds.forEach(function(buffId) {
      possibleBuffs.push(this.servicesGameDataManager.buffsCollection.getBuff({ primaryKey: buffId }))
    }, this), possibleBuffs
  }, ModelHabitatGame.prototype.getHabitatUpgrade = function(isLocal) {
    var resultObject = {}, habitatUpgrade = this.determineHabitatUpgradeRequirements(), habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades[habitatUpgrade.affectedHabitatType];
    return habitatUpgrade ? (resultObject.original = habitatUpgrade, resultObject.ready = this.checkReadyStatus(habitatUpgrade), resultObject.title = habitatUpgradesThemeSettings[habitatUpgrade.identifier], isLocal !== !0 && habitatUpgrade.primaryKey !== settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_CENTER && habitatUpgrade.primaryKey !== settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_CENTER || (resultObject.subTitle = this.getHabitatUpgradeConstructionSubtitleMessage(resultObject.ready, habitatUpgrade)), resultObject.build = {
      duration: habitatUpgrade.buildDuration,
      resources: habitatUpgrade.buildResourceDictionary,
      speedupCost: habitatUpgrade.buildSpeedupCost
    }, resultObject) : null
  }, ModelHabitatGame.prototype.getHabitatUpgradeExtension = function(options) {
    options = options || {};
    var upgradePk, habitatUpgrade, readyObject, resultObject = {};
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        upgradePk = settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_CENTER;
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        upgradePk = settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_CENTER;
        break;
      default:
        servicesLog("warn", "unknown habitat upgrade mode")
    }
    return habitatUpgrade = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: upgradePk }), this.isOwnByPlayer && (readyObject = this.checkReadyStatus(habitatUpgrade)), resultObject.original = habitatUpgrade, resultObject.ready = readyObject || null, resultObject.subTitle = this.getHabitatUpgradeConstructionSubtitleMessage(readyObject, habitatUpgrade), resultObject
  }, ModelHabitatGame.prototype.determineHabitatUpgradeRequirements = function() {
    var upgradeObject;
    switch (this.habitatType) {
      case settingsGameConstant.HABITAT_TYPE.CASTLE:
        upgradeObject = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_CENTER });
        break;
      case settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER:
        upgradeObject = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_EXPANSION }), this.fortressExpansionArray instanceof Array && this.fortressExpansionArray.length >= upgradeObject.habitatAmount && (upgradeObject = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS }));
        break;
      case settingsGameConstant.HABITAT_TYPE.FORTRESS:
        upgradeObject = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_CENTER });
        break;
      case settingsGameConstant.HABITAT_TYPE.CITY_CENTER:
        upgradeObject = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_EXPANSION }), this.fortressExpansionArray instanceof Array && this.fortressExpansionArray.length >= upgradeObject.habitatAmount && (upgradeObject = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY }));
        break;
      default:
        return null
    }
    return upgradeObject
  }, ModelHabitatGame.prototype.checkReadyStatus = function(upgrade) {
    var isResearched = this.areAllKnowledgeResearched(upgrade.requiredKnowledgeArray), areAllPossibleKnowledgeResearched = this.areAllPossibleKnowledgeResearched(), areAllPossibleBuildingUpgraded = this.areAllPossibleBuildingUpgraded(), isUpgraded = areAllPossibleKnowledgeResearched && areAllPossibleBuildingUpgraded, isResourcesEnough = this.hasEnoughResources(upgrade.buildResourceDictionary), isInProgress = this.isHabitatUpgradeConstructionInProgress(upgrade.primaryKey), isExpanded = this.isExpanded(upgrade.habitatAmount), isReadyForBuild = isResearched && isUpgraded && isResourcesEnough && isExpanded;
    return {
      isResearched: isResearched,
      isUpgraded: isUpgraded,
      isResourcesEnough: isResourcesEnough,
      isInProgress: isInProgress,
      isReadyForBuild: isReadyForBuild
    }
  }, ModelHabitatGame.prototype.isHabitatUpgradeConstructionInProgress = function(upgradePrimaryKey) {
    var inProgressModel = null;
    return this.habitatUpgradeOrderArray instanceof Array && this.habitatUpgradeOrderArray.length && this.habitatUpgradeOrderArray.forEach(function(habitatUpgradeConstructionInProgressId) {
      var modeledHabitatUpgradeConstructionInProgress = this.servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgradeInProgress({ id: habitatUpgradeConstructionInProgressId });
      modeledHabitatUpgradeConstructionInProgress.upgradeId === upgradePrimaryKey && (inProgressModel = modeledHabitatUpgradeConstructionInProgress)
    }, this), inProgressModel
  }, ModelHabitatGame.prototype.isExpanded = function(shouldBeExpanded) {
    return shouldBeExpanded = shouldBeExpanded || 0, this.fortressExpansionArray.length >= shouldBeExpanded
  }, ModelHabitatGame.prototype.getHabitatUpgradeConstructionSubtitleMessage = function(readyObject, upgrade) {
    var text = "", habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades[upgrade.affectedHabitatType];
    return readyObject ? readyObject.isReadyForBuild ? text = servicesInternationalization.localize("Build possible") : readyObject.isResearched ? readyObject.isUpgraded ? readyObject.isResourcesEnough || (text = this.getMissingResourcesMessage(upgrade.buildResourceDictionary)) : text = servicesInternationalization.localize("Required") + ": " + servicesInternationalization.localize(habitatUpgradesThemeSettings.fullyUpgraded) : text = servicesInternationalization.localize("Required") + ": " + servicesInternationalization.localize(habitatUpgradesThemeSettings.upgradeConstructionTitle) : text = servicesInternationalization.localize("Required") + ": " + servicesInternationalization.localize("ConquestSectionTitle"), text
  }, ModelHabitatGame.prototype.isLinkedToAnyHabitatUpgradeCenter = function() {
    var result, habitatList = this.servicesGameDataManager.habitatsCollection.getOwnHabitatList();
    return result = habitatList.every(function(ownHabitatId) {
      var modeledHabitat = this.servicesGameDataManager.habitatsCollection.getHabitat(ownHabitatId);
      return modeledHabitat.habitatType !== settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER && modeledHabitat.habitatType !== settingsGameConstant.HABITAT_TYPE.CITY_CENTER || modeledHabitat.fortressExpansionArray.indexOf(this.id.toString()) === -1
    }, this), !result
  }, ModelHabitatGame.prototype.getLinkedToAnotherHabitatUpgradeCenterText = function() {
    var list = [], result = null, habitatList = this.servicesGameDataManager.habitatsCollection.getOwnHabitatList();
    return habitatList.forEach(function(ownHabitatId) {
      var modeledHabitat = this.servicesGameDataManager.habitatsCollection.getHabitat(ownHabitatId);
      modeledHabitat.fortressExpansionArray instanceof Array && (modeledHabitat.fortressExpansionArray.indexOf(this.id.toString()) !== -1 || modeledHabitat.fortressExpansionArray.indexOf(this.id) !== -1) && list.push(modeledHabitat.name)
    }, this), list.length && (result = list.join(", ")), result
  }, ModelHabitatGame.prototype.canLocalUnitsArriveInTime = function(options) {
    var abilitiesWithModifiers, transportationTime, fastestTimePerField = 0, now = new Date, unitsExist = !1, ownLocalDefenders = this.servicesGameDataManager.unitsCollection.getDefendersUnits({ habitatUnitArray: this.localHabitatUnitArray });
    return ownLocalDefenders.forEach(function(unitObject) {
      var unitModel = unitObject.unit;
      unitObject.amount > 0 && (unitsExist = !0, abilitiesWithModifiers = this.applyModifiers({
        targetObject: "Unit",
        movementSpeed: unitModel.secondsPerField
      }), (abilitiesWithModifiers.movementSpeed < fastestTimePerField || !fastestTimePerField) && (fastestTimePerField = abilitiesWithModifiers.movementSpeed))
    }, this), transportationTime = options.distance * fastestTimePerField | 0, now.setSeconds(now.getSeconds() + transportationTime), unitsExist && options.arrivalTime > now
  }, ModelHabitatGame
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatMap, [xy.dNames.gameInstance, xy.dNames.core.modelHabitatBasic, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(gameInstance, CoreModelHabitatBasic, utilsOop, utilsConverter, servicesInternationalization, servicesTheme, settingsGameConstant) {
  "use strict";
  function ModelHabitatMap(options) {
    this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager), this.isOwnByPlayer = !1, this.isRenegade = !0, ModelHabitatMap.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatMap, CoreModelHabitatBasic), ModelHabitatMap.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    mapX: utilsConverter.toNumber,
    mapY: utilsConverter.toNumber,
    player: utilsConverter.toNumber,
    points: utilsConverter.toNumber,
    publicHabitatType: utilsConverter.toNumber,
    noobProtectionEndDate: utilsConverter.toDate,
    nextBattleDate: utilsConverter.toDate
  }, ModelHabitatMap.prototype.finalisation = function() {
    if (!this.name) {
      var habitatType = this.player ? this.habitatType || this.publicHabitatType : settingsGameConstant.HABITAT_TYPE.CASTLE, freeName = servicesTheme.themeSettings.habitat.emptyNameByHabitatType[habitatType];
      this.name = servicesInternationalization.localize(freeName) + " " + this.id
    }
    this.player && (this.isRenegade = !1), this.possibleNextBattleDate = 0, this.setPossibleNextBattleDate()
  }, ModelHabitatMap
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatReservation, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.sessionUpdateSchedule, function(CoreModel, utilsOop, utilsConverter, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelHabitatReservation(options) {
    ModelHabitatReservation.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatReservation, CoreModel), ModelHabitatReservation.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    habitat: utilsConverter.toNumber,
    player: utilsConverter.toNumber,
    status: utilsConverter.toNumber,
    reservationDate: utilsConverter.toDate,
    expirationDate: utilsConverter.toDate
  }, ModelHabitatReservation.prototype.finalisation = function() {
    this.expirationDate && servicesSessionUpdateSchedule.scheduleDate(this.expirationDate)
  }, ModelHabitatReservation
}]), xy.dStaticInjector.set(xy.dNames.core.modelPlayer, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.string, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.network, xy.dNames.services.sessionUpdateSchedule, function(CoreModel, utilsOop, utilsConverter, utilsString, settingsGameConstant, servicesTheme, servicesNetwork, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelPlayer(options) {
    this.updated = !1, this.usedRelocateHabitat = !1, this.allianceAplications = {}, ModelPlayer.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelPlayer, CoreModel), ModelPlayer.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    alliance: utilsConverter.toNumber,
    alliancePermission: utilsConverter.toNumber,
    points: utilsConverter.toNumber,
    rank: utilsConverter.toNumber,
    reportSetup: utilsConverter.toNumber,
    touchDate: utilsConverter.toDate,
    loginId: utilsConverter.toNumber,
    nextLegalFreeHabitatPurchaseDate: utilsConverter.toDate,
    usedRelocateHabitat: utilsConverter.toBoolean,
    attackProtectionEndDate: utilsConverter.toDate,
    attackProtectionCooldownEndDate: utilsConverter.toDate,
    numberOfFreeAttackProtectionsUsed: utilsConverter.toNumber,
    vacationStartDate: utilsConverter.toDate,
    isOnVacation: utilsConverter.toBoolean
  }, ModelPlayer.prototype.finalisation = function() {
    this.isPeripheral && (this.cachedAt = new Date), this.habitatArray instanceof Array && (this.updated = !0), this.extractAllianceApplications(), this.nextLegalFreeHabitatPurchaseDate && servicesSessionUpdateSchedule.scheduleDate(this.nextLegalFreeHabitatPurchaseDate), this.attackProtectionEndDate && servicesSessionUpdateSchedule.scheduleDate(this.attackProtectionEndDate), this.vacationStartDate && servicesSessionUpdateSchedule.scheduleDate(this.vacationStartDate)
  }, ModelPlayer.prototype.extractAllianceApplications = function() {
    this.allianceAplications = {}, this.allianceApplicationArray && this.allianceApplicationArray.length && this.allianceApplicationArray.forEach(function(allianceId) {
      this.allianceAplications[allianceId] = !0
    }, this)
  }, ModelPlayer.prototype.getHabitatAmount = function() {
    return this.habitatArray.length
  }, ModelPlayer.prototype.canDoAll = function() {
    return this.alliancePermission === settingsGameConstant.ALLIANCE_PERMISSION.ALL || this.alliancePermission === settingsGameConstant.ALLIANCE_PERMISSION.MAX
  }, ModelPlayer.prototype.canInvite = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.INVITE_PLAYER
  }, ModelPlayer.prototype.canManageRightsInAlliance = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.PLAYER_PERMISSIONS
  }, ModelPlayer.prototype.canDismissFromAlliance = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.DISMISS_PLAYER
  }, ModelPlayer.prototype.canMassMail = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.MASS_MAIL
  }, ModelPlayer.prototype.canDiplomacy = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.DIPLOMATIC_RELATIONS
  }, ModelPlayer.prototype.canModerateForum = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.MODERATE_FORUM
  }, ModelPlayer.prototype.canDisband = function() {
    return this.canDoAll() || this.alliancePermission & settingsGameConstant.ALLIANCE_PERMISSION.DISBAND_ALLIANCE
  }, ModelPlayer.prototype.amountOfSentConquerResourcesToHabitat = function(habitatId) {
    var amount = 0;
    return this.conquestPointDictionary && this.conquestPointDictionary[habitatId] && (amount += this.conquestPointDictionary[habitatId]), amount
  }, ModelPlayer.prototype.getAmountOfSentConquerResources = function() {
    var amount = 0;
    return this.conquestPointDictionary && Object.keys(this.conquestPointDictionary).forEach(function(habitatId) {
      amount += this.conquestPointDictionary[habitatId]
    }, this), amount
  }, ModelPlayer.prototype.activationOfVactionIsInProgress = function(vacationStartDate) {
    this.vacationStartDate = vacationStartDate
  }, ModelPlayer.prototype.getLink = function() {
    return utilsString.sprintf(servicesTheme.themeSettings.linksFormat.player, this.id, servicesNetwork.worldId)
  }, ModelPlayer
}]), xy.dStaticInjector.set(xy.dNames.core.modelEventClientInfo, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreModel, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function ModelEventClientInfo(options) {
    ModelEventClientInfo.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelEventClientInfo, CoreModel), ModelEventClientInfo.prototype.finalisation = function() {
    this.titleLocKey && (this.title = servicesInternationalization.localizeEvent(this.titleLocKey, this.titleLocArgs).replace(/(\n|\r\n|\\n)+/, "")), this.successTitleLocKey && (this.successTitle = servicesInternationalization.localizeEvent(this.successTitleLocKey, this.successTitleLocArgs).replace(/(\n|\r\n|\\n)+/, "")), this.descriptionLocKey && (this.description = servicesInternationalization.localizeEvent(this.descriptionLocKey, this.descriptionLocArgs).replace(/(\n|\r\n|\\n)+/, "")), this.onProgressLocKey && (this.onProgressLocKey = servicesInternationalization.isLocalizable(settingsGameConstant.LOCALIZATION_TYPE.MAIN, this.onProgressLocKey) ? servicesInternationalization.localize(this.onProgressLocKey) : servicesInternationalization.localizeEvent(this.onProgressLocKey)), this.facebookNameLocKey && (this.facebookTitle = servicesInternationalization.localizeEvent(this.facebookNameLocKey, this.facebookNameLocArgs)), this.facebookDescLocKey && (this.facebookDescription = servicesInternationalization.localizeEvent(this.facebookDescLocKey, this.facebookDescLocArgs))
  }, ModelEventClientInfo
}]), xy.dStaticInjector.set(xy.dNames.core.modelEventTrackable, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.core.modelEventClientInfo, function(CoreModel, utilsOop, utilsConverter, CoreModelEventClientInfo) {
  "use strict";
  function _checkEventsType(name) {
    var spl = name.split(".");
    return spl[0]
  }

  function ModelEventTrackable(options) {
    this.id = 0, ModelEventTrackable.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelEventTrackable, CoreModel), ModelEventTrackable.prototype.correctDataType = {
    completionLimit: utilsConverter.toNumber,
    canSkip: utilsConverter.toBoolean,
    requiresAllConditions: utilsConverter.toBoolean,
    rewardOnAcknowledge: utilsConverter.toBoolean,
    success: utilsConverter.toBoolean,
    deadline: utilsConverter.toDate
  }, ModelEventTrackable.prototype.finalisation = function() {
    this.isTrackable = !0, this.type = _checkEventsType(this.id), this.clientInfo = new CoreModelEventClientInfo(this.clientInfo)
  }, ModelEventTrackable
}]), xy.dStaticInjector.set(xy.dNames.core.modelEventTracking, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, xy.dNames.core.modelEventClientInfo, xy.dNames.services.sessionUpdateSchedule, function(CoreModel, utilsOop, utilsConverter, utilsDateTime, CoreModelEventClientInfo, servicesSessionUpdateSchedule) {
  "use strict";
  function _checkEventsType(name) {
    var spl = name.split(".");
    return spl[0]
  }

  function ModelEventTracking(options) {
    this.isTutorialEvent = !1, this.isEventCanNotBeFinished = !1, this.id = 0, this.eventName = "", this.rewards = null, this.rewardsOnFailure = null, this.conditions = [], ModelEventTracking.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelEventTracking, CoreModel), ModelEventTracking.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    player: utilsConverter.toNumber,
    completionLimit: utilsConverter.toNumber,
    canSkip: utilsConverter.toBoolean,
    requiresAllConditions: utilsConverter.toBoolean,
    rewardOnAcknowledge: utilsConverter.toBoolean,
    success: utilsConverter.toBoolean,
    completedAt: utilsConverter.toDate,
    playerDeadline: utilsConverter.toDate
  }, ModelEventTracking.prototype.finalisation = function() {
    this.playerDeadlineFormated = !1, this.playerDeadline && (servicesSessionUpdateSchedule.scheduleDate(this.playerDeadline), this.playerDeadlineFormated = utilsDateTime.getFormatedDateTimeString(this.playerDeadline)), this.completedAtFormated = !1, this.completedAt && (this.completedAtFormated = utilsDateTime.getFormatedDateTimeString(this.completedAt)), this.type = _checkEventsType(this.eventName), this.clientInfo = new CoreModelEventClientInfo(this.clientInfo), this.isTutorialEvent = "tutorial" === this.type, this.conditions.forEach(function(condition) {
      "never" !== condition.comparison && "never" !== condition.identifier || (this.isEventCanNotBeFinished = !0)
    }, this)
  }, ModelEventTracking
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatUnit, [xy.dNames.gameInstance, xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(gameInstance, CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelHabitatUnit(options) {
    this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager), ModelHabitatUnit.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatUnit, CoreModel), ModelHabitatUnit.prototype.correctDataType = {
    sourceHabitat: utilsConverter.toNumber,
    habitat: utilsConverter.toNumber,
    unitId: utilsConverter.toNumber,
    amount: utilsConverter.toNumber,
    battleType: utilsConverter.toNumber
  }, ModelHabitatUnit.prototype.finalisation = function() {
    this.servicesGameDataManager.unitsCollection.addAvailableForExchangeUnitPrimaryKey(this.unitId)
  }, ModelHabitatUnit
}]), xy.dStaticInjector.set(xy.dNames.core.modelUnit, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.internationalization, function(CoreModel, utilsOop, utilsConverter, servicesInternationalization) {
  "use strict";
  function ModelUnit(options) {
    ModelUnit.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelUnit, CoreModel), ModelUnit.prototype.correctDataType = {
    primaryKey: utilsConverter.toNumber,
    order: utilsConverter.toNumber,
    buildSpeedupCost: utilsConverter.toNumber,
    buildDuration: utilsConverter.toNumber,
    secondsPerField: utilsConverter.toNumber,
    storeAmount: utilsConverter.toNumber,
    volumeAmount: utilsConverter.toNumber,
    volumeResource: utilsConverter.toNumber
  }, ModelUnit.prototype.finalisation = function() {
    this.icon = "icon-unit icon-unit-" + this.primaryKey, this.image = "icon-unit full-image icon-unit-" + this.primaryKey, this.niceIdentifier = this.identifier.replace(/\s/g, "").toLowerCase(), this.title = servicesInternationalization.localize(this.identifier)
  }, ModelUnit
}]), xy.dStaticInjector.set(xy.dNames.core.modelUnitInProgress, [xy.dNames.core.modelInProgress, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, xy.dNames.services.sessionUpdateSchedule, function(CoreModelInProgress, utilsOop, utilsConverter, utilsDateTime, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelUnitInProgress(options) {
    ModelUnitInProgress.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelUnitInProgress, CoreModelInProgress), ModelUnitInProgress.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    complete: utilsConverter.toDate,
    durationFactor: utilsConverter.toNumber,
    durationPerUnitInSeconds: utilsConverter.toNumber,
    unitId: utilsConverter.toNumber,
    orderAmount: utilsConverter.toNumber
  }, ModelUnitInProgress.prototype.finalisation = function() {
    var nextUnitFinishedDate;
    if (this.complete) {
      if (1 === this.orderAmount)nextUnitFinishedDate = this.complete; else {
        var constructionStart, durationOfOneUnit = 1e3 * Math.ceil(this.durationPerUnitInSeconds * this.durationFactor), constructionTimeInMilliSeconds = durationOfOneUnit * this.orderAmount;
        constructionStart = new Date(this.complete.getTime() - constructionTimeInMilliSeconds), nextUnitFinishedDate = new Date(constructionStart.getTime() + durationOfOneUnit)
      }
      this.unitsLeft = this.orderAmount, servicesSessionUpdateSchedule.scheduleDate(nextUnitFinishedDate), this.nextUnitFinishedDate = nextUnitFinishedDate
    }
  }, ModelUnitInProgress
}]), xy.dStaticInjector.set(xy.dNames.core.modelTransit, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.sessionUpdateSchedule, xy.dNames.services.worldSettings, function(CoreModel, utilsOop, utilsConverter, utilsDateTime, settingsGameConstant, servicesSessionUpdateSchedule, serviceWorldSettings) {
  "use strict";
  function ModelTransit(options) {
    this.isReturning = !1, this.groupingSourceHabitat = null, ModelTransit.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelTransit, CoreModel), ModelTransit.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    transitType: utilsConverter.toNumber,
    destinationHabitat: utilsConverter.toNumber,
    sourceHabitat: utilsConverter.toNumber,
    destinationETA: utilsConverter.toDate,
    lastUpdate: utilsConverter.toDate
  }, ModelTransit.prototype.finalisation = function() {
    this.destinationETA && servicesSessionUpdateSchedule.scheduleDate(this.destinationETA), this.groupingSourceHabitat = this.sourceHabitat || this.destinationHabitat, this.isReturning = settingsGameConstant.TRANSIT_TYPE.RETURNING.indexOf(this.transitType) !== -1
  }, ModelTransit.prototype.getSpeedUpTransitCost = function() {
    var key, unitAmount = 0, remainingTimeInMinutes = utilsDateTime.remainTimeInSeconds(this.destinationETA) / 60;
    if (remainingTimeInMinutes < .5)return 0;
    if (this.transitType === settingsGameConstant.TRANSIT_TYPE.SPY_RETURN)unitAmount = serviceWorldSettings.settings.unitsForReturningSpy || 0; else for (key in this.unitDictionary)this.unitDictionary.hasOwnProperty(key) && (unitAmount += this.unitDictionary[key]);
    return Math.ceil(unitAmount / serviceWorldSettings.settings.speedUpReturningUnitsUnit * remainingTimeInMinutes)
  }, ModelTransit.prototype.isTransitActive = function() {
    return utilsDateTime.remainTimeInSeconds(this.destinationETA) > 0
  }, ModelTransit
}]), xy.dStaticInjector.set(xy.dNames.core.modelReport, [xy.dNames.services.log, xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.object, xy.dNames.utils.dateTime, xy.dNames.utils.string, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.gameInstance, function(servicesLog, CoreModel, utilsOop, utilsConverter, utilsObject, utilsDateTime, utilsString, settingsGameConstant, servicesTheme, servicesInternationalization, gameInstance) {
  "use strict";
  function ModelReport(options) {
    this.reportGroup = 0, this.title = "", this.description = "", this.fullDescription = "", this.extraClasses = "", this.icon = "", this.centerMapOnDescriptionCooredinates = null, this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager), ModelReport.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelReport, CoreModel), ModelReport.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    type: utilsConverter.toNumber,
    habitat: utilsConverter.toNumber,
    published: utilsConverter.toBoolean,
    date: utilsConverter.toDate
  }, ModelReport.prototype.finalisation = function() {
    this.prepareExtraData()
  }, ModelReport.prototype.prepareExtraData = function() {
    var destinationHabitatName, sourceHabitatName, conquerorPlayerName, publicHabitatType, iconClassName, destinationHabitat = null, sourceHabitat = null, habitatName = this.servicesGameDataManager.habitatsCollection.getHabitatProperty("name", this.habitat, { isReportRequest: !0 }), mission = null, knowledge = null, destinationHabitatMapCoordinates = null, sourceHabitatMapCoordinates = null;
    servicesTheme.themeSettings.resources.conquestResourceId;
    switch (this.content.destinationHabitat && (destinationHabitat = this.content.destinationHabitat, destinationHabitatName = this.servicesGameDataManager.habitatsCollection.getHabitatProperty("name", destinationHabitat.id, { isReportRequest: !0 }), destinationHabitatMapCoordinates = {
      mapX: +destinationHabitat.mapX,
      mapY: +destinationHabitat.mapY
    }), this.content.sourceHabitat && (sourceHabitat = this.content.sourceHabitat, sourceHabitatName = this.servicesGameDataManager.habitatsCollection.getHabitatProperty("name", sourceHabitat.id, { isReportRequest: !0 }), sourceHabitatMapCoordinates = {
      mapX: +sourceHabitat.mapX,
      mapY: +sourceHabitat.mapY
    }), this.content.missionId && (mission = {
      icon: this.servicesGameDataManager.missionsCollection.getMissionProperty("icon", this.content.missionId),
      name: this.servicesGameDataManager.missionsCollection.getMissionProperty("title", this.content.missionId)
    }), this.content.knowledgeId && (knowledge = {
      icon: this.servicesGameDataManager.knowledgesCollection.getKnowledgeProperty("icon", this.content.knowledgeId),
      name: this.servicesGameDataManager.knowledgesCollection.getKnowledgeProperty("title", this.content.knowledgeId)
    }), this.content.conqueror && (publicHabitatType = this.servicesGameDataManager.habitatsCollection.getHabitatProperty("publicHabitatType", this.habitat), conquerorPlayerName = this.content.conqueror.nick), this.type) {
      case settingsGameConstant.REPORT_TYPE.ATTACK_WARNING:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE, this.title = sourceHabitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("%@ sent an attack to %@.", sourceHabitatName, habitatName), this.icon = servicesTheme.getImageClassName("AttackWarning", "report"), this.centerMapOnDescriptionCooredinates = sourceHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.LOST_FOREIGN_DEFENDER:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE, this.title = servicesInternationalization.localize("Lost foreign defenders"), this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("Lost defenders from %@", destinationHabitatName), this.icon = servicesTheme.getImageClassName("DefenseReport", "report"), this.centerMapOnDescriptionCooredinates = destinationHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.CONQUEST:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.ATTACK, this.title = servicesInternationalization.localize("Conquered %@", destinationHabitatName), this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("%@ was conquered.", destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitAttack", "report"), this.centerMapOnDescriptionCooredinates = destinationHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.CONQUEST_FAILED:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.ATTACK, this.title = servicesInternationalization.localize("Failed to conquer %@", destinationHabitatName), this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("%@ could not be conquered", destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitAttack", "report"), this.centerMapOnDescriptionCooredinates = destinationHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.BATTLE_ROUND_FINISHED:
        this.title = destinationHabitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("A battle was fought at %@.", destinationHabitatName), this.content.battleType === settingsGameConstant.REPORT_TYPE.BATTLE_TYPE.HOME ? (this.reportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE, this.icon = servicesTheme.getImageClassName("DefenseReport", "report")) : this.content.battleType === settingsGameConstant.REPORT_TYPE.BATTLE_TYPE.DEFENDER ? (this.reportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE, this.icon = servicesTheme.getImageClassName("Defense", "report")) : this.content.battleType === settingsGameConstant.REPORT_TYPE.BATTLE_TYPE.OFFENDER && (this.reportGroup = settingsGameConstant.REPORT_GROUP.ATTACK, this.icon = servicesTheme.getImageClassName("TransitAttack", "report")), !this.content.lossDictionary && this.content.unitDictionary ? this.extraClasses = "good-description" : this.content.lossDictionary && this.content.unitDictionary ? this.extraClasses = "simple-description" : this.content.lossDictionary && (this.extraClasses = "bad-description"), this.centerMapOnDescriptionCooredinates = destinationHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.TRANSIT_RETURNED:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.TRANSPORT, this.title = sourceHabitatName || destinationHabitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + destinationHabitatName, this.content.transitType === settingsGameConstant.TRANSIT_TYPE.TRANSPORT_RETURN ? (this.icon = servicesTheme.getImageClassName("TransitTransportReturn", "report"), utilsObject.isEmpty(this.content.resourceDictionary) ? this.fullDescription = servicesInternationalization.localize("A transport delivering resources to %@ returned to %@.", sourceHabitatName, destinationHabitatName) : this.fullDescription = servicesInternationalization.localize("A transit from a Market arrived at %@.", destinationHabitatName)) : this.content.transitType === settingsGameConstant.TRANSIT_TYPE.DEFENSE_RETURN ? (this.fullDescription = servicesInternationalization.localize("Troops defending %@ returned to %@.", sourceHabitatName, destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitDefenseReturn", "report")) : (this.fullDescription = servicesInternationalization.localize("Troops attacking %@ returned to %@.", sourceHabitatName, destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitAttackReturn", "report")), this.centerMapOnDescriptionCooredinates = sourceHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.DELIVERED_DEFENSE:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.TRANSPORT, this.title = sourceHabitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + destinationHabitatName, this.fullDescription = servicesInternationalization.localize("Defenders from %@ arrived at %@.", sourceHabitatName, destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitDefense", "report"), this.centerMapOnDescriptionCooredinates = sourceHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.DELIVERED_RESOURCES:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.TRANSPORT, this.title = sourceHabitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + destinationHabitatName, this.fullDescription = servicesInternationalization.localize("A transport from %@ arrived at %@.", sourceHabitatName, destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitTransport", "report"), this.centerMapOnDescriptionCooredinates = sourceHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.KNOWLEDGE_RESEARCHED:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.KNOWLEDGE, this.title = knowledge.name, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("Research of %@ finished.", knowledge.name), this.icon = knowledge.icon;
        break;
      case settingsGameConstant.REPORT_TYPE.MISSION_FINISHED:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.MISSION, this.title = mission.name, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("Mission %@ accomplished", mission.name), this.icon = mission.icon;
        break;
      case settingsGameConstant.REPORT_TYPE.SPY_FINISHED:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.SPY, this.title = destinationHabitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.content.successful ? (this.fullDescription = servicesInternationalization.localize("Your spy returned with valuable information from %@.", destinationHabitatName), this.icon = servicesTheme.getImageClassName("TransitSpyReturn", "report")) : (this.fullDescription = servicesInternationalization.localize("Your spy was captured at %@.", destinationHabitatName), this.icon = servicesTheme.getImageClassName("SpyCaptured", "report")), this.centerMapOnDescriptionCooredinates = destinationHabitatMapCoordinates;
        break;
      case settingsGameConstant.REPORT_TYPE.SPY_CAPTURED:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.SPY, this.title = habitatName, this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + sourceHabitatName, this.fullDescription = servicesInternationalization.localize("A spy from %@ was captured at %@.", sourceHabitatName, habitatName), this.icon = servicesTheme.getImageClassName("SpyCaptured", "report");
        break;
      case settingsGameConstant.REPORT_TYPE.CASTLE_LOST:
        this.reportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE, this.title = servicesInternationalization.localize("Lost: %@", habitatName), this.description = utilsDateTime.getLocaleTimeString(this.date) + " - " + habitatName, this.fullDescription = servicesInternationalization.localize("Castle %1$@ have been conquered by player %2$@", habitatName, conquerorPlayerName), iconClassName = null !== publicHabitatType ? "LostHabitat-" + publicHabitatType : "LostCastle", this.icon = servicesTheme.getImageClassName(iconClassName, "report");
        break;
      default:
        servicesLog("warn", "You try to model report with unknown type " + this.type + " id: " + this.id)
    }
  }, ModelReport.prototype.getLink = function() {
    return utilsString.sprintf(servicesTheme.themeSettings.linksFormat.report, this.id, this.habitat, this.servicesGameDataManager.settings.worldId)
  }, ModelReport
}]), xy.dStaticInjector.set(xy.dNames.core.modelResource, [xy.dNames.services.log, function(servicesLog) {
  "use strict";
  function ModelResource(rawUrl) {
    this.id = null, this.extension = null, this.value = null, this._status = "created", this.type = null, this.name = null, this.url = null, this._progress = null;
    var urlString, url, id, path, name, extensionPos, extension;
    urlString = rawUrl.split("@"), url = urlString[0], id = urlString.length > 1 ? urlString[1] : null, path = url.split("/"), name = path[path.length - 1], name = name.split("?")[0], extensionPos = name.lastIndexOf("."), extension = null, extension = extensionPos !== -1 ? name.substr(extensionPos + 1) : "default", this.url = url, this.extension = extension, this.id = id || url, this.name = name
  }

  return ModelResource.prototype.load = function(loaderService, loaded, error) {
    var _this = this, loaderDescriptor = loaderService.getLoaderByType(this.extension);
    if (loaderDescriptor) {
      this.type = loaderDescriptor.type;
      var loader = loaderDescriptor.loader(this.url);
      loader.load(function(content) {
        _this.__setValue(content), loaded(_this)
      }, function() {
        _this.__setError(), error(_this)
      }, this._progress)
    } else servicesLog("warn", "Unknown loader for Resource id: " + this.id), servicesLog("debug", this), error(this)
  }, ModelResource.prototype.__setValue = function(value) {
    this.value = value, this._status = "loaded"
  }, ModelResource.prototype.__setError = function() {
    this._status = "error"
  }, ModelResource.prototype.isValid = function() {
    return "loaded" === this._status
  }, ModelResource.prototype.getId = function() {
    return this.id
  }, ModelResource.prototype.setProgress = function(progress) {
    this._progress = progress
  }, ModelResource
}]), xy.dStaticInjector.set(xy.dNames.core.modelMessage, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelMessage(options) {
    this.isSystemMessage = !1, this.isRead = !1, this.discussionEvents = [], ModelMessage.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelMessage, CoreModel), ModelMessage.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    lastEntryDate: utilsConverter.toDate,
    lastReadDate: utilsConverter.toDate,
    lastReadEntryIndex: utilsConverter.toNumber
  }, ModelMessage.prototype.finalisation = function() {
    this.lastReadDate && this.lastReadDate >= this.lastEntryDate && (this.isRead = !0)
  }, ModelMessage.prototype.wasRead = function() {
    this.isRead = !0
  }, ModelMessage
}]), xy.dStaticInjector.set(xy.dNames.core.modelForumThread, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelForumThread(options) {
    this.isRead = !0, ModelForumThread.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelForumThread, CoreModel), ModelForumThread.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    lastMessageDate: utilsConverter.toDate,
    closed: utilsConverter.toBoolean
  }, ModelForumThread.prototype.wasRead = function() {
    this.isRead = !0
  }, ModelForumThread
}]), xy.dStaticInjector.set(xy.dNames.core.modelForumThreadMessage, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelForumThreadMessage(options) {
    this.isRead = !0, ModelForumThreadMessage.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelForumThreadMessage, CoreModel), ModelForumThreadMessage.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    author: utilsConverter.toNumber,
    creationDate: utilsConverter.toDate
  }, ModelForumThreadMessage.prototype.wasRead = function() {
    this.isRead = !0
  }, ModelForumThreadMessage
}]), xy.dStaticInjector.set(xy.dNames.core.modelMessageDiscussionEntry, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelMessageDiscussionEntry(options) {
    this.isSystemMessage = !1, this.isRead = !1, ModelMessageDiscussionEntry.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelMessageDiscussionEntry, CoreModel), ModelMessageDiscussionEntry.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    discussion: utilsConverter.toNumber,
    player: utilsConverter.toNumber,
    creationDate: utilsConverter.toDate
  }, ModelMessageDiscussionEntry
}]), xy.dStaticInjector.set(xy.dNames.core.modelMessageDiscussionMemberChange, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelMessageDiscussionMemberChange(options) {
    ModelMessageDiscussionMemberChange.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelMessageDiscussionMemberChange, CoreModel), ModelMessageDiscussionMemberChange.prototype.correctDataType = {
    id: utilsConverter.toNumber,
    actionType: utilsConverter.toNumber,
    performingPlayer: utilsConverter.toNumber,
    date: utilsConverter.toDate
  }, ModelMessageDiscussionMemberChange.prototype.finalisation = function() {
    if (this.creationDate = this.date, this.targetPlayerArray) {
      var playerArray = [];
      this.targetPlayerArray.forEach(function(playerId) {
        playerArray.push(+playerId)
      }), this.targetPlayerArray = playerArray
    }
  }, ModelMessageDiscussionMemberChange
}]), xy.dStaticInjector.set(xy.dNames.core.modelMission, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.internationalization, function(CoreModel, utilsOop, utilsConverter, servicesInternationalization) {
  "use strict";
  function ModelMission(options) {
    ModelMission.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelMission, CoreModel), ModelMission.prototype.correctDataType = {
    primaryKey: utilsConverter.toNumber,
    order: utilsConverter.toNumber,
    buildSpeedupCost: utilsConverter.toNumber,
    duration: utilsConverter.toNumber,
    missionOccurrence: utilsConverter.toNumber,
    resourceProductionVarianceInt: utilsConverter.toNumber,
    resourceProductionVarianceScale: utilsConverter.toNumber,
    artifactProbabilityInt: utilsConverter.toNumber,
    artifactProbabilityScale: utilsConverter.toNumber,
    unitProductionVarianceInt: utilsConverter.toNumber,
    unitProductionVarianceScale: utilsConverter.toNumber
  }, ModelMission.prototype.finalisation = function() {
    this.niceIdentifier = this.identifier.replace(/\s/g, "").toLowerCase(), this.icon = "icon-mission " + this.identifier.replace(/\s/g, ""), this.title = servicesInternationalization.localize(this.identifier)
  }, ModelMission
}]), xy.dStaticInjector.set(xy.dNames.core.modelMissionInProgress, [xy.dNames.core.modelInProgress, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.sessionUpdateSchedule, function(CoreModelInProgress, utilsOop, utilsConverter, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelMissionInProgress(options) {
    ModelMissionInProgress.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelMissionInProgress, CoreModelInProgress), ModelMissionInProgress.prototype.correctDataType = {
    complete: utilsConverter.toDate,
    durationFactor: utilsConverter.toNumber,
    durationInSeconds: utilsConverter.toNumber,
    missionId: utilsConverter.toNumber
  }, ModelMissionInProgress.prototype.finalisation = function() {
    this.complete && servicesSessionUpdateSchedule.scheduleDate(this.complete)
  }, ModelMissionInProgress
}]), xy.dStaticInjector.set(xy.dNames.core.modelKnowledge, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.internationalization, function(CoreModel, utilsOop, utilsConverter, servicesInternationalization) {
  "use strict";
  function ModelKnowledge(options) {
    ModelKnowledge.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelKnowledge, CoreModel), ModelKnowledge.prototype.correctDataType = {
    primaryKey: utilsConverter.toNumber,
    order: utilsConverter.toNumber,
    buildDuration: utilsConverter.toNumber,
    buildSpeedupCost: utilsConverter.toNumber,
    volumeAmount: utilsConverter.toNumber,
    volumeResource: utilsConverter.toNumber
  }, ModelKnowledge.prototype.finalisation = function() {
    this.icon = "icon-knowledge " + this.identifier.replace(/\s/g, "") + "Icon", this.title = servicesInternationalization.localize(this.identifier)
  }, ModelKnowledge
}]), xy.dStaticInjector.set(xy.dNames.core.modelKnowledgeInProgress, [xy.dNames.core.modelInProgress, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.sessionUpdateSchedule, function(CoreModelInProgress, utilsOop, utilsConverter, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelKnowledgeInProgress(options) {
    ModelKnowledgeInProgress.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelKnowledgeInProgress, CoreModelInProgress), ModelKnowledgeInProgress.prototype.correctDataType = {
    complete: utilsConverter.toDate,
    durationFactor: utilsConverter.toNumber,
    durationInSeconds: utilsConverter.toNumber,
    knowledgeId: utilsConverter.toNumber
  }, ModelKnowledgeInProgress.prototype.finalisation = function() {
    this.complete && servicesSessionUpdateSchedule.scheduleDate(this.complete)
  }, ModelKnowledgeInProgress
}]), xy.dStaticInjector.set(xy.dNames.core.modelBuilding, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, function(CoreModel, utilsOop, utilsConverter) {
  "use strict";
  function ModelBuilding(options) {
    ModelBuilding.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelBuilding, CoreModel), ModelBuilding.prototype.correctDataType = {
    primaryKey: utilsConverter.toNumber,
    order: utilsConverter.toNumber,
    buildDuration: utilsConverter.toNumber,
    level: utilsConverter.toNumber,
    buildSpeedupCost: utilsConverter.toNumber,
    humanResourceId: utilsConverter.toNumber,
    volumeAmount: utilsConverter.toNumber,
    marketDistance: utilsConverter.toNumber
  }, ModelBuilding.prototype.finalisation = function() {
    this.title = this.identifier.replace(/\/\d+/g, ""), this.classIdentifier = this.title.replace(/\s/g, "").toLowerCase(), this.icon = "icon-building icon-building-" + this.classIdentifier, this.isFurtherUpgradePossible = this.upgradeToArray instanceof Array && this.upgradeToArray.length
  }, ModelBuilding.prototype.getResultBuildingPK = function() {
    var pk = null;
    return this.upgradeToArray instanceof Array && this.upgradeToArray.length && (pk = this.upgradeToArray[0]),
            pk
  }, ModelBuilding
}]), xy.dStaticInjector.set(xy.dNames.core.modelBuildingUpgrade, [xy.dNames.core.modelInProgress, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.sessionUpdateSchedule, function(CoreModelInProgress, utilsOop, utilsConverter, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelBuildingUpgrade(options) {
    ModelBuildingUpgrade.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelBuildingUpgrade, CoreModelInProgress), ModelBuildingUpgrade.prototype.correctDataType = {
    buildingTargetID: utilsConverter.toNumber,
    durationFactor: utilsConverter.toNumber,
    durationInSeconds: utilsConverter.toNumber,
    complete: utilsConverter.toDate
  }, ModelBuildingUpgrade.prototype.finalisation = function() {
    this.complete && servicesSessionUpdateSchedule.scheduleDate(this.complete)
  }, ModelBuildingUpgrade
}]), xy.dStaticInjector.set(xy.dNames.core.modelModifier, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreModel, utilsOop, utilsConverter, settingsGameConstan, servicesInternationalization) {
  "use strict";
  function ModelModifier(options) {
    ModelModifier.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelModifier, CoreModel), ModelModifier.prototype.correctDataType = {
    order: utilsConverter.toNumber,
    percentageInt: utilsConverter.toNumber,
    percentageScale: utilsConverter.toNumber,
    primaryKey: utilsConverter.toNumber,
    type: utilsConverter.toNumber
  }, ModelModifier.prototype.finalisation = function() {
    switch (this.icon = "icon-game icon-ModifierIcon-" + this.type, this.persantageHuman = this.percentageInt / Math.pow(10, this.percentageScale - 2), this.type) {
      case settingsGameConstan.MODIFIER_TYPE.BUILD_SPEED:
        "Unit" === this.targetArray[0] && (this.title = servicesInternationalization.localize("%1$ld%% Recruitment Time", this.persantageHuman));
        break;
      case settingsGameConstan.MODIFIER_TYPE.DEFENSE:
        this.title = servicesInternationalization.localize("%1$ld%% Unit Defense", this.persantageHuman - 100);
        break;
      case settingsGameConstan.MODIFIER_TYPE.BUILD_COST:
      case settingsGameConstan.MODIFIER_TYPE.AMOUNT_STORE:
      case settingsGameConstan.MODIFIER_TYPE.AMOUNT_GENERATE:
      case settingsGameConstan.MODIFIER_TYPE.OFFENSE:
      case settingsGameConstan.MODIFIER_TYPE.MOVEMENT_SPEED:
        this.title = servicesInternationalization.localize(this.identifier)
    }
  }, ModelModifier
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatUpgrade, [xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.settings.gameConstant, function(CoreModel, utilsOop, utilsConverter, servicesTheme, servicesInternationalization, servicesLog, settingsGameConstant) {
  "use strict";
  function ModelHabitatUpgrade(options) {
    ModelHabitatUpgrade.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatUpgrade, CoreModel), ModelHabitatUpgrade.prototype.correctDataType = {
    primaryKey: utilsConverter.toNumber,
    order: utilsConverter.toNumber,
    buildDuration: utilsConverter.toNumber,
    buildSpeedupCost: utilsConverter.toNumber,
    habitatAmount: utilsConverter.toNumber,
    listBoundary: utilsConverter.toNumber,
    maximumHabitatDistance: utilsConverter.toNumber
  }, ModelHabitatUpgrade.prototype.finalisation = function() {
    var habitatType, title, habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades;
    switch (this.primaryKey) {
      case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_CENTER:
      case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_EXPANSION:
      case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS:
        habitatType = settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS;
        break;
      case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_CENTER:
      case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_EXPANSION:
      case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY:
        habitatType = settingsGameConstant.HABITAT_UPGRADE_MODE.CITY;
        break;
      default:
        servicesLog("warn", "unknown habitat upgrade mode")
    }
    title = habitatUpgradesThemeSettings[habitatType][this.identifier], this.affectedHabitatType = habitatType, this.title = servicesInternationalization.localize(title)
  }, ModelHabitatUpgrade
}]), xy.dStaticInjector.set(xy.dNames.core.modelHabitatUpgradeInProgress, [xy.dNames.core.modelInProgress, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.services.sessionUpdateSchedule, function(CoreModelInProgress, utilsOop, utilsConverter, servicesSessionUpdateSchedule) {
  "use strict";
  function ModelHabitatUpgradeInProgress(options) {
    ModelHabitatUpgradeInProgress.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelHabitatUpgradeInProgress, CoreModelInProgress), ModelHabitatUpgradeInProgress.prototype.correctDataType = {
    complete: utilsConverter.toDate,
    durationFactor: utilsConverter.toNumber,
    durationInSeconds: utilsConverter.toNumber,
    upgradeId: utilsConverter.toNumber,
    destinationHabitat: utilsConverter.toNumber
  }, ModelHabitatUpgradeInProgress.prototype.finalisation = function() {
    this.complete && servicesSessionUpdateSchedule.scheduleDate(this.complete)
  }, ModelHabitatUpgradeInProgress
}]), xy.dStaticInjector.set(xy.dNames.core.modelSupportBridge, [xy.dNames.gameInstance, xy.dNames.core.model, xy.dNames.utils.oop, xy.dNames.utils.converter, xy.dNames.utils.dateTime, xy.dNames.utils.string, xy.dNames.services.theme, function(gameInstance, CoreModel, utilsOop, utilsConverter, utilsDateTime, utilsString, servicesTheme) {
  "use strict";
  function ModelSupportBridge(options) {
    this.nextAllowedCalculationTime = null, this.key = null, this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager), ModelSupportBridge.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ModelSupportBridge, CoreModel), ModelSupportBridge.prototype.correctDataType = {
    published: utilsConverter.toBoolean,
    nextAllowedCalculationTime: utilsConverter.toDate
  }, ModelSupportBridge.prototype.isCalculationCallPossible = function() {
    return !this.nextAllowedCalculationTime || utilsDateTime.isDatePassed(this.nextAllowedCalculationTime)
  }, ModelSupportBridge.prototype.getLink = function() {
    return utilsString.sprintf(servicesTheme.themeSettings.linksFormat.supportBridge, this.habitatId, this.key, this.servicesGameDataManager.settings.worldId)
  }, ModelSupportBridge
}]), xy.dStaticInjector.set(xy.dNames.core.collection, [xy.dNames.core.coreClass, xy.dNames.utils.oop, xy.dNames.services.log, function(CoreCoreClass, utilsOop, servicesLog) {
  "use strict";
  function CoreCollection(options) {
    CoreCollection.__super__.constructor.call(this, options), this.updated = !1
  }

  return utilsOop.extend(CoreCollection, CoreCoreClass), CoreCollection.prototype.flush = function() {
    servicesLog("warn", 'call not implemented "abstract" method flush of CoreCollection')
  }, CoreCollection
}]), xy.dStaticInjector.set(xy.dNames.core.collectionAlliances, [xy.dNames.services.log, xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelAlliance, xy.dNames.core.modelAllianceClash, xy.dNames.core.modelAllianceRelation, xy.dNames.core.modelAllianceSharing, xy.dNames.settings.gameConstant, xy.dNames.services.sortable, xy.dNames.services.internationalization, function(servicesLog, CoreCollection, utilsOop, CoreModelAlliance, CoreModelAllianceClash, CoreModelAllianceRelation, CoreModelAllianceSharing, settingsGameConstant, servicesSortable, servicesInternationalization) {
  "use strict";
  function CollectionAlliances(options) {
    CollectionAlliances.__super__.constructor.call(this, options), this.playersAllianceId = null, this.alliancesSet = {}, this.diplomacyRelations = {}, this.diplomacyRelationByAllianceId = {}, this.resetDiplomacyRelations = !1, this.alliancesSharingSet = {}, this.alliancesSharingByAlliance = {}, this.warClashedUpdated = !1, this.warClashedAmount = 0, this.warClashedSet = {
      transits: {},
      habitats: {}
    }, this.warClashedData = {}
  }

  return utilsOop.extend(CollectionAlliances, CoreCollection), CollectionAlliances.prototype.setPlayersAllianceId = function(playersAllianceId) {
    this.playersAllianceId = playersAllianceId
  }, CollectionAlliances.prototype.updateAlliancesData = function(data, options) {
    options = options || {}, data instanceof Array && (data.forEach(function(rawAllianceData) {
      options.isPeripheral && (rawAllianceData.isPeripheral = !0);
      var modeledAlly = new CoreModelAlliance(rawAllianceData), allyId = modeledAlly.id;
      modeledAlly.hasOwnProperty("habitatCountByTypeDictionary") && (modeledAlly.updated = !0), this.playersAllianceId === allyId ? modeledAlly.updated && (this.alliancesSet[allyId] = modeledAlly, this.updateWarClashesData({ ownAlliance: modeledAlly })) : (this.alliancesSet.hasOwnProperty(allyId) === !1 || this.alliancesSet[allyId].updated === !1 || modeledAlly.updated) && (this.alliancesSet[allyId] = modeledAlly)
    }, this), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    }))
  }, CollectionAlliances.prototype.updateAllianceWithFullData = function(data) {
    data.Data && (data.Data.Player instanceof Array && this.servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), data.Data.Alliance instanceof Array && data.Data.Alliance.forEach(function(rawAlliance) {
      rawAlliance.updated = !0;
      var modeledAlliance = new CoreModelAlliance(rawAlliance);
      this.alliancesSet[modeledAlliance.id] = modeledAlliance, this.playersAllianceId === modeledAlliance.id && this.updateWarClashesData({ ownAlliance: modeledAlliance })
    }, this)), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    })
  }, CollectionAlliances.prototype.updateAlliancesRelations = function(data) {
    this.resetDiplomacyRelations && (this.resetDiplomacyRelations = !1, this.diplomacyRelations = {}, this.diplomacyRelationByAllianceId = {}), data instanceof Array && (this.diplomacyRelations = {}, this.diplomacyRelationByAllianceId = {}, data.forEach(function(rawAllianceRelationData) {
      var modeledAllianceRelation = new CoreModelAllianceRelation(rawAllianceRelationData);
      this.diplomacyRelations[modeledAllianceRelation.id] = modeledAllianceRelation, this.diplomacyRelationByAllianceId[modeledAllianceRelation.targetAlliance] = modeledAllianceRelation.id
    }, this))
  }, CollectionAlliances.prototype.updateAlliancesSharing = function(data) {
    this.alliancesSharingSet = {}, this.alliancesSharingByAlliance = {}, data instanceof Array && data.forEach(function(rawAllianceSharingData) {
      var modeledAllianceSharing = new CoreModelAllianceSharing(rawAllianceSharingData), allianceId = modeledAllianceSharing.sourceAlliance === this.playersAllianceId ? modeledAllianceSharing.destinationAlliance : modeledAllianceSharing.sourceAlliance;
      modeledAllianceSharing.targetAlliance = allianceId, this.alliancesSharingSet[modeledAllianceSharing.id] = modeledAllianceSharing, this.alliancesSharingByAlliance[allianceId] = modeledAllianceSharing.id
    }, this)
  }, CollectionAlliances.prototype.updateWarClashesData = function(options) {
    if (this.warClashedUpdated = !1, this.warClashedData = {}, options.ownAlliance) {
      this.warClashedSet = { transits: {}, habitats: {} };
      var amount = 0;
      return options.ownAlliance.postedClashTransitPrimaryKeysArray && options.ownAlliance.postedClashTransitPrimaryKeysArray.length && options.ownAlliance.postedClashTransitPrimaryKeysArray.forEach(function(transitId) {
        this.warClashedSet.transits[transitId] = !0, amount += 1
      }, this), options.ownAlliance.postedClashBattleHabitatPrimaryKeysArray && options.ownAlliance.postedClashBattleHabitatPrimaryKeysArray.length && options.ownAlliance.postedClashBattleHabitatPrimaryKeysArray.forEach(function(habitatId) {
        this.warClashedSet.habitats[habitatId] = !0, amount += 1
      }, this), options.ownAlliance.postedClashSupportBridgePrimaryKeysArray && options.ownAlliance.postedClashSupportBridgePrimaryKeysArray.length && options.ownAlliance.postedClashSupportBridgePrimaryKeysArray.forEach(function(habitatId) {
        this.warClashedSet.habitats[habitatId] = !0, amount += 1
      }, this), this.warClashedAmount = amount, void this.servicesGameDataManager.fireDataUpdateListener(null, {
        entity: xy.eNames.dataListeners.dataEntity.allianceClashes,
        identifier: xy.eNames.dataListeners.dataIdentifiers.flushed
      })
    }
    options.AllianceClashTransit && options.AllianceClashTransit.forEach(function(rawClash) {
      var modeledClash = new CoreModelAllianceClash(rawClash);
      this.warClashedData[modeledClash.id] = modeledClash
    }, this), options.AllianceClashBattle && options.AllianceClashBattle.forEach(function(rawClash) {
      rawClash.isBattle = !0;
      var modeledClash = new CoreModelAllianceClash(rawClash);
      this.warClashedData[modeledClash.id] = modeledClash
    }, this), options.AllianceClashSupportBridge && options.AllianceClashSupportBridge.forEach(function(rawClash) {
      var modeledClash = new CoreModelAllianceClash(rawClash);
      this.warClashedData[modeledClash.id] = modeledClash
    }, this), this.warClashedUpdated = !0
  }, CollectionAlliances.prototype.isPlayerMemberOfPlayersAlliance = function(playerId) {
    var player = this.servicesGameDataManager.playersCollection.getPlayer(playerId);
    return player.alliance === this.playersAllianceId
  }, CollectionAlliances.prototype.getAlliance = function(allianceId) {
    allianceId = allianceId || this.playersAllianceId;
    var alliance = this.alliancesSet[allianceId];
    if (alliance) {
      if (alliance.isPeripheral) {
        var now = new Date;
        if (now - alliance.cachedAt > settingsGameConstant.CACHE_LIFE_TIME)return servicesLog("warn", "You tried to obtain expired alliance id"), delete this.alliancesSet[allianceId], null
      }
      return alliance
    }
    return servicesLog("warn", "You tried to obtain unknown alliance id"), null
  }, CollectionAlliances.prototype.getAllianceRelationship = function(allianceId) {
    return this.playersAllianceId ? this.playersAllianceId === allianceId ? settingsGameConstant.ALLIANCE_RELATIONSHIPS.MEMBER : this.diplomacyRelationByAllianceId[allianceId] ? this.diplomacyRelations[this.diplomacyRelationByAllianceId[allianceId]].relationship : settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALL : settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALL
  }, CollectionAlliances.prototype.getEmptyAlliance = function() {
    return { name: servicesInternationalization.localize("No Alliance"), points: "0", isEmpty: !0 }
  }, CollectionAlliances.prototype.canExternalPlayerBeInvited = function(externalPlayer) {
    if (!this.playersAllianceId)return !1;
    if (externalPlayer.alliance === this.playersAllianceId)return !1;
    var alliance = this.getAlliance();
    if (alliance.allianceAplicants[externalPlayer.id])return !1;
    var player = this.servicesGameDataManager.playersCollection.getPlayer();
    return player.canInvite()
  }, CollectionAlliances.prototype.isExternalPlayerInvited = function(externalPlayerId) {
    var player = this.servicesGameDataManager.playersCollection.getPlayer();
    if (!player.canInvite())return !1;
    var alliance = this.getAlliance();
    return !!alliance && (alliance.invitedPlayerArray && alliance.invitedPlayerArray.indexOf(externalPlayerId) !== -1)
  }, CollectionAlliances.prototype.isExternalPlayerApplicant = function(externalPlayerId) {
    var player = this.servicesGameDataManager.playersCollection.getPlayer();
    if (!player.canInvite())return !1;
    var alliance = this.getAlliance();
    return !!alliance && (alliance.allianceAplicants[externalPlayerId] || !1)
  }, CollectionAlliances.prototype.isExternalPlayerAcceptedInvitation = function(externalPlayerId) {
    var alliance = this.getAlliance();
    return !!alliance && alliance.playerArray.indexOf(externalPlayerId.toString()) !== -1
  }, CollectionAlliances.prototype.getAllianceProperty = function(propertyName, allianceId) {
    return allianceId = allianceId || this.playersAllianceId, this.alliancesSet[allianceId] && this.alliancesSet[allianceId][propertyName] ? this.alliancesSet[allianceId][propertyName] : null
  }, CollectionAlliances.prototype.getAllianceMembersNumber = function() {
    return this.alliancesSet[this.playersAllianceId].playerArray.length || 0
  }, CollectionAlliances.prototype.getInvitation = function() {
    return this.alliancesSet[this.playersAllianceId].invitedPlayerArray || []
  }, CollectionAlliances.prototype.getApplications = function() {
    return this.alliancesSet[this.playersAllianceId].applicantArray || []
  }, CollectionAlliances.prototype.getDiplomacyList = function() {
    var id, list = [];
    for (id in this.diplomacyRelations)this.diplomacyRelations.hasOwnProperty(id) && list.push(this.diplomacyRelations[id]);
    return list
  }, CollectionAlliances.prototype.getSharingList = function() {
    var id, list = [];
    for (id in this.alliancesSharingSet)this.alliancesSharingSet.hasOwnProperty(id) && list.push(this.alliancesSharingSet[id]);
    return list
  }, CollectionAlliances.prototype.getSharingByAlliance = function(allianceId) {
    return this.alliancesSharingByAlliance.hasOwnProperty(allianceId) ? this.alliancesSharingSet[this.alliancesSharingByAlliance[allianceId]] : null
  }, CollectionAlliances.prototype.getAttackAndDefenseClashes = function() {
    var key, clashedModel, clashes = { attack: [], defense: [] };
    for (key in this.warClashedData)if (this.warClashedData.hasOwnProperty(key))switch (clashedModel = this.warClashedData[key], clashedModel.battleType) {
      case settingsGameConstant.ALLIANCE_CLASHES_TYPE.ATTACK:
        clashes.attack.push(clashedModel);
        break;
      case settingsGameConstant.ALLIANCE_CLASHES_TYPE.DEFENSE:
        clashes.defense.push(clashedModel)
    }
    return clashes.attack.sort(servicesSortable.byField("eventDate")), clashes.defense.sort(servicesSortable.byField("eventDate")), clashes
  }, CollectionAlliances.prototype.updateAlliance = function(options) {
    this.alliancesSet.hasOwnProperty(options.id) && (this.alliancesSet[options.id][options.key] = options.value), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    })
  }, CollectionAlliances
}]), xy.dStaticInjector.set(xy.dNames.core.collectionAllianceReport, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.services.sortable, xy.dNames.core.modelAllianceFeedReport, function(CoreCollection, utilsOop, servicesSortable, CoreModelAllianceReport) {
  "use strict";
  function CollectionAllianceReports(options) {
    CollectionAllianceReports.__super__.constructor.call(this, options), this.allianceReports = {}, this.lastReadAllianceReportDate = null, this.updated = !1
  }

  return utilsOop.extend(CollectionAllianceReports, CoreCollection), CollectionAllianceReports.prototype.updateAlliancesReports = function(data) {
    data.Data && (this.lastReadAllianceReportDate = data.lastReadAllianceReportDate, data.Data.Alliance instanceof Array && this.servicesGameDataManager.updateAlliancesData(data.Data.Alliance, { isPeripheral: !0 }), data.Data.Habitat instanceof Array && this.servicesGameDataManager.updateHabitatsData(data.Data.Habitat, { isPeripheral: !0 }), data.Data.Player instanceof Array && this.servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), data.Data.AllianceReport instanceof Array && data.Data.AllianceReport.forEach(function(rawAllianceReportData) {
      var modeledAllyReport = new CoreModelAllianceReport(rawAllianceReportData);
      modeledAllyReport.date < this.lastReadAllianceReportDate && (modeledAllyReport.isRead = !0), this.allianceReports[modeledAllyReport.id] = modeledAllyReport
    }, this), this.updated = !0), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.allianceReport,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    })
  }, CollectionAllianceReports.prototype.flushAllianceReportsOnSettingsChanged = function() {
    this.allianceReports = {}, this.updated = !1
  }, CollectionAllianceReports.prototype.flush = function() {
    this.allianceReports = {}, this.updated = !1, this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.allianceReport,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed
    })
  }, CollectionAllianceReports.prototype.getAllianceReportsList = function() {
    var reportId, reportsList = [];
    for (reportId in this.allianceReports)this.allianceReports.hasOwnProperty(reportId) && reportsList.push(this.allianceReports[reportId]);
    return reportsList.sort(servicesSortable.allianceReports), reportsList
  }, CollectionAllianceReports.prototype.getAllianceReport = function(reportId) {
    return this.allianceReports.hasOwnProperty(reportId) ? this.allianceReports[reportId] : null
  }, CollectionAllianceReports.prototype.setReportRead = function(reportId) {
    return this.allianceReports.hasOwnProperty(reportId) && (this.allianceReports[reportId].isRead = !0), null
  }, CollectionAllianceReports
}]), xy.dStaticInjector.set(xy.dNames.core.collectionBuildings, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.core.modelBuilding, xy.dNames.core.modelBuildingUpgrade, xy.dNames.services.sortable, function(CoreCollection, utilsOop, settingsGameConstant, CoreModelBuilding, CoreModelBuildingUpgrade, servicesSortable) {
  "use strict";
  function CollectionBuildings(options) {
    CollectionBuildings.__super__.constructor.call(this, options), this.buildings = {}, this.buildingsByIdentifier = {}, this.buildingsMaxLevel = {}, this.buildingsTitle = {}, this.curentBuildingsUpgrade = {}
  }

  return utilsOop.extend(CollectionBuildings, CoreCollection), CollectionBuildings.prototype.updateBuildingsData = function(data, options) {
    return options = options || {}, data instanceof Array && data.forEach(function(rawBuilding) {
      var modeledBuilding = new CoreModelBuilding(rawBuilding), buildingPK = modeledBuilding.primaryKey;
      this.buildings[buildingPK] = modeledBuilding, this.buildingsByIdentifier[modeledBuilding.identifier] = buildingPK, this.buildingsMaxLevel[modeledBuilding.classIdentifier] || (this.buildingsMaxLevel[modeledBuilding.classIdentifier] = modeledBuilding.level), this.buildingsMaxLevel[modeledBuilding.classIdentifier] < modeledBuilding.level && (this.buildingsMaxLevel[modeledBuilding.classIdentifier] = modeledBuilding.level), this.buildingsTitle[modeledBuilding.classIdentifier] = modeledBuilding.title, modeledBuilding.requiredKnowledgeArray instanceof Array && this.servicesGameDataManager.knowledgesCollection.updateEnables(modeledBuilding.requiredKnowledgeArray, {
        entity: settingsGameConstant.ENTITY.BUILDING,
        entityPrimaryKey: modeledBuilding.primaryKey
      })
    }, this), !0
  }, CollectionBuildings.prototype.updateBuildingUpgradesData = function(data) {
    return data instanceof Array && data.forEach(function(rawBuildingUpgrade) {
      var modeledBuildingUpgrade = new CoreModelBuildingUpgrade(rawBuildingUpgrade);
      this.curentBuildingsUpgrade[modeledBuildingUpgrade.id] = modeledBuildingUpgrade
    }, this), !0
  }, CollectionBuildings.prototype.getBuildingTitle = function(classIdentifier) {
    return classIdentifier && this.buildingsTitle[classIdentifier] ? this.buildingsTitle[classIdentifier] : null
  }, CollectionBuildings.prototype.getBuilding = function(options) {
    options = options || {}, options.primaryKey && (options.pk = options.primaryKey);
    var pk = options.pk || this.buildingsByIdentifier[options.identifier];
    return pk && this.buildings[pk] ? this.buildings[pk] : null
  }, CollectionBuildings.prototype.getBuildingInProgress = function(buildingInProgressId) {
    return this.curentBuildingsUpgrade.hasOwnProperty(buildingInProgressId) ? this.curentBuildingsUpgrade[buildingInProgressId] : null
  }, CollectionBuildings.prototype.getBuildingProperty = function(propertyName, options) {
    options = options || {}, options.primaryKey && (options.pk = options.primaryKey);
    var pk = options.pk || this.buildingsByIdentifier[options.identifier];
    return pk && this.buildings[pk] && this.buildings[pk][propertyName] ? this.buildings[pk][propertyName] : null
  }, CollectionBuildings.prototype.getHabitatBuildingsInUpgradeSet = function(options) {
    options = options || {};
    var habitatModel = options.habitat || this.servicesGameDataManager.habitatsCollection.getHabitat(), setObject = {};
    return habitatModel && habitatModel.habitatBuildingUpgradeArray instanceof Array && habitatModel.habitatBuildingUpgradeArray.forEach(function(buildingUpgradeId) {
      var buildingUpgrade, resultBuildingClassIdentifier;
      buildingUpgrade = this.curentBuildingsUpgrade[buildingUpgradeId], resultBuildingClassIdentifier = this.buildings[buildingUpgrade.buildingTargetID].classIdentifier, setObject[resultBuildingClassIdentifier] = !0
    }, this), setObject
  }, CollectionBuildings.prototype.getHabitatBuildingUpgrades = function(options) {
    options = options || {};
    var habitatModel = options.habitat || this.servicesGameDataManager.habitatsCollection.getHabitat(options.habitatId), limitationIdentifier = options.buildingClass || null, result = [];
    return habitatModel && habitatModel.habitatBuildingUpgradeArray instanceof Array && habitatModel.habitatBuildingUpgradeArray.forEach(function(buildingUpgradeId) {
      var buildingUpgrade, resultBuilding;
      buildingUpgrade = this.curentBuildingsUpgrade[buildingUpgradeId], resultBuilding = this.buildings[buildingUpgrade.buildingTargetID], (!limitationIdentifier || limitationIdentifier && resultBuilding.classIdentifier === limitationIdentifier) && result.push({
        buildingUpgrade: buildingUpgrade,
        resultBuilding: resultBuilding
      })
    }, this), result.sort(servicesSortable.byField("buildingUpgrade", "complete")), result
  }, CollectionBuildings.prototype.getHabitatBuildingOfClass = function(options) {
    var buildingClass, habitatsBuildingsPKArray, building, primaryKey, i, len;
    for (buildingClass = options.buildingClass, habitatsBuildingsPKArray = options.habitat.habitatBuildingKeyArray, len = habitatsBuildingsPKArray.length, i = 0; i < len; i += 1)if (primaryKey = habitatsBuildingsPKArray[i], building = this.getBuilding({ pk: primaryKey }), building.classIdentifier === buildingClass)return building;
    return null
  }, CollectionBuildings.prototype.getAllBuildingsOfClass = function(options) {
    var buildingPK, buildingClass = options.buildingClass, result = {};
    for (buildingPK in this.buildings)this.buildings.hasOwnProperty(buildingPK) && this.buildings[buildingPK].classIdentifier === buildingClass && (result[buildingPK] = this.buildings[buildingPK]);
    return result
  }, CollectionBuildings
}]), xy.dStaticInjector.set(xy.dNames.core.collectionBuffs, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelBuff, xy.dNames.core.modelBuffActive, function(CoreCollection, utilsOop, CoreModelBuff, CoreModelBuffActive) {
  "use strict";
  function CollectionBuff(options) {
    CollectionBuff.__super__.constructor.call(this, options), this.buffSet = {}, this.buffsByIdentifier = {}, this.habitatsBuffSet = {}
  }

  return utilsOop.extend(CollectionBuff, CoreCollection), CollectionBuff.prototype.updateBuffsData = function(data) {
    return data instanceof Array && data.forEach(function(rawBuff) {
      var modeledBuff = new CoreModelBuff(rawBuff), buffPK = modeledBuff.primaryKey;
      this.buffSet[buffPK] = modeledBuff, this.buffsByIdentifier[modeledBuff.identifier] = buffPK
    }, this), !0
  }, CollectionBuff.prototype.updateBuffActiveData = function(data) {
    return data instanceof Array && data.forEach(function(rawHabitatsBuff) {
      var modeledHabitatsBuff = new CoreModelBuffActive(rawHabitatsBuff), id = modeledHabitatsBuff.id;
      this.habitatsBuffSet[id] = modeledHabitatsBuff
    }, this), !0
  }, CollectionBuff.prototype.getBuff = function(options) {
    options = options || {};
    var pk = options.primaryKey || this.buffsByIdentifier[options.identifier];
    return pk && this.buffSet[pk] ? this.buffSet[pk] : null
  }, CollectionBuff.prototype.getHabitatsBuff = function(options) {
    options = options || {};
    var id = options.id;
    return id && this.habitatsBuffSet[id] ? this.habitatsBuffSet[id] : null
  }, CollectionBuff
}]), xy.dStaticInjector.set(xy.dNames.core.collectionHabitats, [xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.storage, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.core.collection, xy.dNames.core.modelHabitatGame, xy.dNames.core.modelHabitatReservation, xy.dNames.core.modelHabitatMap, function(settingsGameConstant, servicesLog, servicesTheme, servicesStorage, utilsOop, utilsDateTime, CoreCollection, CoreModelHabitatGame, CoreModelHabitatReservation, CoreModelHabitatMap) {
  "use strict";
  function CollectionHabitats(options) {
    CollectionHabitats.__super__.constructor.call(this, options);
    var conquerResourceId = servicesTheme.themeSettings.resources.conquestResourceId;
    this.currentHabitatIdSortedPosition = 0, this.currentHabitatId = null, this.firstHabitatId = null, this.playerId = null, this.playersHabitatSet = {}, this.playersHabitatSortedArray = [], this.habitatTypesBelongsToPlayer = {
      0: !1,
      2: !1,
      4: !1
    }, this.habitatSet = {}, this.habitatMapSet = {}, this.habitatReportSet = {}, this.habitatUnderAttack = {}, this.reservationSet = {}, this.habitatReservation = {}, this.habitatReservationAmounts = {
      requested: 0,
      accepted: 0
    }, this.ownHabitatReservationAmounts = {
      requested: 0,
      accepted: 0
    }, this.sortingOwnLocalUnitArrayIndex = 0, this.isReverseSorting = !1, this.sortingFunction = settingsGameConstant.SORTING_HABITAT_FUNCTION.ALPHABET, this.isReverseSortingForeign = !1, this.sortingForeignFunction = settingsGameConstant.SORTING_HABITAT_FUNCTION.ALPHABET, this.sortable = {}, this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.ALPHABET] = function(a, b) {
      var aName = this.habitatSet[a].name.toLowerCase(), bName = this.habitatSet[b].name.toLowerCase();
      return aName === bName ? 0 : aName > bName ? 1 : -1
    }.bind(this), this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.POINTS] = function(a, b) {
      var oA = this.habitatSet[a], oB = this.habitatSet[b], pointDif = oA.points - oB.points;
      if (pointDif)return pointDif;
      var aName = oA.name.toLowerCase(), bName = oB.name.toLowerCase();
      return aName === bName ? 0 : aName > bName ? 1 : -1
    }.bind(this), this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.CONQUER_RESOURCE] = function(a, b) {
      return this.habitatSet[a].habitatResourceDictionary[conquerResourceId].amount - this.habitatSet[b].habitatResourceDictionary[conquerResourceId].amount
    }.bind(this), this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.DISTANCE] = function(a, b) {
      return this.habitatSet[a].distanceToActiveHabitat - this.habitatSet[b].distanceToActiveHabitat
    }.bind(this), this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.UNITS] = function(a, b) {
      var oA = this.habitatSet[a].ownLocalUnits, oB = this.habitatSet[b].ownLocalUnits;
      if (oA instanceof Array && oB instanceof Array) {
        if (this.sortingOwnLocalUnitArrayIndex > -1)return oA[this.sortingOwnLocalUnitArrayIndex].amount - oB[this.sortingOwnLocalUnitArrayIndex].amount;
        if (this.sortingOwnLocalUnitArrayIndex === settingsGameConstant.SORTING_HABITAT_BY_UNIT_KEYS.ALL_UNITS) {
          var aSum = 0, bSum = 0;
          return oA.forEach(function(unit) {
            aSum += unit.amount
          }), oB.forEach(function(unit) {
            bSum += unit.amount
          }), aSum - bSum
        }
      }
      return !(oA instanceof Array) && oB instanceof Array ? -1 : !(oB instanceof Array) && oA instanceof Array ? 1 : 0
    }.bind(this), this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.UNDER_ATTACK] = function(a, b) {
      return this.habitatSet[a].possibleNextBattleDate && this.habitatSet[b].possibleNextBattleDate ? this.habitatSet[a].possibleNextBattleDate - this.habitatSet[b].possibleNextBattleDate : this.habitatSet[a].possibleNextBattleDate ? -1 : this.habitatSet[b].possibleNextBattleDate ? 1 : this.habitatSet[a].points - this.habitatSet[b].points
    }.bind(this)
  }

  return utilsOop.extend(CollectionHabitats, CoreCollection), CollectionHabitats.prototype.setPlayerId = function(playerId) {
    this.playerId = playerId
  }, CollectionHabitats.prototype.setPlayerHabitats = function(habitatIdArray) {
    this.firstHabitatId = +habitatIdArray[0];
    var i, habitatId, len = habitatIdArray.length;
    for (this.playersHabitatSet = {}, this.playersHabitatSortedArray = [], i = 0; i < len; i += 1)habitatId = +habitatIdArray[i], this.playersHabitatSet[habitatId] = !0, this.playersHabitatSortedArray[i] = habitatId;
    return !0
  }, CollectionHabitats.prototype.setCurrentHabitatId = function(habitatId, newPosition) {
    this.playersHabitatSet.hasOwnProperty(habitatId) && (this.currentHabitatId = habitatId, this.currentHabitatIdSortedPosition = newPosition || this.getSortedPositionOfHabitat(habitatId), servicesStorage.storeActiveHabitatId(habitatId), this.servicesGameDataManager.fireDataUpdateListener({ habitat: this.habitatSet[this.currentHabitatId] }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat
    }))
  }, CollectionHabitats.prototype.setAsCurrentNextHabitat = function() {
    var newPosition = 0, possibleNewPosition = this.currentHabitatIdSortedPosition + 1;
    possibleNewPosition < this.playersHabitatSortedArray.length && (newPosition = possibleNewPosition), this.setCurrentHabitatId(this.playersHabitatSortedArray[newPosition], newPosition)
  }, CollectionHabitats.prototype.setAsCurrentPrevHabitat = function() {
    var newPosition = this.playersHabitatSortedArray.length - 1, possibleNewPosition = this.currentHabitatIdSortedPosition - 1;
    possibleNewPosition > -1 && (newPosition = possibleNewPosition), this.setCurrentHabitatId(this.playersHabitatSortedArray[newPosition], newPosition)
  }, CollectionHabitats.prototype.updateHabitatUnderAttack = function(data) {
    this.habitatUnderAttack = {}, data instanceof Array && data.forEach(function(habitatId) {
      this.habitatUnderAttack[habitatId] = !0
    }, this)
  }, CollectionHabitats.prototype.updateHabitatSet = function(data, options) {
    options = options || {};
    var lastActiveHabitatId;
    return data instanceof Array && (data.forEach(function(rawHabitatData) {
      var modeledHabitat, habitatOwnerId = +rawHabitatData.player, habitatId = +rawHabitatData.id;
      this.habitatSet[habitatId] && this.habitatSet[habitatId].player === habitatOwnerId ? this.habitatSet[habitatId].update(rawHabitatData) : (modeledHabitat = new CoreModelHabitatGame(rawHabitatData),
      this.playerId === modeledHabitat.player && (modeledHabitat.isOwnByPlayer = !0), this.habitatSet[habitatId] = modeledHabitat)
    }, this), options.isPeripheral !== !0 && (null === this.currentHabitatId && null === this.firstHabitatId ? this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.lostAllHabitats
    }) : !this.currentHabitatId && this.firstHabitatId && (lastActiveHabitatId = servicesStorage.getActiveHabitatId(), lastActiveHabitatId && this.playersHabitatSet.hasOwnProperty(lastActiveHabitatId) || (lastActiveHabitatId = this.firstHabitatId), this.setLastActiveHabitatAsCurrent(lastActiveHabitatId)))), this.checkHabitatTypesBelongToPLayer(), this.sortOwnHabitat(), !0
  }, CollectionHabitats.prototype.setLastActiveHabitatAsCurrent = function(habitatId) {
    this.setCurrentHabitatId(habitatId), this.servicesGameDataManager.fireDataUpdateListener(this.habitatSet[habitatId], {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setInitialHabitatAction
    }), this.servicesGameDataManager.eventsCollection.setRewardedHabitatId(habitatId), this.servicesGameDataManager.fireDataUpdateListener(this.habitatSet[habitatId], {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setRewardedHabitatAction
    })
  }, CollectionHabitats.prototype.checkHabitatTypesBelongToPLayer = function() {
    this.habitatTypesBelongsToPlayer = { 0: !1, 2: !1, 4: !1 };
    var habitatId;
    for (habitatId in this.playersHabitatSet)this.playersHabitatSet.hasOwnProperty(habitatId) && this.habitatSet[habitatId] && (this.habitatTypesBelongsToPlayer[this.habitatSet[habitatId].publicHabitatType] = !0)
  }, CollectionHabitats.prototype.getHabitatTypesBelongToPlayer = function() {
    return this.habitatTypesBelongsToPlayer
  }, CollectionHabitats.prototype.getDefaultHabitatTabMode = function() {
    var habitatTypeMode;
    return habitatTypeMode = this.habitatTypesBelongsToPlayer[settingsGameConstant.HABITAT_TYPE.CASTLE] ? settingsGameConstant.HABITAT_TYPE.CASTLE : this.habitatTypesBelongsToPlayer[settingsGameConstant.HABITAT_TYPE.FORTRESS] ? settingsGameConstant.HABITAT_TYPE.FORTRESS : settingsGameConstant.HABITAT_TYPE.CITY
  }, CollectionHabitats.prototype.updateWithHabitatMapResponse = function(data, options) {
    return options = options || {}, data instanceof Array && data.forEach(function(rawHabitatData) {
      var modeledHabitat, habitatId = rawHabitatData.id, habitatOwnerId = +rawHabitatData.player;
      options.isPoliticalMapResponse ? (modeledHabitat = new CoreModelHabitatMap(rawHabitatData), modeledHabitat.player !== this.playerId && (this.habitatMapSet[habitatId] = modeledHabitat)) : this.habitatSet.hasOwnProperty(habitatId) && this.habitatSet[habitatId].player === habitatOwnerId ? this.habitatSet[habitatId].update(rawHabitatData) : (modeledHabitat = new CoreModelHabitatGame(rawHabitatData), modeledHabitat.player !== this.playerId && (this.habitatSet[habitatId] = modeledHabitat))
    }, this), !0
  }, CollectionHabitats.prototype.updateWithHabitatReportResponse = function(data) {
    return data instanceof Array && data.forEach(function(rawHabitatData) {
      var modeledHabitat = new CoreModelHabitatMap(rawHabitatData);
      this.habitatReportSet[modeledHabitat.id] = modeledHabitat
    }, this), !0
  }, CollectionHabitats.prototype.updatePossibleNextBattleDateForPlayersHabitats = function() {
    var habitatId;
    for (habitatId in this.playersHabitatSet)this.playersHabitatSet.hasOwnProperty(habitatId) && this.habitatSet[habitatId].setPossibleNextBattleDate()
  }, CollectionHabitats.prototype.sortOwnHabitat = function(options) {
    if (options = options || {}, options.by) {
      if (!this.sortable[options.by])return void servicesLog("error", "Trying to sort by unknown sortable");
      this.sortingFunction = options.by
    }
    if (options.isReverseSorting && (this.isReverseSorting = options.isReverseSorting), options.oppositeDirection && (this.isReverseSorting = !this.isReverseSorting), this.sortingFunction) {
      var sortable = this.sortable[this.sortingFunction];
      this.playersHabitatSortedArray.sort(sortable), this.isReverseSorting && this.playersHabitatSortedArray.reverse()
    }
    return this.currentHabitatIdSortedPosition = this.getSortedPositionOfHabitat(this.currentHabitatId), this.servicesGameDataManager.fireDataUpdateListener(this.habitatSet[this.firstHabitatId], {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.habitatsSorted
    }), !0
  }, CollectionHabitats.prototype.sortPLayerHabitats = function(options) {
    if (options = options || {}, options.by) {
      if (!this.sortable[options.by])return servicesLog("error", "Trying to sort by unknown sortable"), !1;
      this.sortingFunction = options.by
    }
    if (options.isReverseSorting && (this.isReverseSortingForeign = options.isReverseSorting), options.oppositeDirection && (this.isReverseSortingForeign = !this.isReverseSortingForeign), this.sortingForeignFunction) {
      var sortable = this.sortable[this.sortingForeignFunction];
      options.player.habitatArray.sort(sortable), this.isReverseSortingForeign && options.player.habitatArray.reverse()
    }
    return this.currentHabitatIdSortedPosition = this.getSortedPositionOfHabitat(this.currentHabitatId), this.servicesGameDataManager.fireDataUpdateListener(this.habitatSet[this.firstHabitatId], {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.habitatsSorted
    }), !0
  }, CollectionHabitats.prototype.getSortedPositionOfHabitat = function(id) {
    if (!this.isHabitatOwnByPlayer(id))throw new Error("Habitat has not a position cause it own not by player");
    return this.playersHabitatSortedArray.indexOf(id)
  }, CollectionHabitats.prototype.isHabitatOwnByPlayer = function(id) {
    return this.playersHabitatSet[id] || !1
  }, CollectionHabitats.prototype.getTotalForResource = function(resources) {
    var result = {};
    return resources instanceof Array || (resources = [resources]), resources.forEach(function(resourceId) {
      result[resourceId] = 0
    }), this.playersHabitatSortedArray.forEach(function(habitatId) {
      var resourcesDictionary = this.habitatSet[habitatId].habitatResourceDictionary;
      resources.forEach(function(resourceId) {
        try {
          result[resourceId] += resourcesDictionary[resourceId].amount
        } catch (eX) {
          servicesLog("error", "Passed not valid resource to CollectionHabitats.prototype.getTotalForResource method, id " + resourceId), servicesLog("error", eX)
        }
      })
    }, this), result
  }, CollectionHabitats.prototype.getOwnHabitatsAmount = function() {
    return this.playersHabitatSortedArray.length
  }, CollectionHabitats.prototype.getOwnHabitatsUnderAttackAmount = function() {
    var habitatId, amount = 0;
    for (habitatId in this.playersHabitatSet)this.playersHabitatSet.hasOwnProperty(habitatId) && (this.habitatSet[habitatId].setPossibleNextBattleDate(), (this.isHabitatUnderAttack(habitatId) || this.isHabitatGoingToHaveBattle(habitatId)) && (amount += 1));
    return amount
  }, CollectionHabitats.prototype.getOwnHabitatsWeightedAmount = function() {
    var amount = 0;
    return this.playersHabitatSortedArray.forEach(function(habitatId) {
      var modeledHabitat = this.habitatSet[habitatId];
      amount += 2 === modeledHabitat.publicHabitatType ? 5 : 1
    }, this), amount
  }, CollectionHabitats.prototype.getOwnHabitatsAmountByHabitatTypes = function() {
    var ownHabitatsList = this.getOwnHabitatList(), habitatAmountObject = { 0: 0, 2: 0, 4: 0 };
    return ownHabitatsList.forEach(function(habitatId) {
      var habitat = this.getHabitat(habitatId);
      habitatAmountObject[habitat.publicHabitatType] += 1
    }, this), habitatAmountObject
  }, CollectionHabitats.prototype.getOwnHabitatList = function() {
    return this.playersHabitatSortedArray
  }, CollectionHabitats.prototype.getHabitatMapCoordinates = function(id) {
    var habitat = this.habitatSet[id] || this.habitatMapSet[id] || null;
    return habitat ? {
      mapX: habitat.mapX,
      mapY: habitat.mapY
    } : (servicesLog("warn", "Trying to retrieve unknown habitat, for map coordinates request"), null)
  }, CollectionHabitats.prototype.getHabitatDataForReport = function(id) {
    return this.habitatReportSet[id] || null
  }, CollectionHabitats.prototype.getValidHabitatUnitIdSet = function() {
    var habitatId, habitatUnitIdSet = {}, addToSet = function(habitatUnitId) {
      habitatUnitIdSet[habitatUnitId] = !0
    };
    for (habitatId in this.habitatSet)this.habitatSet.hasOwnProperty(habitatId) && this.habitatSet[habitatId] && (this.habitatSet[habitatId].localHabitatUnitArray instanceof Array && this.habitatSet[habitatId].localHabitatUnitArray.forEach(addToSet), this.habitatSet[habitatId].remoteHabitatUnitArray instanceof Array && this.habitatSet[habitatId].remoteHabitatUnitArray.forEach(addToSet));
    return habitatUnitIdSet
  }, CollectionHabitats.prototype.getHabitatDataForMap = function(id) {
    var player, habitat = this.habitatSet[id] || this.habitatMapSet[id] || null, allianceId = 0, color = 0, isHighlighted = servicesStorage.isHighlighted(id);
    return habitat ? (habitat.hasOwnProperty("alliance") ? allianceId = habitat.alliance || 0 : habitat.player && (player = this.servicesGameDataManager.playersCollection.getPlayer(habitat.player), player && player.alliance && (allianceId = player.alliance)), color = isHighlighted ? "highlighted" : habitat.isRenegade ? settingsGameConstant.ALLIANCE_RELATIONSHIPS.RENEGADE : habitat.isOwnByPlayer ? settingsGameConstant.ALLIANCE_RELATIONSHIPS.PLAYER : allianceId ? this.servicesGameDataManager.alliancesCollection.getAllianceRelationship(+allianceId) : settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALL, {
      id: id,
      isOwnByPlayer: habitat.isOwnByPlayer,
      habitatType: habitat.publicHabitatType,
      isRenegade: habitat.isRenegade,
      habitatColorType: color,
      isCurrent: +id === this.currentHabitatId,
      name: habitat.name,
      points: habitat.points,
      mapX: habitat.mapX,
      mapY: habitat.mapY,
      badgeType: this.getHabitatReservationBadge(id),
      nextBattleDate: habitat.nextBattleDate || null
    }) : (servicesLog("warn", "Trying to retrieve unknown habitat, for map drawing"), null)
  }, CollectionHabitats.prototype.isHabitatUnderAttack = function(habitatId) {
    return this.habitatUnderAttack[habitatId] || !1
  }, CollectionHabitats.prototype.isHabitatGoingToHaveBattle = function(habitatId) {
    var habitat = this.getHabitatModel(habitatId);
    if (!habitat)return !1;
    var isNextBattleInFuture = !1, canBattleBeSeen = !1;
    return habitat.nextBattleDate && utilsDateTime.remainTimeInSeconds(habitat.nextBattleDate) > 0 && (isNextBattleInFuture = !0), (habitat.isOwnByPlayer || this.servicesGameDataManager.unitsCollection.isHabitatUnderPLayerTroopsAttack(habitatId)) && (canBattleBeSeen = !0), isNextBattleInFuture && canBattleBeSeen
  }, CollectionHabitats.prototype.getHabitatModel = function(habitatId) {
    var habitat = null;
    try {
      habitat = this.habitatSet[habitatId] || this.habitatMapSet[habitatId]
    } catch (eX) {
      servicesLog("warn", "You tried to obtain unknown habitat by id for next battle checking"), servicesLog("debug", eX)
    }
    return habitat
  }, CollectionHabitats.prototype.getHabitat = function(id) {
    var habitatId = id || this.currentHabitatId, habitat = this.habitatSet[habitatId] || this.habitatMapSet[habitatId] || null, currentHabitat = this.habitatSet[this.currentHabitatId];
    if (!habitat)return servicesLog("warn", "You tried to obtain unknown habitat by id"), null;
    if (habitat.isPeripheral) {
      var now = new Date;
      if (now - habitat.cachedAt > settingsGameConstant.CACHE_LIFE_TIME)return servicesLog("warn", "You tried to obtain expired habitat by id"), null
    }
    return habitat.updateDistanceToActiveHabitat({
      mapX: currentHabitat.mapX,
      mapY: currentHabitat.mapY
    }), this.isHabitatOwnByPlayer(id) && (habitat.ownLocalUnits = this.servicesGameDataManager.unitsCollection.getOwnLocalUnitsList(habitat)), habitat
  }, CollectionHabitats.prototype.getCurrentHabitat = function() {
    return this.habitatSet[this.currentHabitatId]
  }, CollectionHabitats.prototype.getCurrentHabitatId = function() {
    return this.currentHabitatId
  }, CollectionHabitats.prototype.getExtendedHabitatData = function(habitatId, options) {
    var player, alliance, habitat = this.getHabitat(habitatId);
    return options.extendWithPLayer && (player = habitat.player ? this.servicesGameDataManager.playersCollection.getPlayer(habitat.player) : this.servicesGameDataManager.playersCollection.getEmptyPlayer(habitat)), options.extendWithAlliance && (alliance = player && player.alliance ? this.servicesGameDataManager.alliancesCollection.getAlliance(player.alliance) : this.servicesGameDataManager.alliancesCollection.getEmptyAlliance()), {
      habitat: habitat,
      player: player,
      alliance: alliance
    }
  }, CollectionHabitats.prototype.getEmptySummaryHabitat = function() {
    var habitat = {};
    habitat.habitatResourceDictionary = {};
    var key, dictionary = this.habitatSet[this.currentHabitatId].habitatResourceDictionary;
    for (key in dictionary)dictionary.hasOwnProperty(key) && (habitat.habitatResourceDictionary[key] = {
      amount: 0,
      resourceId: dictionary[key].resourceId
    });
    return habitat.ownLocalUnits = this.servicesGameDataManager.unitsCollection.getOwnLocalUnitsList(), habitat
  }, CollectionHabitats.prototype.updateHabitatReservation = function(data) {
    this.habitatReservation = {};
    var requested = 0, accepted = 0, ownAccepted = 0, ownRequested = 0;
    data instanceof Array && data.forEach(function(habitatReservation) {
      var modeledHabitatReservation = new CoreModelHabitatReservation(habitatReservation);
      switch (modeledHabitatReservation.status) {
        case settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED:
          accepted += 1, modeledHabitatReservation.player === this.playerId && (ownAccepted += 1);
          break;
        case settingsGameConstant.HABITAT_RESERVATION_STATUS.REQUESTED:
          requested += 1, modeledHabitatReservation.player === this.playerId && (ownRequested += 1)
      }
      this.reservationSet[modeledHabitatReservation.id] = modeledHabitatReservation, this.habitatReservation.hasOwnProperty(modeledHabitatReservation.habitat) || (this.habitatReservation[modeledHabitatReservation.habitat] = []), this.habitatReservation[modeledHabitatReservation.habitat].push(modeledHabitatReservation.id)
    }, this), this.ownHabitatReservationAmounts = {
      requested: ownRequested,
      accepted: ownAccepted
    }, this.habitatReservationAmounts = {
      requested: requested,
      accepted: accepted
    }, this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.habitatReservation,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    })
  }, CollectionHabitats.prototype.getHabitatReservationsList = function() {
    var id, list = [], addToList = function(reservationId) {
      list.push(this.reservationSet[reservationId])
    }.bind(this);
    for (id in this.habitatReservation)this.habitatReservation.hasOwnProperty(id) && this.habitatReservation[id].forEach(addToList);
    return list
  }, CollectionHabitats.prototype.getHabitatReservationsSetOfGroup = function(groupingMode) {
    var id, habitatReservationsSet = {}, addToSet = function(reservationId) {
      groupingMode === settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN ? this.playerId === this.reservationSet[reservationId].player && (habitatReservationsSet[reservationId] = this.reservationSet[reservationId]) : habitatReservationsSet[reservationId] = this.reservationSet[reservationId]
    }.bind(this);
    for (id in this.habitatReservation)this.habitatReservation.hasOwnProperty(id) && this.habitatReservation[id].forEach(addToSet);
    return habitatReservationsSet
  }, CollectionHabitats.prototype.getReservationsListForHabitat = function(habitatId) {
    var list = [];
    return this.habitatReservation.hasOwnProperty(habitatId) && this.habitatReservation[habitatId].forEach(function(reservationId) {
      var reservation = this.reservationSet[reservationId];
      reservation.status !== settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED && reservation.status !== settingsGameConstant.HABITAT_RESERVATION_STATUS.REQUESTED || list.push(reservation)
    }, this), list
  }, CollectionHabitats.prototype.getReservation = function(reservationId) {
    return this.reservationSet[reservationId]
  }, CollectionHabitats.prototype.deleteReservation = function(reservationId) {
    this.reservationSet[reservationId] = null
  }, CollectionHabitats.prototype.getHabitatReservationBadge = function(habitatId) {
    if (!this.habitatReservation.hasOwnProperty(habitatId))return null;
    var reservation = { left: null, right: null };
    return this.habitatReservation[habitatId].forEach(function(reservationId) {
      var reservationModel = this.reservationSet[reservationId];
      settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED === reservationModel.status && (reservationModel.player === this.playerId ? reservation.left = "by-player" : null === reservation.left && this.servicesGameDataManager.alliancesCollection.isPlayerMemberOfPlayersAlliance(reservationModel.player) ? reservation.left = "by-player-ally" : reservation.right = "by-other-ally")
    }, this), reservation
  }, CollectionHabitats.prototype.getHabitatProperty = function(propertyName, habitatId, options) {
    options = options || {};
    var habitat;
    return habitat = options.isReportRequest ? this.getHabitatDataForReport(habitatId) : this.getHabitat(habitatId), habitat && void 0 !== habitat[propertyName] ? habitat[propertyName] : null
  }, CollectionHabitats.prototype.getClosestFreeHabitat = function() {
    var currentHabitat = this.getCurrentHabitat(), habitats = [];
    return Object.keys(this.habitatSet).forEach(function(key) {
      var habitat = this.habitatSet[key];
      habitat.isRenegade && (habitat.updateDistanceToActiveHabitat(currentHabitat), habitats.push(key))
    }, this), habitats.sort(this.sortable[settingsGameConstant.SORTING_HABITAT_FUNCTION.DISTANCE]), this.habitatSet[habitats[0]]
  }, CollectionHabitats
}]), xy.dStaticInjector.set(xy.dNames.core.collectionEvents, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelEventTrackable, xy.dNames.core.modelEventTracking, xy.dNames.services.sortable, xy.dNames.services.log, function(CoreCollection, utilsOop, CoreModelEventTrackable, CoreModelEventTracking, servicesSortable, servicesLog) {
  "use strict";
  function CollectionEvents(options) {
    CollectionEvents.__super__.constructor.call(this, options), this.rewardedHabitatId = 0, this.trackingEvents = null, this.trackableEvents = null, this._initTutorialEvent = !0, this.hasTutorialEvent = !1
  }

  return utilsOop.extend(CollectionEvents, CoreCollection), CollectionEvents.prototype.updateEventsTrackable = function(rawEvents) {
    return this.trackableEvents = {}, !(rawEvents instanceof Array) || (rawEvents.forEach(function(rawEvent) {
      this.trackableEvents[rawEvent.id] = new CoreModelEventTrackable(rawEvent)
    }, this), !0)
  }, CollectionEvents.prototype.updateEventsTracking = function(rawEvents) {
    return this.trackingEvents = [], !(rawEvents instanceof Array) || (rawEvents.forEach(function(rawEvent) {
      var trackingEvent = new CoreModelEventTracking(rawEvent);
      trackingEvent.isTutorialEvent && (this.hasTutorialEvent = !0), this.trackingEvents.push(trackingEvent)
    }, this), this.trackingEvents.sort(servicesSortable.trackingEvent), !0)
  }, CollectionEvents.prototype.checkPendingEvents = function(player) {
    var event;
    if (this.hasTutorialEvent) {
      if (!this._initTutorialEvent)return !1;
      if (event = this.trackingEvents.find(function(modeledTrackingEvent) {
                return modeledTrackingEvent.isTutorialEvent
              }))return event
    }
    if (!(player.pendingEventArray instanceof Array))return !1;
    player.pendingEventArray.sort(), player.pendingEventArray.reverse();
    var id, i, j, len = player.pendingEventArray.length;
    for (i = 0, j = len; i < j; i += 1)if (id = player.pendingEventArray[i], event = this.trackableEvents[id], event instanceof CoreModelEventTrackable)return event;
    return !1
  }, CollectionEvents.prototype.checkSuccessEvents = function() {
    var success = 0, total = 0;
    return this.trackingEvents.forEach(function(event) {
      event.success ? success += 1 : total += 1
    }), { amountOfSuccess: success, amountTotal: total }
  }, CollectionEvents.prototype.getTrackingEventsList = function() {
    return this.trackingEvents
  }, CollectionEvents.prototype.getTrackingEventById = function(id) {
    var i, len = this.trackingEvents.length;
    for (i = 0; i < len; i += 1)if (this.trackingEvents[i].id === id)return this.trackingEvents[i];
    return null
  }, CollectionEvents.prototype.setRewardedHabitatId = function(id) {
    return this.servicesGameDataManager.habitatsCollection.setCurrentHabitatId(id)
  }, CollectionEvents.prototype.getRewardedHabitatId = function() {
    return this.servicesGameDataManager.habitatsCollection.getCurrentHabitatId()
  }, CollectionEvents.prototype.setTutorialEventStarted = function() {
    this.eventsCollection.initTutorialEvent = !1
  }, CollectionEvents.prototype.setInitTutorialEventFlag = function(newStatus) {
    this._initTutorialEvent = newStatus
  }, CollectionEvents.prototype.getInitTutorialEventFlag = function() {
    return this._initTutorialEvent
  }, CollectionEvents
}]), xy.dStaticInjector.set(xy.dNames.core.collectionUnits, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.core.modelUnit, xy.dNames.core.modelHabitatUnit, xy.dNames.core.modelUnitInProgress, xy.dNames.services.log, xy.dNames.services.sortable, xy.dNames.services.groupable, function(CoreCollection, utilsOop, settingsGameConstant, CoreModelUnit, CoreModelHabitatUnit, CoreModelUnitInProgress, servicesLog, servicesSortable, servicesGroupable) {
  "use strict";
  function CollectionUnits(options) {
    CollectionUnits.__super__.constructor.call(this, options), this.rewardedHabitatId = 0, this.units = {}, this.habitatUnits = {}, this.habitatUnitsByOrigin = {}, this.habitatUnitsByHousing = {}, this.unitsInProgressData = {}, this.resetHabitatInits = !1, this.availableForRecruitUnitsPrimaryKeys = {}, this.availableForExchangeUnitsPrimaryKeys = {}
  }

  return utilsOop.extend(CollectionUnits, CoreCollection), CollectionUnits.prototype.updateUnits = function(rawUnits) {
    return this.units = {}, rawUnits.forEach(function(rawUnit) {
      var modeledUnit = new CoreModelUnit(rawUnit);
      this.units[modeledUnit.primaryKey] = modeledUnit, modeledUnit.requiredKnowledgeArray instanceof Array && this.servicesGameDataManager.knowledgesCollection.updateEnables(modeledUnit.requiredKnowledgeArray, {
        entity: settingsGameConstant.ENTITY.UNIT,
        entityPrimaryKey: modeledUnit.primaryKey
      })
    }, this), !0
  }, CollectionUnits.prototype.updateHabitatUnits = function(rawHabitatUnits) {
    rawHabitatUnits = rawHabitatUnits || [], this.resetHabitatInits && (this.resetHabitatInits = !1, this.habitatUnits = {}, this.availableForExchangeUnitsPrimaryKeys = {}), rawHabitatUnits.forEach(function(rawHabitatUnit) {
      var habitatUnit = new CoreModelHabitatUnit(rawHabitatUnit);
      this.habitatUnits[habitatUnit.id] = habitatUnit
    }, this), this.habitatUnitsByOrigin = {}, this.habitatUnitsByHousing = {};
    var habitatUnitId, habitatUnit, validHabitatUnitIdSet = this.servicesGameDataManager.habitatsCollection.getValidHabitatUnitIdSet();
    for (habitatUnitId in this.habitatUnits)this.habitatUnits.hasOwnProperty(habitatUnitId) && this.habitatUnits[habitatUnitId] && validHabitatUnitIdSet[habitatUnitId] && (habitatUnit = this.habitatUnits[habitatUnitId], this.habitatUnitsByOrigin[habitatUnit.sourceHabitat] || (this.habitatUnitsByOrigin[habitatUnit.sourceHabitat] = []), this.habitatUnitsByOrigin[habitatUnit.sourceHabitat].push(habitatUnit.id), this.habitatUnitsByHousing[habitatUnit.habitat] || (this.habitatUnitsByHousing[habitatUnit.habitat] = []), this.habitatUnitsByHousing[habitatUnit.habitat].push(habitatUnit.id));
    return !0
  }, CollectionUnits.prototype.updateHabitatInProgressUnits = function(rawUnitsInProgressArray) {
    if (rawUnitsInProgressArray instanceof Array)return rawUnitsInProgressArray.forEach(function(rawUnitInProgress) {
      var modeledUnitInProgress = new CoreModelUnitInProgress(rawUnitInProgress);
      this.unitsInProgressData[modeledUnitInProgress.id] = modeledUnitInProgress
    }, this), !0
  }, CollectionUnits.prototype.isHabitatHousingKnownTroops = function(habitatId) {
    return this.habitatUnitsByHousing[habitatId] && this.habitatUnitsByHousing[habitatId].length
  }, CollectionUnits.prototype.isHabitatUnderPLayerTroopsAttack = function(habitatId) {
    var isHabitatUnderAttack = !1;
    return this.habitatUnitsByHousing[habitatId] && this.habitatUnitsByHousing[habitatId].length && (isHabitatUnderAttack = !this.habitatUnitsByHousing[habitatId].every(function(huId) {
      var habitatUnits = this.habitatUnits[huId];
      return !(habitatUnits && habitatUnits.battleType === settingsGameConstant.BATTLE_TYPE.ATTACKER)
    }, this)), isHabitatUnderAttack
  }, CollectionUnits.prototype.findAllUnitsOfKindForHabitat = function(options) {
    options = options || {};
    var units, habitat = options.habitat, unitPrimaryKey = +options.primaryKey, totalAmount = 0;
    return habitat && unitPrimaryKey ? (habitat.localHabitatUnitArray && (units = this.getOwnDefendersUnits({ habitatUnitArray: habitat.localHabitatUnitArray }), units.forEach(function(unitAmountObject) {
      unitPrimaryKey === unitAmountObject.unit.primaryKey && (totalAmount += unitAmountObject.amount)
    })), habitat.remoteHabitatUnitArray && (units = this.getOwnExternalDefendersUnits({ habitatUnitArray: habitat.remoteHabitatUnitArray }), units.forEach(function(unitAmountObject) {
      unitPrimaryKey === unitAmountObject.unit.primaryKey && (totalAmount += unitAmountObject.amount)
    })), habitat.remoteHabitatUnitArray && (units = this.getAttackerUnits({ habitatUnitArray: habitat.remoteHabitatUnitArray }), units.forEach(function(unitAmountObject) {
      unitPrimaryKey === unitAmountObject.unit.primaryKey && (totalAmount += unitAmountObject.amount)
    })), habitat.habitatMissionArray instanceof Array && habitat.habitatMissionArray.forEach(function(activeMissionId) {
      var pk, modelMissionInProgress = this.servicesGameDataManager.missionsCollection.getMissionInProgress(activeMissionId), modelMission = this.servicesGameDataManager.missionsCollection.getMission({ primaryKey: modelMissionInProgress.missionId });
      if (modelMission.unitConsumption)for (pk in modelMission.unitConsumption)modelMission.unitConsumption.hasOwnProperty(pk) && +pk === unitPrimaryKey && (totalAmount += modelMission.unitConsumption[pk])
    }, this), habitat.habitatTransitArray instanceof Array && habitat.habitatTransitArray.forEach(function(transitId) {
      var pk, modelTransit = this.servicesGameDataManager.transitsCollection.getTransit(transitId);
      if (modelTransit.isReturning && habitat.id === modelTransit.destinationHabitat || !modelTransit.isReturning && habitat.id === modelTransit.sourceHabitat)for (pk in modelTransit.unitDictionary)modelTransit.unitDictionary.hasOwnProperty(pk) && +pk === unitPrimaryKey && (totalAmount += modelTransit.unitDictionary[pk])
    }, this), habitat.habitatUnitOrderArray instanceof Array && habitat.habitatUnitOrderArray.forEach(function(unitInProgressId) {
      var modelUnitInProgress = this.getUnitInProgress(unitInProgressId);
      modelUnitInProgress.unitId === unitPrimaryKey && (totalAmount += modelUnitInProgress.orderAmount)
    }, this)) : servicesLog("warn", "Attempt to obtain all units of habitat with not all parameter"), totalAmount
  }, CollectionUnits.prototype.getGroupedUnitsByHabitat = function(options) {
    var habitatUnitId, list = [], habitatUnits = {}, groupingField = options.groupingField || "habitat";
    if (!options.habitatUnitArray)return null;
    options.habitatUnitArray.forEach(function(huId) {
      var modeledHabitatUnits = this.habitatUnits[huId];
      modeledHabitatUnits && options.battleTypes[modeledHabitatUnits.battleType] && (habitatUnits[huId] = modeledHabitatUnits)
    }, this);
    for (habitatUnitId in habitatUnits)habitatUnits.hasOwnProperty(habitatUnitId) && list.push({
      unit: this.units[habitatUnits[habitatUnitId].unitId],
      habitatUnit: habitatUnits[habitatUnitId]
    });
    return servicesGroupable.byField(list, {
      field: "habitatUnit",
      subField: groupingField,
      sortWithinGroups: !0,
      sortWithinGroupsField: "unit",
      sortWithinGroupsSubField: "order"
    })
  }, CollectionUnits.prototype.getDefendersUnits = function(options) {
    var newOptions = { habitatUnitArray: options.habitatUnitArray, battleTypes: {} }, battleTypes = {};
    return battleTypes[settingsGameConstant.BATTLE_TYPE.OWN_HABITAT] = !0, battleTypes[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0, newOptions.battleTypes = battleTypes, this.getUnits(newOptions)
  }, CollectionUnits.prototype.getOwnDefendersUnits = function(options) {
    var newOptions = { habitatUnitArray: options.habitatUnitArray, battleTypes: {} }, battleTypes = {};
    return battleTypes[settingsGameConstant.BATTLE_TYPE.OWN_HABITAT] = !0, newOptions.battleTypes = battleTypes, this.getUnits(newOptions)
  }, CollectionUnits.prototype.getOwnExternalDefendersUnits = function(options) {
    var newOptions = { habitatUnitArray: options.habitatUnitArray, battleTypes: {} }, battleTypes = {};
    return battleTypes[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0, newOptions.battleTypes = battleTypes, this.getUnits(newOptions)
  }, CollectionUnits.prototype.getAttackerUnits = function(options) {
    var newOptions = { habitatUnitArray: options.habitatUnitArray, battleTypes: {} }, battleTypes = {};
    return battleTypes[settingsGameConstant.BATTLE_TYPE.ATTACKER] = !0, newOptions.battleTypes = battleTypes, this.getUnits(newOptions)
  }, CollectionUnits.prototype.getUnits = function(options) {
    var primaryKey, list = [], localUnits = {};
    if (!options.habitatUnitArray)return null;
    options.habitatUnitArray.forEach(function(huId) {
      var habitatUnits = this.habitatUnits[huId];
      habitatUnits && options.battleTypes[habitatUnits.battleType] && (localUnits[habitatUnits.unitId] || (localUnits[habitatUnits.unitId] = 0), localUnits[habitatUnits.unitId] += habitatUnits.amount)
    }, this);
    for (primaryKey in localUnits)localUnits.hasOwnProperty(primaryKey) && list.push({
      unit: this.units[primaryKey],
      amount: localUnits[primaryKey]
    });
    return list.sort(servicesSortable.byField("unit", "order"))
  }, CollectionUnits.prototype.getOwnLocalUnitsList = function(habitat) {
    var primaryKey, habitatId, list = [], units = {}, correctBattleType = settingsGameConstant.BATTLE_TYPE.OWN_HABITAT;
    habitat && (habitatId = habitat.id, habitat.localHabitatUnitArray && habitat.localHabitatUnitArray.forEach(function(huId) {
      var unitPrimaryKey, unitAmount, habitatUnits = this.habitatUnits[huId];
      habitatUnits && habitatUnits.habitat === habitatId && habitatUnits.battleType === correctBattleType && (unitPrimaryKey = habitatUnits.unitId, unitAmount = habitatUnits.amount, units[unitPrimaryKey] || (units[unitPrimaryKey] = 0), units[unitPrimaryKey] += unitAmount)
    }, this));
    for (primaryKey in this.units)this.units.hasOwnProperty(primaryKey) && (units.hasOwnProperty(primaryKey) ? list.push({
      unit: this.units[primaryKey],
      amount: units[primaryKey],
      battleType: correctBattleType,
      habitat: habitatId,
      sourceHabitat: habitatId
    }) : list.push({
      unit: this.units[primaryKey],
      amount: 0,
      battleType: null,
      habitat: habitatId,
      sourceHabitat: habitatId
    }));
    return list.sort(servicesSortable.byField("unit", "order"))
  }, CollectionUnits.prototype.getOwnLocalUnitsAmount = function(options) {
    var result = {}, habitatId = options.habitatId, habitat = options.habitat || this.servicesGameDataManager.habitatsCollection.getHabitat(habitatId), correctBattleType = settingsGameConstant.BATTLE_TYPE.OWN_HABITAT, habitatUnitsList = options.habitatUnitArray || habitat.localHabitatUnitArray || this.habitatUnitsByOrigin[habitatId] || null;
    return habitatUnitsList && habitatUnitsList.forEach(function(huId) {
      var unitPrimaryKey, unitAmount, habitatUnits = this.habitatUnits[huId];
      habitatUnits && habitatUnits.habitat === habitatId && habitatUnits.battleType === correctBattleType && (unitPrimaryKey = habitatUnits.unitId, unitAmount = habitatUnits.amount, result[unitPrimaryKey] || (result[unitPrimaryKey] = 0), result[unitPrimaryKey] += unitAmount)
    }, this), result
  }, CollectionUnits.prototype.getUnitsList = function() {
    var primaryKey, list = [];
    for (primaryKey in this.units)this.units.hasOwnProperty(primaryKey) && list.push(this.units[primaryKey]);
    return list
  }, CollectionUnits.prototype.getAvailableForRecruitmentUnitsList = function() {
    var primaryKey, list = [];
    for (primaryKey in this.availableForRecruitUnitsPrimaryKeys)this.availableForRecruitUnitsPrimaryKeys.hasOwnProperty(primaryKey) && list.push(this.units[primaryKey]);
    return list
  }, CollectionUnits.prototype.getAvailableForExchangeUnitsList = function() {
    var primaryKey, list = [];
    for (primaryKey in this.availableForExchangeUnitsPrimaryKeys)this.availableForExchangeUnitsPrimaryKeys.hasOwnProperty(primaryKey) && list.push(this.units[primaryKey]);
    return list
  }, CollectionUnits.prototype.getUnitsListForUnitDictionary = function(unitDictionary) {
    var primaryKey, list = [];
    for (primaryKey in unitDictionary)unitDictionary.hasOwnProperty(primaryKey) && list.push({
      unit: this.units[primaryKey],
      amount: unitDictionary[primaryKey]
    });
    return list.sort(servicesSortable.byField("unit", "order"))
  }, CollectionUnits.prototype.getUnit = function(options) {
    options = options || {};
    var pk = options.primaryKey;
    return pk && this.units[pk] ? this.units[pk] : null
  }, CollectionUnits.prototype.getUnitProperty = function(propertyName, options) {
    options = options || {};
    var pk = options.primaryKey;
    return pk && this.units[pk] && this.units[pk][propertyName] ? this.units[pk][propertyName] : null
  }, CollectionUnits.prototype.getUnitInProgress = function(unitInProgressId) {
    return unitInProgressId && this.unitsInProgressData[unitInProgressId] ? this.unitsInProgressData[unitInProgressId] : null
  }, CollectionUnits.prototype.getForeignerHabitatLocalUnits = function(habitatId) {
    if (this.habitatUnitsByHousing.hasOwnProperty(habitatId)) {
      var unitsList = this.habitatUnitsByHousing[habitatId], sourceHabitatsTrueRemoteUnitsSet = {}, trueUnitList = [];
      return unitsList.forEach(function(habitatUnitId) {
        var sourceHabitat, modeledHabitatUnit = this.habitatUnits[habitatUnitId], sourceHabitatId = modeledHabitatUnit.sourceHabitat;
        if (!sourceHabitatsTrueRemoteUnitsSet[sourceHabitatId] && (sourceHabitatId && (sourceHabitat = this.servicesGameDataManager.habitatsCollection.getHabitat(sourceHabitatId)), sourceHabitat)) {
          sourceHabitatsTrueRemoteUnitsSet[sourceHabitatId] = {};
          var i, sourceHabitatRemoteHabitatUnitArray = sourceHabitat.remoteHabitatUnitArray, len = sourceHabitatRemoteHabitatUnitArray.length;
          for (i = 0; i < len; i += 1)sourceHabitatsTrueRemoteUnitsSet[sourceHabitatId][sourceHabitatRemoteHabitatUnitArray[i]] = !0
        }
        sourceHabitatsTrueRemoteUnitsSet[sourceHabitatId][habitatUnitId] && trueUnitList.push(habitatUnitId)
      }, this), trueUnitList
    }
    return []
  }, CollectionUnits.prototype.doesHabitatClearFromOffenders = function(options) {
    var clearFromOffenders, habitatId = options.habitatId;
    return !(options.checkAttackOnHabitat && this.habitatUnitsByHousing.hasOwnProperty(habitatId) && (clearFromOffenders = this.habitatUnitsByHousing[habitatId].every(function(habitatUnitId) {
              var modeledHabitatUnit = this.habitatUnits[habitatUnitId];
              return modeledHabitatUnit.battleType !== settingsGameConstant.BATTLE_TYPE.ATTACKER
            }, this), !clearFromOffenders)) && !(options.checkAttackFromHabitat && this.habitatUnitsByOrigin.hasOwnProperty(habitatId) && (clearFromOffenders = this.habitatUnitsByOrigin[habitatId].every(function(habitatUnitId) {
              var modeledHabitatUnit = this.habitatUnits[habitatUnitId];
              return modeledHabitatUnit.battleType !== settingsGameConstant.BATTLE_TYPE.ATTACKER
            }, this), !clearFromOffenders))
  }, CollectionUnits.prototype.flushHabittasUnits = function(habitatUnitsToFlush) {
    habitatUnitsToFlush.forEach(function(habitatUnitId) {
      this.habitatUnits.hasOwnProperty(habitatUnitId) && (this.habitatUnits[habitatUnitId] = null)
    }, this)
  }, CollectionUnits.prototype.addAvailableForRecruitUnitPrimaryKey = function(unitPK) {
    this.availableForRecruitUnitsPrimaryKeys[unitPK] = !0
  }, CollectionUnits.prototype.addAvailableForExchangeUnitPrimaryKey = function(unitPK) {
    this.availableForExchangeUnitsPrimaryKeys[unitPK] = !0
  }, CollectionUnits.prototype.doesHabitatHasExternalDefendersUnits = function(habitatUnitArray) {
    var lookUpBattleType = settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE;
    return habitatUnitArray.some(function(huId) {
      var modelHabitatUnit = this.habitatUnits[huId];
      return modelHabitatUnit.battleType === lookUpBattleType
    }, this)
  }, CollectionUnits.prototype.getAllHabitatUnitsGroupedBy = function(options) {
    var habitatUnitsIdsList = options.habitatUnitsIdsList || Object.keys(this.habitatUnits), habitatUnitsModelList = [], battleTypes = options.battleType || null;
    return habitatUnitsIdsList.forEach(function(habitatUnitId) {
      var habitatUnitModel = this.habitatUnits[habitatUnitId];
      battleTypes && !battleTypes[habitatUnitModel.battleType] || habitatUnitsModelList.push(habitatUnitModel)
    }, this), servicesGroupable.byField(habitatUnitsModelList, { field: options.groupingField, sortWithinGroups: !1 })
  }, CollectionUnits
}]), xy.dStaticInjector.set(xy.dNames.core.collectionPlayers, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.core.modelPlayer, function(CoreCollection, utilsOop, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesLog, servicesTheme, CoreModelPLayer) {
  "use strict";
  function CollectionPlayers(options) {
    CollectionPlayers.__super__.constructor.call(this, options), this.playerId = null, this.playersSet = {}
  }

  return utilsOop.extend(CollectionPlayers, CoreCollection), CollectionPlayers.prototype.setPlayerId = function(playerId) {
    this.playerId = playerId
  }, CollectionPlayers.prototype.setPlayersAllianceId = function(playersAllianceId) {
    this.servicesGameDataManager.alliancesCollection.setPlayersAllianceId(playersAllianceId)
  }, CollectionPlayers.prototype.updatePlayersData = function(data, options) {
    return options = options || {}, data instanceof Array && data.forEach(function(rawPlayerData) {
      var loopPlayerId = +rawPlayerData.id;
      this.playerId !== loopPlayerId && (rawPlayerData.isPeripheral = !0);
      var modeledPlayer = new CoreModelPLayer(rawPlayerData);
      if (this.playerId === loopPlayerId) {
        if (modeledPlayer.hasOwnProperty("reportSetup") === !1)return;
        options.isPeripheral || (this.setPlayersAllianceId(modeledPlayer.alliance), this.playersSet[this.playerId] = modeledPlayer)
      } else(this.playersSet.hasOwnProperty(loopPlayerId) === !1 || this.playersSet[loopPlayerId].updated === !1 || modeledPlayer.updated) && (this.playersSet[loopPlayerId] = modeledPlayer)
    }, this), !0
  }, CollectionPlayers.prototype.getPlayer = function(id) {
    id = id || this.playerId;
    var player = this.playersSet[id];
    if (player) {
      if (player.isPeripheral) {
        var now = new Date;
        if (now - player.cachedAt > settingsGameConstant.CACHE_LIFE_TIME)return servicesLog("warn", "You tried to obtain expired players id"), delete this.playersSet[id], null
      }
      return player
    }
    return null
  }, CollectionPlayers.prototype.getEmptyPlayer = function(habitat) {
    return {
      nick: servicesInternationalization.localize(servicesTheme.themeSettings.habitat.emptyOwnersNameByHabitatType[habitat.publicHabitatType]) + " " + habitat.id,
      points: habitat.points,
      isEmpty: !0
    }
  }, CollectionPlayers.prototype.getPlayersListData = function(list, options) {
    options = options || {};
    var playersList = [];
    return list instanceof Array ? list.forEach(function(playerId) {
      options.excludePLayer && +playerId === this.playerId || playersList.push(this.getPlayer(playerId))
    }, this) : servicesLog("warn", "You pass not an array as param to getPLayerListData method of players collection"), playersList
  }, CollectionPlayers.prototype.getUnknownPlayersInList = function(list) {
    return list.filter(function(playerId) {
      return !this.playersSet.hasOwnProperty(playerId)
    }, this)
  }, CollectionPlayers.prototype.getPlayersPremiumResource = function() {
    return this.getPlayerProperty("gold")
  }, CollectionPlayers.prototype.getPlayerProperty = function(propertyName, playerId) {
    return playerId = playerId || this.playerId, this.playersSet[playerId] && this.playersSet[playerId][propertyName] ? this.playersSet[playerId][propertyName] : null
  }, CollectionPlayers.prototype.getNextLegalFreeHabitatPurchaseDate = function(habitatType) {
    if (!this.playersSet[this.playerId].nextLegalFreeHabitatPurchaseDateDictionary[habitatType])return !1;
    var now = new Date, nextLegalDate = null;
    return this.playersSet[this.playerId].nextLegalFreeHabitatPurchaseDateDictionary[habitatType] > now && (nextLegalDate = this.playersSet[this.playerId].nextLegalFreeHabitatPurchaseDateDictionary[habitatType]), nextLegalDate
  }, CollectionPlayers.prototype.getPLayersAlliance = function(id) {
    return id = id || this.playerId, this.playersSet[id] && this.playersSet[id].alliance ? this.playersSet[id].alliance : this.playersSet[id] ? null : (servicesLog("warn", "You tried to obtain unknown player by id"), !1)
  }, CollectionPlayers.prototype.isCurrentPlayer = function(id) {
    return this.playerId === id
  }, CollectionPlayers.prototype.updatePlayersProperty = function(options) {
    var id = options.id || this.playerId;
    this.playersSet[id].hasOwnProperty(options.property) && "undefined" !== options.value && (this.playersSet[id][options.property] = options.value)
  }, CollectionPlayers.prototype.getAppliedAlliences = function() {
    var applications = [], player = this.playersSet[this.playerId];
    return player.allianceApplicationArray instanceof Array && player.allianceApplicationArray.forEach(function(allianceId) {
      var alliance = this.servicesGameDataManager.alliancesCollection.getAlliance(allianceId);
      applications.push(alliance)
    }, this), applications
  }, CollectionPlayers.prototype.getAllInviterAlliances = function() {
    var invitations = [], player = this.playersSet[this.playerId];
    return player.allianceInvitationArray instanceof Array && player.allianceInvitationArray.forEach(function(allianceId) {
      var alliance = this.servicesGameDataManager.alliancesCollection.getAlliance(allianceId);
      invitations.push(alliance)
    }, this), invitations
  }, CollectionPlayers.prototype.geInvitationsFromAlliance = function(allianceId) {
    var invitations = [], player = this.playersSet[this.playerId];
    return player.allianceInvitationArray instanceof Array && player.allianceInvitationArray.forEach(function(localAllianceId) {
      if (allianceId === +localAllianceId) {
        var alliance = this.servicesGameDataManager.alliancesCollection.getAlliance(localAllianceId);
        invitations.push(alliance)
      }
    }, this), invitations
  }, CollectionPlayers.prototype.getHighestPriorityAlliancePermission = function(alliancePermission) {
    var rights = [settingsGameConstant.ALLIANCE_PERMISSION.DISBAND_ALLIANCE, settingsGameConstant.ALLIANCE_PERMISSION.PLAYER_PERMISSIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISMISS_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.DIPLOMATIC_RELATIONS, settingsGameConstant.ALLIANCE_PERMISSION.MODERATE_FORUM, settingsGameConstant.ALLIANCE_PERMISSION.MASS_MAIL, settingsGameConstant.ALLIANCE_PERMISSION.INVITE_PLAYER], highestPermission = 0, isLeader = alliancePermission === settingsGameConstant.ALLIANCE_PERMISSION.MAX || alliancePermission === settingsGameConstant.ALLIANCE_PERMISSION.ALL;
    return isLeader ? highestPermission = settingsGameConstant.ALLIANCE_PERMISSION.MAX : rights.forEach(function(mask) {
      !highestPermission && alliancePermission & mask && (highestPermission = alliancePermission & mask)
    }), highestPermission
  }, CollectionPlayers.prototype.flushPlayersDataOnDisbandFromAlliance = function(playerId) {
    this.playersSet[playerId] && (this.playersSet[playerId].updated = !1, this.playersSet[playerId].alliance = null)
  }, CollectionPlayers.prototype.flushPlayersData = function(playerId) {
    this.playersSet[playerId] && (this.playersSet[playerId].updated = !1)
  }, CollectionPlayers.prototype.getPlayersProtectiveShieldStatus = function() {
    var stillUnderNoobProtection, clearFromAttackingTransits, clearFromBattles, player = this.getPlayer(), ownHabitatsList = this.servicesGameDataManager.habitatsCollection.getOwnHabitatList();
    return player.attackProtectionEndDate && utilsDateTime.remainTimeInSeconds(player.attackProtectionEndDate) > 0 ? settingsGameConstant.PROTECTION_SHIELD_STATUS.ACTIVE : player.attackProtectionCooldownEndDate && utilsDateTime.remainTimeInSeconds(player.attackProtectionCooldownEndDate) > 0 ? settingsGameConstant.PROTECTION_SHIELD_STATUS.COOLDOWN : player.isOnVacation ? settingsGameConstant.PROTECTION_SHIELD_STATUS.UNAVAILABLE : player.vacationStartDate && utilsDateTime.remainTimeInSeconds(player.vacationStartDate) > 0 ? settingsGameConstant.PROTECTION_SHIELD_STATUS.UNAVAILABLE : (stillUnderNoobProtection = ownHabitatsList.every(function(habitatId) {
      var modeledHabitat = this.servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      return modeledHabitat.noobProtectionEndDate && utilsDateTime.remainTimeInSeconds(modeledHabitat.noobProtectionEndDate) > 0
    }, this)) ? settingsGameConstant.PROTECTION_SHIELD_STATUS.UNAVAILABLE : (clearFromAttackingTransits = ownHabitatsList.every(function(habitatId) {
      return !this.servicesGameDataManager.transitsCollection.getTransits({
        habitatId: habitatId,
        isOutgoing: !0,
        isIncoming: !0,
        transitType: settingsGameConstant.TRANSIT_TYPE.ATTACK
      })
    }, this)) ? (clearFromBattles = ownHabitatsList.every(function(habitatId) {
      return this.servicesGameDataManager.unitsCollection.doesHabitatClearFromOffenders({
        habitatId: habitatId,
        checkAttackOnHabitat: !0,
        checkAttackFromHabitat: !0
      })
    }, this), clearFromBattles ? settingsGameConstant.PROTECTION_SHIELD_STATUS.AVAILABLE : settingsGameConstant.PROTECTION_SHIELD_STATUS.UNAVAILABLE) : settingsGameConstant.PROTECTION_SHIELD_STATUS.UNAVAILABLE
  }, CollectionPlayers.prototype.getPlayersVacationShieldStatus = function() {
    var player = this.getPlayer();
    return player.vacationStartDate && utilsDateTime.remainTimeInSeconds(player.vacationStartDate) > 0 ? settingsGameConstant.VACATION_SHIELD_STATUS.STARTING : player.attackProtectionEndDate && utilsDateTime.remainTimeInSeconds(player.attackProtectionEndDate) > 0 ? settingsGameConstant.VACATION_SHIELD_STATUS.UNAVAILABLE : settingsGameConstant.VACATION_SHIELD_STATUS.AVAILABLE
  }, CollectionPlayers
}]), xy.dStaticInjector.set(xy.dNames.core.collectionTransits, [xy.dNames.core.collection, xy.dNames.core.modelTransit, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.sortable, xy.dNames.services.groupable, function(CoreCollection, CoreModelTransit, utilsOop, settingsGameConstant, servicesSortable, servicesGroupable) {
  "use strict";
  function CollectionTransits(options) {
    CollectionTransits.__super__.constructor.call(this, options), this.transits = {}, this.transitsByOrigin = {}, this.transitsByDesination = {}, this.transitsByType = {}, this.flagPartialCollectionMode = !1, this.flagAllTransitsCached = !1, this.cachedTransitByHabitat = {}
  }

  return utilsOop.extend(CollectionTransits, CoreCollection), CollectionTransits.prototype.flushCollectionCache = function() {
    return this.transits = {}, this.transitsByOrigin = {}, this.transitsByDesination = {}, this.transitsByType = {}, this.flagAllTransitsCached = !1, this.flagPartialCollectionMode = !1, this.cachedTransitByHabitat = {}, !0
  }, CollectionTransits.prototype.flushTransitsCache = function() {
    return this.transits = {}, this.transitsByOrigin = {}, this.transitsByDesination = {}, this.transitsByType = {}, this.cachedTransitByHabitat = {}, this.flagAllTransitsCached = !1, !0
  }, CollectionTransits.prototype.prepareCollectionForPartialTransitUpdate = function() {
    this.flagPartialCollectionMode = !0
  }, CollectionTransits.prototype.isPartialTransitMode = function() {
    return this.flagPartialCollectionMode
  }, CollectionTransits.prototype.isHabitatsTransitCached = function(habitatId) {
    return this.flagPartialCollectionMode && (this.flagAllTransitsCached || this.cachedTransitByHabitat[habitatId])
  }, CollectionTransits.prototype.isAllTransitCached = function() {
    return this.flagAllTransitsCached
  }, CollectionTransits.prototype.globalUpdateAllTransits = function(rawTransits) {
    this.flushTransitsCache() && rawTransits && rawTransits instanceof Array && this.updateTransits(rawTransits) && (this.flagAllTransitsCached = !0, this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.transitsCache,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    }))
  }, CollectionTransits.prototype.globalUpdateTransit = function(rawTransits) {
    this.flushCollectionCache() && rawTransits && rawTransits instanceof Array && this.updateTransits(rawTransits)
  }, CollectionTransits.prototype.partialUpdateTransit = function(habitatId, rawTransits) {
    this.cachedTransitByHabitat[habitatId] = !0, rawTransits && rawTransits instanceof Array && this.updateTransits(rawTransits) && this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.transitsCache,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    })
  }, CollectionTransits.prototype.updateTransits = function(rawTransits) {
    return rawTransits.forEach(function(rawTransit) {
      var modeledTransit = new CoreModelTransit(rawTransit);
      this.transits[modeledTransit.id] = modeledTransit, modeledTransit.sourceHabitat && (this.transitsByOrigin[modeledTransit.sourceHabitat] || (this.transitsByOrigin[modeledTransit.sourceHabitat] = {}), this.transitsByOrigin[modeledTransit.sourceHabitat][modeledTransit.id] = !0), modeledTransit.destinationHabitat && (this.transitsByDesination[modeledTransit.destinationHabitat] || (this.transitsByDesination[modeledTransit.destinationHabitat] = {}), this.transitsByDesination[modeledTransit.destinationHabitat][modeledTransit.id] = !0), modeledTransit.transitType && (this.transitsByType[modeledTransit.transitType] || (this.transitsByType[modeledTransit.transitType] = {}), this.transitsByType[modeledTransit.transitType][modeledTransit.id] = !0)
    }, this), this.servicesGameDataManager.habitatsCollection.updatePossibleNextBattleDateForPlayersHabitats(), !0
  }, CollectionTransits.prototype.getTransit = function(transitId) {
    return this.transits.hasOwnProperty(transitId) ? this.transits[transitId] : null
  }, CollectionTransits.prototype.getHabitatTransitsForHabitat = function(habitatId) {
    var transits = [], isTransitsExisting = !1, currentHabitat = this.servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    return this.transitsByDesination[habitatId] && Object.keys(this.transitsByDesination[habitatId]).forEach(function(transit) {
      var modeledTransit = this.transits[transit], targetHabitatName = modeledTransit.sourceHabitat || modeledTransit.destinationHabitat, isOwnHabitat = this.servicesGameDataManager.habitatsCollection.isHabitatOwnByPlayer(modeledTransit.destinationHabitat), transitOfTypeCanSynchronize = modeledTransit.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK && !isOwnHabitat || modeledTransit.transitType === settingsGameConstant.TRANSIT_TYPE.DEFENSE, canHabitatSynchronizeWithTransit = !1, destinationHabitat = this.servicesGameDataManager.habitatsCollection.getHabitat(modeledTransit.destinationHabitat);
      modeledTransit.isTransitActive() && (transitOfTypeCanSynchronize && (canHabitatSynchronizeWithTransit = currentHabitat.canLocalUnitsArriveInTime({
        distance: destinationHabitat.distanceToActiveHabitat,
        arrivalTime: modeledTransit.destinationETA
      })), isTransitsExisting = !0, transits.push({
        transit: modeledTransit,
        canHabitatSynchronizeWithTransit: canHabitatSynchronizeWithTransit,
        targetHabitatName: this.servicesGameDataManager.habitatsCollection.getHabitatProperty("name", targetHabitatName),
        isReturning: modeledTransit.isReturning,
        type: settingsGameConstant.TRANSIT_SUMMARY_TYPE.INCOMING
      }))
    }, this), this.transitsByOrigin[habitatId] && Object.keys(this.transitsByOrigin[habitatId]).forEach(function(transit) {
      var modeledTransit = this.transits[transit], targetHabitatName = modeledTransit.destinationHabitat || modeledTransit.sourceHabitat, transitOfTypeCanSynchronize = modeledTransit.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK || modeledTransit.transitType === settingsGameConstant.TRANSIT_TYPE.DEFENSE, canHabitatSynchronizeWithTransit = !1, destinationHabitat = this.servicesGameDataManager.habitatsCollection.getHabitat(modeledTransit.destinationHabitat);
      modeledTransit.isTransitActive() && (transitOfTypeCanSynchronize && (canHabitatSynchronizeWithTransit = currentHabitat.canLocalUnitsArriveInTime({
        distance: destinationHabitat.distanceToActiveHabitat,
        arrivalTime: modeledTransit.destinationETA
      })), isTransitsExisting = !0, transits.push({
        transit: modeledTransit,
        canHabitatSynchronizeWithTransit: canHabitatSynchronizeWithTransit,
        targetHabitatName: this.servicesGameDataManager.habitatsCollection.getHabitatProperty("name", targetHabitatName),
        isReturning: modeledTransit.isReturning,
        type: settingsGameConstant.TRANSIT_SUMMARY_TYPE.OUTGOING
      }))
    }, this), transits.sort(servicesSortable.byField("transit", "destinationETA")), isTransitsExisting ? transits : null
  }, CollectionTransits.prototype.getTransits = function(options) {
    var result = [], transitType = options.transitType || !1, filterFunction = function(transitId) {
      var transitModel = this.transits[transitId];
      transitModel.isTransitActive() && (transitType === !1 || transitType && transitModel.transitType === transitType) && result.push(transitModel)
    };
    return options.isIncoming && this.transitsByDesination[options.habitatId] && Object.keys(this.transitsByDesination[options.habitatId]).forEach(filterFunction, this), options.isOutgoing && this.transitsByOrigin[options.habitatId] && Object.keys(this.transitsByOrigin[options.habitatId]).forEach(filterFunction, this), result.length ? result : null
  }, CollectionTransits.prototype.getAllTransitsGroupedBy = function(options) {
    var transitsModelsList = [], idsList = options.transitsIdsList || Object.keys(this.transits);
    return idsList.forEach(function(transitId) {
      var transitModel = this.transits[transitId];
      transitModel && transitModel.isTransitActive() && transitsModelsList.push(this.transits[transitId])
    }, this), transitsModelsList.sort(servicesSortable.byField("destinationETA")), servicesGroupable.byField(transitsModelsList, {
      field: options.groupingField,
      sortWithinGroups: !1
    })
  }, CollectionTransits
}]), xy.dStaticInjector.set(xy.dNames.core.collectionMessages, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.sortable, xy.dNames.settings.gameConstant, xy.dNames.core.modelMessage, xy.dNames.core.modelMessageDiscussionEntry, xy.dNames.core.modelMessageDiscussionMemberChange, function(CoreCollection, utilsOop, servicesLog, servicesSortable, settingsGameConstant, CoreModelMessage, CoreModelMessageDiscussionEntry, CoreModelMessageDiscussionMemberChange) {
  "use strict";
  function CollectionMessages(options) {
    CollectionMessages.__super__.constructor.call(this, options), this.systemMessagesSet = {}, this.deletedMessageThreads = {}, this.discussionEntriesSet = {}, this.disscussionSet = {}, this.discussionMemberChangeSet = {}, this.cachedMessageContent = {}
  }

  return utilsOop.extend(CollectionMessages, CoreCollection), CollectionMessages.prototype.updateMessages = function(data) {
    var systemMessage = [], discussion = [];
    try {
      systemMessage = data.Data.SystemMessage
    } catch (eX) {
      servicesLog("warn", "No System messages in response"), servicesLog("debug", eX)
    }
    this.updateSystemMessages(systemMessage, { isResetOnUpdate: !0 });
    try {
      discussion = data.Data.Discussion
    } catch (eX) {
      servicesLog("warn", "No Discussions array in response"), servicesLog("debug", eX)
    }
    this.updateDiscussions(discussion, { isResetOnUpdate: !0 }), this.checkUnreadMessagesAmount()
  }, CollectionMessages.prototype.updateDiscussions = function(discussion, options) {
    options = options || {}, discussion = discussion || [], options.isResetOnUpdate && (this.disscussionSet = {}), discussion.forEach(function(rawMessageTitle) {
      var modeledMT = new CoreModelMessage(rawMessageTitle);
      this.disscussionSet[modeledMT.id] = modeledMT
    }, this), options.fireMessageChecking && this.checkUnreadMessagesAmount()
  }, CollectionMessages.prototype.updateSystemMessages = function(systemMessages, options) {
    options = options || {}, systemMessages = systemMessages || [], options.isResetOnUpdate && (this.systemMessagesSet = {}), systemMessages.forEach(function(rawMessage) {
      var modeledMT = new CoreModelMessage(rawMessage);
      modeledMT.isSystemMessage = !0, this.systemMessagesSet[modeledMT.id] = modeledMT
    }, this), options.fireMessageChecking && this.checkUnreadMessagesAmount()
  }, CollectionMessages.prototype.checkUnreadMessagesAmount = function() {
    var key, unreadMessagesAmount = 0;
    for (key in this.systemMessagesSet)this.systemMessagesSet.hasOwnProperty(key) && !this.systemMessagesSet[key].isRead && (unreadMessagesAmount += 1);
    for (key in this.disscussionSet)this.disscussionSet.hasOwnProperty(key) && !this.disscussionSet[key].isRead && (unreadMessagesAmount += 1);
    this.servicesGameDataManager.updateUnreadMessagesAmount(unreadMessagesAmount), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.messages,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    })
  }, CollectionMessages.prototype.getSystemMessagesTitles = function() {
    var messageId, data = [];
    for (messageId in this.systemMessagesSet)this.systemMessagesSet.hasOwnProperty(messageId) && data.push(this.systemMessagesSet[messageId]);
    return data.sort(servicesSortable.menuMessagesList), data
  }, CollectionMessages.prototype.getDiscussionMessagesTitles = function() {
    var messageId, data = [];
    for (messageId in this.disscussionSet)this.disscussionSet.hasOwnProperty(messageId) && data.push(this.disscussionSet[messageId]);
    return data.sort(servicesSortable.menuMessagesList), data
  }, CollectionMessages.prototype.getMessagesSet = function() {
    var messageId, messagesSet = {};
    for (messageId in this.disscussionSet)this.disscussionSet.hasOwnProperty(messageId) && (messagesSet[messageId] = this.disscussionSet[messageId]);
    for (messageId in this.systemMessagesSet)this.systemMessagesSet.hasOwnProperty(messageId) && (messagesSet[messageId] = this.systemMessagesSet[messageId]);
    return messagesSet
  }, CollectionMessages.prototype.getMessage = function(message) {
    return message.isSystemMessage ? this.systemMessagesSet[message.id] : this.disscussionSet[message.id]
  }, CollectionMessages.prototype.updateMessageContent = function(data) {
    data = data || {}, data.SystemMessage && data.SystemMessage.forEach(function(message) {
      var messageId = +message.id, modeledMessage = this.systemMessagesSet[messageId];
      modeledMessage ? (modeledMessage.update(message), modeledMessage.wasRead()) : servicesLog("warn", "Updating unknown system message")
    }, this), data.DiscussionMemberChange && data.DiscussionMemberChange.forEach(function(rawDisscussionMemberChangeObject) {
      var modelDiscussionMemberChange = new CoreModelMessageDiscussionMemberChange(rawDisscussionMemberChangeObject);
      this.discussionMemberChangeSet[modelDiscussionMemberChange.id] = modelDiscussionMemberChange
    }, this), data.DiscussionEntry && data.DiscussionEntry.forEach(function(rawDiscussionEntry) {
      var modeledDiscussionEntry = new CoreModelMessageDiscussionEntry(rawDiscussionEntry);
      this.discussionEntriesSet[modeledDiscussionEntry.id] = modeledDiscussionEntry
    }, this), data.Player && this.servicesGameDataManager.playersCollection.updatePlayersData(data.Player, { isPeripheral: !0 }), data.Discussion && data.Discussion.forEach(function(rawDiscussion) {
      var discussionId = +rawDiscussion.id, modeledMessage = this.disscussionSet[discussionId];
      modeledMessage ? modeledMessage.update(rawDiscussion) : modeledMessage = new CoreModelMessage(rawDiscussion), modeledMessage.wasRead(), modeledMessage.discussionEvents = [];
      var i, len = modeledMessage.discussionEntryArray.length;
      for (i = 0; i < len; i += 1)this.discussionEntriesSet[+modeledMessage.discussionEntryArray[i]].isRead = modeledMessage.lastReadDate >= this.discussionEntriesSet[+modeledMessage.discussionEntryArray[i]].creationDate, modeledMessage.discussionEvents.push(this.discussionEntriesSet[modeledMessage.discussionEntryArray[i]]);
      for (len = modeledMessage.discussionMemberChangeArray.length, i = 0; i < len; i += 1)modeledMessage.discussionEvents.push(this.discussionMemberChangeSet[modeledMessage.discussionMemberChangeArray[i]]);
      modeledMessage.discussionEvents.sort(servicesSortable.byField("creationDate"))
    }, this), this.checkUnreadMessagesAmount()
  }, CollectionMessages.prototype.onDeleteMessagesThread = function(options) {
    var systemMessagesIdsArray = options.systemMessagesIdsArray || [], discussionMessagesIdsArray = options.discussionMessagesIdsArray || [], updatedMessages = options.updatedMessages || {}, addDeletedMessageThreadId = function(messageThreadId) {
      this.deletedMessageThreads[messageThreadId] = !0
    }.bind(this);
    systemMessagesIdsArray.forEach(addDeletedMessageThreadId), discussionMessagesIdsArray.forEach(addDeletedMessageThreadId), this.updateMessages(updatedMessages), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.messages,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    })
  }, CollectionMessages.prototype.isMessageThreadDeleted = function(messageThreadId) {
    return this.deletedMessageThreads.hasOwnProperty(messageThreadId) && this.deletedMessageThreads[messageThreadId]
  }, CollectionMessages.prototype.cacheDiscussionMessageContent = function(options) {
    var messageContent = options.content || "", messageSubject = options.subject || "", identifier = options.identifier;
    this.cachedMessageContent[identifier] || (this.cachedMessageContent[identifier] = {}), this.cachedMessageContent[identifier] = {
      subject: messageSubject,
      content: messageContent
    }
  }, CollectionMessages.prototype.getDiscussionMessageContent = function(identifier) {
    return this.cachedMessageContent[identifier] || null
  }, CollectionMessages.prototype.deleteDiscussionMessageContent = function(identifier) {
    this.cachedMessageContent[identifier] = null, delete this.cachedMessageContent[identifier]
  }, CollectionMessages
}]), xy.dStaticInjector.set(xy.dNames.core.collectionReports, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelReport, xy.dNames.services.groupable, xy.dNames.services.sortable, function(CoreCollection, utilsOop, CoreModelReport, servicesGroupable, servicesSortable) {
  "use strict";
  function CollectionReports(options) {
    CollectionReports.__super__.constructor.call(this, options), this.deletedReports = {}, this.propertiesInitialization()
  }

  return utilsOop.extend(CollectionReports, CoreCollection), CollectionReports.prototype.propertiesInitialization = function() {
    this.updated = !1, this.read = !1, this.externalReports = {}, this.reportsSet = {}, this.groupsAmount = {}
  }, CollectionReports.prototype.updateReportsData = function(data, options) {
    options = options || {}, options.softUpdate || this.propertiesInitialization(), data.Data && (data.Data.Habitat instanceof Array && this.servicesGameDataManager.habitatsCollection.updateWithHabitatReportResponse(data.Data.Habitat), data.Data.Report instanceof Array && data.Data.Report.forEach(function(rawReport) {
      var modeledReport = new CoreModelReport(rawReport), reportId = modeledReport.id;
      options.isReportExternal ? this.externalReports[reportId] = modeledReport : (this.reportsSet[reportId] = modeledReport, options.softUpdate && this.reportsSet.hasOwnProperty(reportId) || (this.groupsAmount[modeledReport.reportGroup] ? this.groupsAmount[modeledReport.reportGroup] += 1 : this.groupsAmount[modeledReport.reportGroup] = 1))
    }, this)), options.softUpdate || (this.updated = !0), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.report,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    })
  }, CollectionReports.prototype.flush = function() {
    this.propertiesInitialization(), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.forum,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed
    })
  }, CollectionReports.prototype.onShow = function() {
    this.read = !0, this.servicesGameDataManager.updateUnreadReportsAmount(0)
  }, CollectionReports.prototype.isExternalReportCached = function(externalReportId) {
    return this.externalReports.hasOwnProperty(externalReportId)
  }, CollectionReports.prototype.getGroupedReportsList = function(options) {
    options = options || {};
    var reportId, arrayForGrouping = [], onlyReportGroup = options.onlyReportGroup;
    for (reportId in this.reportsSet)this.reportsSet.hasOwnProperty(reportId) && (!onlyReportGroup || onlyReportGroup && onlyReportGroup === this.reportsSet[reportId].reportGroup) && arrayForGrouping.push(this.reportsSet[reportId]);
    return servicesGroupable.arrayByField(arrayForGrouping, {
      field: "date",
      areGroupsDate: !0,
      sortGroups: !0,
      sortGroupsIsReverse: !0,
      sortWithinGroups: !0,
      sortWithinGroupsSortable: servicesSortable.reports
    })
  }, CollectionReports.prototype.getReportsSetOfGroup = function(options) {
    options = options || {};
    var reportId, reportsSet = {}, onlyReportGroup = options.onlyReportGroup;
    for (reportId in this.reportsSet)this.reportsSet.hasOwnProperty(reportId) && (!onlyReportGroup || onlyReportGroup && onlyReportGroup === this.reportsSet[reportId].reportGroup) && (reportsSet[reportId] = this.reportsSet[reportId]);
    return reportsSet
  }, CollectionReports.prototype.getReportsOverview = function(request) {
    if (request.isReportExternal)return { report: this.externalReports[request.reportId], isReportExternal: !0 };
    var keyReportId, report = this.reportsSet[request.reportId], reportGroup = request.currentReportGroup, reportsAmountInGroup = this.groupsAmount[reportGroup], arrayOfGroup = [];
    for (keyReportId in this.reportsSet)this.reportsSet.hasOwnProperty(keyReportId) && reportGroup === this.reportsSet[keyReportId].reportGroup && arrayOfGroup.push(this.reportsSet[keyReportId]);
    arrayOfGroup.sort(servicesSortable.reports);
    var i, reportIndex = 0, prevReportsId = null, nextReportsId = null, len = arrayOfGroup.length;
    for (i = 0; i < len; i += 1)if (arrayOfGroup[i].id === request.reportId) {
      reportIndex = i + 1, i > 0 && (prevReportsId = arrayOfGroup[i - 1].id), i < len - 1 && (nextReportsId = arrayOfGroup[i + 1].id);
      break
    }
    return {
      report: report,
      reportIndexInGroup: reportIndex,
      reportsInGroupLength: reportsAmountInGroup,
      prevReportsId: prevReportsId,
      nextReportsId: nextReportsId
    }
  }, CollectionReports.prototype.onDeleteReports = function(options) {
    var deletedReportsId = options.deletedReportsId || [], updatedReports = options.updatedReports || {};
    deletedReportsId.forEach(function(reportId) {
      this.deletedReports[reportId] = !0
    }, this), this.updateReportsData(updatedReports), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.report,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    })
  }, CollectionReports.prototype.isReportDeleted = function(reportId) {
    return this.deletedReports.hasOwnProperty(reportId) && this.deletedReports[reportId]
  }, CollectionReports
}]), xy.dStaticInjector.set(xy.dNames.core.collectionForums, [xy.dNames.services.log, xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelForumThread, xy.dNames.core.modelForumThreadMessage, xy.dNames.services.sortable, function(servicesLog, CoreCollection, utilsOop, CoreModelForumThread, CoreModelForumThreadMessage, servicesSortable) {
  "use strict";
  function CollectionForums(options) {
    CollectionForums.__super__.constructor.call(this, options), this.deletedForumThreads = {}, this.cachedMessageContent = {}, this.propertiesInitialization()
  }

  return utilsOop.extend(CollectionForums, CoreCollection), CollectionForums.prototype.propertiesInitialization = function() {
    this.updated = !1, this.threads = {}, this.threadsMessages = {}
  }, CollectionForums.prototype.updateForumData = function(data, options) {
    options = options || {};
    var forumMessage = [], forumThread = [];
    options.softUpdate || this.propertiesInitialization();
    try {
      forumMessage = data.Data.ForumMessage
    } catch (eX) {
      servicesLog("warn", "No Forum messages in response"), servicesLog("debug", eX)
    }
    this.updateForumMessages(forumMessage);
    try {
      forumThread = data.Data.ForumThread
    } catch (eX) {
      servicesLog("warn", "No Forum thread messages in response"), servicesLog("debug", eX);
    }
    this.updateForumThread(forumThread), data.Data && (!options.sessionUpdate && data.Data.Player instanceof Array && this.servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), !options.sessionUpdate && data.Data.Habitat instanceof Array && this.servicesGameDataManager.updateHabitatsData(data.Data.Habitat, { isPeripheral: !0 })), options.softUpdate || (this.updated = !0), data.Data && data.Data.ForumMessage && this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.forum,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received
    })
  }, CollectionForums.prototype.updateForumMessages = function(forumMessages) {
    forumMessages = forumMessages || [], forumMessages.forEach(function(rawForumMessage) {
      var modeledForumMessage = new CoreModelForumThreadMessage(rawForumMessage);
      this.threadsMessages[modeledForumMessage.id] = modeledForumMessage
    }, this)
  }, CollectionForums.prototype.updateForumThread = function(forumThread) {
    forumThread = forumThread || [], forumThread.forEach(function(rawThread) {
      var modeledThread = new CoreModelForumThread(rawThread), threadId = modeledThread.id;
      modeledThread.updated = !1, this.threads.hasOwnProperty(threadId) ? modeledThread.wasRead() : modeledThread.isRead = !this.unreadThreads[threadId], modeledThread.forumMessageArray instanceof Array && (modeledThread.updated = modeledThread.forumMessageArray.every(function(forumMessageId) {
        return this.threadsMessages.hasOwnProperty(forumMessageId)
      }, this)), this.threads[threadId] = modeledThread
    }, this)
  }, CollectionForums.prototype.onDeleteForumThreads = function(threadsIdsArray) {
    this.threads = {}, threadsIdsArray.forEach(function(threadId) {
      this.deletedForumThreads[threadId] = !0
    }, this)
  }, CollectionForums.prototype.isForumThreadDeleted = function(threadId) {
    return this.deletedForumThreads.hasOwnProperty(threadId) && this.deletedForumThreads[threadId]
  }, CollectionForums.prototype.onDeleteThreadsMessages = function(deletedForumMessagesIdArray) {
    deletedForumMessagesIdArray instanceof Array && deletedForumMessagesIdArray.forEach(function(forumMessageId) {
      this.threadsMessages[forumMessageId] = null, delete this.threadsMessages[forumMessageId]
    }, this)
  }, CollectionForums.prototype.flush = function() {
    this.propertiesInitialization()
  }, CollectionForums.prototype.setUnreadThreads = function(unreadThread) {
    this.unreadThreads = {};
    var readyToFlush = !1;
    unreadThread instanceof Array && unreadThread.forEach(function(unreadThreadId) {
      this.threads.hasOwnProperty(unreadThreadId) ? (this.threads[unreadThreadId].isRead = !1, this.threads[unreadThreadId].updated = !1) : readyToFlush = !0, this.unreadThreads[unreadThreadId] = !0
    }, this), readyToFlush && this.flush()
  }, CollectionForums.prototype.isThreadCached = function(threadId) {
    return !!this.threads.hasOwnProperty(threadId) && this.threads[threadId].updated
  }, CollectionForums.prototype.getThreadsList = function() {
    var threadId, resultArray = [];
    for (threadId in this.threads)this.threads.hasOwnProperty(threadId) && resultArray.push(this.threads[threadId]);
    return resultArray.sort(servicesSortable.forumThread), {
      threads: resultArray,
      canPlayerModerateForum: this.servicesGameDataManager.playersCollection.getPlayer().canModerateForum()
    }
  }, CollectionForums.prototype.getThreadsSet = function() {
    var threadId, threadsSet = {};
    for (threadId in this.threads)this.threads.hasOwnProperty(threadId) && (threadsSet[threadId] = this.threads[threadId]);
    return threadsSet
  }, CollectionForums.prototype.getThreadsMessages = function(threadId) {
    var resultList = [];
    return this.threads[threadId] && this.threads[threadId].forumMessageArray instanceof Array ? (this.threads[threadId].wasRead(), this.threads[threadId].forumMessageArray.forEach(function(forumMessageId) {
      this.threadsMessages.hasOwnProperty(forumMessageId) ? resultList.push(this.threadsMessages[forumMessageId]) : servicesLog("error", "Unknown messages on step where all forum messages for current thread have to be cached, thread id: " + threadId)
    }, this), resultList.sort(servicesSortable.forumThreadMessages), resultList) : null
  }, CollectionForums.prototype.changeThreadStatus = function(threadId, newStatus) {
    this.threads[threadId].closed = newStatus, this.servicesGameDataManager.fireDataUpdateListener(this.threads[threadId], {
      entity: xy.eNames.dataListeners.dataEntity.forum,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    })
  }, CollectionForums.prototype.cacheThreadMessageContent = function(options) {
    var messageContent = options.content || "", messageSubject = options.subject || "", identifier = options.identifier;
    this.cachedMessageContent[identifier] || (this.cachedMessageContent[identifier] = {}), this.cachedMessageContent[identifier] = {
      subject: messageSubject,
      content: messageContent
    }
  }, CollectionForums.prototype.getThreadMessageContent = function(identifier) {
    return this.cachedMessageContent[identifier] || null
  }, CollectionForums.prototype.deleteThreadMessageContent = function(identifier) {
    this.cachedMessageContent[identifier] = null, delete this.cachedMessageContent[identifier]
  }, CollectionForums
}]),xy.dStaticInjector.set(xy.dNames.core.collectionMassFunctionsCache, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelAutomaticConquestPointTradingSettings, function(CoreCollection, utilsOop, CoreModelAutomaticConquestPointTradingSettings) {
  "use strict";
  function CollectionMassFunctionsCache(options) {
    CollectionMassFunctionsCache.__super__.constructor.call(this, options), this.propertiesInitialization()
  }

  return utilsOop.extend(CollectionMassFunctionsCache, CoreCollection), CollectionMassFunctionsCache.prototype.propertiesInitialization = function() {
    this.automaticConquestPointTradingSettingsCache = null
  }, CollectionMassFunctionsCache.prototype.updateAutomaticConquestPointTradingSettingsCache = function(settings) {
    settings && (this.automaticConquestPointTradingSettingsCache = new CoreModelAutomaticConquestPointTradingSettings(settings))
  }, CollectionMassFunctionsCache.prototype.getAutomaticConquestPointTradingSettings = function() {
    return this.automaticConquestPointTradingSettingsCache
  }, CollectionMassFunctionsCache
}]),xy.dStaticInjector.set(xy.dNames.core.collectionMissions, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelMission, xy.dNames.core.modelMissionInProgress, function(CoreCollection, utilsOop, CoreModelMission, CoreModelMissionInProgress) {
  "use strict";
  function CollectionMissions(options) {
    CollectionMissions.__super__.constructor.call(this, options), this.missionsSet = {}, this.missionsByIdentifierSet = {}, this.missionsInProgressSet = {}
  }

  return utilsOop.extend(CollectionMissions, CoreCollection), CollectionMissions.prototype.updateMissionsData = function(missions) {
    missions instanceof Array && missions.forEach(function(rawMission) {
      var modeledMission = new CoreModelMission(rawMission);
      this.missionsSet[modeledMission.primaryKey] = modeledMission, this.missionsByIdentifierSet[modeledMission.identifier] = modeledMission.primaryKey
    }, this)
  }, CollectionMissions.prototype.updateMissionInProgressData = function(missionsInProgress) {
    missionsInProgress instanceof Array && missionsInProgress.forEach(function(rawMissionsInProgress) {
      var modeledMissionInProgress = new CoreModelMissionInProgress(rawMissionsInProgress);
      this.missionsInProgressSet[modeledMissionInProgress.id] = modeledMissionInProgress
    }, this)
  }, CollectionMissions.prototype.getMission = function(options) {
    return options.primaryKey && this.missionsSet.hasOwnProperty(options.primaryKey) ? this.missionsSet[options.primaryKey] : options.identifier && this.missionsByIdentifierSet.hasOwnProperty(options.identifier) ? this.missionsSet[this.missionsByIdentifierSet[options.identifier]] : null
  }, CollectionMissions.prototype.getMissionProperty = function(property, primaryKey) {
    return this.missionsSet.hasOwnProperty(primaryKey) && this.missionsSet[primaryKey][property] ? this.missionsSet[primaryKey][property] : null
  }, CollectionMissions.prototype.getMissionInProgress = function(missionInProgressId) {
    return this.missionsInProgressSet.hasOwnProperty(missionInProgressId) ? this.missionsInProgressSet[missionInProgressId] : null
  }, CollectionMissions
}]),xy.dStaticInjector.set(xy.dNames.core.collectionKnowledges, [xy.dNames.core.collection, xy.dNames.core.modelKnowledge, xy.dNames.core.modelKnowledgeInProgress, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(CoreCollection, CoreModelKnowledge, CoreModelKnowledgeInProgress, utilsOop, settingsGameConstant, servicesLog) {
  "use strict";
  function CollectionKnowledges(options) {
    CollectionKnowledges.__super__.constructor.call(this, options), this.knowledgesSet = {}, this.knowledgesByIdentifierSet = {}, this.knowledgesInProgressSet = {}, this.knowledgeEnables = {}
  }

  return utilsOop.extend(CollectionKnowledges, CoreCollection), CollectionKnowledges.prototype.updateKnowledgesData = function(knowledges) {
    knowledges instanceof Array && knowledges.forEach(function(rawKnowledges) {
      var modeledKnowledge = new CoreModelKnowledge(rawKnowledges);
      this.knowledgesSet[modeledKnowledge.primaryKey] = modeledKnowledge, this.knowledgesByIdentifierSet[modeledKnowledge.identifier] = modeledKnowledge.primaryKey, modeledKnowledge.requiredKnowledgeArray instanceof Array && this.updateEnables(modeledKnowledge.requiredKnowledgeArray, {
        entity: settingsGameConstant.ENTITY.KNOWLEDGE,
        entityPrimaryKey: modeledKnowledge.primaryKey
      })
    }, this)
  }, CollectionKnowledges.prototype.updateKnowledgesInProgressData = function(knowledgesInProgress) {
    knowledgesInProgress instanceof Array && knowledgesInProgress.forEach(function(rawKnowledgesInProgress) {
      var modeledKnowledgeInProgress = new CoreModelKnowledgeInProgress(rawKnowledgesInProgress);
      this.knowledgesInProgressSet[modeledKnowledgeInProgress.id] = modeledKnowledgeInProgress
    }, this)
  }, CollectionKnowledges.prototype.updateEnables = function(knowledgeArray, options) {
    knowledgeArray.forEach(function(knowledgePK) {
      this.knowledgeEnables.hasOwnProperty(knowledgePK) || (this.knowledgeEnables[knowledgePK] = {}), this.knowledgeEnables[knowledgePK][options.entity] || (this.knowledgeEnables[knowledgePK][options.entity] = []), this.knowledgeEnables[knowledgePK][options.entity].push(options.entityPrimaryKey)
    }, this)
  }, CollectionKnowledges.prototype.getKnowledge = function(options) {
    return options.primaryKey && this.knowledgesSet.hasOwnProperty(options.primaryKey) ? this.knowledgesSet[options.primaryKey] : options.identifier && this.knowledgesByIdentifierSet.hasOwnProperty(options.identifier) ? this.knowledgesSet[this.knowledgesByIdentifierSet[options.identifier]] : (servicesLog("warn", "You try to retrieve unknown knowledge, CollectionKnowledges.getKnowledge"), servicesLog("debug", options), null)
  }, CollectionKnowledges.prototype.getKnowledgeInProgress = function(knowledgeInProgressId) {
    return this.knowledgesInProgressSet.hasOwnProperty(knowledgeInProgressId) ? this.knowledgesInProgressSet[knowledgeInProgressId] : null
  }, CollectionKnowledges.prototype.getEnabledByKnowledge = function(knowledgePrimaryKey) {
    return this.knowledgeEnables.hasOwnProperty(knowledgePrimaryKey) ? this.knowledgeEnables[knowledgePrimaryKey] : null
  }, CollectionKnowledges.prototype.getKnowledgeProperty = function(property, primaryKey) {
    return this.knowledgesSet.hasOwnProperty(primaryKey) && this.knowledgesSet[primaryKey][property] ? this.knowledgesSet[primaryKey][property] : null
  }, CollectionKnowledges
}]),xy.dStaticInjector.set(xy.dNames.core.collectionModifiers, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelModifier, function(CoreCollection, utilsOop, CoreModelModifier) {
  "use strict";
  function CollectionModifiers(options) {
    CollectionModifiers.__super__.constructor.call(this, options), this.modifiersSet = {}, this.modifiersByIdentifierSet = {}
  }

  return utilsOop.extend(CollectionModifiers, CoreCollection), CollectionModifiers.prototype.updateModifiersData = function(data, options) {
    return options = options || {}, data instanceof Array && data.forEach(function(rawModifier) {
      var modeledModifier = new CoreModelModifier(rawModifier), primaryKey = modeledModifier.primaryKey;
      this.modifiersSet[primaryKey] = modeledModifier, this.modifiersByIdentifierSet[modeledModifier.identifier] = primaryKey
    }, this), !0
  }, CollectionModifiers.prototype.getModifier = function(options) {
    options = options || {};
    var pk = options.primaryKey || this.modifiersByIdentifierSet[options.identifier];
    return pk && this.modifiersSet[pk] ? this.modifiersSet[pk] : null
  }, CollectionModifiers
}]),xy.dStaticInjector.set(xy.dNames.core.collectionHabitatUpgradesConstruction, [xy.dNames.core.collection, xy.dNames.utils.oop, xy.dNames.core.modelHabitatUpgrade, xy.dNames.core.modelHabitatUpgradeInProgress, function(CoreCollection, utilsOop, CoreModelHabitatUpgrade, CoreModelHabitatUpgradeInProgress) {
  "use strict";
  function CollectionHabitatUpgradesConstruction(options) {
    CollectionHabitatUpgradesConstruction.__super__.constructor.call(this, options), this.upgradesSet = {}, this.upgradesInProgressSet = {}, this.expansionOptionsSet = {}
  }

  return utilsOop.extend(CollectionHabitatUpgradesConstruction, CoreCollection), CollectionHabitatUpgradesConstruction.prototype.updateUpgradeData = function(upgrades) {
    upgrades instanceof Array && upgrades.forEach(function(rawUpgrade) {
      var modeledUpgrade = new CoreModelHabitatUpgrade(rawUpgrade);
      this.upgradesSet[modeledUpgrade.primaryKey] = modeledUpgrade
    }, this)
  }, CollectionHabitatUpgradesConstruction.prototype.updateUpgradesInProgressData = function(upgradesInProgress) {
    upgradesInProgress instanceof Array && upgradesInProgress.forEach(function(rawUpgradeInProgress) {
      var modeledFortressConstructionInProgress = new CoreModelHabitatUpgradeInProgress(rawUpgradeInProgress);
      this.upgradesInProgressSet[modeledFortressConstructionInProgress.id] = modeledFortressConstructionInProgress
    }, this)
  }, CollectionHabitatUpgradesConstruction.prototype.flushExpansionOptionsData = function() {
    return this.expansionOptionsSet = {}, !0
  }, CollectionHabitatUpgradesConstruction.prototype.updateExpansionOptionsData = function(options) {
    var habitatsList = [];
    return options.data.Player instanceof Array && this.servicesGameDataManager.updatePlayersData(options.data.Player, { isPeripheral: !0 }), options.data.Habitat instanceof Array && (this.servicesGameDataManager.updateHabitatsData(options.data.Habitat, { isPeripheral: !0 }), options.data.Habitat.forEach(function(rawHabitat) {
      habitatsList.push(+rawHabitat.id)
    })), this.expansionOptionsSet[options.habitatId] = habitatsList, !0
  }, CollectionHabitatUpgradesConstruction.prototype.getUpgrade = function(options) {
    return options.primaryKey && this.upgradesSet.hasOwnProperty(options.primaryKey) ? this.upgradesSet[options.primaryKey] : null
  }, CollectionHabitatUpgradesConstruction.prototype.getUpgradeInProgress = function(options) {
    return options.id && this.upgradesInProgressSet.hasOwnProperty(options.id) ? this.upgradesInProgressSet[options.id] : null
  }, CollectionHabitatUpgradesConstruction.prototype.getExpansionOptions = function(options) {
    return options.habitatId && this.expansionOptionsSet.hasOwnProperty(options.habitatId) ? this.expansionOptionsSet[options.habitatId] : null
  }, CollectionHabitatUpgradesConstruction
}]),xy.dStaticInjector.set(xy.dNames.core.collectionRankCache, [xy.dNames.core.collection, xy.dNames.utils.oop, function(CoreCollection, utilsOop) {
  "use strict";
  function CollectionRankCache(options) {
    CollectionRankCache.__super__.constructor.call(this, options), this.propertiesInitialization()
  }

  return utilsOop.extend(CollectionRankCache, CoreCollection), CollectionRankCache.prototype.propertiesInitialization = function() {
    this.cache = {}, this.categolicalCache = {}
  }, CollectionRankCache.prototype.updateCategoricalCache = function(data, options) {
    options = options || {};
    var categories = [];
    return data instanceof Array && data.forEach(function(categoryServerResponse) {
      var cache = {
        name: categoryServerResponse.name,
        rankTypes: categoryServerResponse.rankTypes,
        subjectId: categoryServerResponse.subjectId
      };
      categoryServerResponse.rank ? (cache.quantifier = categoryServerResponse.rank.quantifier, cache.rank = categoryServerResponse.rank.rank, cache.row = categoryServerResponse.rank.row) : (cache.quantifier = null, cache.rank = null, cache.row = null), categories.push(cache)
    }), this.categolicalCache.hasOwnProperty(options.currentsSubjectType) || (this.categolicalCache[options.currentsSubjectType] = {}), this.categolicalCache[options.currentsSubjectType][options.subjectId] = categories, !0
  }, CollectionRankCache.prototype.getCategoricalCache = function(options) {
    return options = options || {}, this.categolicalCache.hasOwnProperty(options.currentsSubjectType) && this.categolicalCache[options.currentsSubjectType].hasOwnProperty(options.subjectId) && this.categolicalCache[options.currentsSubjectType][options.subjectId] ? this.categolicalCache[options.currentsSubjectType][options.subjectId] : null
  }, CollectionRankCache.prototype.updateCache = function(data, options) {
    return options = options || {}, this.cache.hasOwnProperty(options.currentsSubjectType) || (this.cache[options.currentsSubjectType] = {}), this.cache[options.currentsSubjectType].hasOwnProperty(options.currentRankType) || (this.cache[options.currentsSubjectType][options.currentRankType] = {}), this.cache[options.currentsSubjectType][options.currentRankType][options.offset] = data, !0
  }, CollectionRankCache.prototype.getCachedPage = function(options) {
    return this.cache.hasOwnProperty(options.currentsSubjectType) && this.cache[options.currentsSubjectType].hasOwnProperty(options.currentRankType) && this.cache[options.currentsSubjectType][options.currentRankType].hasOwnProperty(options.offset.toString()) && this.cache[options.currentsSubjectType][options.currentRankType][options.offset] instanceof Array ? this.cache[options.currentsSubjectType][options.currentRankType][options.offset] : null
  }, CollectionRankCache.prototype.flush = function() {
    this.propertiesInitialization(), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.rank,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed
    })
  }, CollectionRankCache
}]),xy.dStaticInjector.set(xy.dNames.services.log, [function() {
  "use strict";
  return function() {
    if ("dev" === window.ENVIRONMENT || "qa" === window.ENVIRONMENT) {
      var arg = Array.from(arguments), mode = arg.shift();
      console[mode].apply(console, arg)
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.services.parserBPList, [xy.dNames.services.log, function(servicesLog) {
  "use strict";
  function readInt64BE(dataView, aStart) {
    var high32 = dataView.getInt32(aStart), low32 = dataView.getInt32(aStart + 4);
    return 0 !== high32 && high32 !== -1 && servicesLog("warn", "64 bit int contains more that 32 bits - JavaScript can handle only 32 bit ints!"), low32
  }

  function readInt(dataView, aStart, objectRefSize) {
    if (0 === objectRefSize)throw new Error("objectRefSize is zero!");
    aStart = aStart || 0;
    var aRef = 0;
    return aRef = 1 === objectRefSize ? dataView.getInt8(aStart) : 2 === objectRefSize ? dataView.getInt16(aStart) : 4 === objectRefSize ? dataView.getInt32(aStart) : readInt64BE(dataView, aStart)
  }

  function readUInt64BE(dataView, aStart) {
    var high32 = dataView.getUint32(aStart), low32 = dataView.getUint32(aStart + 4);
    return 0 !== high32 && 4294967295 !== high32 && servicesLog("warn", "64 bit int contains more that 32 bits - JavaScript can handle only 32 bit ints!"), low32
  }

  function readUInt(dataView, aStart, objectRefSize) {
    if (0 === objectRefSize)throw new Error("objectRefSize is zero!");
    aStart = aStart || 0;
    var aRef = 0;
    return aRef = 1 === objectRefSize ? dataView.getUint8(aStart) : 2 === objectRefSize ? dataView.getUint16(aStart) : 4 === objectRefSize ? dataView.getUint32(aStart) : readUInt64BE(dataView, aStart)
  }

  function parseBinaryPropertyList(arrayBuffer) {
    function parseObject(tableOffset) {
      function parseSimple() {
        switch (objInfo) {
          case 0:
            return null;
          case 8:
            return !1;
          case 9:
            return !0;
          case 15:
            return null;
          default:
            throw new Error("Unhandled simple type 0x" + objType.toString(16))
        }
      }

      function parseInteger() {
        var length = 1 << objInfo;
        if (length >= maxObjectSize)throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + maxObjectSize + " are available.");
        return readInt(dataView, offset + 1, length)
      }

      function parseUID() {
        var length = objInfo + 1;
        if (length >= maxObjectSize)throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + maxObjectSize + " are available.");
        return readUInt(dataView, offset + 1, length)
      }

      function parseReal() {
        var length = 1 << objInfo;
        if (length > maxObjectSize)throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + maxObjectSize + " are available.");
        if (4 === length)return dataView.getFloat32(offset + 1);
        if (8 === length)return dataView.getFloat64(offset + 1);
        throw new Error("Unknown real size:" + length)
      }

      function parseDate() {
        return 3 !== objInfo && servicesLog("error", "Unknown date type :" + objInfo + ". Parsing anyway..."), new Date(EPOCH + 1e3 * dataView.getFloat64(offset + 1))
      }

      function parseData() {
        throw new Error("parseData is deprecated: " + objInfo)
      }

      function parsePlistString(isUtf16) {
        isUtf16 = isUtf16 || 0;
        var int_type, intType, intInfo, intLength, i, length = objInfo, stroffset = 1;
        if (15 === objInfo && (int_type = dataView.getUint8(offset + 1), intType = (240 & int_type) / 16, 1 !== intType && servicesLog("error", "UNEXPECTED LENGTH-INT TYPE! " + intType), intInfo = 15 & int_type, intLength = 1 << intInfo, stroffset = 2 + intLength, length = readUInt(dataView, offset + 2, intLength)), length * (isUtf16 + 1) >= maxObjectSize)throw new Error("To little heap space available! Wanted to read " + length + " bytes, but only " + maxObjectSize + " are available.");
        var aString = "";
        for (i = 0; i < length; i += 1)aString += isUtf16 ? String.fromCharCode(dataView.getUint16(offset + stroffset + 2 * i)) : String.fromCharCode(dataView.getUint8(offset + stroffset + i));
        return aString
      }

      function parseArray() {
        var int_type, intType, intInfo, intLength, i, objRef, length = objInfo, arrayoffset = 1;
        if (15 === objInfo && (int_type = dataView.getUint8(offset + 1), intType = (240 & int_type) / 16, 1 !== intType && servicesLog("error", "0xa: UNEXPECTED LENGTH-INT TYPE!", intType), intInfo = 15 & int_type, intLength = 1 << intInfo, arrayoffset = 2 + intLength, length = readUInt(dataView, offset + 2, intLength)), length * objectRefSize > maxObjectSize)throw new Error("To little heap space available!");
        var array = [];
        for (i = 0; i < length; i += 1)objRef = readUInt(dataView, offset + arrayoffset + i * objectRefSize, objectRefSize), array[i] = parseObject(objRef);
        return array
      }

      function parseDictionary() {
        var int_type, intType, intInfo, intLength, length = objInfo, dictoffset = 1;
        if (15 === objInfo && (int_type = dataView.getUint8(offset + 1), intType = (240 & int_type) / 16, 1 !== intType && servicesLog("error", "0xD: UNEXPECTED LENGTH-INT TYPE!", intType), intInfo = 15 & int_type, intLength = 1 << intInfo, dictoffset = 2 + intLength, length = readUInt(dataView, offset + 2, intLength)), 2 * length * objectRefSize > maxObjectSize)throw new Error("To little heap space available!");
        var keyRef, valRef, key, val, i, dict = {};
        for (i = 0; i < length; i += 1)keyRef = readUInt(dataView, offset + dictoffset + i * objectRefSize, objectRefSize), valRef = readUInt(dataView, offset + dictoffset + i * objectRefSize + length * objectRefSize, objectRefSize), key = parseObject(keyRef), val = parseObject(valRef), dict[key] = val;
        return dict
      }

      var offset = offsetTable[tableOffset], type = dataView.getUint8(offset), objType = (240 & type) >> 4, objInfo = 15 & type;
      switch (objType) {
        case 0:
          return parseSimple();
        case 1:
          return parseInteger();
        case 8:
          return parseUID();
        case 2:
          return parseReal();
        case 3:
          return parseDate();
        case 4:
          return parseData();
        case 5:
          return parsePlistString(!1);
        case 6:
          return parsePlistString(!0);
        case 10:
          return parseArray();
        case 13:
          return parseDictionary();
        default:
          throw new Error("Unhandled type 0x" + objType.toString(16))
      }
    }

    if (!arrayBuffer)return !1;
    var i, offsetSize, objectRefSize, numObjects, topObject, offsetTableOffset, offsetTable = [];
    try {
      dataView = new DataView(arrayBuffer)
    } catch (eX) {
      servicesLog("error", eX)
    }
    for (i = 0; i < "bplist".length; i += 1)if (dataView.getUint8(i) !== "bplist".charCodeAt(i))throw new Error('Invalid binary plist. Expected "bplist" at offset 0.');
    for (offsetSize = dataView.getUint8(arrayBuffer.byteLength - 32 + 6), objectRefSize = dataView.getUint8(arrayBuffer.byteLength - 32 + 7), numObjects = readUInt64BE(dataView, arrayBuffer.byteLength - 32 + 8), topObject = readUInt64BE(dataView, arrayBuffer.byteLength - 32 + 16), offsetTableOffset = readUInt64BE(dataView, arrayBuffer.byteLength - 32 + 24), i = 0; i < numObjects; i += 1)offsetTable[i] = readUInt(dataView, offsetTableOffset + i * offsetSize, offsetSize);
    return parseObject(topObject)
  }

  var dataView, maxObjectSize = 1e8, EPOCH = 9783072e5;
  return parseBinaryPropertyList
}]),xy.dStaticInjector.set(xy.dNames.services.loader, [xy.dNames.gameInstance, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.httpRequest, function(gameInstance, utilsOop, servicesLog, servicesHTTPRequest) {
  "use strict";
  var __resourceLoaderByType = {}, ServiceLoader = {};
  ServiceLoader.registerLoaderForType = function(extension, loaderByFileType) {
    __resourceLoaderByType[extension] = loaderByFileType
  }, ServiceLoader.getLoaderByType = function(extension) {
    return __resourceLoaderByType[extension]
  };
  var ResourceLoaderImageClass = function() {
    function ResourceLoaderImage(url) {
      this._url = url
    }

    return ResourceLoaderImage.prototype.load = function(loaded, error) {
      var img = new Image;
      img.addEventListener("load", function(e) {
        loaded(e.target)
      }, !1), img.addEventListener("error", function() {
        error()
      }, !1), img.src = this._url
    }, ResourceLoaderImage
  }();
  ServiceLoader.registerLoaderForType("png", {
    type: "image", loader: function(url) {
      return new ResourceLoaderImageClass(url)
    }
  }), ServiceLoader.registerLoaderForType("gif", {
    type: "image", loader: function(url) {
      return new ResourceLoaderImageClass(url)
    }
  }), ServiceLoader.registerLoaderForType("jpg", {
    type: "image", loader: function(url) {
      return new ResourceLoaderImageClass(url)
    }
  });
  var ResourceLoaderJSONClass = function() {
    function ResourceLoaderJSON(url, initializer) {
      this._parse = !0, this._url = url, this.settings = { parse: !1 }, initializer = initializer || {}, Object.assign(this.settings, initializer)
    }

    return ResourceLoaderJSON.prototype.load = function(loaded, error, progress) {
      var xhr = servicesHTTPRequest.getXHR(), onProgressCallBack = null;
      progress && (onProgressCallBack = function(evt) {
        if (evt.lengthComputable) {
          var percentComplete = evt.loaded / evt.total * 100;
          progress(percentComplete)
        } else progress(-1)
      }), servicesHTTPRequest.registerEvents(xhr, {
        context: this, options: null, onLoad: function(xhr, e) {
          if (200 !== +xhr.status)return void error();
          var text = "";
          xhr.responseText ? text = xhr.responseText : e && (text = e.currentTarget ? e.currentTarget.responseText : e.target.responseText), "" !== text && loaded(this.getValue(text))
        }, onProgress: onProgressCallBack
      }), xhr.open("GET", this._url, !0), xhr.send()
    }, ResourceLoaderJSON.prototype.getValue = function(text) {
      return this.settings.parse ? JSON.parse(text) : text
    }, ResourceLoaderJSON
  }();
  ServiceLoader.registerLoaderForType("json", {
    type: "javascript json", loader: function(url) {
      return new ResourceLoaderJSONClass(url, { parse: !0 })
    }
  }), ServiceLoader.registerLoaderForType("txt", {
    type: "plain text files", loader: function(url) {
      return new ResourceLoaderJSONClass(url, { parse: !1 })
    }
  }), ServiceLoader.registerLoaderForType("fnt", {
    type: "Glypth designer fnt", loader: function(url) {
      return new ResourceLoaderJSONClass(url, { parse: !1 })
    }
  });
  var ResourceLoaderXMLClass = function(_super) {
    function ResourceLoaderXML(url) {
      ResourceLoaderXML.__super__.constructor.call(this, url)
    }

    return utilsOop.extend(ResourceLoaderXML, _super), ResourceLoaderXML.prototype.getValue = function(text) {
      if (void 0 !== DOMParser) {
        var parser = new DOMParser, doc = parser.parseFromString(text, "text/xml");
        return this.__parseNode(doc.documentElement)
      }
      return {}
    }, ResourceLoaderXML.prototype.__parseNode = function(node) {
      var data = null, tagName = node.tagName;
      switch (tagName) {
        case"plist":
          data = this.__parseArray(node);
          break;
        case"dict":
          data = this.__parseDict(node);
          break;
        case"array":
          data = this.__parseArray(node);
          break;
        case"string":
          var i, len = node.childNodes.length;
          if (1 === len)data = node.firstChild.nodeValue; else for (data = "", i = 0; i < len; i += 1)data += node.childNodes[i].nodeValue;
          break;
        case"false":
          data = !1;
          break;
        case"true":
          data = !0;
          break;
        case"real":
          data = parseFloat(node.firstChild.nodeValue);
          break;
        case"integer":
          data = parseInt(node.firstChild.nodeValue, 10)
      }
      return data
    }, ResourceLoaderXML.prototype.__parseArray = function(node) {
      var i, child, data = [], len = node.childNodes.length;
      for (i = 0; i < len; i += 1)child = node.childNodes[i], 1 === child.nodeType && data.push(this.__parseNode(child));
      return data
    }, ResourceLoaderXML.prototype.__parseDict = function(node) {
      var i, child, data = {}, key = null, len = node.childNodes.length;
      for (i = 0; i < len; i += 1)child = node.childNodes[i], 1 === child.nodeType && ("key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this.__parseNode(child));
      return data
    }, ResourceLoaderXML
  }(ResourceLoaderJSONClass);
  ServiceLoader.registerLoaderForType("xml", {
    type: "XML file", loader: function(url) {
      return new ResourceLoaderXMLClass(url)
    }
  }), ServiceLoader.registerLoaderForType("plist", {
    type: "MAC Plist file", loader: function(url) {
      return new ResourceLoaderXMLClass(url)
    }
  });
  var ResourceLoaderAudioBufferClass = function() {
    function ResourceLoaderAudioBuffer(url) {
      this._url = null, this._url = url
    }

    var audioContext = function() {
      var ctx = "undefined" != typeof AudioContext ? AudioContext : "undefined" != typeof webkitAudioContext ? webkitAudioContext : null;
      return ctx && new ctx
    }();
    return ResourceLoaderAudioBuffer.prototype.load = function(loaded, error) {
      if (gameInstance.isMobileMode())return void loaded(null);
      var xhr = servicesHTTPRequest.getXHR();
      servicesHTTPRequest.registerEvents(xhr, {
        context: this, options: null, onLoad: function(requestO) {
          audioContext.decodeAudioData(requestO.response, function(buffer) {
            loaded(buffer)
          }, function(e) {
            servicesLog("warn", "Audio decoding issues"), servicesLog("debug", e), loaded(null)
          })
        }
      }), xhr.responseType = "arraybuffer", xhr.open("GET", this._url, !0), xhr.send()
    }, ResourceLoaderAudioBuffer
  }();
  return ServiceLoader.registerLoaderForType("mp3", {
    type: "mp3 audio", loader: function(url) {
      return new ResourceLoaderAudioBufferClass(url)
    }
  }), ServiceLoader.registerLoaderForType("wav", {
    type: "wav audio", loader: function(url) {
      return new ResourceLoaderAudioBufferClass(url)
    }
  }), ServiceLoader.registerLoaderForType("ogg", {
    type: "ogg audio", loader: function(url) {
      return new ResourceLoaderAudioBufferClass(url)
    }
  }), ServiceLoader
}]),xy.dStaticInjector.set(xy.dNames.services.httpRequest, [xy.dNames.services.log, function(servicesLog) {
  "use strict";
  var HTTPRequest = {};
  return HTTPRequest.getXHR = function() {
    var xhr = null;
    if ("undefined" != typeof XMLHttpRequest && "undefined" == typeof ActiveXObject)try {
      xhr = new XMLHttpRequest
    } catch (eX) {
      servicesLog("warn", "Issue with XMLHttpRequest initialization"), servicesLog("debug", eX)
    } else if ("undefined" != typeof ActiveXObject)try {
      xhr = new ActiveXObject("Msxml2.XMLHTTP")
    } catch (eX) {
      servicesLog("warn", 'Issue with ActiveXObject("Msxml2.XMLHTTP") initialization'), servicesLog("debug", eX);
      try {
        xhr = new ActiveXObject("Microsoft.XMLHTTP")
      } catch (eX1) {
        servicesLog("warn", 'Issue with ActiveXObject("Microsoft.XMLHTTP") initialization'), servicesLog("debug", eX1)
      }
    }
    return xhr
  }, HTTPRequest.registerEvents = function(xhr, parameters) {
    parameters.onLoad && (xhr.onload = function() {
      parameters.onLoad.call(parameters.context, xhr, parameters.options)
    }), parameters.onReadyStateChange && (xhr.onreadystatechange = function() {
      parameters.onReadyStateChange.call(parameters.context, xhr, parameters.options)
    }), parameters.onProgress && (xhr.onprogress = function() {
      parameters.onProgress.call(parameters.context, xhr, parameters.options)
    }), parameters.onError && (xhr.onerror = function() {
      parameters.onError.call(parameters.context, parameters.options)
    }), parameters.onAbort && (xhr.onabort = function() {
      parameters.onAbort.call(parameters.context, parameters.options)
    }), parameters.onTimeout && (xhr.ontimeout = function() {
      parameters.onTimeout.call(parameters.context, parameters.options)
    })
  }, HTTPRequest
}]),xy.dStaticInjector.set(xy.dNames.services.sortable, {
  byField: function(field, subfield) {
    "use strict";
    return function(a, b) {
      return subfield ? a[field][subfield] - b[field][subfield] : a[field] - b[field]
    }
  }, reports: function(a, b) {
    "use strict";
    var sortOrder = b.date - a.date;
    return 0 === sortOrder && (sortOrder = a.type - b.type), sortOrder
  }, forumThread: function(a, b) {
    "use strict";
    return b.lastMessageDate - a.lastMessageDate
  }, player: function(options) {
    "use strict";
    switch (options.field) {
      case"nick":
        return function(a, b) {
          var result = 0;
          if (a.nick > b.nick)result = 1; else {
            if (!(a.nick < b.nick))return 0;
            result = -1
          }
          return options.isDESC && (result = -result), result
        };
      case"points":
        return function(a, b) {
          var result = a.points - b.points;
          return options.isDESC && (result = -result), result
        };
      case"alliancePermission":
        return function(a, b) {
          if (a.alliancePermission === -1 && b.alliancePermission === -1)return 0;
          if (a.alliancePermission === -1)return options.isDESC ? -1 : 1;
          if (b.alliancePermission === -1)return options.isDESC ? 1 : -1;
          var result = a.alliancePermission - b.alliancePermission;
          return options.isDESC && (result = -result), result
        }
    }
  }, menuMessagesList: function(a, b) {
    "use strict";
    return b.lastEntryDate - a.lastEntryDate
  }, forumThreadMessages: function(a, b) {
    "use strict";
    return a.creationDate - b.creationDate;
  }, allianceReports: function(a, b) {
    "use strict";
    return b.date - a.date
  }, trackingEvent: function(a, b) {
    "use strict";
    return "world" === a.type && "world" === b.type ? a.success === !0 && b.success === !0 ? a.completedAt - b.completedAt : a.success === !0 ? -1 : b.success === !0 ? 1 : a.playerDeadline - b.playerDeadline : "task" === a.type && "task" === b.type ? a.success === !0 && b.success === !0 ? a.id - b.id : a.success === !0 ? -1 : b.success === !0 ? 1 : a.id - b.id : a.isTutorialEvent ? -1 : b.isTutorialEvent ? 1 : "world" === a.type ? -1 : "world" === b.type ? 1 : a.id - b.id
  }, arrivalTimeFinderOptimalTime: function(a, b) {
    "use strict";
    var aName, bName, time = a.closenessToOptimal - b.closenessToOptimal;
    return 0 === time ? (aName = a.habitat.name.toLowerCase(), bName = b.habitat.name.toLowerCase(), aName === bName ? 0 : aName > bName ? 1 : -1) : time
  }, arrivalTimeFinderDistance: function(a, b) {
    "use strict";
    var aName, bName, time = a.distance - b.distance;
    return 0 === time ? (aName = a.habitat.name.toLowerCase(), bName = b.habitat.name.toLowerCase(), aName === bName ? 0 : aName > bName ? 1 : -1) : time
  }, currentWorlds: function(a, b) {
    "use strict";
    return b.lastLoginDate - a.lastLoginDate
  }, mapTiles: function(a, b) {
    "use strict";
    return a.frame && a.frame.origin && b.frame && b.frame.origin ? a.frame.origin.y === b.frame.origin.y ? a.frame.origin.x - b.frame.origin.x : a.frame.origin.y - b.frame.origin.y : 0
  }, habitatOnMapTile: function(a, b) {
    "use strict";
    return a.mapY === b.mapY ? a.mapX - b.mapX : a.mapY - b.mapY
  }, habitatsForExpandingList: function(a, b) {
    "use strict";
    return a.upgradeObject.ready || b.upgradeObject.ready ? a.upgradeObject.ready ? b.upgradeObject.ready ? b.upgradeObject.ready.isReadyForBuild - a.upgradeObject.ready.isReadyForBuild : -1 : 1 : a.modeledHabitat.distanceToActiveHabitat - b.modeledHabitat.distanceToActiveHabitat
  }
}),xy.dStaticInjector.set(xy.dNames.services.groupable, [xy.dNames.services.sortable, xy.dNames.utils.dateTime, function(servicesSortable, utilsDateTime) {
  "use strict";
  return {
    byField: function(groupable, options) {
      var result;
      return result = groupable instanceof Array ? this.arrayByField(groupable, options) : this.objectByField(groupable, options)
    }, objectByField: function(object, options) {
      var key, array = [];
      for (key in object)object.hasOwnProperty(key) && array.push(object[key]);
      return this.arrayByField(array, options)
    }, arrayByField: function(array, options) {
      var field = options.field, subField = options.subField, keys = [], groupedSet = {}, humanKeysSet = {}, result = [];
      if (array.forEach(function(thing) {
                var key = subField ? thing[field][subField] : thing[field], humanKey = key;
                options.areGroupsDate && (humanKey = key, key = utilsDateTime.getSortableDateString(key)), groupedSet[key] || (keys.push(key), groupedSet[key] = [], humanKeysSet[key] = humanKey), groupedSet[key].push(thing)
              }), options.sortGroups && (keys.sort(), options.sortGroupsIsReverse && keys.reverse()), options.sortWithinGroups) {
        var groupsSortingFieldSortable = null;
        options.sortWithinGroupsField && options.sortWithinGroupsSubField ? groupsSortingFieldSortable = servicesSortable.byField.bind(this, options.sortWithinGroupsField, options.sortWithinGroupsSubField) : options.sortWithinGroupsField ? groupsSortingFieldSortable = servicesSortable.byField.bind(this, options.sortWithinGroupsField) : options.sortWithinGroupsSortable && (groupsSortingFieldSortable = options.sortWithinGroupsSortable), keys.forEach(function(key) {
          groupsSortingFieldSortable && groupedSet[key].sort(groupsSortingFieldSortable), options.sortWithinGroupsIsReverse && groupedSet[key].reverse()
        })
      }
      return keys.forEach(function(key) {
        result.push(groupedSet[key])
      }), { humanKeysSet: humanKeysSet, groupsKeys: keys, groups: result }
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassNetwork, [xy.dNames.mixins.setOption, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.parserBPList, xy.dNames.services.httpRequest, function(mixinsSetOption, utilsNetwork, settingsGameConstant, servicesParserBPList, servicesHTTPRequest) {
  "use strict";
  function CoreServiceClassNetwork(connectionSetting) {
    this.pending = !1, this.pendingQueue = [], this.responseTimestamp = null, this.clientPlatform = "", this.deviceType = "", this.clientIdentifier = "", this.worldServerUrl = "", this.capabilitiesHeader = [], Object.assign(this, connectionSetting), Object.assign(this, mixinsSetOption)
  }

  return CoreServiceClassNetwork.prototype.preApplyGameData = function(data) {
    var params = {};
    return Object.assign(params, data), params.clientPlatform = this.clientPlatform, params.worldId = this.worldId, params.logoutUrl = this.logoutUrl, params.lang = this.lang, utilsNetwork.objectToURIString(params)
  }, CoreServiceClassNetwork.prototype.preApplyConnectData = function(data) {
    var params = {};
    return Object.assign(params, data), params.clientPlatform = this.clientPlatform, params.worldId = this.worldId, params.logoutUrl = this.logoutUrl, this.credential.facebookAccessToken ? (params.facebookAccessToken = this.credential.facebookAccessToken, params.deviceId = this.credential.facebookAccessToken) : this.credential.googleAccessToken ? (params.googleAccessToken = this.credential.googleAccessToken, params.deviceId = this.credential.googleAccessToken) : (params.login = this.credential.login, params.deviceId = this.credential.login, params.password = this.credential.password), params.lang = this.lang, utilsNetwork.objectToURIString(params)
  }, CoreServiceClassNetwork.prototype.preApplyLoginData = function(data) {
    var params = {};
    return Object.assign(params, data), params.clientPlatform = this.clientPlatform, params.lang = this.lang, this.credential && (this.credential.facebookAccessToken ? (params.facebookAccessToken = this.credential.facebookAccessToken, params.deviceId = this.credential.facebookAccessToken) : this.credential.googleAccessToken ? (params.googleAccessToken = this.credential.googleAccessToken, params.deviceId = this.credential.googleAccessToken) : (params.login = this.credential.login, params.deviceId = this.credential.login, params.password = this.credential.password)), params.deviceType = this.deviceType, utilsNetwork.objectToURIString(params)
  }, CoreServiceClassNetwork.prototype.postApplyData = function(data, options) {
    this.pending = !1, this.restoreRequest();
    var status = "success";
    data ? data.hasOwnProperty("error") || data.hasOwnProperty("clientCommand") ? status = "soft-fail" : this.responseTimestamp = data.responseTimestamp : status = "hard-fail", options.dataSource.requestCallBack(status, data, options)
  }, CoreServiceClassNetwork.prototype.restoreRequest = function() {
    if (!this.pending) {
      this.pending = !0;
      var request = this.pendingQueue.shift();
      return request ? void this.innerRequest(request.data, request.action, request.options) : void(this.pending = !1)
    }
  }, CoreServiceClassNetwork.prototype.request = function(data, action, options) {
    var params, url;
    if (options = options || {}, data = data || {}, options.isPoliticalMapRequest)return void this.innerMapRequest(data);
    options.isLogin ? (params = this.preApplyLoginData(data), url = this.loginServerUrl + action) : options.isConnect ? (params = this.preApplyConnectData(data), url = this.worldServerUrl + action) : (params = this.preApplyGameData(data), url = this.worldServerUrl + action);
    var xhr = servicesHTTPRequest.getXHR(), postApplyCallBack = function(options) {
      this.postApplyData(null, options)
    }, readyStateChange = function(xhr, options) {
      if (4 === xhr.readyState && xhr.status >= 200 && xhr.status <= 207) {
        var fileReader, aBlob;
        fileReader = new FileReader, fileReader.addEventListener("loadend", function() {
          var arrayBuffer = fileReader.result, parsedData = servicesParserBPList(arrayBuffer);
          this.postApplyData(parsedData, options)
        }.bind(this)), aBlob = xhr.response, fileReader.readAsArrayBuffer(aBlob)
      }
    };
    servicesHTTPRequest.registerEvents(xhr, {
      context: this,
      options: options,
      onReadyStateChange: readyStateChange,
      onError: postApplyCallBack,
      onAbort: postApplyCallBack,
      onTimeout: postApplyCallBack
    });
    var method = options.method || "POST";
    method === settingsGameConstant.REQUEST_MODE.GET && (url = url + "?" + utilsNetwork.objectToURIString(data)), xhr.open(method, url, !0), xhr.responseType = "blob", xhr.setRequestHeader("Accept", "application/x-bplist"), xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    var shouldFullyUpdate = options.shouldFullyUpdate || !1;
    this.responseTimestamp && !shouldFullyUpdate && xhr.setRequestHeader("XYClient-PartialUpdateSince", this.responseTimestamp), this.capabilitiesHeader.forEach(function(capabilityString) {
      xhr.setRequestHeader("XYClient-Capabilities", capabilityString)
    }), xhr.setRequestHeader("XYClient-Client", this.clientIdentifier), xhr.withCredentials = !0, method === settingsGameConstant.REQUEST_MODE.GET ? xhr.send() : xhr.send(params)
  }, CoreServiceClassNetwork.prototype.innerMapRequest = function(param) {
    var url, injection, timeOutTimer, loadAttempt = param.loadAttempt || 0;
    injection = document.createElement("script"), injection.setAttribute("id", "jtile-" + param.id), url = this.worldMapUrl + "/" + param.id + ".jtile", injection.setAttribute("type", "application/javascript"), injection.setAttribute("src", url), document.getElementsByTagName("head")[0].appendChild(injection), injection.addEventListener("error", function() {
      loadAttempt += 1, loadAttempt < 3 && (timeOutTimer = setTimeout(function() {
        injection.parentNode.removeChild(injection), param.loadAttempt = loadAttempt, this.innerMapRequest(param)
      }.bind(this), (500 + (1e4 * Math.random() | 0)) * loadAttempt))
    }.bind(this)), injection.addEventListener("load", function() {
      setTimeout(function() {
        injection.parentNode.removeChild(injection)
      }, 1e3)
    })
  }, CoreServiceClassNetwork
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassInternationalization, [xy.dNames.utils.string, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(utilsString, utilsObject, settingsGameConstant, servicesLog) {
  "use strict";
  function CoreServiceClassInternationalization(locale) {
    this.updateLocale(locale || {})
  }

  return CoreServiceClassInternationalization.prototype.updateLocale = function(locale) {
    this.locale = {}, this.locale[settingsGameConstant.LOCALIZATION_TYPE.MAIN] = {}, this.locale[settingsGameConstant.LOCALIZATION_TYPE.EVENT] = {}, Object.assign(this.locale[settingsGameConstant.LOCALIZATION_TYPE.MAIN], locale.main), Object.assign(this.locale[settingsGameConstant.LOCALIZATION_TYPE.EVENT], locale.event)
  }, CoreServiceClassInternationalization.prototype.getLocalizationOf = function(localeType, translationKey) {
    var localizationString = null, locale = this.locale[localeType];
    localizationString = locale.hasOwnProperty(translationKey) ? locale[translationKey] : "??" + translationKey + "??";
    try {
      localizationString = localizationString.replace(/\\{1,3}"/g, '"')
    } catch (eX) {
      servicesLog("warn", "Localisation String is not a String"), servicesLog("debug", eX)
    }
    return localizationString
  }, CoreServiceClassInternationalization.prototype.isLocalizable = function(localeType, translationKey) {
    return "string" == typeof translationKey ? this.locale[localeType].hasOwnProperty(translationKey) : !!utilsObject.isPlainObject(translationKey)
  }, CoreServiceClassInternationalization.prototype.localize = function() {
    var args = Array.from(arguments);
    return this.localization(settingsGameConstant.LOCALIZATION_TYPE.MAIN, args)
  }, CoreServiceClassInternationalization.prototype.localizeMain = function() {
    var args = Array.from(arguments);
    return this.localization(settingsGameConstant.LOCALIZATION_TYPE.MAIN, args)
  }, CoreServiceClassInternationalization.prototype.localizeEvent = function() {
    var args = Array.from(arguments);
    return this.localization(settingsGameConstant.LOCALIZATION_TYPE.EVENT, args)
  }, CoreServiceClassInternationalization.prototype.localization = function(localeType, args) {
    var i, result = [], len = args.length;
    if (1 === len)return this.getLocalizationOf(localeType, args[0]);
    for (result.push(this.getLocalizationOf(localeType, args[0])), i = 1; i < len; i += 1)this.isLocalizable(localeType, args[i]) ? result.push(this.getLocalizationOf(localeType, args[i])) : result.push(args[i]);
    return utilsString.sprintf(result)
  }, CoreServiceClassInternationalization
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassKeyboardManager, [xy.dNames.settings.gameConstant, xy.dNames.services.log, function(settingsGameConstant, servicesLog) {
  "use strict";
  function CoreServiceClassKeyboardManager() {
    var listeners = {};
    this.fireKeyListener = function(options) {
      var listenerUniqueId, firedListeners = {}, idsArray = [];
      if (listeners[options.key]) {
        firedListeners = listeners[options.key];
        for (listenerUniqueId in firedListeners)firedListeners.hasOwnProperty(listenerUniqueId) && idsArray.push(listenerUniqueId);
        idsArray.forEach(function(listenerId) {
          firedListeners[listenerId] && setTimeout(function() {
            this.fireListenerCallBack(firedListeners[listenerId], { key: options.key })
          }.bind(this), 25)
        }, this)
      }
    }, this.fireListenerCallBack = function(listener, options) {
      listener && listener.listenerContext && listener.listenerCalBackFunction.call(listener.listenerContext, options)
    }, this.registerKeyboardListener = function(options) {
      listeners.hasOwnProperty(options.key) || (listeners[options.key] = {}), listeners[options.key][options.listenerUniqueId] = {
        listenerContext: options.listenerContext,
        listenerCalBackFunction: options.listenerCalBackFunction
      }
    }, this.removeKeyboardListener = function(options) {
      try {
        delete listeners[options.key][options.listenerUniqueId]
      } catch (e) {
        servicesLog("error", e.toString()), servicesLog("debug", e)
      }
    }, this.__checkKey = function(key) {
      var fixedKey;
      switch (key) {
        case settingsGameConstant.KEYBOARD_KEYS.ARROW_LEFT:
        case settingsGameConstant.KEYBOARD_KEYS.ARROW_RIGHT:
          fixedKey = key;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.ARROW_LEFT_SAFARI:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.ARROW_LEFT;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.ARROW_RIGHT_SAFARI:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.ARROW_RIGHT;
          break;
        default:
          return !1
      }
      return this.fireKeyListener({ key: fixedKey }), !0
    }, this.__checkPositionKey = function(code) {
      var fixedKey;
      switch (code) {
        case settingsGameConstant.KEYBOARD_KEYS.KEY_W:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_A:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_S:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_D:
          fixedKey = code;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_W_SAFARI:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_W_SAFARI_S:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_W;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_A_SAFARI:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_A_SAFARI_S:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_A;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_S_SAFARI:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_S_SAFARI_S:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_S;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_D_SAFARI:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_D_SAFARI_S:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_D;
          break;
        default:
          return !1
      }
      return this.fireKeyListener({ key: fixedKey }), !0
    }, this.__checkSymbolKey = function(code) {
      var fixedKey;
      switch (code) {
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_HABITAT:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_GAME:
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_POLITICAL:
          fixedKey = code;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_HABITAT_SAFARI:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_HABITAT;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_GAME_SAFARI:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_GAME;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_POLITICAL_SAFARI:
          fixedKey = settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_POLITICAL;
          break;
        default:
          return !1
      }
      return this.fireKeyListener({ key: fixedKey }), !0
    }, document.addEventListener("keyup", function(event) {
      if (!event.defaultPrevented) {
        if (event.target && event.target.tagName)switch (event.target.tagName) {
          case"TEXTAREA":
          case"textarea":
          case"INPUT":
          case"input":
            return !0
        }
        return !this.__checkKey(event.key || event.keyIdentifier) && !this.__checkSymbolKey(event.code || event.which || event.keyCode) || void event.preventDefault()
      }
    }.bind(this), !0), document.addEventListener("keypress", function(event) {
      if (!event.defaultPrevented) {
        if (event.target && event.target.tagName)switch (event.target.tagName) {
          case"TEXTAREA":
          case"textarea":
          case"INPUT":
          case"input":
            return !0
        }
        return !this.__checkPositionKey(event.code || event.which || event.keyCode) || void event.preventDefault()
      }
    }.bind(this), !0)
  }

  return CoreServiceClassKeyboardManager
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassEventManager, [xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(utilsObject, settingsGameConstant, servicesLog) {
  "use strict";
  function CoreServiceClassEventManager() {
    this.listeners = {}
  }

  return CoreServiceClassEventManager.prototype.handleClientEvent = function(identifier, data, options) {
    options = options || { reHandleAttempt: 0 }, this.listeners[identifier] ? (data = data || {}, servicesLog("log", "fired client event: " + identifier), this.fireEventListeners(identifier, data)) : xy.eNames.eventListeners.delayedIdentifiers[identifier] && options.reHandleAttempt < settingsGameConstant.EVENT_RE_HANDLE_LIMIT ? setTimeout(function() {
      this.handleClientEvent(identifier, data, { reHandleAttempt: options.reHandleAttempt + 1 })
    }.bind(this), 500) : (servicesLog("warn", "Can not fire client event: " + identifier), servicesLog("debug", data))
  }, CoreServiceClassEventManager.prototype.fireEventListeners = function(identifier, data) {
    var firedListeners = {}, listeners = this.listeners;
    listeners[identifier] && (firedListeners = listeners[identifier], Object.keys(firedListeners).forEach(function(key) {
      firedListeners[key] && setTimeout(function() {
        this.fireListenerCallBack(firedListeners[key], data)
      }.bind(this), 25)
    }, this))
  }, CoreServiceClassEventManager.prototype.fireListenerCallBack = function(listener, data) {
    listener && listener.listenerContext && listener.listenerCalBackFunction.call(listener.listenerContext, data)
  }, CoreServiceClassEventManager.prototype.registerEventListener = function(listener) {
    this.listeners.hasOwnProperty(listener.identifier) || (this.listeners[listener.identifier] = {}), this.listeners[listener.identifier][listener.listenerUniqueId] = {
      listenerContext: listener.listenerContext,
      listenerCalBackFunction: listener.listenerCalBackFunction
    }
  }, CoreServiceClassEventManager.prototype.deRegisterEventListener = function(listener) {
    try {
      return this.listeners[listener.identifier][listener.listenerUniqueId] = null, delete this.listeners[listener.identifier][listener.listenerUniqueId], 0 === utilsObject.effectiveLength(this.listeners[listener.identifier]) && delete this.listeners[listener.identifier], !0
    } catch (eX) {
      servicesLog("warn", "Can not remove event listener in Event Manager"), servicesLog("debug", eX)
    }
  }, CoreServiceClassEventManager
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassTheme, [xy.dNames.gameInstance, xy.dNames.utils.network, xy.dNames.services.log, xy.dNames.services.worldSettings, function(gameInstance, utilsNetwork, servicesLog, servicesWorldSettings) {
  "use strict";
  function CoreServiceClassTheme(themeJSON) {
    if (possibleGames.indexOf(themeJSON.game) === -1)throw new Error("Can't init the Theme for unknown game");
    this.themeSettings = {}, this.environmentSettings = {}, Object.assign(this.themeSettings, themeJSON)
  }

  var possibleGames = ["lordsandknights", "new cool game"];
  return CoreServiceClassTheme.prototype.getConnectionSettings = function(environment) {
    var settings = this.themeSettings.settings.connectionSetting;
    return Object.assign(settings, this.themeSettings.settings["server-" + environment]), this.environmentSettings = settings, settings
  }, CoreServiceClassTheme.prototype.getImageClassName = function(img, group) {
    var imageClassName = null;
    return this.themeSettings.imagesClassNames[group] && this.themeSettings.imagesClassNames[group][img] && (imageClassName = this.themeSettings.imagesClassNames[group][img]), imageClassName ? imageClassName : (servicesLog("error", "Can not load image class name from theme, group: " + group + " name: " + img), "")
  }, CoreServiceClassTheme.prototype.getFAQLink = function(topic) {
    var faqLinks = this.themeSettings.faqLinks, lang = gameInstance.getGameLanguage();
    return faqLinks[topic] ? faqLinks.baseURL + faqLinks[topic] + "&l=" + lang : null
  }, CoreServiceClassTheme.prototype.getStatisticLink = function(options) {
    if (servicesWorldSettings.settings.featureStatisticsWebView && servicesWorldSettings.settings.statisticsBaseURL) {
      var action, params;
      switch (options.entity) {
        case"player":
          params = {
            world_id: options.worldId,
            player_id: options.playerId
          }, action = this.themeSettings.statisticActions.player;
          break;
        case"alliance":
          params = {
            world_id: options.worldId,
            alliance_id: options.allianceId,
            player_id: options.playerId
          }, action = this.themeSettings.statisticActions.alliance
      }
      return servicesWorldSettings.settings.statisticsBaseURL + action + "?" + utilsNetwork.objectToURIString(params)
    }
    return null
  }, CoreServiceClassTheme.prototype.getWebShopLink = function(options) {
    options = options || {};
    var url = this.environmentSettings.webShopUrl, params = {};
    return options.addPlayer && (params.playerId = options.playerId, params.worldId = options.worldId, params.lang = options.lang || gameInstance.getGameLanguage(), url += "?" + utilsNetwork.objectToURIString(params)), url
  }, CoreServiceClassTheme
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassGameDataManager, [xy.dNames.utils.converter, xy.dNames.services.log, xy.dNames.settings.gameConstant, xy.dNames.services.worldSettings, xy.dNames.services.theme, xy.dNames.services.sessionUpdateSchedule, xy.dNames.services.storage, xy.dNames.services.eventManager, xy.dNames.core.collectionAlliances, xy.dNames.core.collectionAllianceReport, xy.dNames.core.collectionHabitats, xy.dNames.core.collectionPlayers, xy.dNames.core.collectionEvents, xy.dNames.core.collectionUnits, xy.dNames.core.collectionTransits, xy.dNames.core.collectionMessages, xy.dNames.core.collectionReports, xy.dNames.core.collectionForums, xy.dNames.core.collectionMissions, xy.dNames.core.collectionKnowledges, xy.dNames.core.collectionBuildings, xy.dNames.core.collectionModifiers, xy.dNames.core.collectionBuffs, xy.dNames.core.collectionHabitatUpgradesConstruction, xy.dNames.core.collectionRankCache, xy.dNames.core.collectionMassFunctionsCache, function(utilsConverter, servicesLog, settingsGameConstant, servicesWorldSettings, servicesTheme, servicesSessionUpdateSchedule, servicesStorage, servicesEventManager, CoreCollectionAlliances, CoreCollectionAllianceReport, CoreCollectionHabitats, CoreCollectionPlayers, CoreCollectionEvents, CoreCollectionUnits, CoreCollectionTransit, CoreCollectionMessages, CoreCollectionReports, CoreCollectionForums, CoreCollectionMission, CoreCollectionKnowledges, CoreCollectionBuildings, CoreCollectionModifiers, CoreCollectionBuffs, CoreCollectionHabitatUpgradesConstruction, CollectionRankCache, CoreCollectionMassFunctionsCache) {
  "use strict";
  function CoreServiceClassGameDataManager() {
    var playerId, eventsSetting, dictionariesData, alerts, listeners, activeModelLink;
    this.sceneMapDataLoaded = !1, this.sceneHabitatDataLoaded = !1, this.initGameData = function() {
      servicesLog("log", "init new game data service"), this.settings = {}, this.habitatsCollection = new CoreCollectionHabitats({ servicesGameDataManager: this }), this.playersCollection = new CoreCollectionPlayers({ servicesGameDataManager: this }), this.alliancesCollection = new CoreCollectionAlliances({ servicesGameDataManager: this }), this.allianceReportsCollection = new CoreCollectionAllianceReport({ servicesGameDataManager: this }), this.unitsCollection = new CoreCollectionUnits({ servicesGameDataManager: this }), this.eventsCollection = new CoreCollectionEvents({ servicesGameDataManager: this }), this.transitsCollection = new CoreCollectionTransit({ servicesGameDataManager: this }), this.messagesCollection = new CoreCollectionMessages({ servicesGameDataManager: this }), this.reportsCollection = new CoreCollectionReports({ servicesGameDataManager: this }), this.forumsCollection = new CoreCollectionForums({ servicesGameDataManager: this }), this.missionsCollection = new CoreCollectionMission({ servicesGameDataManager: this }), this.knowledgesCollection = new CoreCollectionKnowledges({ servicesGameDataManager: this }), this.buildingsCollection = new CoreCollectionBuildings({ servicesGameDataManager: this }), this.modifiersCollection = new CoreCollectionModifiers({ servicesGameDataManager: this }), this.buffsCollection = new CoreCollectionBuffs({ servicesGameDataManager: this }), this.habitatUpgradesConstructionsCollection = new CoreCollectionHabitatUpgradesConstruction({ servicesGameDataManager: this }), this.rankingCollection = new CollectionRankCache({ servicesGameDataManager: this }), this.massFunctionsCollection = new CoreCollectionMassFunctionsCache({ servicesGameDataManager: this }), eventsSetting = {}, dictionariesData = { habitatUnderAttack: {} }, alerts = {
        bottomBar: {
          unreadDiscussionCount: 0,
          unreadReportCount: 0,
          unreadThreadCount: 0,
          successEvents: 0
        }
      }, listeners = {}, playerId = null, activeModelLink = null
    }, this.receiveGameData = function(rawData) {
      if (void 0 !== rawData.Data) {
        servicesWorldSettings.updateWorldTime({
          time: rawData.time,
          worldDawn: rawData.worldDawn,
          worldDusk: rawData.worldDusk
        }), rawData.defaultValues && servicesWorldSettings.updateWorldSettings(rawData.defaultValues), rawData.hasOwnProperty("nextUpdateDate") && servicesSessionUpdateSchedule.scheduleDate(utilsConverter.toDate(rawData.nextUpdateDate)), rawData.hasOwnProperty("selectedPlayer") && (playerId = +rawData.selectedPlayer, this.habitatsCollection.setPlayerId(playerId), this.playersCollection.setPlayerId(playerId)), this.habitatUpgradesConstructionsCollection.updateUpgradeData(rawData.Upgrade), this.modifiersCollection.updateModifiersData(rawData.Modifier), this.buffsCollection.updateBuffsData(rawData.Buff), this.buildingsCollection.updateBuildingsData(rawData.Building), this.missionsCollection.updateMissionsData(rawData.Mission), this.knowledgesCollection.updateKnowledgesData(rawData.Knowledge), this.habitatsCollection.updateHabitatUnderAttack(rawData.habitatUnderAttackArray), this.forumsCollection.updateForumData(rawData, {
          sessionUpdate: !0,
          softUpdate: !0
        });
        var updatePlayersDataSync, gameData = rawData.Data;
        if (this.handlePossibleOmittedData(rawData.omittedEntityArray || []), this.transitsCollection.isPartialTransitMode() ? this.transitsCollection.flushTransitsCache() : gameData.Transit && this.transitsCollection.globalUpdateTransit(gameData.Transit || []), this.habitatUpgradesConstructionsCollection.updateUpgradesInProgressData(gameData.HabitatUpgradeOrder), this.habitatsCollection.updateHabitatReservation(gameData.HabitatReservation), this.updateUnitsDictionary(rawData.Unit), this.unitsCollection.updateHabitatInProgressUnits(gameData.HabitatUnitOrder), this.buildingsCollection.updateBuildingUpgradesData(gameData.HabitatBuildingUpgrade), this.buffsCollection.updateBuffActiveData(gameData.HabitatBuff), this.knowledgesCollection.updateKnowledgesInProgressData(gameData.HabitatKnowledgeOrder), this.missionsCollection.updateMissionInProgressData(gameData.HabitatMission), updatePlayersDataSync = this.updatePlayersData(gameData.Player)) {
          var playerModel = this.playersCollection.getPlayer();
          if (playerModel.points >= 20 && !servicesStorage.isPlayerAlreadyTracked(playerModel.id) && (servicesStorage.addAlreadyTrackedPlayer(playerModel.id), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.matAnalyticsIdentifiers.twentyPointsEarned)), !(playerModel.habitatArray instanceof Array) || playerModel.habitatArray.length < 1)return this.habitatsCollection.firstHabitatId = null, this.habitatsCollection.currentHabitatId = null, void this.fireDataUpdateListener(null, {
            entity: xy.eNames.dataListeners.dataEntity.habitat,
            identifier: xy.eNames.dataListeners.dataIdentifiers.lostAllHabitats
          });
          this.habitatsCollection.setPlayerHabitats(playerModel.habitatArray) && this.habitatsCollection.updateHabitatSet(gameData.Habitat) && this.updateHabitatsUnits(gameData.HabitatUnit), this.updateEvents({
            trackableEvents: gameData.TrackableEvent,
            trackingEvents: gameData.TrackingEvent,
            player: playerModel
          }), this.updateAlliancesData(gameData.Alliance), this.alliancesCollection.updateAlliancesRelations(gameData.Diplomacy), this.alliancesCollection.updateAlliancesSharing(gameData.AllianceSharing)
        }
        this.checkUnreadAlert(rawData), this.prepareExtraResourcesDataForTopBar(), void 0 !== rawData.unreadReportCount && +rawData.unreadReportCount > 0 && this.reportsCollection.updated && this.reportsCollection.read && this.reportsCollection.flush(), this.allianceReportsCollection.flush(), this.habitatUpgradesConstructionsCollection.flushExpansionOptionsData(), this.rankingCollection.flush(), this.forumsCollection.setUnreadThreads(rawData.unreadThreadArray), setTimeout(function() {
          this.fireDataUpdateListener(null, {
            entity: xy.eNames.dataListeners.dataEntity.gameData,
            identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate
          })
        }.bind(this), 400)
      }
    }, this.handlePossibleOmittedData = function(omittedEntityArray) {
      omittedEntityArray.forEach(function(entity) {
        switch (entity) {
          case"Transit":
            this.transitsCollection.prepareCollectionForPartialTransitUpdate();
            break;
          default:
            servicesLog("warn", "Unknown omitted entity in omittedEntityArray: " + entity)
        }
      }, this)
    }, this.updateUnitsDictionary = function(unitsData) {
      unitsData && this.unitsCollection.updateUnits(unitsData)
    }, this.updateHabitatsUnits = function(habitatUnitsData) {
      habitatUnitsData && this.unitsCollection.updateHabitatUnits(habitatUnitsData)
    }, this.updateEvents = function(data) {
      var updated;
      if (updated = this.eventsCollection.updateEventsTrackable(data.trackableEvents), updated && (updated = this.eventsCollection.updateEventsTracking(data.trackingEvents)), updated) {
        var rewardDestination = eventsSetting.rewardDestination || this.habitatsCollection.firstHabitatId, successEventsAmount = this.eventsCollection.checkSuccessEvents();
        eventsSetting = {
          amountOfSuccess: successEventsAmount.amountOfSuccess,
          amountTotal: successEventsAmount.amountTotal,
          rewardDestination: rewardDestination
        };
        var pendingEvent = this.eventsCollection.checkPendingEvents(data.player);
        if (pendingEvent) {
          var firePendingEvent = function(event) {
            event.isTutorialEvent ? (this.eventsCollection.setInitTutorialEventFlag(!1), this.fireDataUpdateListener(event, {
              entity: xy.eNames.dataListeners.dataEntity.gameData,
              identifier: xy.eNames.dataListeners.dataIdentifiers.startTutorialEvent
            })) : this.fireDataUpdateListener(event, {
              entity: xy.eNames.dataListeners.dataEntity.gameData,
              identifier: xy.eNames.dataListeners.dataIdentifiers.newPendingEvent
            })
          }.bind(this, pendingEvent);
          firePendingEvent()
        }
      }
    }, this.updateHabitatsData = function(data, options) {
      options = options || {}, options.player && this.habitatsCollection.setPlayerHabitats(options.player.habitatArray), data instanceof Array && this.habitatsCollection.updateHabitatSet(data, options)
    }, this.updatePlayersData = function(data, options) {
      return data instanceof Array && this.playersCollection.updatePlayersData(data, options), !0
    }, this.updateAlliancesData = function(data, options) {
      data instanceof Array && this.alliancesCollection.updateAlliancesData(data, options)
    }, this.updateUnreadMessagesAmount = function(newUnreadMessagesAmount) {
      alerts.bottomBar.unreadDiscussionCount = newUnreadMessagesAmount, this.updateBottomBarAlerts()
    }, this.updateUnreadReportsAmount = function(newUnreadReportAmount) {
      alerts.bottomBar.unreadReportCount = newUnreadReportAmount, this.updateBottomBarAlerts()
    }, this.checkUnreadAlert = function(rawData) {
      void 0 !== rawData.unreadDiscussionCount && (alerts.bottomBar.unreadDiscussionCount = rawData.unreadDiscussionCount), void 0 !== rawData.unreadReportCount && (alerts.bottomBar.unreadReportCount = rawData.unreadReportCount), void 0 !== rawData.unreadThreadCount && (alerts.bottomBar.unreadThreadCount = rawData.unreadThreadCount);
      var eventsAmount = this.eventsCollection.checkSuccessEvents();
      alerts.bottomBar.successEvents = eventsAmount.amountOfSuccess, this.updateBottomBarAlerts()
    }, this.updateBottomBarAlerts = function() {
      this.fireDataUpdateListener({ alerts: alerts.bottomBar }, {
        entity: xy.eNames.dataListeners.dataEntity.bottomBar,
        identifier: xy.eNames.dataListeners.dataIdentifiers.updated
      })
    }, this.changeCurrentHabitat = function(data) {
      switch (data) {
        case settingsGameConstant.SET_CURRENT_HABITAT_EVENT.PREV:
          this.habitatsCollection.setAsCurrentPrevHabitat();
          break;
        case settingsGameConstant.SET_CURRENT_HABITAT_EVENT.NEXT:
          this.habitatsCollection.setAsCurrentNextHabitat();
          break;
        default:
          this.habitatsCollection.setCurrentHabitatId(data)
      }
    }, this.prepareExtraResourcesDataForTopBar = function() {
      var conquestResourceIndex = servicesTheme.themeSettings.resources.conquestResourceId, extraResources = {
        conquest: this.habitatsCollection.getTotalForResource(conquestResourceIndex)[conquestResourceIndex],
        premium: this.playersCollection.getPlayersPremiumResource()
      };
      this.fireDataUpdateListener({ extraResources: extraResources }, {
        entity: xy.eNames.dataListeners.dataEntity.resources,
        identifier: xy.eNames.dataListeners.dataIdentifiers.setExtraResources
      })
    }, this.fireDataUpdateListener = function(data, options) {
      var listenerUniqueId, firedListeners = {}, idsArray = [];
      if (listeners[options.entity] && listeners[options.entity][options.identifier]) {
        firedListeners = listeners[options.entity][options.identifier];
        for (listenerUniqueId in firedListeners)firedListeners.hasOwnProperty(listenerUniqueId) && idsArray.push(listenerUniqueId);
        idsArray.forEach(function(listenerId) {
          firedListeners[listenerId] && setTimeout(function() {
            this.fireListenerCallBack(firedListeners[listenerId], data)
          }.bind(this), 25)
        }, this)
      }
    }, this.fireListenerCallBack = function(listener, data) {
      listener && listener.listenerContext && (listener.listenerContext.stopLocalUpdate instanceof Function && listener.listenerContext.stopLocalUpdate.call(listener.listenerContext), listener.listenerCalBackFunction.call(listener.listenerContext, data))
    }, this.registerDataUpdateListener = function(options) {
      listeners.hasOwnProperty(options.entity) ? listeners[options.entity].hasOwnProperty(options.identifier) || (listeners[options.entity][options.identifier] = {}) : (listeners[options.entity] = {}, listeners[options.entity][options.identifier] = {}), listeners[options.entity][options.identifier][options.listenerUniqueId] = {
        listenerContext: options.listenerContext,
        listenerCalBackFunction: options.listenerCalBackFunction
      }
    }, this.removeDataUpdateListener = function(options) {
      try {
        delete listeners[options.entity][options.identifier][options.listenerUniqueId]
      } catch (e) {
        servicesLog("error", e.toString()), servicesLog("debug", e)
      }
    }, this.setActiveModelLink = function(object) {
      "function" == typeof object.getLink ? activeModelLink = object.getLink() : servicesLog("error", "Try to set link of object that does not have it")
    }, this.getActiveModelLink = function() {
      return activeModelLink || ""
    }, this.clearActiveModelLink = function() {
      activeModelLink = null
    }, this.isModelHasActiveLink = function(object) {
      return "function" == typeof object.getLink ? activeModelLink === object.getLink() : (servicesLog("warn", "Try to set link of object that does not have it"), !1)
    }, this.getPlayerId = function() {
      return playerId
    }, this.getAllianceId = function() {
      return this.alliancesCollection.playersAllianceId
    }, this.getEventsStatistics = function() {
      return this.eventsCollection.checkSuccessEvents()
    }, this.getTrackingEvents = function() {
      return this.eventsCollection.getTrackingEventsList()
    }, this.getEvent = function(id) {
      return this.eventsCollection.getTrackingEventById(id)
    }
  }

  return CoreServiceClassGameDataManager
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassSessionUpdateSchedule, [xy.dNames.settings.gameConstant, xy.dNames.utils.dateTime, function(settingsGameConstant, utilsDateTime) {
  "use strict";
  function CoreServiceClassSessionUpdateSchedule() {
    function deleteMinFromQueue() {
      queue && (queue = queue.next)
    }

    function addToQueue(date) {
      var obj = { value: date, next: null }, now = new Date;
      if (!(date < now))if (queue)if (queue.value > obj.value)obj.next = queue, queue = obj; else for (var queuePointer = queue; queuePointer;) {
        if (!queuePointer.next) {
          queuePointer.next = obj;
          break
        }
        if (queuePointer.next.value > obj.value) {
          obj.next = queuePointer.next, queuePointer.next = obj;
          break
        }
        if (queuePointer.next.value === obj.value)break;
        queuePointer = queuePointer.next
      } else queue = obj
    }

    var queue = null, lastUpdateTime = new Date, datesSet = {};
    this.scheduleDate = function(date) {
      var scheduleDate, dateInMilliseconds = date.getTime();
      dateInMilliseconds -= dateInMilliseconds % settingsGameConstant.SESSION_UPDATE_SCHEDULE_INTERVAL, dateInMilliseconds += settingsGameConstant.SESSION_UPDATE_SCHEDULE_INTERVAL, scheduleDate = new Date(dateInMilliseconds), datesSet[dateInMilliseconds] || (datesSet[dateInMilliseconds] = !0, addToQueue(scheduleDate))
    }, this.checkUpdateSchedule = function() {
      if (!queue)return settingsGameConstant.SESSION_UPDATE_SCHEDULE_STATUS.STOP_TIMER;
      var now = new Date, min = queue.value, passedFromLastUpdate = 1e3 * utilsDateTime.passedTimeInSeconds(lastUpdateTime);
      return now > min && passedFromLastUpdate > settingsGameConstant.SESSION_UPDATE_SCHEDULE_INTERVAL ? (deleteMinFromQueue(), this.cleanAllEarlierThan(now), settingsGameConstant.SESSION_UPDATE_SCHEDULE_STATUS.UPDATE) : settingsGameConstant.SESSION_UPDATE_SCHEDULE_STATUS.CONTINUE
    }, this.cleanAllEarlierThan = function(date) {
      if (queue) {
        var min = queue.value;
        min < date && (deleteMinFromQueue(), this.cleanAllEarlierThan(date))
      }
    }, this.setLastUpdateTime = function() {
      lastUpdateTime = new Date
    }, this.isSessionUpdatePossible = function() {
      return utilsDateTime.passedTimeInSeconds(lastUpdateTime) > settingsGameConstant.SESSION_UPDATE_SCHEDULE_MIN_DELAY_SECONDS
    }
  }

  return CoreServiceClassSessionUpdateSchedule
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassWorldSettings, [xy.dNames.utils.dateTime, xy.dNames.core.modelDefaultSettings, function(utilsDateTime, CoreModelDefaultSettings) {
  "use strict";
  function CoreServiceClassWorldSettings() {
    this.settings = {}
  }

  return CoreServiceClassWorldSettings.prototype.updateWorldSettings = function(rawSettings) {
    this.settings = new CoreModelDefaultSettings(rawSettings)
  }, CoreServiceClassWorldSettings.prototype.updateWorldTime = function(worldTime) {
    this.worldTime = worldTime.time, this.worldDawn = worldTime.worldDawn, this.worldDusk = worldTime.worldDusk, utilsDateTime.setTimeGap(this.worldTime), utilsDateTime.worldDawn = this.worldDawn, utilsDateTime.worldDusk = this.worldDusk
  }, CoreServiceClassWorldSettings.prototype.isDistanceLimited = function() {
    return this.settings.hasOwnProperty("transitDistanceMultiplier")
  }, CoreServiceClassWorldSettings
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassLocalStorage, [xy.dNames.gameInstance, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(gameInstance, utilsObject, settingsGameConstant, servicesLog) {
  "use strict";
  function CoreServiceClassLocalStorage() {
    this.storage = localStorage
  }

  return CoreServiceClassLocalStorage.prototype.initClientStorage = function(options) {
    options = options || {}, this.clientCache = {
      language: null,
      gameSettings: {}
    }, this.clientKey = "game-client-" + options.game, this.__loadFromStorage(this.clientKey, this.clientCache)
  }, CoreServiceClassLocalStorage.prototype.initLoginStorage = function(options) {
    options = options || {}, this.loginCache = { deniedWorlds: {} }, this.loginKey = "game-" + options.game + options.player, this.__loadFromStorage(this.loginKey, this.loginCache)
  }, CoreServiceClassLocalStorage.prototype.initGameStorage = function(options) {
    options = options || {}, this.gameCache = {
      tutorial: {},
      highlighted: {},
      activeHabitat: null,
      trackedPlayer: {},
      lastFormationOfMovementType: {},
      massRecruitmentUnitLimits: {},
      massBuildingsHabitatsSelection: {},
      massRiseBuffsHabitatsSelection: {},
      massMissionsHabitatsSelection: {},
      massRestockHabitatsSelection: {},
      massExchangeHabitatsSelection: {},
      massResearchHabitatsSelection: {},
      massRecruitmentHabitatsSelection: {}
    }, this.gameKey = "game-" + options.game + options.world + options.player, this.__loadFromStorage(this.gameKey, this.gameCache), this.servicesGameDataManager = gameInstance.injector.get(xy.dNames.services.gameDataManager)
  }, CoreServiceClassLocalStorage.prototype.__loadFromStorage = function(key, value) {
    var parsedValue, storedValue = this.storage.getItem(key);
    if (storedValue && "string" == typeof storedValue)try {
      parsedValue = JSON.parse(this.storage.getItem(key)), Object.assign(value, parsedValue)
    } catch (e) {
      servicesLog("warn", "Can't parse data from storage")
    }
  }, CoreServiceClassLocalStorage.prototype.__updateStorage = function(key, value) {
    this.storage.setItem(key, JSON.stringify(value))
  }, CoreServiceClassLocalStorage.prototype.setClientLanguage = function(language) {
    this.clientCache.language = language, this.__updateStorage(this.clientKey, this.clientCache)
  }, CoreServiceClassLocalStorage.prototype.getClientLanguage = function() {
    return this.clientCache.language
  }, CoreServiceClassLocalStorage.prototype.setTutorialSubordinateStepIdentifier = function(identifier) {
    this.gameCache.tutorial.subordinateStepIdentifier = identifier, this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.getTutorialSubordinateStepIdentifier = function() {
    return this.gameCache.tutorial.subordinateStepIdentifier || null
  }, CoreServiceClassLocalStorage.prototype.addToHighlighted = function(habitatId) {
    this.gameCache.highlighted[habitatId] = !0, this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.removeHighlighted = function(habitatId) {
    this.gameCache.highlighted[habitatId] = null, delete this.gameCache.highlighted[habitatId], this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.switchHighlighting = function(habitatId) {
    this.gameCache.highlighted[habitatId] ? this.removeHighlighted(habitatId) : this.addToHighlighted(habitatId), this.servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.changesInHighlighting
    })
  }, CoreServiceClassLocalStorage.prototype.isHighlighted = function(habitatId) {
    return this.gameCache.highlighted.hasOwnProperty(habitatId) && this.gameCache.highlighted[habitatId]
  }, CoreServiceClassLocalStorage.prototype.storeLastFormationUnits = function(options) {
    var unitsDictionary = options.unitsDictionary || {}, resourcesDictionary = options.resourcesDictionary || {}, cachedObject = {}, buildSubjectDictionary = function(subjectObject) {
      var key, subjectDictionary = {};
      for (key in subjectObject)subjectObject.hasOwnProperty(key) && subjectObject[key] > 0 && (subjectDictionary[key] = subjectObject[key]);
      return subjectDictionary
    };
    cachedObject.lastFormationMode = options.lastFormationMode, utilsObject.effectiveLength(unitsDictionary) && (cachedObject.unitsDictionary = buildSubjectDictionary(unitsDictionary)), utilsObject.effectiveLength(resourcesDictionary) && (cachedObject.resourcesDictionary = buildSubjectDictionary(resourcesDictionary)), this.gameCache.lastFormationOfMovementType = cachedObject, this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.getLastFormationUnits = function() {
    return this.gameCache.lastFormationOfMovementType
  }, CoreServiceClassLocalStorage.prototype.storeMassRecruitmentUnitLimits = function(habitatTypeKey, unitPrimaryKey, limit) {
    this.gameCache.massRecruitmentUnitLimits[unitPrimaryKey] || (this.gameCache.massRecruitmentUnitLimits[unitPrimaryKey] = {}), this.gameCache.massRecruitmentUnitLimits[unitPrimaryKey][habitatTypeKey] = limit, this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.getMassRecruitmentUnitLimits = function(habitatTypeKey, unitPrimaryKey) {
    return this.gameCache.massRecruitmentUnitLimits[unitPrimaryKey] && this.gameCache.massRecruitmentUnitLimits[unitPrimaryKey][habitatTypeKey] ? this.gameCache.massRecruitmentUnitLimits[unitPrimaryKey][habitatTypeKey] : null
  }, CoreServiceClassLocalStorage.prototype.storeMassFunctionsHabitatsSelection = function(options) {
    var massFunctionsType = options.massFunctionsType, selectedHabitats = options.selectedHabitats, field = options.field, subfield = options.subfield;
    switch (massFunctionsType) {
      case settingsGameConstant.MASS_FUNCTIONS.RESTOCK:
        this.gameCache.massRestockHabitatsSelection || (this.gameCache.massRestockHabitatsSelection = {}), this.gameCache.massRestockHabitatsSelection = selectedHabitats;
        break;
      case settingsGameConstant.MASS_FUNCTIONS.RISE_BUFFS:
        this.gameCache.massRiseBuffsHabitatsSelection || (this.gameCache.massRiseBuffsHabitatsSelection = {}), this.gameCache.massRiseBuffsHabitatsSelection = selectedHabitats;
        break;
      case settingsGameConstant.MASS_FUNCTIONS.EXCHANGE:
        this.gameCache.massExchangeHabitatsSelection[field] || (this.gameCache.massExchangeHabitatsSelection[field] = {}), this.gameCache.massExchangeHabitatsSelection[field][subfield] || (this.gameCache.massExchangeHabitatsSelection[field][subfield] = {}), this.gameCache.massExchangeHabitatsSelection[field][subfield] = selectedHabitats;
        break;
      case settingsGameConstant.MASS_FUNCTIONS.KNOWLEDGE:
        this.gameCache.massResearchHabitatsSelection[field] || (this.gameCache.massResearchHabitatsSelection[field] = {}), this.gameCache.massResearchHabitatsSelection[field] = selectedHabitats;
        break;
      case settingsGameConstant.MASS_FUNCTIONS.MISSIONS:
        this.gameCache.massMissionsHabitatsSelection || (this.gameCache.massMissionsHabitatsSelection = {}), this.gameCache.massMissionsHabitatsSelection = selectedHabitats;
        break;
      case settingsGameConstant.MASS_FUNCTIONS.RECRUITMENT:
        this.gameCache.massRecruitmentHabitatsSelection[field] || (this.gameCache.massRecruitmentHabitatsSelection[field] = {}), this.gameCache.massRecruitmentHabitatsSelection[field][subfield] = selectedHabitats;
        break;
      case settingsGameConstant.MASS_FUNCTIONS.BUILDINGS:
        this.gameCache.massBuildingsHabitatsSelection[field] || (this.gameCache.massBuildingsHabitatsSelection[field] = {}), this.gameCache.massBuildingsHabitatsSelection[field] = selectedHabitats
    }
    this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.getMassFunctionsHabitatsSelection = function(options) {
    var massFunctionsType = options.massFunctionsType, field = options.field, subfield = options.subfield;
    switch (massFunctionsType) {
      case settingsGameConstant.MASS_FUNCTIONS.RESTOCK:
        return this.gameCache.massRestockHabitatsSelection || null;
      case settingsGameConstant.MASS_FUNCTIONS.RISE_BUFFS:
        return this.gameCache.massRiseBuffsHabitatsSelection || null;
      case settingsGameConstant.MASS_FUNCTIONS.EXCHANGE:
        return this.gameCache.massExchangeHabitatsSelection[field] ? this.gameCache.massExchangeHabitatsSelection[field][subfield] : null;
      case settingsGameConstant.MASS_FUNCTIONS.KNOWLEDGE:
        return this.gameCache.massResearchHabitatsSelection[field] || null;
      case settingsGameConstant.MASS_FUNCTIONS.MISSIONS:
        return this.gameCache.massMissionsHabitatsSelection || null;
      case settingsGameConstant.MASS_FUNCTIONS.RECRUITMENT:
        return this.gameCache.massRecruitmentHabitatsSelection[field] ? this.gameCache.massRecruitmentHabitatsSelection[field][subfield] : null;
      case settingsGameConstant.MASS_FUNCTIONS.BUILDINGS:
        return this.gameCache.massBuildingsHabitatsSelection[field] || null;
      default:
        return null
    }
  }, CoreServiceClassLocalStorage.prototype.addDeniedWorld = function(deniedWorldId) {
    this.loginCache.deniedWorlds[deniedWorldId] = !0, this.__updateStorage(this.loginKey, this.loginCache)
  }, CoreServiceClassLocalStorage.prototype.isWorldDenied = function(deniedWorldId) {
    return this.loginCache.deniedWorlds.hasOwnProperty(deniedWorldId) && this.loginCache.deniedWorlds[deniedWorldId]
  }, CoreServiceClassLocalStorage.prototype.removeDeniedWorld = function(deniedWorldId) {
    this.loginCache.deniedWorlds[deniedWorldId] = null, delete this.loginCache.deniedWorlds[deniedWorldId], this.__updateStorage(this.loginKey, this.loginCache)
  }, CoreServiceClassLocalStorage.prototype.storeActiveHabitatId = function(habitatId) {
    this.gameCache.activeHabitat = habitatId, this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.getActiveHabitatId = function() {
    return this.gameCache.activeHabitat || null
  }, CoreServiceClassLocalStorage.prototype.getMusicSettingsObject = function() {
    return this.clientCache.musicSettingsObject || settingsGameConstant.DEFAULT_MUSIC_SETTINGS_OBJECT
  }, CoreServiceClassLocalStorage.prototype.storeMusicSettingsObject = function(musicSettingsObject) {
    return this.clientCache.musicSettingsObject = musicSettingsObject, this.__updateStorage(this.clientKey, this.clientCache), !0
  }, CoreServiceClassLocalStorage.prototype.addAlreadyTrackedPlayer = function(playerId) {
    this.gameCache.trackedPlayer[playerId] = !0, this.__updateStorage(this.gameKey, this.gameCache)
  }, CoreServiceClassLocalStorage.prototype.isPlayerAlreadyTracked = function(playerId) {
    return this.gameCache.trackedPlayer.hasOwnProperty(playerId) && this.gameCache.trackedPlayer[playerId]
  }, CoreServiceClassLocalStorage
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassResourcesManager, [xy.dNames.core.modelResource, xy.dNames.services.log, xy.dNames.services.loader, xy.dNames.services.internationalization, function(CoreModelResource, servicesLog, servicesLoader, servicesInternationalization) {
  "use strict";
  function CoreServiceClassResourcesManager() {
    this._resources = {}, this._totalToLoad = 0, this._totalLoaded = 0, this._pendingResourcesQueue = [], this._callbackContext = null, this._successCallback = null, this._progressCallback = null, this._errorCallback = null, this._flagPenidingModeUsage = !1, this._flagError = !1
  }

  return CoreServiceClassResourcesManager.prototype._loadResources = function() {
    this._pendingResourcesQueue.forEach(function(idToLoad) {
      var modelResources = this._resources[idToLoad];
      modelResources.load(servicesLoader, this._progress.bind(this), this._error.bind(this))
    }, this)
  }, CoreServiceClassResourcesManager.prototype._progress = function() {
    this._totalLoaded += 1, this._totalLoaded === this._totalToLoad ? this._loaded() : this._progressCallback instanceof Function && this._progressCallback.call(this._callbackContext, this._flagError, this._totalLoaded, this._totalToLoad)
  }, CoreServiceClassResourcesManager.prototype._loaded = function() {
    this._successCallback.call(this._callbackContext), this._flagPenidingModeUsage && this._callbackContext[xy.eNames.core.pendingModeOff](), this._clearManagerOnLoaded()
  }, CoreServiceClassResourcesManager.prototype._error = function() {
    if (this._callbackContext) {
      var settings = {
        title: servicesInternationalization.localize("No Internet Connection"),
        text: servicesInternationalization.localize("Please check your internet connection and then try again. Feel free to contact our support if the problem persists: https://xyrality.helpshift.com/")
      };
      this._callbackContext.showDialogAlert(settings)
    }
    this._errorCallback && this._errorCallback.call(this._callbackContext), this._flagPenidingModeUsage && this._callbackContext[xy.eNames.core.pendingModeOff]()
  }, CoreServiceClassResourcesManager.prototype._setCallbacks = function(options, totalToLoad) {
    this._totalLoaded = 0, this._totalToLoad = totalToLoad || 0, this._flagPenidingModeUsage = !1, this._callbackContext = options.context || null, this._successCallback = options.onLoaded || null, this._progressCallback = options.onProgress || null, this._errorCallback = options.onError || null
  }, CoreServiceClassResourcesManager.prototype._clearManagerOnLoaded = function() {
    this._totalLoaded = 0, this._totalToLoad = 0, this._flagPenidingModeUsage = !1, this._pendingResourcesQueue = [], this._callbackContext = null, this._successCallback = null, this._progressCallback = null, this._errorCallback = null
  }, CoreServiceClassResourcesManager.prototype._setLoadingFlags = function() {
    this._flagError = !1, this._flagPenidingModeUsage = !1
  }, CoreServiceClassResourcesManager.prototype.getResourcesValue = function(id) {
    var value = null;
    try {
      value = this._resources[id].value
    } catch (eX) {
      servicesLog("warn", "Can not provide resource value"), servicesLog("debug", eX)
    }
    return value
  }, CoreServiceClassResourcesManager.prototype.loadGameInitialResources = function(resources, options) {
    this._setCallbacks(options, resources.length), this._setLoadingFlags(), resources.forEach(function(fullPath) {
      this._resources[fullPath] = new CoreModelResource(fullPath), this._pendingResourcesQueue.push(fullPath)
    }, this), this._loadResources()
  }, CoreServiceClassResourcesManager.prototype.reloadInternationalizationResources = function(newLocaleString, options) {
    var path = xy.res.internationalizationPath, fingerprint = xy.res.internationalizationFingerprinnt, keysToLoad = Object.keys(path);
    this._setCallbacks(options, keysToLoad.length), this._setLoadingFlags(), this._callbackContext[xy.eNames.core.pendingModeOn](), this._flagPenidingModeUsage = !0, keysToLoad.forEach(function(key) {
      var fullPath = path[key] + newLocaleString + ".json" + fingerprint, modelResources = new CoreModelResource(fullPath);
      xy.res[key] = fullPath, this._resources[fullPath] = modelResources, this._pendingResourcesQueue.push(fullPath)
    }, this), this._loadResources()
  }, CoreServiceClassResourcesManager
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassMusicManager, [xy.dNames.utils.object, xy.dNames.utils.number, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.storage, xy.dNames.services.eventManager, xy.dNames.services.resourcesManager, xy.dNames.services.theme, function(utilsObject, utilsNumber, settingsGameConstant, servicesLog, servicesStorage, servicesEvenManager, servicesResourcesManager, servicesTheme) {
  "use strict";
  function CoreServiceClassMusicManager() {
    this.flagIsMusicAvailable = !0, this.flagPlayerMusicPlaying = !1, this.flagPlayerSFXPlaying = !1, this.flagPlayerAtmospherePlaying = !1, this.playerMusic = document.createElement("audio"), this.playerSFX = document.createElement("audio"), this.playerAtmosphere = document.createElement("audio"), this.urlPrefix = window.location.protocol + "//" + window.location.host + "/", this.musicManagerInitialization()
  }

  return CoreServiceClassMusicManager.prototype.musicManagerInitialization = function() {
    this.doesSupportMPEG() && (this.setUpMusicPlayer(), this.setUpSFXPlayer(), this.setUpAtmospherePlayer()), this.playMusic();
    var atmosphereSFXEvents = servicesTheme.themeSettings.music.atmosphereSFXEvents;
    Object.keys(atmosphereSFXEvents).forEach(function(eventKey) {
      servicesEvenManager.registerEventListener({
        identifier: eventKey,
        listenerUniqueId: this.instanceId,
        listenerContext: this,
        listenerCalBackFunction: this.playAtmosphereSFX.bind(this, atmosphereSFXEvents[eventKey])
      })
    }, this);
    var gameSFXEvents = servicesTheme.themeSettings.music.gameSFXEvents;
    Object.keys(gameSFXEvents).forEach(function(eventKey) {
      servicesEvenManager.registerEventListener({
        identifier: eventKey,
        listenerUniqueId: this.instanceId,
        listenerContext: this,
        listenerCalBackFunction: this.playGameSFX.bind(this, gameSFXEvents[eventKey])
      })
    }, this), servicesEvenManager.registerEventListener({
      identifier: xy.eNames.eventListeners.identifier.changesInMusicSettingsObject,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.changeMusicSettingsObject
    })
  }, CoreServiceClassMusicManager.prototype.doesSupportMPEG = function() {
    return !!this.playerMusic.canPlayType("audio/mpeg;") || (servicesLog("warn", "Browser can not play MPEG"), this.flagIsMusicAvailable = !1, !1)
  }, CoreServiceClassMusicManager.prototype.setUpAtmospherePlayer = function() {
    this.flagIsMusicAvailable && (this.adjustVolumeLevel(settingsGameConstant.MEDIA_TYPE.MUSIC), this.playerAtmosphere.addEventListener("ended", function() {
      this.flagPlayerAtmospherePlaying = !1
    }.bind(this)))
  }, CoreServiceClassMusicManager.prototype.setUpMusicPlayer = function() {
    this.flagIsMusicAvailable && (this.adjustVolumeLevel(settingsGameConstant.MEDIA_TYPE.ATMOSPHERE), this.playerMusic.addEventListener("ended", function() {
      this.flagPlayerMusicPlaying = !1, this.playMusic()
    }.bind(this)))
  }, CoreServiceClassMusicManager.prototype.setUpSFXPlayer = function() {
    this.flagIsMusicAvailable && (this.adjustVolumeLevel(settingsGameConstant.MEDIA_TYPE.SFX), this.playerSFX.addEventListener("ended", function() {
      this.flagPlayerSFXPlaying = !1
    }.bind(this)))
  }, CoreServiceClassMusicManager.prototype.adjustVolumeLevel = function(mediaType) {
    var player, volume, musicSettingsObject = servicesStorage.getMusicSettingsObject();
    switch (mediaType) {
      case settingsGameConstant.MEDIA_TYPE.SFX:
        player = this.playerSFX, volume = musicSettingsObject.sfxStateIsOn ? musicSettingsObject.sfxVolume / 100 : 0;
        break;
      case settingsGameConstant.MEDIA_TYPE.MUSIC:
        player = this.playerMusic, volume = musicSettingsObject.musicStateIsOn ? musicSettingsObject.musicVolume / 100 : 0;
        break;
      case settingsGameConstant.MEDIA_TYPE.ATMOSPHERE:
        player = this.playerAtmosphere, volume = musicSettingsObject.sfxStateIsOn ? musicSettingsObject.sfxVolume / 100 : 0
    }
    player.volume = volume
  }, CoreServiceClassMusicManager.prototype.playMusic = function() {
    if (this.flagIsMusicAvailable) {
      var musicTrackId, musicSettingsObject = servicesStorage.getMusicSettingsObject(), musicTracksList = servicesTheme.themeSettings.music.musicList;
      musicSettingsObject.musicStateIsOn ? this.flagPlayerMusicPlaying || (this.flagPlayerMusicPlaying = !0, musicTrackId = utilsNumber.getRandomIntFromRange(0, musicTracksList.length), this.playerMusic.src = xy.res[musicTracksList[musicTrackId]], this.playerMusic.play()) : (this.playerMusic.pause(), this.flagPlayerMusicPlaying = !1)
    }
  }, CoreServiceClassMusicManager.prototype.playAtmosphereSFX = function(musicTracksList) {
    if (this.flagIsMusicAvailable) {
      musicTracksList = musicTracksList || servicesTheme.themeSettings.music.atmosphereSFXEvents["scene--switch-to-habitat-scene"];
      var musicTrackId, musicSettingsObject = servicesStorage.getMusicSettingsObject();
      musicSettingsObject.sfxStateIsOn && musicTracksList && musicTracksList.length ? (this.flagPlayerAtmospherePlaying = !0, musicTrackId = utilsNumber.getRandomIntFromRange(0, musicTracksList.length), this.playerAtmosphere.src = xy.res[musicTracksList[musicTrackId]], this.playerAtmosphere.play()) : (this.playerAtmosphere.pause(), this.flagPlayerAtmospherePlaying = !1)
    }
  }, CoreServiceClassMusicManager.prototype.playGameSFX = function(resourceKey) {
    this.flagIsMusicAvailable && (this.flagPlayerSFXPlaying && this.playerSFX.src === this.urlPrefix + xy.res[resourceKey] || (this.flagPlayerSFXPlaying = !0, this.playerSFX.src = xy.res[resourceKey], this.playerSFX.play()))
  }, CoreServiceClassMusicManager.prototype.changeMusicSettingsObject = function() {
    Object.keys(settingsGameConstant.MEDIA_TYPE).forEach(function(mediaKey) {
      this.adjustVolumeLevel(settingsGameConstant.MEDIA_TYPE[mediaKey])
    }, this), this.playMusic()
  }, CoreServiceClassMusicManager
}]),xy.dStaticInjector.set(xy.dNames.core.serviceClassAnalytics, [xy.dNames.services.eventManager, xy.dNames.services.log, xy.dNames.settings.gameConstant, function(servicesEventManager, servicesLog, settingsGameConstant) {
  "use strict";
  function CoreServiceClassAnalytics() {
    this.initGoogleAnalytics(), this.registerGoogleAnalyticsClientEvents(), this.registerMATClientEvents()
  }

  return CoreServiceClassAnalytics.prototype.initGoogleAnalytics = function() {
    window.GoogleAnalyticsObject = "ga", window.ga = window.ga || function() {
              (window.ga.q = window.ga.q || []).push(arguments)
            }, window.ga.l = new Date, window.ga("create", settingsGameConstant.GOOGLE_ANALYTICS.CLIENT_ID, "auto")
  }, CoreServiceClassAnalytics.prototype.registerGoogleAnalyticsClientEvents = function() {
    var identifier, googleAnalyticsEvents = xy.eNames.eventListeners.googleAnalyticsIdentifiers;
    for (identifier in googleAnalyticsEvents)googleAnalyticsEvents.hasOwnProperty(identifier) && servicesEventManager.registerEventListener({
      identifier: googleAnalyticsEvents[identifier],
      listenerUniqueId: identifier,
      listenerContext: this,
      listenerCalBackFunction: this.successGoogleAnalyticsEventHandler.bind(this, identifier)
    })
  }, CoreServiceClassAnalytics.prototype.successGoogleAnalyticsEventHandler = function(identifier) {
    ga("send", "event", settingsGameConstant.GOOGLE_ANALYTICS.EVENT_GROUP, identifier)
  }, CoreServiceClassAnalytics.prototype.registerMATClientEvents = function() {
    var identifier, matEvents = xy.eNames.eventListeners.matAnalyticsIdentifiers;
    for (identifier in matEvents)matEvents.hasOwnProperty(identifier) && servicesEventManager.registerEventListener({
      identifier: matEvents[identifier],
      listenerUniqueId: identifier,
      listenerContext: this,
      listenerCalBackFunction: this.successMATEventHandler.bind(this, identifier)
    })
  }, CoreServiceClassAnalytics.prototype.successMATEventHandler = function(identifier) {
    var url, xhr = new XMLHttpRequest, MAT_SETTINGS = settingsGameConstant.MAT_ANALYTICS;
    url = MAT_SETTINGS.URL + "&site_id=" + MAT_SETTINGS.SITE_ID + "&site_event_id=" + MAT_SETTINGS.EVENT_GROUP_ID[identifier] + "&advertiser_id=" + MAT_SETTINGS.ADVERTISER_ID, xhr.open("GET", url, !0), xhr.send(), xhr.onreadystatechange = function() {
      4 === xhr.readyState && xhr.status >= 200 && xhr.status <= 207 && servicesLog("warn", "MAT tracking has been successfully sent")
    }
  }, CoreServiceClassAnalytics
}]),xy.dStaticInjector.set(xy.dNames.components.rendererLoadingGame, [xy.dNames.componentsEngine, function(componentsEngine) {
  "use strict";
  var Cover = componentsEngine.createClass({
    render: function() {
      return React.createElement("div", {
        id: "over-layer--game-loading",
        className: this.props.statusClassName,
        style: { backgroundImage: 'url("' + this.props.loadingImage + '")' }
      }, React.createElement("div", { className: "game-loading--progress-bar" }, React.createElement("div", {
        className: "game-loading--progress-line",
        style: { width: this.props.progress + "%", background: this.props.loadingBarColor }
      })))
    }
  });
  return {
    progress: function(progress) {
      componentsEngine.render(React.createElement(Cover, {
        progress: progress,
        statusClassName: "in",
        loadingImage: xy.res.loadingImage,
        loadingBarColor: "rgb(43,194,83)"
      }), document.getElementById(xy.DomElements.gameOverLayer))
    }, done: function() {
      componentsEngine.render(React.createElement(Cover, {
        progress: 100,
        statusClassName: "",
        loadingImage: xy.res.loadingImage,
        loadingBarColor: "rgb(43,194,83)"
      }), document.getElementById(xy.DomElements.gameOverLayer))
    }, clear: function() {
      var el = document.getElementById(xy.DomElements.gameOverLayer);
      el && componentsEngine.unmountComponentAtNode(el)
    }, error: function() {
      componentsEngine.render(React.createElement(Cover, {
        progress: 100,
        statusClassName: "in",
        loadingImage: xy.res.loadingImage,
        loadingBarColor: "rgb(255,0,0)"
      }), document.getElementById(xy.DomElements.gameOverLayer))
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.components.rendererRequestPending, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.services.log, function(componentEngine, settingsGameConstant, servicesLog) {
  "use strict";
  var amountOfRequests = 0, isShadowCover = !1, coverHTML = document.createElement("div");
  return coverHTML.setAttribute("id", "over-layer--game-pending"), coverHTML.setAttribute("class", ""), coverHTML.innerHTML = '<img className="loading-animation" src="' + xy.res.loadingAnimationForCover + '" alt="" />', {
    add: function() {
      var parentEl = document.getElementById(xy.DomElements.gameOverLayer);
      parentEl.appendChild(coverHTML)
    }, progress: function(options) {
      options = options || {};
      var isForced = options.isForced || !1, show = !1;
      (!isForced && !isShadowCover && 0 === amountOfRequests || isForced && 0 === amountOfRequests) && (show = !0), show && coverHTML.setAttribute("class", "in"), options.callback && setTimeout(function() {
        options.callback()
      }, 200), amountOfRequests += 1, servicesLog("log", "Cover amounts, add to : " + amountOfRequests)
    }, done: function() {
      setTimeout(function() {
        amountOfRequests -= 1, servicesLog("log", "Cover amounts, eliminate to : " + amountOfRequests), 0 === amountOfRequests && coverHTML.setAttribute("class", "")
      }, settingsGameConstant.COVER_DELAY)
    }, addShadowCover: function() {
      isShadowCover = !0, coverHTML.setAttribute("class", ""), servicesLog("log", "Shadow cover on")
    }, removeShadowCover: function() {
      isShadowCover = !1, amountOfRequests > 0 && coverHTML.setAttribute("class", "in"), servicesLog("log", "Shadow cover off")
    }, isPendingMode: function() {
      return 0 !== amountOfRequests
    }, error: function() {
      servicesLog("warn", "Error in progress cover")
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.components.containerWindowBox, [xy.dNames.componentsEngine, xy.dNames.components.borderOuter, xy.dNames.components.borderInner, function(componentEngine, ComponentsBorderOuter, ComponentsBorderInner) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      return React.createElement("div", {
        className: "window",
        style: { backgroundImage: 'url("' + xy.res.textureBackBG + '")' }
      }, React.createElement(ComponentsBorderOuter, null, React.createElement(ComponentsBorderInner, null, this.props.children)))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.containerBorderedBox, [xy.dNames.componentsEngine, xy.dNames.components.borderInner, function(componentEngine, ComponentsBorderInner) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      return React.createElement("div", { className: "bordered-box" }, React.createElement(ComponentsBorderInner, null, this.props.children))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.borderOuter, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      return React.createElement("div", { className: "border--outer" }, React.createElement("div", {
        className: "border--outer-top",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderTop + '")' }
      }), React.createElement("div", {
        className: "border--outer-bottom",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderBottom + '")' }
      }), React.createElement("div", {
        className: "border--outer-left",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderLeft + '")' }
      }), React.createElement("div", {
        className: "border--outer-right",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderRight + '")' }
      }), React.createElement("div", {
        className: "border--outer-corner-top_left",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderCornerTL + '")' }
      }), React.createElement("div", {
        className: "border--outer-corner-top_right",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderCornerTR + '")' }
      }), React.createElement("div", {
        className: "border--outer-corner-bottom_left",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderCornerBL + '")' }
      }), React.createElement("div", {
        className: "border--outer-corner-bottom_right",
        style: { backgroundImage: 'url("' + xy.res.textureOuterBorderCornerBR + '")' }
      }), this.props.children)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.borderInner, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      return React.createElement("div", { className: "border--inner" }, React.createElement("div", {
        className: "border--inner-top", style: { backgroundImage: 'url("' + xy.res.textureInnerBorderTop + '")' }
      }), React.createElement("div", {
        className: "border--inner-bottom",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderBottom + '")' }
      }), React.createElement("div", {
        className: "border--inner-left",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderLeft + '")' }
      }), React.createElement("div", {
        className: "border--inner-right",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderRight + '")' }
      }), React.createElement("div", {
        className: "border--inner-corner-top_left",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderCornerTL + '")' }
      }), React.createElement("div", {
        className: "border--inner-corner-top_right",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderCornerTR + '")' }
      }), React.createElement("div", {
        className: "border--inner-corner-bottom_left",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderCornerBL + '")' }
      }), React.createElement("div", {
        className: "border--inner-corner-bottom_right",
        style: { backgroundImage: 'url("' + xy.res.textureInnerBorderCornerBR + '")' }
      }), this.props.children)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.dialogAlert, [xy.dNames.componentsEngine, xy.dNames.gameInstance, xy.dNames.utils.string, xy.dNames.services.internationalization, xy.dNames.mixins.dialogHandlers, xy.dNames.components.buttonMain, function(componentEngine, gameInstance, utilsString, servicesInternationalization, mixinDialogHandlers, ComponentsControlButtonMain) {
  "use strict";
  var Alert = componentEngine.createClass({
    mixins: [mixinDialogHandlers], render: function() {
      var settings = { title: "", text: "" };
      Object.assign(settings, this.props.settings);
      var contentText = utilsString.getHTMLOfString(settings.text, settings.context), buttonSettings = {
        title: servicesInternationalization.localize("ok"),
        onClick: this.onSubmitAlert,
        type: "submit"
      }, classes = "dialog";
      return React.createElement("div", { className: classes + this.state.alertStatus }, React.createElement("div", { className: "dialog--title-container" }, settings.title), React.createElement("div", { className: "dialog--container" }, React.createElement("div", { className: "dialog--text-section" }, React.createElement("div", { className: "text" }, contentText)), React.createElement("div", { className: "dialog--button-section" }, React.createElement(ComponentsControlButtonMain, { settings: buttonSettings }))))
    }
  });
  return {
    show: function(settings) {
      componentEngine.render(React.createElement(Alert, {
        status: "in",
        settings: settings
      }), document.getElementById(xy.DomElements.gameDialogLayer))
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.components.dialogDialog, [xy.dNames.componentsEngine, xy.dNames.gameInstance, xy.dNames.utils.string, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, xy.dNames.mixins.dialogHandlers, xy.dNames.components.buttonMain, function(componentEngine, gameInstance, utilsString, servicesInternationalization, settingsGameConstant, mixinDialogHandlers, ComponentsControlButtonMain) {
  "use strict";
  var Alert = componentEngine.createClass({
    mixins: [mixinDialogHandlers], render: function() {
      var settings = {
        classes: "",
        title: "",
        text: ""
      }, buttonSettingsCancel = {
        onClick: this.onSubmitDialog.bind(this, "cancel"),
        title: servicesInternationalization.localize("cancel")
      }, buttonSettingsOk = {
        onClick: this.onSubmitDialog.bind(this, "ok"),
        title: servicesInternationalization.localize("ok"),
        type: "submit"
      };
      Object.assign(settings, this.props.settings);
      var contentText = utilsString.getHTMLOfString(settings.text, settings.context);
      return React.createElement("div", { className: "dialog " + settings.classes + " " + this.state.alertStatus }, React.createElement("div", { className: "dialog--title-container" }, settings.title), React.createElement("div", { className: "dialog--container" }, React.createElement("div", { className: "dialog--text-section" }, React.createElement("div", { className: "text" }, contentText)), React.createElement("div", { className: "dialog--button-section" }, React.createElement(ComponentsControlButtonMain, { settings: buttonSettingsCancel }), React.createElement(ComponentsControlButtonMain, { settings: buttonSettingsOk }))))
    }
  });
  return {
    show: function(settings) {
      componentEngine.render(React.createElement(Alert, {
        status: "in",
        settings: settings
      }), document.getElementById(xy.DomElements.gameDialogLayer))
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.components.dialogNotEnoughSource, [xy.dNames.componentsEngine, xy.dNames.gameInstance, xy.dNames.utils.string, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.mixins.dialogHandlers, xy.dNames.components.buttonMain, xy.dNames.components.icon, function(componentEngine, gameInstance, utilsString, servicesInternationalization, servicesTheme, mixinDialogHandlers, ComponentsControlButtonMain, ComponentsIcon) {
  "use strict";
  var Alert = componentEngine.createClass({
    mixins: [mixinDialogHandlers], render: function() {
      var settings = { title: "", text: "" };
      Object.assign(settings, this.props.settings);
      var premiumResource = servicesTheme.themeSettings.resources.premium, premiumResourceIcon = servicesTheme.themeSettings.imagesClassNames.premiumResources[premiumResource], contentText = utilsString.getHTMLOfString(settings.text, settings.context), buttonSettings = {
        title: servicesInternationalization.localize("ShopButton"),
        icon: premiumResourceIcon,
        onClick: this.onSubmitAlert,
        type: "submit"
      }, closeIconSettings = { icon: servicesTheme.themeSettings.imagesClassNames.icon.closeDialog };
      return React.createElement("div", { className: "dialog not-enough-source " + this.state.alertStatus }, React.createElement("div", {
        className: "dialog--close-button",
        onClick: this.onCloseAlert
      }, React.createElement(ComponentsIcon, { settings: closeIconSettings })), React.createElement("div", { className: "dialog--title-container" }, settings.title), React.createElement("div", { className: "dialog--container" }, React.createElement("div", { className: "dialog--text-section" }, React.createElement("div", { className: "text" }, contentText)), React.createElement("div", { className: "dialog--button-section" }, React.createElement(ComponentsControlButtonMain, { settings: buttonSettings }))))
    }
  });
  return {
    show: function(settings) {
      componentEngine.render(React.createElement(Alert, {
        status: "in",
        settings: settings
      }), document.getElementById(xy.DomElements.gameDialogLayer))
    }
  }
}]),xy.dStaticInjector.set(xy.dNames.components.inputSubject, [xy.dNames.componentsEngine, xy.dNames.components.inputTextField, function(componentEngine, ComponentsInputTextField) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", counter: !1, value: "", maxLength: "", onChange: null };
      Object.assign(settings, this.props.settings);
      var counter = null, textFieldSettings = {
        classes: settings.classes,
        value: settings.value,
        maxLength: settings.maxLength,
        handlerOnChange: settings.onChange
      };
      return settings.counter && (counter = React.createElement("div", { className: "input-value-counter color-white" }, settings.counter)), React.createElement("div", { className: "form-component input--create-edit-content" + settings.classes }, counter, React.createElement(ComponentsInputTextField, { settings: textFieldSettings }))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.inputContent, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    onChange: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.settings.onChange(event)
    }, render: function() {
      var settings = { classes: "", value: "" };
      Object.assign(settings, this.props.settings);
      var counter = null;
      return settings.counter && (counter = React.createElement("div", { className: "input-value-counter color-white" }, settings.counter)), React.createElement("div", { className: "form-component input--create-edit-content" + settings.classes }, counter, React.createElement("textarea", {
        className: "component--input input-content--text-area",
        onChange: this.onChange,
        value: settings.value
      }))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.inputTextField, [xy.dNames.componentsEngine, xy.dNames.utils.string, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        type: "text",
        name: "name",
        placeHolder: "",
        value: "",
        maxLength: "",
        handlerOnFocus: null,
        handlerOnBlur: null,
        handlerOnChange: null
      };
      return Object.assign(settings, this.props.settings), React.createElement("input", {
        className: "component--input " + settings.classes,
        type: settings.type,
        defaultValue: settings.value,
        name: settings.name,
        placeholder: settings.placeHolder,
        maxLength: settings.maxLength,
        onFocus: settings.handlerOnFocus,
        onBlur: settings.handlerOnBlur,
        onChange: settings.handlerOnChange
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.inputTextFieldWithValidation, [xy.dNames.componentsEngine, xy.dNames.components.alertTooltip, xy.dNames.components.inputTextField, xy.dNames.components.buttonMain, xy.dNames.utils.string, function(componentEngine, ComponentsAlertTooltip, ComponentsInputTextField, ComponentsButtonMain, utilString) {
  "use strict";
  return componentEngine.createClass({
    getInitialState: function() {
      return { tooltipStatus: "", clearedInitialError: !1, isButtonActive: !1, value: "" }
    }, handleChange: function(event) {
      event.preventDefault();
      var value = event.target.value, isValidationPassed = this.validate(value);
      this.setState({ isButtonActive: isValidationPassed, value: value }, null)
    }, handleFocus: function(event) {
      event.preventDefault();
      var value = event.target.value, isValidationPassed = this.validate(value);
      this.setState({
        tooltipStatus: "",
        clearedInitialError: !0,
        isButtonActive: isValidationPassed,
        value: value
      }, null)
    }, handleBlur: function(event) {
      var tooltipStatus, value = event.target.value, isValidationPassed = this.validate(value);
      isValidationPassed || (this.props.settings.validationErrorText && (tooltipStatus = "in"), this.setState({
        tooltipStatus: tooltipStatus,
        isButtonActive: isValidationPassed,
        value: value
      }, null))
    }, handleSubmit: function(event) {
      this.props.settings.submitButton.onClick.apply(this.props.settings.submitButton.context, [this.state.value, event])
    }, validate: function(value) {
      var isVerified = !0, validationRegExp = this.props.settings.validationRegExp instanceof RegExp ? this.props.settings.validationRegExp : utilString.getRegExp(this.props.settings.validationRegExp);
      validationRegExp.lastIndex = 0;
      var validatingString = this.props.settings.removeSpaces ? value.replace(/\s/g, "") : value;
      return validationRegExp.test(validatingString) || (isVerified = !1), isVerified
    }, render: function() {
      var buttonSettings, inputSettings = {
        validationErrorText: null,
        validationRegExp: null,
        forcedErrorText: null,
        classes: "input-text-field",
        type: "text",
        name: "name",
        placeHolder: this.props.settings.placeHolder || "",
        value: this.props.settings.value || "",
        tooltipSettings: {},
        handlerOnFocus: this.handleFocus,
        handlerOnBlur: this.handleBlur,
        handlerOnChange: this.handleChange
      }, tooltipSettings = {
        position: this.props.settings.position || "top",
        status: this.state.tooltipStatus,
        text: this.props.settings.validationErrorText,
        classes: this.props.settings.tooltipClasses || ""
      }, extraClasses = this.props.settings.classes, button = null;
      return this.state.clearedInitialError === !1 && this.props.settings.forcedErrorText && (tooltipSettings.status = "in", tooltipSettings.text = this.props.forcedErrorText), this.props.settings.submitButton && (extraClasses += " form-component-input-with-button", buttonSettings = {}, buttonSettings.onClick = this.handleSubmit, buttonSettings.icon = this.props.settings.submitButton.icon || "controls menu-accept", buttonSettings.isDisabled = !this.state.isButtonActive, button = React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button"
      })), React.createElement("div", { className: "form-component " + extraClasses }, React.createElement(ComponentsAlertTooltip, {
        settings: tooltipSettings,
        key: "tooltip"
      }), React.createElement(ComponentsInputTextField, { settings: inputSettings, key: "input" }), button)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.inputTextTabularCell, [xy.dNames.componentsEngine, xy.dNames.components.menuListElementButtonAction, function(componentEngine, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    getInitialState: function() {
      return this.constructState(this.props)
    }, componentWillReceiveProps: function(newProps) {
      this.setState(this.constructState(newProps), null)
    }, constructState: function(props) {
      return { value: props.settings.value }
    }, onInputChanges: function(event) {
      var value = parseInt(event.target.value || 0) || 0, maxValue = +this.props.settings.maxValue;
      value > maxValue && (value = maxValue), this.setState({ value: value }, null), this.props.settings.handlerOnChange(value)
    }, handlerOnSetMaxValue: function() {
      var maxValue = +this.props.settings.maxValue;
      this.setState({ value: maxValue }, null), this.props.settings.handlerOnChange(maxValue)
    }, render: function() {
      var settings = { classes: "", title: "", maxValue: "", value: "", withMaxOutButton: !1, handlerOnChange: null };
      Object.assign(settings, this.props.settings);
      var actionButtonSettings, actionButton = null;
      return settings.withMaxOutButton && (actionButtonSettings = {
        icon: "controls jump-to-top-button",
        classes: "tabular-cell--maxout-button",
        onClick: this.handlerOnSetMaxValue
      }, actionButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: actionButtonSettings })), React.createElement("div", { className: "tabular-cell--input-container" }, React.createElement("div", { className: "centered last" }, settings.title), React.createElement("input", {
        className: "component--input small centered" + settings.classes,
        type: "text",
        value: this.state.value,
        onChange: this.onInputChanges
      }), actionButton)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.dropdownLanguage, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.components.dropdownLanguageItem, function(gameInstance, componentEngine, settingsGameConstant, ComponentsDropDownLanguageItem) {
  "use strict";
  return componentEngine.createClass({
    getInitialState: function() {
      return { isOpened: !1, selected: null }
    }, handleOpen: function() {
      this.setState({ isOpened: !0 }, null), document.addEventListener("click", this.handleHide)
    }, handleHide: function() {
      this.setState({ isOpened: !1 }, null), document.removeEventListener("click", this.handleHide)
    }, handleSelect: function(item) {
      this.setState({ selected: item }, function() {
        this.props.settings.onSelect instanceof Function && this.props.settings.onSelect.call(this.props.settings.initialComponent, item)
      }.bind(this))
    }, render: function() {
      var availableLanguage = settingsGameConstant.AVAILABLE_LANGUAGES, currentGameLocaleString = gameInstance.getGameLanguage(), currentGameLocaleObject = {
        locale: currentGameLocaleString,
        name: availableLanguage[currentGameLocaleString].name,
        flagCode: availableLanguage[currentGameLocaleString].flag
      }, currentDropdownLocale = this.state.selected || currentGameLocaleObject, languageList = [];
      Object.keys(availableLanguage).forEach(function(localeKey) {
        languageList.push({
          locale: localeKey,
          name: availableLanguage[localeKey].name,
          flagCode: availableLanguage[localeKey].flag
        })
      });
      var settings = { initialComponent: null, onSelect: null };
      Object.assign(settings, this.props.settings);
      var activeSelection, activeSelectionSettings, dropdownVisibilityClass = this.state.isOpened ? "opened" : "hidden", list = [];
      return activeSelectionSettings = currentGameLocaleObject, activeSelectionSettings.onClick = this.handleOpen, activeSelection = React.createElement(ComponentsDropDownLanguageItem, { settings: activeSelectionSettings }), languageList.forEach(function(localeItem) {
        var localSettings = localeItem;
        localSettings.onClick = this.handleSelect.bind(this, localeItem), localeItem.locale === currentDropdownLocale.locale && (localSettings.isActive = !0), list.push(React.createElement(ComponentsDropDownLanguageItem, {
          settings: localSettings,
          key: localeItem.locale
        }))
      }, this), React.createElement("div", { className: "dropdown dropdown--language-selector " + dropdownVisibilityClass }, React.createElement("div", { className: "dropdown--selected" }, activeSelection), React.createElement("div", { className: "dropdown--list" }, list))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.dropdownLanguageItem, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentEngine, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { isActive: !1, locale: "en", name: "English", flagCode: "UK", onClick: null };
      Object.assign(settings, this.props.settings);
      var iconSettings, className = "dropdown--item";
      return settings.isActive && (className += " dropdown--item-selected"), iconSettings = { icon: "icon-flag flag-" + settings.flagCode }, React.createElement("div", {
        className: className,
        onClick: settings.onClick
      }, React.createElement(ComponentsIcon, { settings: iconSettings }), React.createElement("div", null, settings.name))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.button, [xy.dNames.componentsEngine, function(componentsEngine) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { title: "", icon: "", classes: "", type: "button", onClick: null };
      Object.assign(settings, this.props.settings);
      var classes = "button ", icon = null;
      return settings.icon && (classes += "button-with-icon ", icon = React.createElement("span", { className: "icon-in-button" }, React.createElement("img", {
        className: "icon",
        src: this.props.settings.icon
      }))), React.createElement("button", {
        className: classes + settings.classes,
        type: settings.type,
        onClick: settings.onClick
      }, icon, React.createElement("span", { className: "button-title-text" }, settings.title))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.buttonMain, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentsEngine, ComponentsIcon) {
  "use strict";
  return componentsEngine.createClass({
    onDisabledClick: function(event) {
      event.preventDefault(), event.stopPropagation()
    }, componentDidMount: function() {
      var button;
      "submit" === this.props.settings.type && (button = componentsEngine.findDOMNode(this.refs.button), button.focus())
    }, render: function() {
      var settings = {
        title: "",
        icon: "",
        classes: "",
        type: "button",
        onClick: null,
        isActive: !1,
        isDisabled: !1,
        alertNumber: 0,
        alertNumberPosition: "right"
      };
      Object.assign(settings, this.props.settings);
      var iconSetting, classes = "button button--default ", onClick = settings.onClick, onSubmit = null, icon = null, alert = null;
      return settings.icon && (classes += "button-with-icon ", iconSetting = {
        classes: "icon-in-button",
        icon: settings.icon
      }, icon = React.createElement(ComponentsIcon, { settings: iconSetting })), (null === settings.onClick || settings.isDisabled) && (onClick = this.onDisabledClick, classes += "disabled "), settings.isActive && (onClick = this.onDisabledClick, classes += "active "), "submit" === settings.type && (onSubmit = onClick), settings.alertNumber && (classes += "button-with-alert ", alert = React.createElement("div", { className: "buttons--alert " + settings.alertNumberPosition }, settings.alertNumber)), React.createElement("button", {
        ref: "button",
        className: classes + settings.classes,
        type: settings.type,
        onClick: onClick,
        onSubmit: onSubmit
      }, alert, icon, React.createElement("span", { className: "button-title-text" }, settings.title))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.buttonBordered, [xy.dNames.componentsEngine, xy.dNames.components.borderInner, xy.dNames.components.icon, function(componentEngine, ComponentsBorderInner, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        title: "",
        description: "",
        classes: "",
        onClick: null,
        disabled: !1,
        id: null,
        iconLeft: null,
        iconRight: null
      }, description = null, leftIcon = null, rightIcon = null, iconSettings = null;
      Object.assign(settings, this.props.settings);
      var classes = "button-bordered-box ";
      return settings.disabled && (classes += "disabled ", settings.onClick = null), settings.description && (description = React.createElement("div", { className: "button-bordered-box--description" }, settings.description)), settings.iconLeft && (classes += "with-icon-left ", iconSettings = {
        classes: "icon-left",
        icon: settings.iconLeft
      }, leftIcon = React.createElement(ComponentsIcon, { settings: iconSettings })), settings.iconRight && (classes += "with-icon-right ", iconSettings = {
        classes: "icon-right",
        icon: settings.iconRight
      }, rightIcon = React.createElement(ComponentsIcon, { settings: iconSettings })), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick,
        dataId: settings.id
      }, React.createElement(ComponentsBorderInner, null, leftIcon, React.createElement("div", { className: "button-bordered-box--text" }, React.createElement("div", { className: "button-bordered-box--title" }, settings.title), description), rightIcon))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.buttonForBars, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentEngine, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settingsIcon, alert, settings = {
        title: "",
        classes: "",
        onClick: null,
        disabled: !1,
        icon: null,
        alertNumber: 0,
        alertNumberPosition: "right"
      }, classes = "button-for-bars ";
      return Object.assign(settings, this.props.settings), settingsIcon = { icon: settings.icon }, settings.disabled && (classes += " disabled ", settings.onClick = null), settings.alertNumber && (classes += "button-with-alert ", alert = React.createElement("div", { className: "buttons--alert " + settings.alertNumberPosition }, settings.alertNumber)), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, alert, React.createElement(ComponentsIcon, { settings: settingsIcon }), React.createElement("div", { className: "button-for-bars--title" }, settings.title))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.buttonPageListing, [xy.dNames.services.theme, xy.dNames.componentsEngine, xy.dNames.components.icon, function(servicesTheme, componentsEngine, ComponentsIcon) {
  "use strict";
  return componentsEngine.createClass({
    onDisabledClick: function(event) {
      event.preventDefault(), event.stopPropagation()
    }, render: function() {
      var settings = { isDown: !1, isUp: !1, classes: "", onClick: null, isDisabled: !1 };
      Object.assign(settings, this.props.settings);
      var icon, iconSetting, classes = "button button--default button-with-icon button-page-listing ", onClick = settings.onClick, iconPageListingSettingsTheme = servicesTheme.themeSettings.imagesClassNames.buttonPageListing;
      return iconSetting = {
        classes: "icon-in-button",
        icon: settings.isDown ? iconPageListingSettingsTheme.down : iconPageListingSettingsTheme.up
      }, icon = React.createElement(ComponentsIcon, { settings: iconSetting }), (null === settings.onClick || settings.isDisabled) && (onClick = this.onDisabledClick, classes += "disabled "), settings.isActive && (onClick = this.onDisabledClick, classes += "active "), React.createElement("button", {
        className: classes + settings.classes,
        type: "button",
        onClick: onClick
      }, icon)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.icon, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", icon: null, onClick: null };
      Object.assign(settings, this.props.settings);
      var classes = "icon ";
      return React.createElement("div", {
        className: classes + settings.classes + " " + settings.icon,
        onClick: settings.onClick
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.alertTooltip, [xy.dNames.componentsEngine, function(componentsEngine) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { classes: "", position: "top", status: "", text: "" };
      return Object.assign(settings, this.props.settings), React.createElement("div", { className: "tooltip " + settings.position + " " + settings.classes + " " + settings.status }, React.createElement("div", { className: "tooltip-arrow" }), React.createElement("div", { className: "tooltip-inner" }, settings.text))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.listTitleMain, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", title: "" };
      return Object.assign(settings, this.props.settings), React.createElement("div", { className: "list--title-main " + settings.classes }, settings.title)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.listTitleDefault, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", title: "" };
      return Object.assign(settings, this.props.settings), React.createElement("div", { className: "list--title-default " + settings.classes }, settings.title)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.allianceInvitationMenuElement, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.widgetAllianceInvitation, function(componentEngine, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsWidgetAllianceInvitation) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { initialComponent: null, invitations: [], onAcceptClick: null, onRejectClick: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      return settings.invitations.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Invitations") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-title-innovations-to-alliance"
      })), settings.invitations.forEach(function(alliance) {
        var componentSetting = {
          allianceName: alliance.name,
          onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
            next: xy.dNames.game.menuAllianceProfile.name,
            options: { allianceId: alliance.id }
          }),
          handlerAccept: settings.onAcceptClick.bind(settings.initialComponent, alliance.id),
          handlerReject: settings.onRejectClick.bind(settings.initialComponent, alliance.id)
        };
        componentsSections.push(React.createElement(ComponentsWidgetAllianceInvitation, {
          settings: componentSetting,
          key: "component-innovations-to-alliance" + alliance.id
        }))
      }, this)), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.allianceMenuElement, [xy.dNames.componentsEngine, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { initialComponent: null, alliance: {} };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeIcons = servicesTheme.themeSettings.imagesClassNames;
      return sectionComponentSettings = {
        title: settings.alliance.name,
        description: settings.alliance.points,
        iconLeft: themeIcons.alliance.allianceIcon
      }, settings.alliance.isEmpty || (sectionComponentSettings.onClick = settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
        next: xy.dNames.game.menuAllianceProfile.name,
        options: { allianceId: settings.alliance.id }
      }), sectionComponentSettings.iconRight = themeIcons.controls.next), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-alliance"
      })), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.allianceHabitatReservationsMenuElement, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.log, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetAllianceRelationBadge, function(componentsEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesLog, ComponentsMenuListElementBasic, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, timer = !1;
      if (!props.settings.reservationModel.expirationDate)return {};
      try {
        timer = props.settings.reservationModel.expirationDate, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Castle reservations timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = {
        reservationModel: {},
        selectedReservationsSet: {},
        ownAllianceId: 0,
        currentGroupingMode: 0,
        canEdit: !1,
        editMode: !1,
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var reservationSettings, isOwnAlliance = !0, reservationModel = settings.reservationModel, originalThis = settings.initialComponent;
      if (reservationSettings = {
                title: servicesGameDataManager.habitatsCollection.getHabitatProperty("name", reservationModel.habitat),
                onClick: originalThis.handlerNextClick.bind(originalThis, {
                  next: xy.dNames.game.menuAllianceHabitatReservationOverview.name,
                  options: { reservationId: reservationModel.id }
                })
              }, settings.currentGroupingMode === settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.DATE) {
        var nick = servicesGameDataManager.playersCollection.getPlayerProperty("nick", reservationModel.player);
        reservationSettings.description = reservationModel.expirationDate ? nick + " - " + this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(reservationModel.expirationDate) : nick
      } else reservationSettings.description = reservationModel.expirationDate ? this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(reservationModel.expirationDate) : utilsDateTime.getLocaleDateTimeString(reservationModel.reservationDate);
      if (servicesGameDataManager.playersCollection.getPlayerProperty("alliance", reservationModel.player) !== settings.ownAllianceId && (isOwnAlliance = !1, reservationSettings.iconRight = React.createElement(ComponentsWidgetAllianceRelationBadge, {
                settings: {
                  playerId: reservationModel.player,
                  classes: "icon-right"
                }
              })), reservationModel.hasClash)reservationSettings.iconLeft = "icon-game icon-ReservationAttention"; else switch (reservationModel.status) {
        case settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED:
          reservationSettings.iconLeft = "icon-game icon-ReservationAccept";
          break;
        case settingsGameConstant.HABITAT_RESERVATION_STATUS.REJECTED:
          reservationSettings.iconLeft = "icon-game icon-ReservationDecline";
          break;
        case settingsGameConstant.HABITAT_RESERVATION_STATUS.REQUESTED:
          reservationSettings.iconLeft = "icon-game icon-ReservationAsk"
      }
      return settings.editMode ? isOwnAlliance ? (reservationSettings.isSelectable = !0, reservationSettings.onSelect = originalThis.onCheckboxClick.bind(originalThis, reservationModel), settings.selectedReservationsSet[reservationModel.id] && (reservationSettings.isSelected = !0)) : reservationSettings.disabled = !0 : settings.canEdit && isOwnAlliance && reservationModel.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.REQUESTED && (reservationSettings.iconRight = "icon-game icon-BuffActivate", reservationSettings.iconRightIsButton = !0, reservationSettings.iconRightOnClick = originalThis.onAcceptButtonClick.bind(originalThis, reservationModel)), React.createElement(ComponentsMenuListElementBasic, {
        settings: reservationSettings,
        key: "menu-element-reservation-in-list-" + reservationModel.id
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatMenuElement, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetAllianceRelationBadge, function(componentEngine, servicesInternationalization, ComponentsMenuListElementBasic, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        initialComponent: null,
        habitat: null,
        onClick: null,
        showAllianceRelationBadge: !0,
        classes: "",
        iconLeft: "",
        disabled: !1,
        description: null,
        addIndex: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, description, iconLeft, onClick, componentsSections = [], habitat = settings.habitat, originalThis = settings.initialComponent;
      onClick = settings.onClick ? settings.onClick : originalThis.handlerCenterMap.bind(originalThis, habitat), description = settings.description ? settings.description : servicesInternationalization.localize("%d Points", habitat.points), iconLeft = settings.iconLeft ? settings.iconLeft : "icon-game icon-CenterHabitat-" + habitat.publicHabitatType;
      var name = null !== settings.addIndex ? settings.addIndex + ". " + habitat.name : habitat.name;
      return sectionComponentSettings = {
        title: name,
        classes: settings.classes,
        description: description,
        onClick: onClick,
        iconLeft: iconLeft,
        disabled: settings.disabled
      }, settings.showAllianceRelationBadge ? sectionComponentSettings.iconRight = React.createElement(ComponentsWidgetAllianceRelationBadge, {
        settings: {
          playerId: habitat.player,
          classes: "icon-right"
        }
      }) : settings.onClick && (sectionComponentSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-habitat-details"
      })), React.createElement("div", null, componentsSections);
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatTabularCell, [xy.dNames.componentsEngine, xy.dNames.services.theme, xy.dNames.components.icon, xy.dNames.components.resourceIconAmount, function(componentsEngine, servicesTheme, ComponentsIcon, ComponentsResourceIconAmount) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        initialComponent: null,
        onExtendClick: null,
        isExtendable: !1,
        isExtended: !1,
        isSubHabitat: !1,
        classes: "",
        habitat: null,
        showResources: !1,
        actionButtons: []
      };
      Object.assign(settings, this.props.settings);
      var expandIconSettings, themeIcons = servicesTheme.themeSettings.imagesClassNames, habitat = settings.habitat, name = habitat.name, extraClasses = "", expandIcon = null;
      if (settings.isExtended ? expandIcon = themeIcons.tabular.collapse : settings.isExtendable && (expandIcon = themeIcons.tabular.expand), expandIcon && (expandIconSettings = { icon: expandIcon }, expandIcon = React.createElement(ComponentsIcon, { settings: expandIconSettings })), settings.showResources) {
        var resourcesSettings, idResource, amount, percent, resources = [], resourcesDictionary = habitat.habitatResourceDictionary;
        extraClasses += " with-resource-row";
        for (idResource in resourcesDictionary)resourcesDictionary.hasOwnProperty(idResource) && +idResource !== servicesTheme.themeSettings.resources.conquestResourceId && (servicesTheme.themeSettings.resources.humanResourceId === +idResource ? (amount = resourcesDictionary[idResource].storeAmount - resourcesDictionary[idResource].amount, percent = 100 - (amount / resourcesDictionary[idResource].storeAmount * 100 | 0)) : (amount = resourcesDictionary[idResource].amount, percent = amount / resourcesDictionary[idResource].storeAmount * 100 | 0), resourcesSettings = {
          icon: "icon-resource-" + idResource,
          amount: amount,
          percent: percent,
          showFill: !1,
          classes: "dark"
        }, resources.push(React.createElement(ComponentsResourceIconAmount, {
          settings: resourcesSettings,
          key: "resource-" + idResource
        })))
      }
      var habitatIconSettings = { icon: settings.isSubHabitat ? themeIcons.habitat.centerOnMapByType[habitat.publicHabitatType] : themeIcons.habitat.habitatByType[habitat.publicHabitatType] }, habitatIcon = React.createElement(ComponentsIcon, { settings: habitatIconSettings });
      return settings.actionButtons.length && (extraClasses += " with-right-button"), React.createElement("div", { className: "tabular-cell-element tabular-habitat-title-cell " + extraClasses }, React.createElement("div", {
        className: "tabular-habitat-title-cell--expansion-icon",
        onClick: settings.onExtendClick
      }, expandIcon), React.createElement("div", { className: "tabular-habitat-title-cell--habitat-icon" }, habitatIcon), React.createElement("div", { className: "tabular-habitat-title-cell--habitat-title" }, name), React.createElement("div", { className: "tabular-habitat-title-cell--resource-row" }, resources), React.createElement("div", { className: "tabular-habitat-title-cell--action-section" }, settings.actionButtons))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatAnnexMenuElement, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.mixins.menuComponentTimer, xy.dNames.components.menuListElementBasic, function(componentEngine, servicesInternationalization, servicesTheme, servicesLog, utilsDateTime, settingsGameConstant, mixinsMenuComponentTimer, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, timer = !1;
      if (!props.settings.nextLegalFreeHabitatPurchaseDate)return {};
      try {
        utilsDateTime.remainTimeInSeconds(props.settings.nextLegalFreeHabitatPurchaseDate) > 0 && (timer = props.settings.nextLegalFreeHabitatPurchaseDate, remainTimeString = utilsDateTime.remainTime(timer, !0))
      } catch (eX) {
        servicesLog("warn", "Annex habitat timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { habitat: null, nextLegalFreeHabitatPurchaseDate: !1, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, faqLink, componentsSections = [], originalThis = settings.initialComponent, habitatType = settings.habitat.publicHabitatType;
      return sectionComponentSettings = {
        iconLeft: servicesTheme.themeSettings.imagesClassNames.habitat.buyHabitatByType[habitatType],
        iconRight: "controls menu-next",
        onClick: originalThis.onAnnexHabitatClick,
        title: servicesInternationalization.localize(servicesTheme.themeSettings.buyHabitatTitle[habitatType])
      }, settings.nextLegalFreeHabitatPurchaseDate && (sectionComponentSettings.description = this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(settings.nextLegalFreeHabitatPurchaseDate), sectionComponentSettings.disabled = !0), faqLink = servicesTheme.themeSettings.faqLinks.annexCastle, faqLink && (sectionComponentSettings = originalThis.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings })), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetHabitatOverview, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.utils.number, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.icon, xy.dNames.components.resourceIconAmount, xy.dNames.components.unitIconAmount, function(componentEngine, utilsDateTime, utilsNumber, servicesInternationalization, servicesTheme, ComponentsIcon, ComponentsResourceIconAmount, ComponentsUnitIconAmount) {
  "use strict";
  return componentEngine.createClass({
    componentDidMount: function() {
      this.props.onRender && this.props.onRender()
    }, componentDidUpdate: function() {
      this.props.onRender && this.props.onRender()
    }, render: function() {
      var settings = {
        classes: "",
        habitat: {},
        inactive: !1,
        isCurrentHabitat: !1,
        isSummary: !1,
        habitatIcon: null,
        hideResources: !1,
        hideUnits: !1,
        onClick: null,
        showDistance: !1,
        isSelectable: !1,
        isSelected: !1,
        restockRow: !1,
        buffsRow: null,
        missionsRow: null,
        massRecruitmentRow: null,
        massKnowledgeRow: null
      };
      Object.assign(settings, this.props.settings);
      var title, classes = "menu-list-element habitat-overview--widget ", titleSettings = {};
      settings.onClick && (classes += "clickable "), settings.isSummary ? (titleSettings = servicesInternationalization.localize("Summary"), title = React.createElement("div", { className: "habitat-overview-title summary" }, titleSettings)) : (titleSettings = {
        name: settings.habitat.name,
        points: settings.habitat.points,
        extraClasses: settings.isCurrentHabitat ? "active-habitat" : ""
      }, titleSettings.icon = settings.habitatIcon || "icon icon-game icon-habitat-" + settings.habitat.publicHabitatType, settings.inactive && (titleSettings.extraClasses += " inactive"), title = React.createElement("div", { className: "habitat-overview-title " + titleSettings.extraClasses }, React.createElement("div", { className: titleSettings.icon }), React.createElement("div", { className: "habitat-overview-title--habitat-name" }, titleSettings.name), React.createElement("div", { calssNAme: "habitat-overview-title--habitat-points" }, titleSettings.points)));
      var selecting = null;
      if (settings.isSelectable) {
        classes += "selectable ";
        var iconSettings = { icon: settings.isSelected ? "menu-selectable checked" : "menu-selectable" };
        selecting = React.createElement("div", {
          className: "menu-list-element-selectable-area",
          onClick: settings.onSelect
        }, React.createElement(ComponentsIcon, { settings: iconSettings }))
      }
      var resourcesRow = null;
      if (!settings.hideResources) {
        var resourcesSettings, idResource, amount, percent, resources = [], resourcesDictionary = settings.habitat.habitatResourceDictionary;
        for (idResource in resourcesDictionary)resourcesDictionary.hasOwnProperty(idResource) && (settings.isSummary || servicesTheme.themeSettings.resources.humanResourceId !== +idResource ? (amount = resourcesDictionary[idResource].amount, percent = amount / resourcesDictionary[idResource].storeAmount * 100 | 0) : (amount = resourcesDictionary[idResource].storeAmount - resourcesDictionary[idResource].amount, percent = 100 - (amount / resourcesDictionary[idResource].storeAmount * 100 | 0)), resourcesSettings = {
          icon: "icon-resource-" + idResource,
          amount: settings.isSummary ? utilsNumber.shortWithSuffixes(amount) : amount,
          percent: percent,
          showFill: !settings.isSummary,
          classes: "dark"
        }, resources.push(React.createElement(ComponentsResourceIconAmount, {
          settings: resourcesSettings,
          key: "resource-" + idResource
        })));
        resourcesRow = React.createElement("div", { className: "habitat-overview-row" }, resources)
      }
      var unitsRow = null;
      if (!settings.hideUnits) {
        var units = [];
        settings.habitat.ownLocalUnits.forEach(function(locatedUnit) {
          if (locatedUnit.amount) {
            var unitSettings = {
              icon: "icon-unit-" + locatedUnit.unit.primaryKey,
              amount: settings.isSummary ? utilsNumber.shortWithSuffixes(locatedUnit.amount) : locatedUnit.amount,
              classes: "dark"
            };
            units.push(React.createElement(ComponentsUnitIconAmount, {
              settings: unitSettings,
              key: "unit-" + locatedUnit.unit.primaryKey
            }))
          }
        }, this), unitsRow = React.createElement("div", { className: "habitat-overview-row" }, units)
      }
      var distance = null;
      !settings.isSummary && settings.showDistance && (distance = React.createElement("div", { className: "habitat-overview-row right" }, React.createElement("span", { className: "habitat-overview--distance" }, servicesInternationalization.localize("%d fields", settings.habitat.distanceToActiveHabitat))));
      var extraRowClasses, extraRow = null, massFunctionsIconsThemeSettings = servicesTheme.themeSettings.imagesClassNames.massFunction || {};
      if (settings.restockRow) {
        var restocks, countDownRestock = null, restockDate = settings.habitat.nextLegalRestockDate, restockIconSettings = { icon: "icon-game icon-RestockResourceStorage" };
        restocks = React.createElement(ComponentsIcon, { settings: restockIconSettings }), extraRowClasses = "habitat-overview-row upper-border", settings.inactive && (extraRowClasses += " inactive"), restockDate && utilsDateTime.remainTimeInSeconds(restockDate) > 0 ? (extraRowClasses += " sparse inactive", countDownRestock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: restockIconSettings }), " ", React.createElement("span", null, utilsDateTime.remainTime(restockDate)))) : extraRowClasses += " right", extraRow = React.createElement("div", { className: extraRowClasses }, countDownRestock, restocks)
      }
      if (settings.buffsRow && (extraRow = [], settings.buffsRow.buffs.forEach(function(modeledBuff) {
                var buffIcon, buffIconSettings = { icon: modeledBuff.icon }, activeBuff = settings.buffsRow.activeBuffs[modeledBuff.primaryKey], extraClass = "right", activeBuffDescription = null;
                buffIcon = React.createElement(ComponentsIcon, { settings: buffIconSettings }), activeBuff && (extraClass = "sparse", activeBuffDescription = React.createElement("div", null, utilsDateTime.getLocaleDateTimeString(activeBuff.expirationDate) + " - " + utilsDateTime.remainTime(activeBuff.expirationDate))), extraRowClasses = "habitat-overview-row upper-border " + extraClass, settings.inactive && (extraRowClasses += " inactive"), extraRow.push(React.createElement("div", { className: extraRowClasses }, activeBuffDescription, buffIcon))
              }, this)), settings.missionsRow) {
        var possibleMissionsBlock, missionIconSettings = { icon: massFunctionsIconsThemeSettings.massMission }, extraClass = "right", activeMissionsBlock = null;
        possibleMissionsBlock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: missionIconSettings }), " ", React.createElement("span", null, settings.missionsRow.possibleMissions)), settings.missionsRow.activeMissions && (extraClass = "sparse", activeMissionsBlock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: missionIconSettings }), " ", React.createElement("span", null, settings.missionsRow.activeMissions))), extraRowClasses = "habitat-overview-row upper-border " + extraClass, settings.inactive && (extraRowClasses += " inactive"), extraRow = React.createElement("div", { className: extraRowClasses }, activeMissionsBlock, possibleMissionsBlock)
      }
      if (settings.massKnowledgeRow) {
        var possibleKnowledgeBlock, massKnowledgeIconSettings = { icon: settings.massKnowledgeRow.possibleKnowledge.knowledge.icon }, activeKnowledgeIconSettings = { icon: massFunctionsIconsThemeSettings.massKnowledge }, massKnowledgeClass = "right", activeKnowledgeBlock = null;
        possibleKnowledgeBlock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: massKnowledgeIconSettings }), " ", React.createElement("span", null, settings.massKnowledgeRow.possibleKnowledge.amount)), settings.massKnowledgeRow.activeResearchesAmount && (massKnowledgeClass = "sparse", activeKnowledgeBlock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: activeKnowledgeIconSettings }), " ", React.createElement("span", null, settings.massKnowledgeRow.activeResearchesAmount))), extraRowClasses = "habitat-overview-row upper-border " + massKnowledgeClass, settings.inactive && (extraRowClasses += " inactive"), extraRow = React.createElement("div", { className: extraRowClasses }, activeKnowledgeBlock, possibleKnowledgeBlock)
      }
      if (settings.massBuildingRow) {
        var possibilityBlock, massBuildingIconSettings = { icon: "icon-building icon-building-" + settings.massBuildingRow.possibleBuildingConstruction.buildingClassIdentifier }, activeBuildingsIconSettings = { icon: "icon-game icon-habitat-" + settings.habitat.publicHabitatType }, massBuildingClass = "right", activeBuildingsBlock = null;
        possibilityBlock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: massBuildingIconSettings }), " ", React.createElement("span", null, settings.massBuildingRow.possibleBuildingConstruction.amount)), settings.massBuildingRow.activeBuildingConstructionAmount && (massBuildingClass = "sparse", activeBuildingsBlock = React.createElement("div", null, React.createElement(ComponentsIcon, { settings: activeBuildingsIconSettings }), " ", React.createElement("span", null, settings.massBuildingRow.activeBuildingConstructionAmount))), extraRowClasses = "habitat-overview-row upper-border " + massBuildingClass, settings.inactive && (extraRowClasses += " inactive"), extraRow = React.createElement("div", { className: extraRowClasses }, activeBuildingsBlock, possibilityBlock)
      }
      if (settings.massRecruitmentRow) {
        var unitsIconSettings, possibleUnitsBlock, recruitmentExtraClass = "right", activeUnitsBlock = null, activeUnits = null;
        unitsIconSettings = {
          icon: settings.massRecruitmentRow.possibleUnitConstruction.unit.icon,
          amount: settings.massRecruitmentRow.possibleUnitConstruction.amount,
          classes: "horizontal dark"
        }, settings.massRecruitmentRow.possibleUnitConstruction.amount > 9999 ? unitsIconSettings.classes += " widest" : settings.massRecruitmentRow.possibleUnitConstruction.amount > 99 && (unitsIconSettings.classes += " wider"), possibleUnitsBlock = React.createElement(ComponentsUnitIconAmount, { settings: unitsIconSettings }), settings.massRecruitmentRow.activeUnitConstruction instanceof Array && settings.massRecruitmentRow.activeUnitConstruction.length && (recruitmentExtraClass = "sparse", activeUnits = [], settings.massRecruitmentRow.activeUnitConstruction.forEach(function(obj, ind) {
          var localSettings = { icon: obj.unit.icon, amount: obj.amount, classes: "horizontal dark float-left" };
          obj.amount > 9999 ? localSettings.classes += " widest" : obj.amount > 99 && (localSettings.classes += " wider"), activeUnits.push(React.createElement(ComponentsUnitIconAmount, {
            settings: localSettings,
            key: "active-unit-construction-" + ind
          }))
        }), activeUnitsBlock = React.createElement("div", { className: "habitat-overview-extra-row-left-column" }, activeUnits)), extraRowClasses = "habitat-overview-row upper-border " + recruitmentExtraClass, settings.inactive && (extraRowClasses += " inactive"), extraRow = React.createElement("div", { className: extraRowClasses }, activeUnitsBlock, possibleUnitsBlock)
      }
      return React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, selecting, title, resourcesRow, unitsRow, extraRow, distance)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetHabitatMassExchange, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.icon, xy.dNames.components.resourceIconAmount, xy.dNames.components.unitIconAmount, function(componentEngine, servicesInternationalization, servicesTheme, ComponentsIcon, ComponentsResourceIconAmount, ComponentsUnitIconAmount) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        habitat: {},
        inactive: !1,
        tradingResourceId: 0,
        exchangeableResource: [],
        transportUnit: {},
        minRequiredAmountUnits: 0,
        maxAvailableAmountTradingResource: 0,
        isSelectable: !1,
        isSelected: !1,
        onSelect: null
      };
      Object.assign(settings, this.props.settings);
      var title, titleSettings, componentSettings, classes = "menu-list-element habitat-overview--widget ";
      titleSettings = {
        icon: "icon icon-game icon-habitat-" + settings.habitat.publicHabitatType,
        name: settings.habitat.name,
        points: settings.habitat.points,
        extraClasses: settings.isCurrentHabitat ? "active-habitat" : ""
      }, settings.inactive && (titleSettings.extraClasses += " inactive"), title = React.createElement("div", { className: "habitat-overview-title " + titleSettings.extraClasses }, React.createElement("div", { className: titleSettings.icon }), React.createElement("div", { className: "habitat-overview-title--habitat-name" }, titleSettings.name), React.createElement("div", { calssNAme: "habitat-overview-title--habitat-points" }, titleSettings.points));
      var selecting = null;
      if (settings.isSelectable) {
        classes += "selectable ";
        var iconSettings = { icon: settings.isSelected ? "menu-selectable checked" : "menu-selectable" };
        selecting = React.createElement("div", {
          className: "menu-list-element-selectable-area",
          onClick: settings.onSelect
        }, React.createElement(ComponentsIcon, { settings: iconSettings }))
      }
      var firstRow, unitSettings, firstRowElements = [], unitAmount = 0;
      settings.habitat.ownLocalUnits.forEach(function(locatedUnit) {
        locatedUnit.unit.primaryKey === settings.transportUnit.primaryKey && (unitAmount += locatedUnit.amount)
      }, this), unitSettings = {
        icon: "icon-unit-" + settings.transportUnit.primaryKey,
        amount: unitAmount,
        classes: "dark"
      }, firstRowElements.push(React.createElement(ComponentsUnitIconAmount, {
        settings: unitSettings,
        key: "unit-" + settings.transportUnit.primaryKey
      }));
      var resourcesDictionary = settings.habitat.habitatResourceDictionary, addResourceToFirstRow = function(idResource) {
        var resourcesSettings, amount = resourcesDictionary[idResource].amount, percent = amount / resourcesDictionary[idResource].storeAmount * 100 | 0;
        resourcesSettings = {
          icon: "icon-resource-" + idResource,
          amount: amount,
          percent: percent,
          showFill: !0,
          classes: "dark"
        }, firstRowElements.push(React.createElement(ComponentsResourceIconAmount, {
          settings: resourcesSettings,
          key: "resource-" + idResource
        }))
      };
      settings.exchangeableResource.forEach(addResourceToFirstRow), addResourceToFirstRow(settings.tradingResourceId), firstRow = React.createElement("div", { className: "habitat-overview-row" }, firstRowElements);
      var barterRow, barterRowElements = [];
      unitAmount = settings.minRequiredAmountUnits || 0, unitSettings = {
        icon: "icon-unit-" + settings.transportUnit.primaryKey,
        amount: unitAmount,
        classes: "dark"
      }, barterRowElements.push(React.createElement(ComponentsUnitIconAmount, {
        settings: unitSettings,
        key: "unit-trading-" + settings.transportUnit.primaryKey
      })), componentSettings = { icon: servicesTheme.themeSettings.imagesClassNames.icon.exchange }, barterRowElements.push(React.createElement(ComponentsIcon, {
        settings: componentSettings,
        key: "trading-logo-icon"
      })), componentSettings = {
        icon: "icon-resource-" + settings.tradingResourceId,
        amount: settings.maxAvailableAmountTradingResource,
        showFill: !1,
        classes: "dark"
      }, barterRowElements.push(React.createElement(ComponentsResourceIconAmount, {
        settings: componentSettings,
        key: "trading-resource-amount"
      }));
      var extraRowClasses = "habitat-overview-row upper-border right";
      return settings.inactive && (extraRowClasses += " inactive"), barterRow = React.createElement("div", { className: extraRowClasses }, barterRowElements), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, selecting, title, firstRow, barterRow)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetHabitatAmount, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.menuListElementBasic, function(componentEngine, servicesInternationalization, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { habitatCountByTypeDictionary: {} };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], habitatCountByTypeDictionary = settings.habitatCountByTypeDictionary;
      return 0 === habitatCountByTypeDictionary[0] && 0 === habitatCountByTypeDictionary[2] && 0 === habitatCountByTypeDictionary[4] ? (sectionComponentSettings = {
        title: servicesInternationalization.localize("Castles"),
        rightColumnDataValue: "0"
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitats-amount-empty"
      }))) : (habitatCountByTypeDictionary[0] > 0 && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Castles"),
        rightColumnDataValue: habitatCountByTypeDictionary[0]
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitats-amount-habitat-type-0"
      }))), habitatCountByTypeDictionary[2] > 0 && (sectionComponentSettings = {
        title: servicesInternationalization.localize("No. of fortresses"),
        rightColumnDataValue: habitatCountByTypeDictionary[2]
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitats-amount-habitat-type-2"
      }))), habitatCountByTypeDictionary[4] > 0 && (sectionComponentSettings = {
        title: servicesInternationalization.localize("No. of cities"),
        rightColumnDataValue: habitatCountByTypeDictionary[4]
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitats-amount-habitat-type-4"
      })))), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.missionTabularCell, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, function(componentsEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesLog, servicesTheme, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, secondsLeft, timer = !1;
      try {
        if (!props.settings.missionInProgress)return {};
        timer = props.settings.missionInProgress.complete, remainTimeString = utilsDateTime.remainTime(timer, !0), secondsLeft = utilsDateTime.remainTimeInSeconds(timer)
      } catch (eX) {
        servicesLog("warn", "Mission timer error"), servicesLog("debug", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        expired: secondsLeft < 1,
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { initialComponent: null, habitat: {}, mission: {}, missionInProgress: {}, activated: !1 };
      Object.assign(settings, this.props.settings);
      var rightIconButtonIcon, rightIconButtonSettings, originalThis = settings.initialComponent, themeIcons = servicesTheme.themeSettings.imagesClassNames, missionIcons = themeIcons.missions, rightIconButton = null, isInstantFinishingAvailable = settings.missionInProgress.doesHalfTimeOfConstructionPassNormally(), isCancelAvailable = settings.missionInProgress.wasSpeedUp(), rightIconButtonOnClick = originalThis.onMissionSpeedUpClick;
      this.state.expired || (isCancelAvailable ? (rightIconButtonIcon = missionIcons.cancel, rightIconButtonOnClick = originalThis.onMissionCancelClick) : rightIconButtonIcon = isInstantFinishingAvailable ? missionIcons.finish : missionIcons.speedUp, rightIconButtonSettings = {
        icon: "white " + rightIconButtonIcon,
        onClick: rightIconButtonOnClick.bind(originalThis, {
          missionInProgress: settings.missionInProgress,
          mission: settings.mission,
          habitat: settings.habitat
        })
      }, rightIconButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings }));
      var sectionComponentSettings = {
        iconLeft: settings.mission.icon,
        title: settings.mission.title,
        iconRight: rightIconButton,
        description: this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(settings.missionInProgress.complete),
        hideBorders: !0,
        activated: settings.activated
      };
      return React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatUpgradesConstructUpgradeCenter, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.overviewWidgetConstructCost, function(componentEngine, mixinsMenuComponentHandlers, utilsDateTime, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsOverviewWidgetConstructCost) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = { classes: "", upgradeObject: null, currentHabitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], habitatUpgradeThemeIcons = servicesTheme.themeSettings.imagesClassNames.habitatUpgrades, habitatUpgradeThemeSettings = servicesTheme.themeSettings.habitatUpgrades, habitatType = settings.upgradeObject.original.affectedHabitatType, faqLinkSettings = "constructFortressCenter", originalThis = settings.initialComponent;
      sectionComponentSettings = {
        iconLeft: habitatUpgradeThemeIcons[habitatType].build,
        title: settings.upgradeObject.original.title
      };
      var faqLink = servicesTheme.getFAQLink(faqLinkSettings);
      faqLink && (sectionComponentSettings = originalThis.addFAQButton(sectionComponentSettings, faqLink)), settings.upgradeObject.original.subTitle && (sectionComponentSettings.description = settings.upgradeObject.original.subTitle), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "title-habitat-upgrade"
      }));
      var classAvailabilityName, fullyUpgradeLocalization = habitatUpgradeThemeSettings[habitatType].fullyUpgraded;
      if (settings.upgradeObject.ready.isUpgraded || (classAvailabilityName = "color-red"), sectionComponentSettings = {
                iconLeft: habitatUpgradeThemeIcons[habitatType].fullyUpgraded,
                title: servicesInternationalization.localize("Required"),
                rightColumnDataValue: React.createElement("div", { className: classAvailabilityName }, servicesInternationalization.localize(fullyUpgradeLocalization))
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "required-section-fully-upgraded"
              })), settings.upgradeObject.ready.isInProgress) {
        var inProgress = settings.upgradeObject.ready.isInProgress, completeTime = inProgress.complete, rightActionButton = {
          classes: "menu-element--button--action",
          icon: inProgress.isLessThanHalfConstructionTimeRemain() ? habitatUpgradeThemeIcons.expandFinish : habitatUpgradeThemeIcons.expandSpeedUp,
          onClick: originalThis.onUpgradeProgressSpeedUpClick.bind(originalThis, {
            inProgress: inProgress,
            upgrade: settings.upgradeObject.original
          }),
          isDisabled: !1
        };
        sectionComponentSettings = {
          iconLeft: habitatUpgradeThemeIcons[habitatType].build,
          title: settings.upgradeObject.original.title,
          description: utilsDateTime.getLocaleDateTimeString(completeTime) + " - " + utilsDateTime.remainTime(completeTime),
          iconRight: React.createElement(ComponentsMenuListElementButtonAction, {
            settings: rightActionButton,
            key: "construct-button"
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "habitat-upgrade-in-progress"
        }))
      } else sectionComponentSettings = {
        constructingEntity: settings.upgradeObject.original,
        currentHabitat: settings.currentHabitat,
        initialComponent: originalThis,
        showMissingResources: !0,
        externalRequirementsPassed: settings.upgradeObject.ready.isReadyForBuild,
        onConstructButtonClick: originalThis.onConstructHabitatUpgradeCenterClick,
        title: settings.upgradeObject.original.title
      }, componentsSections.push(React.createElement(ComponentsOverviewWidgetConstructCost, {
        settings: sectionComponentSettings,
        key: "habitat-upgrade-cost-" + settings.upgradeObject.original.primaryKey
      }));
      return React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatUpgradesExpandUpgradeCenter, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.overviewWidgetConstructCost, function(componentEngine, mixinsMenuComponentHandlers, utilsDateTime, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsOverviewWidgetConstructCost) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = { classes: "", upgradeObject: null, currentHabitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeSettings = servicesTheme.themeSettings, habitatType = settings.upgradeObject.original.affectedHabitatType, habitatUpgradesThemeSettings = themeSettings.habitatUpgrades[habitatType], habitatUpgradesThemeIcons = themeSettings.imagesClassNames.habitatUpgrades, faqLinkSettings = "expandFortressCenter", originalThis = settings.initialComponent;
      sectionComponentSettings = {
        iconLeft: habitatUpgradesThemeIcons[habitatType].build,
        title: settings.upgradeObject.original.title
      };
      var faqLink = servicesTheme.getFAQLink(faqLinkSettings);
      return faqLink && (sectionComponentSettings = originalThis.addFAQButton(sectionComponentSettings, faqLink)), settings.upgradeObject.original.subTitle && (sectionComponentSettings.description = settings.upgradeObject.original.subTitle), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "title-habitat-upgrade"
      })), sectionComponentSettings = { title: servicesInternationalization.localize(habitatUpgradesThemeSettings.descriptionKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "description-habitat-upgrade"
      })), sectionComponentSettings = {
        constructingEntity: settings.upgradeObject.original,
        currentHabitat: settings.currentHabitat,
        showMissingResources: !0,
        externalRequirementsPassed: !1,
        disableRequiredSection: !0,
        initialComponent: originalThis,
        onConstructButtonClick: originalThis.onConstructHabitatUpgradeCenterClick,
        title: servicesInternationalization.localize(habitatUpgradesThemeSettings.upgradeConstructionTitle)
      }, componentsSections.push(React.createElement(ComponentsOverviewWidgetConstructCost, {
        settings: sectionComponentSettings,
        key: "unit-overview-cost"
      })), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatUpgradesConstructUpgrade, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.overviewWidgetConstructCost, function(componentEngine, mixinsMenuComponentHandlers, utilsDateTime, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsOverviewWidgetConstructCost) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = { classes: "", upgradeObject: null, currentHabitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeSettings = servicesTheme.themeSettings, faqLinkSettings = "constructFortressCenter", habitatType = settings.upgradeObject.original.affectedHabitatType, habitatUpgradesThemeSettings = themeSettings.habitatUpgrades[habitatType], habitatUpgradesThemeIcons = themeSettings.imagesClassNames.habitatUpgrades, originalThis = settings.initialComponent;
      sectionComponentSettings = {
        iconLeft: habitatUpgradesThemeIcons[habitatType].build,
        title: settings.upgradeObject.original.title
      };
      var faqLink = servicesTheme.getFAQLink(faqLinkSettings);
      if (faqLink && (sectionComponentSettings = originalThis.addFAQButton(sectionComponentSettings, faqLink)), settings.upgradeObject.original.subTitle && (sectionComponentSettings.description = settings.upgradeObject.original.subTitle), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "title-habitat-upgrade"
              })), sectionComponentSettings = { title: servicesInternationalization.localize(habitatUpgradesThemeSettings.descriptionKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "description-habitat-upgrade"
              })), settings.upgradeObject.ready.isInProgress) {
        var inProgress = settings.upgradeObject.ready.isInProgress, completeTime = inProgress.complete, rightActionButton = {
          classes: "menu-element--button--action",
          icon: inProgress.isLessThanHalfConstructionTimeRemain() ? habitatUpgradesThemeIcons.expandFinish : habitatUpgradesThemeIcons.expandSpeedUp,
          onClick: originalThis.onUpgradeProgressSpeedUpClick.bind(originalThis, {
            inProgress: inProgress,
            upgrade: settings.upgradeObject.original
          }),
          isDisabled: !1
        };
        sectionComponentSettings = {
          iconLeft: habitatUpgradesThemeIcons[habitatType].build,
          title: settings.upgradeObject.original.title,
          description: utilsDateTime.getLocaleDateTimeString(completeTime) + " - " + utilsDateTime.remainTime(completeTime),
          iconRight: React.createElement(ComponentsMenuListElementButtonAction, {
            settings: rightActionButton,
            key: "construct-button"
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "habitat-upgrade-in-progress"
        }))
      } else sectionComponentSettings = {
        constructingEntity: settings.upgradeObject.original,
        currentHabitat: settings.currentHabitat,
        showMissingResources: !0,
        disableRequiredSection: !0,
        initialComponent: originalThis,
        onConstructButtonClick: originalThis.onConstructHabitatUpgradeClick.bind(originalThis, { habitatUpgradeCenter: settings.currentHabitat }),
        title: servicesInternationalization.localize(habitatUpgradesThemeSettings.upgradeConstructionTitle)
      }, componentsSections.push(React.createElement(ComponentsOverviewWidgetConstructCost, {
        settings: sectionComponentSettings,
        key: "habitat-upgrade-cost"
      }));
      return React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatUpgradesExpandedList, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementButtonAction, function(componentEngine, utilsDateTime, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        isInProgress: !1,
        list: [],
        habitatUpgradeCenter: null,
        habitatUpgradeMode: "",
        initialComponent: null,
        haveToExpand: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, componentsSections = [], habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades[settings.habitatUpgradeMode], themeIcons = servicesTheme.themeSettings.imagesClassNames;
      return sectionComponentSettings = { title: habitatUpgradesThemeSettings.title }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "expanded-list-title"
      })), sectionComponentSettings = {
        iconLeft: themeIcons.icon["centerMapHabitatTypeIcon-" + settings.habitatUpgradeCenter.publicHabitatType],
        title: settings.habitatUpgradeCenter.name,
        description: habitatUpgradesThemeSettings.upgradeCenterTitle,
        onClick: settings.initialComponent.handlerCenterMap.bind(settings.initialComponent, settings.habitatUpgradeCenter)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitat-upgrade-center-expanded-habitat"
      })), settings.list.forEach(function(modeledHabitat, index) {
        var rightIconButton, rightIconButtonSettings, localComponentSettings;
        rightIconButtonSettings = {
          icon: themeIcons.habitatUpgrades.cancel + " white",
          onClick: originalThis.onCancelExpandClick.bind(originalThis, {
            habitat: modeledHabitat,
            habitatUpgradeMode: settings.habitatUpgradeMode
          })
        }, rightIconButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings }), localComponentSettings = {
          iconLeft: themeIcons.icon["centerMapHabitatTypeIcon-" + modeledHabitat.publicHabitatType],
          iconRight: rightIconButton,
          description: servicesInternationalization.localize("%ld. Expansion", index + 1),
          title: modeledHabitat.name,
          onClick: settings.initialComponent.handlerCenterMap.bind(settings.initialComponent, modeledHabitat)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "habitat-upgrade-expanded-habitat-" + index
        }))
      }), settings.haveToExpand && (sectionComponentSettings = { text: servicesInternationalization.localize(habitatUpgradesThemeSettings.habitatsNumberLeft, settings.haveToExpand) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "section-habitats-left-to-expand"
      }))), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatUpgradesExpandingList, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, function(componentEngine, utilsDateTime, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", list: [], initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeIcons = servicesTheme.themeSettings.imagesClassNames;
      return sectionComponentSettings = { title: servicesInternationalization.localize("Extension list") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "for-expansion-list-title"
      })), settings.list.forEach(function(expandObject) {
        var inProgress = expandObject.upgradeInProgress, completeTime = inProgress.complete, rightActionButton = {
          classes: "menu-element--button--action",
          icon: inProgress.isLessThanHalfConstructionTimeRemain() ? themeIcons.habitatUpgrades.expandFinish : themeIcons.habitatUpgrades.expandSpeedUp,
          onClick: settings.initialComponent.onUpgradeProgressSpeedUpClick.bind(settings.initialComponent, {
            inProgress: inProgress,
            upgrade: expandObject.upgradeObject
          }),
          isDisabled: !1
        };
        sectionComponentSettings = {
          iconLeft: themeIcons.icon["centerMapHabitatTypeIcon-" + expandObject.modeledHabitat.publicHabitatType],
          title: expandObject.modeledHabitat.name,
          description: utilsDateTime.getLocaleDateTimeString(completeTime) + " - " + utilsDateTime.remainTime(completeTime),
          iconRight: React.createElement(ComponentsMenuListElementButtonAction, {
            settings: rightActionButton,
            key: "construct-button"
          }),
          onClick: settings.initialComponent.handlerCenterMap.bind(settings.initialComponent, expandObject.modeledHabitat)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "habitat-upgrade-expansion-habitat-" + expandObject.modeledHabitat.id
        }))
      }), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatUpgradesHabitatsForExpansion, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.settings.gameConstant, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.widgetAllianceRelationBadge, function(componentEngine, utilsDateTime, servicesTheme, servicesInternationalization, servicesGameDataManager, settingsGameConstants, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", list: [], habitatUpgradeMode: "", canStartExpansion: !1, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, title, componentsSections = [], themeSettings = servicesTheme.themeSettings, themeIcons = themeSettings.imagesClassNames, habitatUpgradesThemeSettings = themeSettings.habitatUpgrades[settings.habitatUpgradeMode];
      return title = settings.canStartExpansion ? habitatUpgradesThemeSettings.readyToStartExpansionTitle : habitatUpgradesThemeSettings.unreadyToStartExpansionTitle, sectionComponentSettings = { title: servicesInternationalization.localize(title) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "for-expansion-list-title"
      })), settings.list.forEach(function(expandObject) {
        if (sectionComponentSettings = {
                  iconLeft: themeIcons.icon["centerMapHabitatTypeIcon-" + expandObject.modeledHabitat.publicHabitatType],
                  title: expandObject.modeledHabitat.name,
                  onClick: settings.initialComponent.handlerCenterMap.bind(settings.initialComponent, expandObject.modeledHabitat)
                }, settings.canStartExpansion) {
          var ownHabitatReadyStateDescription, rightActionButton, isReadyForBuild = !!expandObject.upgradeObject.ready && expandObject.upgradeObject.ready.isReadyForBuild;
          ownHabitatReadyStateDescription = expandObject.upgradeObject.original.primaryKey === settingsGameConstants.HABITAT_UPGRADE_TYPE.FORTRESS_CENTER || expandObject.upgradeObject.original.primaryKey === settingsGameConstants.HABITAT_UPGRADE_TYPE.CITY_CENTER ? expandObject.upgradeObject.subTitle : servicesInternationalization.localize(habitatUpgradesThemeSettings.upgradeCenterTitle), sectionComponentSettings.description = ownHabitatReadyStateDescription, expandObject.isOwnByPlayer ? (rightActionButton = {
            classes: "menu-element--button--action",
            icon: themeIcons.habitatUpgrades.expand,
            onClick: settings.initialComponent.onExpansionHabitatUpgradeCenterClick.bind(settings.initialComponent, {
              habitatToLink: expandObject.modeledHabitat,
              upgrade: expandObject.upgradeObject
            }),
            isDisabled: !(isReadyForBuild && settings.canStartExpansion)
          }, sectionComponentSettings.iconRight = React.createElement(ComponentsMenuListElementButtonAction, {
            settings: rightActionButton,
            key: "construct-button"
          })) : sectionComponentSettings.iconRight = React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              playerId: expandObject.modeledHabitat.player,
              classes: "icon-right"
            }
          })
        } else sectionComponentSettings.description = expandObject.isOwnByPlayer ? servicesGameDataManager.playersCollection.getPlayerProperty("nick") : expandObject.otherPlayer.nick, sectionComponentSettings.iconRight = React.createElement(ComponentsWidgetAllianceRelationBadge, {
          settings: {
            playerId: expandObject.modeledHabitat.player,
            classes: "icon-right"
          }
        });
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "habitat-upgrade-expansion-habitat-" + expandObject.modeledHabitat.id
        }))
      }), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitIconAmount, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { icon: "", amount: 0, classes: "" };
      Object.assign(settings, this.props.settings);
      var classes = "icon-amount--widget ";
      return React.createElement("div", { className: classes + settings.classes }, React.createElement("div", { className: "icon icon-unit " + settings.icon }), React.createElement("div", { className: "amount" }, settings.amount))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitsListAttackersInForeignerHabitat, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetUnitsList, function(componentEngine, utilsDateTime, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsWidgetUnitList) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { initialComponent: null, attackers: [], habitat: {}, classes: "", massSendBackActionType: !1 };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      return sectionComponentSettings = { title: servicesInternationalization.localize("Offending troops") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-attacker-all"
      })), sectionComponentSettings = {
        initialComponent: settings.initialComponent,
        unitsList: settings.attackers,
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuUnitsAttackersExternal.name,
          options: { habitatId: settings.habitat.id, massSendBackActionType: settings.massSendBackActionType }
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
        settings: sectionComponentSettings,
        key: "menu--attacker-list-all"
      })), settings.habitat.nextBattleDate && (sectionComponentSettings = { text: servicesInternationalization.localize("Next battle: %@", utilsDateTime.getLocaleDateTimeString(settings.habitat.nextBattleDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-next-battle"
      }))), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitsListLocalAttackers, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetUnitsList, function(componentEngine, utilsDateTime, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsWidgetUnitList) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { initialComponent: null, attackers: [], habitat: {}, classes: "" };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      return sectionComponentSettings = { title: servicesInternationalization.localize("Offending troops") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-attacker-all"
      })), sectionComponentSettings = {
        initialComponent: settings.initialComponent,
        unitsList: settings.attackers,
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuUnitAttackersLocal.name,
          options: { habitatId: settings.habitat.id }
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
        settings: sectionComponentSettings,
        key: "menu--attacker-list-all"
      })), settings.habitat.nextBattleDate && (sectionComponentSettings = { text: servicesInternationalization.localize("Next battle: %@", utilsDateTime.getLocaleDateTimeString(settings.habitat.nextBattleDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-next-battle"
      }))), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitsListLocalDefenders, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.widgetUnitsList, function(componentEngine, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsWidgetUnitList) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        initialComponent: null,
        isCurrentHabitatUnitList: !1,
        defenders: [],
        habitat: {},
        classes: "",
        massSendBackActionType: !1
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = { title: servicesInternationalization.localize("Defending troops") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-defenders-all"
      }));
      var nextMenuOption = {};
      return settings.isCurrentHabitatUnitList || (nextMenuOption = { habitatId: settings.habitat.id }), nextMenuOption.massSendBackActionType = settings.massSendBackActionType, sectionComponentSettings = {
        initialComponent: settings.initialComponent,
        unitsList: settings.defenders,
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuUnitsDefendersLocal.name,
          options: nextMenuOption
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
        settings: sectionComponentSettings,
        key: "menu--defenders-list-all"
      })), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitsListExternalAttackers, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetUnitsList, function(componentEngine, utilsDateTime, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsWidgetUnitList) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { initialComponent: null, attackers: [], habitat: {}, classes: "", massSendBackActionType: !1 };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      return sectionComponentSettings = { title: servicesInternationalization.localize("Outbound attacking troops") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-attacker-external-all"
      })), sectionComponentSettings = {
        initialComponent: settings.initialComponent,
        unitsList: settings.attackers,
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuUnitsAttackersExternal.name,
          options: { habitatId: settings.habitat.id, massSendBackActionType: settings.massSendBackActionType }
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
        settings: sectionComponentSettings,
        key: "menu--attacker-list-external-all"
      })), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitsListExternalDefenders, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.widgetUnitsList, function(componentEngine, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsWidgetUnitList) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { initialComponent: null, defenders: [], habitat: {}, classes: "", massSendBackActionType: !1 };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      return sectionComponentSettings = { title: servicesInternationalization.localize("Outbound defending troops") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-defenders-external"
      })), sectionComponentSettings = {
        initialComponent: settings.initialComponent,
        unitsList: settings.defenders,
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuUnitsDefendersExternal.name,
          options: { habitat: settings.habitat, massSendBackActionType: settings.massSendBackActionType }
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
        settings: sectionComponentSettings,
        key: "menu--defenders-list-external"
      })), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitsListReturnFromHabitat, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.utils.moving, xy.dNames.utils.object, xy.dNames.services.log, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.sortable, xy.dNames.settings.gameConstant, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.widgetRangeSliderDivider, function(componentEngine, utilsDateTime, utilMoving, utilObject, servicesLog, servicesInternationalization, servicesTheme, servicesSortable, settingsGameConstant, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsMenuListTitleBasic, ComponentsHabitatMenuElement, ComponentsWidgetAllianceRelationBadge, ComponentsWidgetRangeSliderDivider) {
  "use strict";
  return componentEngine.createClass({
    getNewState: function(settings) {
      var unitDictionary = {};
      return settings.unitsList.forEach(function(UnitHabitatUnitObject) {
        var unit = UnitHabitatUnitObject.unit, unitPrimaryKey = unit.primaryKey, habitatUnit = UnitHabitatUnitObject.habitatUnit;
        habitatUnit.amount && (unitDictionary[unitPrimaryKey] = habitatUnit.amount)
      }), { unitDictionary: unitDictionary || {} }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, componentWillReceiveProps: function(newProps) {
      (this.props.settings.sourceHabitat.id !== newProps.settings.sourceHabitat.id || newProps.settings.forceRedraw) && this.setState(this.getNewState(newProps.settings), null)
    }, onRecallClick: function(event) {
      event.preventDefault();
      var primaryKey, unitsAvailable = {}, habitatUnitsToFlush = [];
      this.props.settings.unitsList.forEach(function(UnitHabitatUnitObject) {
        var unit = UnitHabitatUnitObject.unit, unitPrimaryKey = unit.primaryKey, habitatUnit = UnitHabitatUnitObject.habitatUnit;
        unitsAvailable[unitPrimaryKey] = habitatUnit.id
      });
      for (primaryKey in this.state.unitDictionary)this.state.unitDictionary.hasOwnProperty(primaryKey) && this.state.unitDictionary[primaryKey] && unitsAvailable.hasOwnProperty(primaryKey) && habitatUnitsToFlush.push(unitsAvailable[primaryKey]);
      this.props.settings.onRecallAction(this.state.unitDictionary, habitatUnitsToFlush)
    }, onSetValueByRangeSlider: function(unitPrimaryKey, amount) {
      var unitDictionary = this.state.unitDictionary;
      unitDictionary[unitPrimaryKey] = amount, this.setState({ unitDictionary: unitDictionary }, null)
    }, render: function() {
      var settings = {
        initialComponent: null,
        currentHabitat: null,
        habitat: null,
        sourceHabitat: null,
        destinationHabitat: null,
        unitsList: [],
        isAttackersExternal: !1,
        isDefendersExternal: !1,
        isDefendersLocal: !1,
        classes: ""
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, recallIcon, recallTitle, themeIcons = servicesTheme.themeSettings.imagesClassNames, componentsSections = [], habitat = settings.habitat, originalThis = settings.initialComponent, title = "";
      if (settings.isDefendersExternal)title = "Outbound defending troops", recallIcon = themeIcons.units.recallDefendersTroops, recallTitle = "title/button recall"; else if (settings.isAttackersExternal)title = "Outbound attacking troops", recallIcon = themeIcons.units.recallAttackersTroops, recallTitle = "title/button recall"; else if (settings.isDefendersLocal) {
        title = "Defending troops", recallIcon = themeIcons.units.recallDefendersTroops;
        try {
          recallTitle = settings.sourceHabitat.id === settings.currentHabitat.id ? "title/button send back" : "title/button recall"
        } catch (eX) {
          servicesLog("warn", "destinationHabitat and/or currentHabitat are not ModelHabitatGame"), servicesLog("debug", eX), recallTitle = "title/button send back"
        }
      }
      if (sectionComponentSettings = { title: servicesInternationalization.localize(title) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "menu-title-units-external"
              })), sectionComponentSettings = {
                initialComponent: originalThis,
                habitat: habitat,
                showAllianceRelationBadge: !1
              }, componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
                settings: sectionComponentSettings,
                key: "menu-element-habitat-details-" + habitat.id
              })), settings.unitsList.sort(servicesSortable.byField("unit", "order")), settings.unitsList.forEach(function(UnitHabitatUnitObject) {
                var unit = UnitHabitatUnitObject.unit, unitPrimaryKey = unit.primaryKey, habitatUnit = UnitHabitatUnitObject.habitatUnit;
                sectionComponentSettings = {
                  handleIcon: unit.icon,
                  currentValue: this.state.unitDictionary[unitPrimaryKey],
                  minValue: 0,
                  maxValue: habitatUnit.amount,
                  title: unit.title,
                  onChange: this.onSetValueByRangeSlider.bind(this, unitPrimaryKey)
                }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
                  settings: sectionComponentSettings,
                  key: "recall-unit-range-slider-" + unitPrimaryKey
                }))
              }, this), settings.destinationHabitat.isOwnByPlayer || settings.isAttackersExternal) {
        var distance = settings.sourceHabitat.computeDistanceBetweenHabitats(settings.destinationHabitat), transportTimeInSeconds = utilMoving.getTransportationTime(this.state.unitDictionary, { distance: distance });
        sectionComponentSettings = {
          iconLeft: themeIcons.startTransit.transportTime,
          title: servicesInternationalization.localize("Transport duration"),
          rightColumnDataValue: utilsDateTime.secondsToTimeString(transportTimeInSeconds, !0)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "transport-time"
        }));
        var arrivalDate = utilMoving.getArrivalTime(this.state.unitDictionary, { distance: distance }), cycle = utilsDateTime.getDayCycle(arrivalDate);
        sectionComponentSettings = {
          iconLeft: themeIcons.startTransit.transportTime,
          title: servicesInternationalization.localize("Destination ETA")
        }, utilObject.effectiveLength(this.state.unitDictionary) ? (sectionComponentSettings.rightColumnLeftIcon = "icon-game colored icon-" + cycle + "Icon", sectionComponentSettings.rightColumnDataValue = utilsDateTime.getLocaleDateTimeString(arrivalDate)) : sectionComponentSettings.rightColumnDataValue = settingsGameConstant.ARRIVAL_DEFAULT_TIME, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "arrival-time"
        }))
      }
      return sectionComponentSettings = {
        iconLeft: recallIcon,
        title: servicesInternationalization.localize(recallTitle),
        onClick: this.onRecallClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-defenders-send-back"
      })), React.createElement("div", null, componentsSections)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitTabularCell, [xy.dNames.componentsEngine, xy.dNames.services.theme, xy.dNames.components.inputTextTabularCell, xy.dNames.components.menuListElementButtonAction, function(componentsEngine, servicesTheme, ComponentsInputTextTabularCell, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { unitObject: null, habitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var componentsSettings, unitObject = settings.unitObject, habitat = settings.habitat, unit = unitObject.unit, components = [], originalThis = settings.initialComponent, maxForRecruitment = unitObject.maxForRecruitment;
      return componentsSettings = {
        classes: "",
        maxValue: maxForRecruitment,
        title: unitObject.amount,
        value: maxForRecruitment,
        handlerOnChange: originalThis.onChangeUnitAmountToSendBack.bind(originalThis, habitat.id, unit.primaryKey),
        withMaxOutButton: !0
      }, components.push(React.createElement(ComponentsInputTextTabularCell, { settings: componentsSettings })), componentsSettings = {
        icon: "icon-game white icon-Recruit",
        onClick: originalThis.onConstructClick.bind(originalThis, { unit: unit, habitat: habitat }),
        isDisabled: !maxForRecruitment
      }, components.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: componentsSettings })), React.createElement("div", { className: "recruitment--cell" }, components)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.unitInProgressTabularCell, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.components.menuListElementButtonAction, function(componentsEngine, utilsDateTime, servicesTheme, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { upgradeObject: null, unitObject: null, habitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var componentsSettings, unitInProgress = settings.unitInProgress.inProgressModel, components = [], isInstantFinishingAvailable = unitInProgress.isLessThanHalfConstructionTimeRemain(), themeIcon = servicesTheme.themeSettings.imagesClassNames, unitRecruitmentIcons = themeIcon.units;
      return components.push(React.createElement("div", { className: "complete" }, utilsDateTime.remainTime(unitInProgress.complete))), components.push(React.createElement("div", null, unitInProgress.unitsLeft)), componentsSettings = {
        icon: "white " + (isInstantFinishingAvailable ? unitRecruitmentIcons.recruitFinish : unitRecruitmentIcons.recruitSpeedUp),
        onClick: settings.initialComponent.onSpeedUpClick.bind(settings.initialComponent, {
          unitInProgress: unitInProgress,
          habitat: settings.habitat,
          unit: settings.unitInProgress.unitModel
        })
      }, components.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: componentsSettings })), React.createElement("div", { className: "recruitment--cell" }, components)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.resourceIconAmount, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { icon: "", amount: 0, classes: "", percent: "", showFill: !0, onClick: null }, amountClass = "";
      Object.assign(settings, this.props.settings);
      var classes = "icon-amount--widget ";
      return settings.showFill && (amountClass = settings.percent > 99 ? "full" : settings.percent > 79 ? "almost-full" : "good"), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, React.createElement("div", { className: "icon icon-resource " + settings.icon }), React.createElement("div", { className: "amount " + amountClass }, settings.amount))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.resourceProgressBar, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var progressBarrClass, settings = { icon: "", amount: 0, percent: 0, classes: "" };
      Object.assign(settings, this.props.settings);
      var classes = "resource-progress-bar--widget ";
      return progressBarrClass = settings.percent > 99 ? "full" : settings.percent > 79 ? "almost-full" : "good", React.createElement("div", { className: classes + settings.classes }, React.createElement("div", { className: "icon resource-progress-bar--icon icon-resource " + settings.icon }), React.createElement("div", { className: "resource-progress-bar--values-box" }, React.createElement("div", { className: "resource-progress-bar--amount" }, settings.amount), React.createElement("div", { className: "resource-progress-bar--bar-wrapper " + progressBarrClass }, React.createElement("div", {
        className: "resource-progress-bar--bar",
        style: { width: settings.percent + "%" }
      }))))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.tapBarHabitatType, [xy.dNames.componentsEngine, xy.dNames.utils.object, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuTapBar, function(componentEngine, utilsObject, servicesTheme, servicesInternationalization, ComponentsMenuTapBar) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        tabMode: 0,
        availableHabitatTypes: {},
        classes: "",
        tabWithIcon: !1,
        initialComponent: null,
        onBarButtonClick: null
      };
      Object.assign(settings, this.props.settings);
      var tapBarSettings, originalThis = settings.initialComponent, tapBar = null, themeHabitatNameByType = servicesTheme.themeSettings.habitat.publicHabitatTypeNames, themeHabitatTabBarIconsByType = servicesTheme.themeSettings.imagesClassNames.habitat.habitatTabBarByType;
      if (utilsObject.length(settings.availableHabitatTypes) > 1) {
        var habitatType, buttonSettings, buttons = [];
        for (habitatType in settings.availableHabitatTypes)settings.availableHabitatTypes.hasOwnProperty(habitatType) && settings.availableHabitatTypes[habitatType] && (buttonSettings = {
          isActive: +habitatType === settings.tabMode,
          onClick: settings.onBarButtonClick.bind(originalThis, +habitatType)
        }, settings.tabWithIcon ? buttonSettings.icon = themeHabitatTabBarIconsByType[habitatType] : buttonSettings.title = servicesInternationalization.localize(themeHabitatNameByType[habitatType]), buttons.push(buttonSettings));
        tapBarSettings = {
          buttons: buttons,
          classes: settings.classes
        }, tapBar = React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings })
      }
      return tapBar
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.tabularCell, [xy.dNames.componentsEngine, function(componentsEngine) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { classes: "", value: null };
      Object.assign(settings, this.props.settings);
      var classes = "tabular-cell " + settings.classes;
      return React.createElement("div", { className: classes }, settings.value)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.changeGroupingDirectionTabularHeader, [xy.dNames.componentsEngine, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.components.buttonMain, function(componentsEngine, utilsObject, settingsGameConstant, servicesTheme, ComponentsButtonMain) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        initialComponent: null,
        activeDirection: settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET
      };
      Object.assign(settings, this.props.settings);
      var buttonSettings, originalThis = settings.initialComponent, themeIconSettings = servicesTheme.themeSettings.imagesClassNames, classes = "tabular-header--grouping-direction " + settings.classes, rows = [];
      return buttonSettings = {
        icon: themeIconSettings.controls.targetIn,
        classes: "button--tabular--header--th",
        onClick: originalThis.onTargetInDirectionGroupingButtonClick.bind(originalThis, settings.tabIndex),
        isDisabled: settings.activeDirection === settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET
      }, rows.push(React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button-collapse-all"
      })), buttonSettings = {
        icon: themeIconSettings.controls.targetOut,
        classes: "button--tabular--header--th",
        onClick: originalThis.onTargetOutDirectionGroupingButtonClick.bind(originalThis, settings.tabIndex),
        isDisabled: settings.activeDirection === settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET
      }, rows.push(React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button-extend-all"
      })), React.createElement("div", { className: classes }, rows)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.tabularRow, [xy.dNames.componentsEngine, xy.dNames.components.tabularCell, function(componentsEngine, ComponentsTabularCell) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { classes: "", isExtended: !1, cells: [] };
      Object.assign(settings, this.props.settings);
      var classes = "tabular-row size-" + settings.cells.length + " " + settings.classes, cells = [];
      return settings.isExtended && (classes += "extended"), settings.cells.forEach(function(cell, index) {
        cells.push(React.createElement(ComponentsTabularCell, { settings: cell, key: "tabular-cell-index-" + index }))
      }, this), React.createElement("div", { className: classes }, cells)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.tabularRowHeader, [xy.dNames.componentsEngine, xy.dNames.components.tabularRow, function(componentsEngine, ComponentsTabularRow) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { classes: "", cells: [] };
      Object.assign(settings, this.props.settings);
      var headerSettings = { classes: "tabular-header ", cells: settings.cells };
      return React.createElement(ComponentsTabularRow, { settings: headerSettings })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.tabular, [xy.dNames.componentsEngine, xy.dNames.components.tabularRow, xy.dNames.components.menuListTextBasic, function(componentsEngine, ComponentsTabularRow, ComponentsMenuListTextBasic) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { classes: "", header: [], rows: [], emptyText: "Nothing to show" };
      Object.assign(settings, this.props.settings);
      var emptySettings, classes = "tabular " + settings.classes, rows = [];
      return rows.push(React.createElement(ComponentsTabularRow, {
        settings: settings.header,
        key: "tabular-header"
      })), settings.rows.length ? settings.rows.forEach(function(row, index) {
        rows.push(React.createElement(ComponentsTabularRow, { settings: row, key: "tabular-row-index-" + index }))
      }, this) : (emptySettings = { text: settings.emptyText }, rows.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: emptySettings,
        key: "tabular-row-empty"
      }))), React.createElement("div", { className: classes }, rows)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.toggleAllTabularHeader, [xy.dNames.componentsEngine, xy.dNames.utils.object, xy.dNames.services.theme, xy.dNames.components.buttonMain, function(componentsEngine, utilsObject, servicesTheme, ComponentsButtonMain) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { classes: "", initialComponent: null, extendableHabitatsLength: 0 };
      Object.assign(settings, this.props.settings);
      var buttonSettings, initialState = settings.initialComponent.state, themeIconSettings = servicesTheme.themeSettings.imagesClassNames, classes = "tabular-header--toggle-all-section " + settings.classes, rows = [];
      return buttonSettings = {
        icon: themeIconSettings.controls.arrowRight,
        classes: "button--tabular--header--th",
        onClick: settings.initialComponent.onCollapseAllClick,
        isDisabled: 0 === utilsObject.effectiveLength(initialState.extendedHabitats)
      }, rows.push(React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button-collapse-all"
      })), buttonSettings = {
        icon: themeIconSettings.controls.arrowDown,
        classes: "button--tabular--header--th",
        onClick: settings.initialComponent.onExtendAllClick,
        isDisabled: utilsObject.effectiveLength(initialState.extendedHabitats) === settings.extendableHabitatsLength
      }, rows.push(React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button-extend-all"
      })), React.createElement("div", { className: classes }, rows)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.habitatTypesTabularHeader, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.components.tapBarHabitatType, function(componentsEngine, settingsGameConstant, ComponentsTabBarHabitatType) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        tabMode: settingsGameConstant.HABITAT_TYPE.CASTLE,
        availableHabitatTypes: {},
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var tapBarSettings;
      return tapBarSettings = {
        tabMode: settings.tabMode,
        availableHabitatTypes: settings.availableHabitatTypes,
        onBarButtonClick: settings.initialComponent.onBarButtonClick,
        initialComponent: settings.initialComponent,
        tabWithIcon: !0,
        classes: "tabular-header--habitat-types"
      }, React.createElement(ComponentsTabBarHabitatType, { settings: tapBarSettings })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetAllianceRelationBadge, [xy.dNames.componentsEngine, xy.dNames.components.icon, xy.dNames.services.gameDataManager, xy.dNames.settings.gameConstant, function(componentEngine, ComponentsIcon, servicesGameDataManager, settingsGameConstant) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { relation: null, allianceId: null, playerId: null, habitatId: null, classes: "", onClick: null };
      Object.assign(settings, this.props.settings);
      var relationCod, classes = "alliance-relationship--widget ", iconSettings = {};
      return settings.playerId && (servicesGameDataManager.playersCollection.isCurrentPlayer(settings.playerId) ? relationCod = settingsGameConstant.ALLIANCE_RELATIONSHIPS.PLAYER : settings.allianceId = servicesGameDataManager.playersCollection.getPLayersAlliance(settings.playerId)), settings.allianceId && (relationCod = servicesGameDataManager.alliancesCollection.getAllianceRelationship(settings.allianceId)), settings.relation && (relationCod = settings.relation), relationCod || (relationCod = settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALL), iconSettings.icon = "icon-alliance-relationship relationship-" + relationCod, React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, React.createElement(ComponentsIcon, { settings: iconSettings }))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetAlliancePermissionBadges, [xy.dNames.componentsEngine, xy.dNames.components.menuListElementBasic, xy.dNames.components.icon, xy.dNames.settings.gameConstant, function(componentEngine, ComponentsMenuListElementBasic, ComponentsIcon, settingsGameConstant) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { permission: 0, classes: "", onClick: null };
      Object.assign(settings, this.props.settings);
      var menuElementSettings, classes = "alliance-permission--widget " + settings.classes, iconSettings = {}, iconsSet = [];
      if (settings.permission) {
        var rights = [settingsGameConstant.ALLIANCE_PERMISSION.INVITE_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.MASS_MAIL, settingsGameConstant.ALLIANCE_PERMISSION.MODERATE_FORUM, settingsGameConstant.ALLIANCE_PERMISSION.DIPLOMATIC_RELATIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISMISS_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.PLAYER_PERMISSIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISBAND_ALLIANCE], isLeader = settings.permission === settingsGameConstant.ALLIANCE_PERMISSION.MAX || settings.permission === settingsGameConstant.ALLIANCE_PERMISSION.ALL;
        rights.forEach(function(mask) {
          (isLeader || settings.permission & mask) && (iconSettings = { icon: "icon-permission permission-" + mask }, iconsSet.push(React.createElement(ComponentsIcon, {
            settings: iconSettings,
            key: "permission-icon-" + mask
          })))
        })
      } else iconSettings = { icon: "icon-permission  permission-0" }, iconsSet.push(React.createElement(ComponentsIcon, {
        settings: iconSettings,
        key: "permission-icon"
      }));
      return menuElementSettings = {
        title: iconsSet,
        classes: classes
      }, settings.onClick && (menuElementSettings.onClick = settings.onClick, menuElementSettings.iconRight = "controls menu-next"), React.createElement(ComponentsMenuListElementBasic, { settings: menuElementSettings })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetAlliancePermissionList, [xy.dNames.componentsEngine, xy.dNames.components.menuListElementBasic, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, function(componentEngine, ComponentsMenuListElementBasic, settingsGameConstant, servicesInternationalization, servicesTheme) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { permission: 0, classes: "", onClick: null };
      Object.assign(settings, this.props.settings);
      var list = [], rights = [settingsGameConstant.ALLIANCE_PERMISSION.INVITE_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.MASS_MAIL, settingsGameConstant.ALLIANCE_PERMISSION.MODERATE_FORUM, settingsGameConstant.ALLIANCE_PERMISSION.DIPLOMATIC_RELATIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISMISS_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.PLAYER_PERMISSIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISBAND_ALLIANCE], isLeader = settings.permission === settingsGameConstant.ALLIANCE_PERMISSION.MAX || settings.permission === settingsGameConstant.ALLIANCE_PERMISSION.ALL;
      return rights.forEach(function(mask) {
        var settingPermission = {
          iconLeft: "icon-permission permission-" + mask,
          title: servicesInternationalization.localize(servicesTheme.themeSettings.alliancePermissionsName[mask])
        };
        (isLeader || settings.permission & mask) && (settingPermission.iconRight = "controls menu-accept"), list.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: settingPermission,
          key: "permission-in-list-" + mask
        }))
      }), React.createElement("div", null, list)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetAllianceInvitation, [xy.dNames.componentsEngine, xy.dNames.components.menuListElementBasic, xy.dNames.components.buttonMain, function(componentEngine, ComponentsMenuListElementBasic, ComponentsButtonMain) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", allianceName: "", onClick: null, handlerAccept: null, handlerReject: null };
      Object.assign(settings, this.props.settings);
      var buttonSettings, sectionComponentSettings, classes = "alliance-invitation--widget " + settings.classes, buttons = [];
      return buttonSettings = {
        onClick: settings.handlerAccept,
        classes: "button-in-menu-element-base",
        icon: "controls menu-accept"
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button-accept"
      })), buttonSettings = {
        onClick: settings.handlerReject,
        classes: "button-in-menu-element-base",
        icon: "controls menu-reject"
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: buttonSettings,
        key: "button-reject"
      })), sectionComponentSettings = {
        classes: classes,
        onClick: settings.onClick,
        iconLeft: "icon-game icon-ButtonAlliance",
        title: settings.allianceName,
        rightColumnDataValue: React.createElement("div", { key: "buttons-section" }, buttons)
      }, React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "widget-alliance-invitation"
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetContentText, [xy.dNames.componentsEngine, xy.dNames.utils.string, function(componentEngine, utilsString) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { content: null, executingComponent: null, classes: "" };
      Object.assign(settings, this.props.settings);
      var content = utilsString.getHTMLOfString(settings.content, settings.executingComponent);
      return React.createElement("div", { className: settings.classes }, React.createElement("div", { className: "element--content" }, content))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetBatchResourcesUnits, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.utils.object, xy.dNames.components.resourceIconAmount, xy.dNames.components.unitIconAmount, function(componentEngine, servicesInternationalization, servicesTheme, utilsObject, ComponentsResourceIconAmount, ComponentsUnitIconAmount) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        title: "",
        units: {},
        unitVariance: 1,
        resources: {},
        resourceVariance: 1,
        currentHabitat: {},
        onClick: null
      };
      Object.assign(settings, this.props.settings);
      var classes = "menu-list-element habitat-overview--widget ";
      settings.onClick && (classes += "clickable ");
      var title = null;
      settings.title && (title = React.createElement("div", { className: "habitat-overview-title summary" }, settings.title));
      var resourcesSettings, idResource, resourceAmount, resourceClasses, isEnoughParticularResource, localResourceDictionary, resources = [];
      for (idResource in settings.resources)settings.resources.hasOwnProperty(idResource) && (resourceAmount = settings.resources[idResource], resourceClasses = "dark", utilsObject.isEmpty(settings.currentHabitat) || (localResourceDictionary = {}, localResourceDictionary[idResource] = settings.resources[idResource], isEnoughParticularResource = settings.currentHabitat.hasEnoughResources(localResourceDictionary), isEnoughParticularResource || (resourceClasses = "not-enough")), 1 !== settings.resourceVariance && (resourceAmount = Math.floor(resourceAmount * settings.resourceVariance) + "-" + resourceAmount, resourceClasses += " widest"), resourcesSettings = {
        icon: "icon-resource-" + idResource,
        amount: resourceAmount,
        showFill: !1,
        classes: resourceClasses
      }, resources.push(React.createElement(ComponentsResourceIconAmount, {
        settings: resourcesSettings,
        key: "resource-" + idResource
      })));
      var unitSettings, unitId, unitAmount, unitClasses, isEnoughParticularUnit, localUnitsDictionary, units = [];
      for (unitId in settings.units)settings.units.hasOwnProperty(unitId) && (unitAmount = settings.units[unitId], unitClasses = "dark", utilsObject.isEmpty(settings.currentHabitat) || (localUnitsDictionary = {}, localUnitsDictionary[unitId] = settings.units[unitId], isEnoughParticularUnit = settings.currentHabitat.hasEnoughUnits(localUnitsDictionary), isEnoughParticularUnit || (unitClasses = "not-enough")), 1 !== settings.unitVariance && (unitAmount = Math.floor(unitAmount * settings.unitVariance) + "-" + unitAmount, unitClasses += " widest"), unitSettings = {
        icon: "icon-unit-" + unitId,
        amount: unitAmount,
        classes: unitClasses
      }, units.push(React.createElement(ComponentsUnitIconAmount, { settings: unitSettings, key: "unit-" + unitId })));
      var resourceRow = null, unitsRow = null;
      return resources.length && (resourceRow = React.createElement("div", { className: "habitat-overview-row" }, resources)), units.length && (unitsRow = React.createElement("div", { className: "habitat-overview-row" }, units)), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, title, resourceRow, unitsRow)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetRangeSlider, [xy.dNames.componentsEngine, xy.dNames.services.eventManager, xy.dNames.components.menuListTitleBasic, xy.dNames.components.buttonMain, function(componentEngine, servicesEventManager, ComponentsMenuListTitleBasic, ComponentsButtonMain) {
  "use strict";
  function maxmin(pos, min, max) {
    return pos < min ? min : pos > max ? max : pos
  }

  return componentEngine.createClass({
    currentValue: null, getInitialState: function() {
      return { rightLimitForHandler: 0 }
    }, componentDidMount: function() {
      var setLimits = function() {
        var slider = componentEngine.findDOMNode(this.refs.slider);
        this.setState({ rightLimitForHandler: slider.offsetWidth }, null)
      }.bind(this);
      setLimits()
    }, onIncreaseClick: function(event) {
      event.preventDefault();
      var value;
      this.props.settings.currentValue < this.props.settings.maxValue && (value = this.props.settings.currentValue + 1, this.updateValue(value), setTimeout(function() {
        servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.rangeSliderIncreaseButtonClick, { value: value })
      }.bind(this), 100))
    }, onDecreaseClick: function(event) {
      event.preventDefault(), this.props.settings.currentValue > this.props.settings.minValue && this.updateValue(this.props.settings.currentValue - 1)
    }, onMouseLeave: function(event) {
      this.handleDragEnd(event)
    }, onRangeClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var target = event.currentTarget, offsetLeft = target.offsetLeft, offsetLeftParent = target.offsetParent && target.offsetParent.offsetLeft ? target.offsetParent.offsetLeft : 0, absoluteX = event.clientX, pos = absoluteX - offsetLeft - offsetLeftParent, newValue = this.getValueFromPosition(pos);
      this.updateValue(newValue)
    }, onHandleMouseDown: function(event) {
      event.preventDefault(), event.stopPropagation(), document.addEventListener("mousemove", this.handleDrag), document.addEventListener("mouseup", this.handleDragEnd)
    }, handleDrag: function(event) {
      this.props.settings.handleDragStart && this.props.settings.handleDragStart();
      var pos = this.getPositionAfterMoving(event), value = this.getValueFromPosition(pos);
      this.updateValue(value)
    }, handleDragEnd: function() {
      this.props.settings.handleDragEnd && this.props.settings.handleDragEnd(), document.removeEventListener("mousemove", this.handleDrag), document.removeEventListener("mouseup", this.handleDragEnd)
    }, updateValue: function(newValue) {
      this.props.settings.onChange(newValue), setTimeout(function() {
        servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.rangeSliderSetValue, { value: newValue })
      }.bind(this), 100)
    }, acceptValue: function() {
      this.props.settings.acceptButtonCallBack();
      var value = this.props.settings.currentValue;
      setTimeout(function() {
        servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.rangeSliderAcceptButtonClick, { value: value })
      }.bind(this), 100)
    }, getPositionAfterMoving: function(event) {
      var slider, coordinate, direction;
      return slider = componentEngine.findDOMNode(this.refs.slider), coordinate = event.clientX, direction = slider.getBoundingClientRect().left, coordinate - direction
    }, getPositionFromValue: function(value) {
      var percentage, pos, limit = this.state.rightLimitForHandler, minValue = this.props.settings.minValue, maxValue = this.props.settings.maxValue;
      return percentage = (value - minValue) / (maxValue - minValue), pos = Math.round(percentage * limit)
    }, getValueFromPosition: function(pos) {
      var percentage, limit = this.state.rightLimitForHandler, minValue = this.props.settings.minValue, maxValue = this.props.settings.maxValue, step = 1;
      return percentage = maxmin(pos, 0, limit) / (limit || 1), step * Math.round(percentage * (maxValue - minValue) / step) + minValue
    }, coordinates: function(pos) {
      var value, fillPos, handlePos;
      return value = this.getValueFromPosition(pos), handlePos = this.getPositionFromValue(value), fillPos = handlePos, {
        fill: fillPos,
        handle: handlePos
      }
    }, render: function() {
      var settings = {
        title: null,
        classes: "",
        handleIcon: null,
        currentValue: 1,
        minValue: 0,
        maxValue: 100,
        showButtons: !0,
        showAcceptButton: !1,
        acceptButtonIcon: null,
        acceptButtonCallBack: null,
        handleDragEnd: null,
        handleDragStart: null,
        onChange: null
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, classes = "menu-list-element widget--range-slider ", title = null;
      settings.title && (componentSettings = { title: settings.title }, title = React.createElement(ComponentsMenuListTitleBasic, {
        settings: componentSettings,
        key: "widget-range-slider-title"
      }));
      var handleClassName = "widget-range-slider--handle ";
      handleClassName += settings.handleIcon ? "icon " + settings.handleIcon : "basic", classes += settings.classes;
      var buttons = null;
      settings.showButtons && (buttons = [], componentSettings = {
        title: "-",
        onClick: this.onDecreaseClick
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: componentSettings,
        key: "widget-range-slider-decrease-button"
      })), settings.showAcceptButton && (componentSettings = {
        classes: "menu-element--button--action range-slider-accept-value--button ",
        icon: "white " + settings.acceptButtonIcon,
        onClick: this.acceptValue
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: componentSettings,
        key: "widget-range-slider-accept-button"
      }))), componentSettings = {
        classes: "range-slider-increase-value--button",
        title: "+",
        onClick: this.onIncreaseClick
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: componentSettings,
        key: "widget-range-slider-increase-button"
      })));
      var currentValue = this.currentValue || settings.currentValue, position = this.getPositionFromValue(currentValue), coordinates = this.coordinates(position), fillStyle = { width: coordinates.fill + "px" }, handleStyle = { left: coordinates.handle + "px" }, element = React.createElement("div", {
        className: classes,
        key: "widget-range-slider"
      }, React.createElement("div", { className: "widget-range-slider--values-row" }, React.createElement("div", { className: "value min-value" }, settings.minValue), React.createElement("div", {
        ref: "current-value",
        className: "widget-range-slider--current-value"
      }, settings.currentValue), React.createElement("div", { className: "value max-value" }, settings.maxValue)), React.createElement("div", {
        ref: "slider",
        className: "widget-range-slider--body",
        onClick: this.onRangeClick
      }, React.createElement("div", {
        ref: "fill",
        className: "widget-range-slider--fill",
        style: fillStyle
      }), React.createElement("div", {
        ref: "handle",
        className: handleClassName,
        onMouseDown: this.onHandleMouseDown,
        style: handleStyle
      })), React.createElement("div", { className: "widget-range-slider--buttons-row" }, buttons));
      return React.createElement("div", { onMouseLeave: this.onMouseLeave }, title, element)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetRangeSliderDivider, [xy.dNames.componentsEngine, xy.dNames.services.eventManager, xy.dNames.components.menuListTitleBasic, xy.dNames.components.buttonMain, function(componentEngine, servicesEventManager, ComponentsMenuListTitleBasic, ComponentsButtonMain) {
  "use strict";
  function maxmin(pos, min, max) {
    return pos < min ? min : pos > max ? max : pos
  }

  return componentEngine.createClass({
    currentValue: null, getInitialState: function() {
      return { rightLimitForHandler: 0 }
    }, componentDidMount: function() {
      var setLimits = function() {
        var slider = componentEngine.findDOMNode(this.refs.slider);
        this.setState({ rightLimitForHandler: slider.offsetWidth }, null)
      }.bind(this);
      setLimits()
    }, onMouseLeave: function(event) {
      this.handleDragEnd(event)
    }, onIncreaseClick: function(event) {
      event.preventDefault();
      var step = this.props.settings.changeStepValue || 1, newValue = this.props.settings.currentValue + step;
      newValue <= this.props.settings.maxValue && (this.updateValue(newValue), setTimeout(function() {
        servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.rangeSliderIncreaseButtonClick, {
          filter: this.specializedClass,
          value: newValue
        })
      }.bind(this), 100))
    }, onDecreaseClick: function(event) {
      event.preventDefault();
      var step = this.props.settings.changeStepValue || 1, newValue = this.props.settings.currentValue - step;
      newValue >= this.props.settings.minValue && this.updateValue(newValue)
    }, onRangeClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var target = event.currentTarget, offsetLeft = target.offsetLeft, offsetLeftParent = target.offsetParent && target.offsetParent.offsetLeft ? target.offsetParent.offsetLeft : 0, absoluteX = event.clientX, pos = absoluteX - offsetLeft - offsetLeftParent, newValue = this.getValueFromPosition(pos);
      this.updateValue(newValue)
    }, onHandleMouseDown: function(event) {
      event.preventDefault(), event.stopPropagation(), document.addEventListener("mousemove", this.handleDrag), document.addEventListener("mouseup", this.handleDragEnd)
    }, handleDrag: function(event) {
      var pos = this.getPositionAfterMoving(event), value = this.getValueFromPosition(pos);
      this.updateValue(value)
    }, handleDragEnd: function() {
      document.removeEventListener("mousemove", this.handleDrag), document.removeEventListener("mouseup", this.handleDragEnd)
    }, updateValue: function(newValue) {
      var mod, step = this.props.settings.changeStepValue || 1, limit = this.props.settings.maxLimitOnCurrentValue;
      limit >= this.props.settings.minValue && newValue > limit && (newValue = limit), mod = newValue % step, newValue -= mod, newValue < this.props.settings.minValue ? newValue = this.props.settings.minValue : newValue > this.props.settings.maxValue && (newValue = this.props.settings.maxValue), this.props.settings.onChange(newValue), setTimeout(function() {
        servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.rangeSliderSetValue, {
          filter: this.specializedClass,
          value: newValue
        })
      }.bind(this), 100)
    }, acceptValue: function() {
      this.props.settings.acceptButtonCallBack(), setTimeout(function() {
        servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.rangeSliderAcceptButtonClick, {
          filter: this.specializedClass,
          value: this.props.settings.currentValue
        })
      }.bind(this), 100)
    }, getPositionAfterMoving: function(event) {
      var slider, coordinate, direction;
      return slider = componentEngine.findDOMNode(this.refs.slider), coordinate = event.clientX, direction = slider.getBoundingClientRect().left, coordinate - direction
    }, getPositionFromValue: function(value) {
      var percentage, pos, limit = this.state.rightLimitForHandler, minValue = this.props.settings.minValue, maxValue = this.props.settings.maxValue;
      return percentage = (value - minValue) / (maxValue - minValue), pos = Math.round(percentage * limit)
    }, getValueFromPosition: function(pos) {
      var percentage, limit = this.state.rightLimitForHandler, minValue = this.props.settings.minValue, maxValue = this.props.settings.maxValue, step = 1;
      return percentage = maxmin(pos, 0, limit) / (limit || 1), step * Math.round(percentage * (maxValue - minValue) / step) + minValue
    }, coordinates: function(pos) {
      var value, fillPos, handlePos;
      return value = this.getValueFromPosition(pos), handlePos = this.getPositionFromValue(value), fillPos = handlePos, {
        fill: fillPos,
        handle: handlePos
      }
    }, render: function() {
      var settings = {
        title: null,
        classes: "",
        handleIcon: null,
        currentValue: 1,
        minValue: 0,
        maxValue: 100,
        disabled: !1,
        maxLimitOnCurrentValue: null,
        onChange: null
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, classes = "menu-list-element widget--range-slider divider-slider ";
      settings.disabled && (classes += "unclickable ");
      var handleClassName = "widget-range-slider--handle ";
      handleClassName += settings.handleIcon ? "icon " + settings.handleIcon : "basic", classes += settings.classes;
      var topRow, currentValue = this.currentValue || settings.currentValue, topRowElements = [];
      this.specializedClass = ("specialized--" + settings.handleIcon).replace(/\s/g, ""), componentSettings = {
        title: settings.maxValue - currentValue,
        onClick: this.onDecreaseClick
      }, topRowElements.push(React.createElement(ComponentsButtonMain, {
        settings: componentSettings,
        key: "widget-range-slider-decrease-button"
      })), topRowElements.push(React.createElement("div", { key: "widget-range-slider-title" }, settings.title)), componentSettings = {
        classes: "button-increase--" + this.specializedClass,
        title: settings.minValue + currentValue,
        onClick: this.onIncreaseClick
      }, topRowElements.push(React.createElement(ComponentsButtonMain, {
        settings: componentSettings,
        key: "widget-range-slider-increase-button"
      })), topRow = React.createElement("div", { className: "widget-range-slider--buttons-row divider-row" }, topRowElements);
      var position = this.getPositionFromValue(currentValue), coordinates = this.coordinates(position), fillStyle = { width: coordinates.fill + "px" }, handleStyle = { left: coordinates.handle + "px" }, element = React.createElement("div", {
        className: classes,
        key: "widget-range-slider divider-slider"
      }, React.createElement("div", null, topRow), React.createElement("div", {
        ref: "slider",
        className: "widget-range-slider--body",
        onClick: this.onRangeClick
      }, React.createElement("div", {
        ref: "fill",
        className: "widget-range-slider--fill",
        style: fillStyle
      }), React.createElement("div", {
        ref: "handle",
        className: handleClassName,
        onMouseDown: this.onHandleMouseDown,
        style: handleStyle
      })));
      return React.createElement("div", { onMouseLeave: this.onMouseLeave }, element)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetResourcesList, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, servicesInternationalization, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { resourcesDictionary: {}, classes: "" };
      Object.assign(settings, this.props.settings);
      var id, componentSettings, list = [];
      for (id in settings.resourcesDictionary)settings.resourcesDictionary.hasOwnProperty(id) && (componentSettings = {
        title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[id]),
        iconLeft: "icon-resource icon-resource-" + id,
        rightColumnDataValue: settings.resourcesDictionary[id]
      }, list.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: componentSettings,
        key: "menu-resource-in-list-" + id
      })));
      return React.createElement("div", null, list)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetUnitsList, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.menuListElementBasic, function(componentEngine, servicesInternationalization, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        initialComponent: null,
        unitsList: [],
        classes: "",
        showDescriptionOnClick: !0,
        habitatId: null,
        habitatUnit: null,
        onClick: null
      };
      Object.assign(settings, this.props.settings);
      var list = [];
      return settings.unitsList.forEach(function(unitEntry) {
        var onClick = settings.onClick || settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
                  next: xy.dNames.game.menuUnitOverview.name,
                  options: { habitatUnit: settings.habitatUnit, habitatId: settings.habitatId, unit: unitEntry.unit }
                }), unitSettings = {
          title: servicesInternationalization.localize(unitEntry.unit.identifier),
          iconLeft: "icon-unit icon-unit-" + unitEntry.unit.primaryKey,
          iconRight: "controls menu-next",
          onClick: onClick
        };
        unitEntry.amount && (unitSettings.rightColumnDataValue = unitEntry.amount), unitEntry.habitatUnit && (unitSettings.rightColumnDataValue = unitEntry.habitatUnit.amount), list.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: unitSettings,
          key: "menu-unit-in-list-" + unitEntry.unit.primaryKey
        }))
      }, this), React.createElement("div", null, list)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetRename, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.components.inputTextField, xy.dNames.components.alertTooltip, xy.dNames.components.menuListElementButtonAction, function(componentEngine, settingsGameConstant, servicesInternationalization, ComponentsInputTextField, ComponentsAlertTooltip, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceNextRedrawUpdate || newProps.settings.habitat && newProps.settings.habitat.id !== this.props.settings.habitat.id) && this.setState({
        isEditingMode: !1,
        isErrorVisible: !1,
        errorMessage: null,
        name: "",
        isButtonActive: !1,
        isStateValuesActive: !1,
        clearedErrorOnLoading: !1
      }, null)
    }, getInitialState: function() {
      return {
        isEditingMode: !1,
        isErrorVisible: !1,
        errorMessage: null,
        name: "",
        isButtonActive: !1,
        isStateValuesActive: !1,
        clearedErrorOnLoading: !1
      }
    }, onEditClick: function() {
      this.setState({
        isEditingMode: !0, isErrorVisible: !1, errorMessage: null, name: "", isButtonActive: !1, isStateValuesActive: !1
      }, null)
    }, onCancelClick: function() {
      this.setState({
        isEditingMode: !1,
        isErrorVisible: !1,
        errorMessage: null,
        name: "",
        isButtonActive: !1,
        isStateValuesActive: !1
      }, null)
    }, onSubmitClick: function(event) {
      event.preventDefault();
      var value = this.state.name, isValidationPassed = this.validate(value), originalThis = this.props.settings.initialComponent;
      value && value !== this.props.settings.name ? isValidationPassed && (this.props.settings.onSubmitAction.call(originalThis, value), this.onCancelClick()) : this.onCancelClick()
    }, onInputFocus: function(event) {
      event.preventDefault();
      var value = event.target.value;
      this.setState({ isErrorVisible: !1, name: value, isStateValuesActive: !0, clearedErrorOnLoading: !0 }, null)
    }, onInputChange: function(event) {
      event.preventDefault();
      var value = event.target.value, isValidationPassed = this.validate(value);
      this.setState({
        isErrorVisible: !isValidationPassed,
        errorMessage: this.getErrorMessage(value),
        isButtonActive: isValidationPassed,
        name: value
      }, null)
    }, onInputBlur: function(event) {
      event.preventDefault();
      var value = event.target.value, isValidationPassed = this.validate(value);
      isValidationPassed || this.setState({
        isErrorVisible: !0,
        errorMessage: this.getErrorMessage(value),
        isButtonActive: !1,
        value: value
      }, null)
    }, validate: function(value) {
      var validatingString = value.replace(/\s/g, ""), length = validatingString.length;
      return length <= this.props.settings.maxLength && length >= this.props.settings.minLength
    }, getErrorMessage: function(value) {
      var validatingString = value.replace(/\s/g, ""), length = validatingString.length;
      return length > this.props.settings.maxLength ? servicesInternationalization.localize("The name is too long") : length < this.props.settings.minLength ? servicesInternationalization.localize("The name is too short") : null
    }, render: function() {
      var settings = {
        classes: "",
        name: "",
        onSubmitAction: null,
        initialComponent: null,
        removeSpaces: !0,
        alertPosition: "top",
        errorOnLoading: null,
        possibleNames: [],
        minLength: 0,
        maxLength: 0,
        forceNextRedrawUpdate: !1,
        habitat: null
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, activeName, localComponent, state = this.state, components = [], error = null;
      if (state.isStateValuesActive ? (activeName = state.name, error = state.isErrorVisible && state.errorMessage ? state.errorMessage : null) : (activeName = settings.name, error = state.clearedErrorOnLoading ? null : settings.errorOnLoading), state.isEditingMode)error && (componentSettings = {
        status: "in",
        position: settings.alertPosition,
        text: error
      }, components.push(React.createElement(ComponentsAlertTooltip, {
        settings: componentSettings,
        key: "error-tooltip"
      }))), localComponent = React.createElement("input", {
        className: "widget-rename-item component--input",
        onFocus: this.onInputFocus,
        onChange: this.onInputChange,
        onBlur: this.onInputBlur,
        value: activeName,
        key: "input-text-name"
      }), components.push(localComponent), componentSettings = {
        icon: "controls menu-accept",
        onClick: this.onSubmitClick,
        isDisabled: !state.isButtonActive
      }, components.push(React.createElement(ComponentsMenuListElementButtonAction, {
        settings: componentSettings,
        key: "accept-button"
      })), componentSettings = {
        icon: "controls menu-reject",
        onClick: this.onCancelClick
      }, components.push(React.createElement(ComponentsMenuListElementButtonAction, {
        settings: componentSettings,
        key: "reject-button"
      })); else {
        var maxChar = 200 / settingsGameConstant.CHARACTER_SIZE, actualChar = activeName.length, fontSize = "1em";
        actualChar > maxChar && (fontSize = (maxChar / actualChar).toFixed(1) + "em"), localComponent = React.createElement("div", {
          className: "widget-rename-item text ",
          style: { fontSize: fontSize },
          key: "plane-text-name"
        }, activeName), components.push(localComponent), componentSettings = {
          icon: "controls menu-bar-edit",
          onClick: this.onEditClick
        }, components.push(React.createElement(ComponentsMenuListElementButtonAction, {
          settings: componentSettings,
          key: "edit-button"
        }))
      }
      return React.createElement("div", { className: "widget-rename form-component" }, components)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetSupportBridgeRound, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, settingsGameConstant, utilsDateTime, servicesInternationalization, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    onEditClick: function() {
      var settings = this.props.settings, state = +settings.state, isForeignerMode = settings.isForeignerMode || !1, newState = state >= 2 ? 0 : state + 1;
      isForeignerMode && 2 === state || (isForeignerMode && 2 === newState && (newState = 0), settings.onChange(newState))
    }, render: function() {
      var settings = {
        round: 0,
        date: null,
        state: 2,
        initialComponent: null,
        onChange: null,
        affectedHabitat: null,
        isForeignerMode: !1
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, originalThis = settings.initialComponent, components = [], iconSB = servicesTheme.themeSettings.imagesClassNames.featureSupportBridge;
      return componentSettings = {
        iconLeft: iconSB["round-" + settings.state],
        title: servicesInternationalization.localize("Battle round %1$ld", settings.round),
        description: utilsDateTime.getLocaleDateTimeString(settings.date),
        onClick: this.onEditClick
      }, settings.isForeignerMode && 2 !== settings.state && (componentSettings.iconRight = iconSB.support, componentSettings.iconRightIsButton = !0, componentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuHabitatSendUnitsResources.name,
        options: {
          attackingHabitat: settings.affectedHabitat,
          mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT
        }
      })), components.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: componentSettings,
        key: "widget-sb-round"
      })), React.createElement("div", null, components)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetTimeDurationPicker, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.inputTextField, xy.dNames.components.alertTooltip, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.buttonMain, function(componentEngine, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsInputTextField, ComponentsAlertTooltip, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementButtonAction, ComponentsButtonMain) {
  "use strict";
  return componentEngine.createClass({
    componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getInitialWidgetSettings(newProps), null)
    }, getInitialWidgetSettings: function(props) {
      return {
        isEditingMode: !1,
        hours: props.settings.currentHours,
        minutes: props.settings.currentMinutes,
        seconds: props.settings.currentSeconds
      }
    }, getInitialState: function() {
      return this.getInitialWidgetSettings(this.props)
    }, onEditModeClick: function() {
      this.setState({ isEditingMode: !0 }, null)
    }, onCancelClick: function() {
      this.setState(this.getInitialWidgetSettings(this.props), null)
    }, onSubmitClick: function(event) {
      event.preventDefault();
      var options = { hours: this.state.hours, minutes: this.state.minutes, seconds: this.state.seconds };
      this.props.settings.onSubmit && this.props.settings.onSubmit(options)
    }, onHoursChange: function(max, event) {
      event.preventDefault();
      var value = +event.target.value, newState = {};
      value >= 0 && value <= max && (value === max && (newState.minutes = 0, newState.seconds = 0), newState.hours = value, this.setState(newState, null))
    }, onMinutesSecondsChange: function(state, max, event) {
      event.preventDefault();
      var value = +event.target.value, newState = {};
      value >= 0 && value < max && (newState[state] = value, this.setState(newState, null))
    }, render: function() {
      var settings = {
        classes: "",
        minString: "",
        maxString: "",
        maxHours: 72,
        currentHours: 0,
        currentMinutes: 0,
        currentSeconds: 0,
        onSubmit: null
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, localComponent, state = this.state, components = [], maxHours = settings.maxHours, maxMinutes = 60, maxSeconds = 60;
      if (state.isEditingMode) {
        componentSettings = {
          classes: "first",
          title: servicesInternationalization.localize("Transport duration")
        }, components.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: componentSettings,
          key: "transport-time-title"
        })), this.state.hours === maxHours && (maxMinutes = 0, maxSeconds = 0), components.push(React.createElement("div", {
          className: "form--component form--inline inline--center",
          key: "time-inputs"
        }, React.createElement("input", {
          value: this.state.hours,
          className: "component--input xs-width",
          type: "text",
          pattern: "\\d*",
          maxLength: "2",
          onChange: this.onHoursChange.bind(this, maxHours)
        }), React.createElement("input", {
          value: this.state.minutes,
          className: "component--input xs-width",
          type: "text",
          pattern: "\\d*",
          maxLength: "2",
          onChange: this.onMinutesSecondsChange.bind(this, "minutes", maxMinutes)
        }), React.createElement("input", {
          value: this.state.seconds,
          className: "component--input xs-width",
          type: "text",
          pattern: "\\d*",
          maxLength: "2",
          onChange: this.onMinutesSecondsChange.bind(this, "seconds", maxSeconds)
        }))), componentSettings = { text: "hh:mm:ss" }, components.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: componentSettings,
          key: "transport-time-description"
        })), componentSettings = { text: servicesInternationalization.localize("Minimum transport time %1$@", settings.minString) }, components.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: componentSettings,
          key: "transport-time-min"
        })), componentSettings = { text: servicesInternationalization.localize("Maximum transport time %1$@", settings.maxString) }, components.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: componentSettings,
          key: "transport-time-max"
        }));
        var buttons = [];
        componentSettings = {
          onClick: this.onCancelClick,
          title: servicesInternationalization.localize("cancel")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-cancel"
        })), componentSettings = {
          onClick: this.onSubmitClick,
          title: servicesInternationalization.localize("ok")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-ok"
        })), components.push(React.createElement("div", {
          className: "form--component form--inline inline--center",
          key: "time-submit"
        }, buttons))
      } else {
        var hours = settings.currentHours > 9 ? settings.currentHours : "0" + settings.currentHours, minutes = settings.currentMinutes > 9 ? settings.currentMinutes : "0" + settings.currentMinutes, second = settings.currentSeconds > 9 ? settings.currentSeconds : "0" + settings.currentSeconds, currentTime = hours + ":" + minutes + ":" + second;
        localComponent = {
          icon: "controls menu-bar-settings",
          onClick: this.onEditModeClick
        }, componentSettings = {
          classes: "first",
          iconLeft: servicesTheme.themeSettings.imagesClassNames.startTransit.transportTime,
          title: servicesInternationalization.localize("Transport duration"),
          rightColumnDataValue: currentTime,
          iconRight: React.createElement(ComponentsMenuListElementButtonAction, {
            settings: localComponent,
            key: "edit-button"
          })
        }, components.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: componentSettings,
          key: "transport-time"
        }))
      }
      return React.createElement("div", null, components)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetDateTimePicker, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.components.inputTextField, xy.dNames.components.alertTooltip, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.buttonMain, xy.dNames.components.icon, function(componentEngine, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesTheme, servicesLog, ComponentsInputTextField, ComponentsAlertTooltip, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementButtonAction, ComponentsButtonMain, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getInitialWidgetSettings(newProps), null)
    }, getInitialWidgetSettings: function(props) {
      var date = props.settings.currentDate || new Date, maxHours = props.settings.maxHours || 72, minDate = props.settings.minDate, maxDate = props.settings.maxDate;
      return minDate || (minDate = new Date), maxDate || (maxDate = new Date, maxDate.setTime(minDate.getTime()), maxDate.setHours(maxDate.getHours() + maxHours)), {
        isEditingMode: !1,
        date: date,
        minDate: minDate,
        maxDate: maxDate,
        dateString: null
      }
    }, getInitialState: function() {
      return this.getInitialWidgetSettings(this.props)
    }, onEditModeClick: function() {
      this.setState({ isEditingMode: !0 }, null)
    }, onCancelClick: function() {
      this.setState(this.getInitialWidgetSettings(this.props), null)
    }, onResetClick: function(event) {
      event.preventDefault(), this.props.settings.onReset && this.props.settings.onReset()
    }, onSubmitClick: function(event) {
      event.preventDefault(), this.props.settings.onSubmit && this.props.settings.onSubmit(this.state.date)
    }, onTimeChange: function(mode, measure, event) {
      event.preventDefault(), event.stopPropagation();
      var minutes, copyDate = new Date, currentDate = this.state.date, minDate = this.state.minDate, maxDate = this.state.maxDate;
      switch (copyDate.setTime(currentDate.getTime()), measure) {
        case"hour":
          minutes = 60;
          break;
        case"minute":
          minutes = 1
      }
      switch (mode) {
        case"up":
          copyDate.setMinutes(copyDate.getMinutes() + minutes);
          break;
        case"down":
          copyDate.setMinutes(copyDate.getMinutes() - minutes)
      }
      copyDate.getTime() < minDate.getTime() && copyDate.setTime(minDate.getTime()), copyDate.getTime() > maxDate.getTime() && copyDate.setTime(maxDate.getTime()), currentDate.getTime() !== copyDate.getTime() && this.setState({
        dateString: null,
        date: copyDate
      }, null)
    }, onDateChange: function(mode, event) {
      event.preventDefault(), event.stopPropagation();
      var copyDate = new Date, currentDate = this.state.date, minDate = this.state.minDate, maxDate = this.state.maxDate;
      switch (copyDate.setTime(currentDate.getTime()), mode) {
        case"up":
          copyDate.setDate(copyDate.getDate() + 1);
          break;
        case"down":
          copyDate.setDate(copyDate.getDate() - 1)
      }
      copyDate.getTime() < minDate.getTime() && copyDate.setTime(minDate.getTime()), copyDate.getTime() > maxDate.getTime() && copyDate.setTime(maxDate.getTime()), currentDate.getDate() !== copyDate.getDate() && this.setState({
        dateString: null,
        date: copyDate
      }, null)
    }, render: function() {
      var settings = {
        classes: "",
        isResetAvailable: !1,
        currentDate: null,
        onSubmit: null,
        onReset: null,
        isDisabled: !1
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, localComponent, upperIconClasses, lowerIconClasses, state = this.state, components = [], inputComponents = [], upperIconSettings = { icon: servicesTheme.themeSettings.imagesClassNames.buttonPageListing.up }, lowerIconSettings = { icon: servicesTheme.themeSettings.imagesClassNames.buttonPageListing.down };
      if (state.isEditingMode) {
        componentSettings = { title: servicesInternationalization.localize("Choose arrival time") }, components.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: componentSettings,
          key: "transport-time-title"
        }));
        var date, hours = state.date.getHours(), minutes = state.date.getMinutes();
        minutes < 10 && (minutes = "0" + minutes), hours < 10 && (hours = "0" + hours), date = state.dateString ? state.dateString : utilsDateTime.getDateHTML5InputFormat(state.date);
        var dateCanBeIncreased = state.maxDate.getDate() > state.date.getDate() || state.maxDate.getMonth() > state.date.getMonth() || state.maxDate.getYear() > state.date.getYear(), dateCanBeDecreased = state.minDate.getDate() < state.date.getDate(), hoursCanBeIncreased = state.maxDate.getHours() > state.date.getHours(), hoursCanBeDecreased = state.minDate.getHours() < state.date.getHours(), minutesCanBeIncreased = state.maxDate.getMinutes() > state.date.getMinutes(), minutesCanBeDecreased = state.minDate.getMinutes() < state.date.getMinutes();
        lowerIconClasses = dateCanBeDecreased ? "" : " inactive", upperIconClasses = dateCanBeIncreased ? "" : " inactive", inputComponents.push(React.createElement("div", { className: "widget--date-time-picker--date" }, React.createElement("div", {
          className: "widget--date-time-picker--arrow" + upperIconClasses,
          onClick: this.onDateChange.bind(this, "up")
        }, React.createElement(ComponentsIcon, { settings: upperIconSettings })), React.createElement("input", {
          value: date,
          className: "component--input",
          type: "text",
          readOnly: !0
        }), React.createElement("div", {
          className: "widget--date-time-picker--arrow" + lowerIconClasses,
          onClick: this.onDateChange.bind(this, "down")
        }, React.createElement(ComponentsIcon, { settings: lowerIconSettings })))), lowerIconClasses = dateCanBeDecreased || hoursCanBeDecreased ? "" : " inactive", upperIconClasses = dateCanBeIncreased || hoursCanBeIncreased ? "" : " inactive", inputComponents.push(React.createElement("div", { className: "widget--date-time-picker--hour" }, React.createElement("div", {
          className: "widget--date-time-picker--arrow" + upperIconClasses,
          onClick: this.onTimeChange.bind(this, "up", "hour")
        }, React.createElement(ComponentsIcon, { settings: upperIconSettings })), React.createElement("input", {
          value: hours,
          className: "component--input",
          type: "text",
          readOnly: !0
        }), React.createElement("div", {
          className: "widget--date-time-picker--arrow" + lowerIconClasses,
          onClick: this.onTimeChange.bind(this, "down", "hour")
        }, React.createElement(ComponentsIcon, { settings: lowerIconSettings })))), lowerIconClasses = dateCanBeDecreased || hoursCanBeDecreased || minutesCanBeDecreased ? "" : " inactive", upperIconClasses = dateCanBeIncreased || hoursCanBeIncreased || minutesCanBeIncreased ? "" : " inactive", inputComponents.push(React.createElement("div", { className: "widget--date-time-picker--minute" }, React.createElement("div", {
          className: "widget--date-time-picker--arrow" + upperIconClasses,
          onClick: this.onTimeChange.bind(this, "up", "minute")
        }, React.createElement(ComponentsIcon, { settings: upperIconSettings })), React.createElement("input", {
          value: minutes,
          className: "component--input",
          type: "text",
          readOnly: !0
        }), React.createElement("div", {
          className: "widget--date-time-picker--arrow" + lowerIconClasses,
          onClick: this.onTimeChange.bind(this, "down", "minute")
        }, React.createElement(ComponentsIcon, { settings: lowerIconSettings })))), components.push(React.createElement("div", {
          className: "form--component widget--date-time-picker--fields",
          key: "date-time-inputs"
        }, inputComponents)), componentSettings = { text: servicesInternationalization.localize("Earliest arrival time %1$@", utilsDateTime.getLocaleDateTimeString(state.minDate)) }, components.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: componentSettings,
          key: "transport-time-min"
        })), componentSettings = { text: servicesInternationalization.localize("Latest arrival time %1$@", utilsDateTime.getLocaleDateTimeString(state.maxDate)) }, components.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: componentSettings,
          key: "transport-time-max"
        }));
        var buttons = [];
        componentSettings = {
          onClick: this.onCancelClick,
          title: servicesInternationalization.localize("cancel")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-cancel"
        })), settings.isResetAvailable && (componentSettings = {
          onClick: this.onResetClick,
          title: servicesInternationalization.localize("Reset")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-reset"
        }))), componentSettings = {
          onClick: this.onSubmitClick,
          title: servicesInternationalization.localize("ok")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-ok"
        })), components.push(React.createElement("div", {
          className: "form--component form--inline inline--center",
          key: "time-submit"
        }, buttons))
      } else {
        var currentTimeString = utilsDateTime.getLocaleDateTimeString(this.state.date), cycle = utilsDateTime.getDayCycle(this.state.date);
        localComponent = {
          isDisabled: settings.isDisabled,
          icon: "controls menu-bar-settings",
          onClick: this.onEditModeClick
        }, componentSettings = {
          disabled: settings.isDisabled,
          classes: settings.classes,
          iconLeft: "icon-game colored icon-" + cycle + "Icon",
          title: servicesInternationalization.localize("Destination ETA"),
          rightColumnDataValue: currentTimeString,
          iconRight: React.createElement(ComponentsMenuListElementButtonAction, {
            settings: localComponent,
            key: "edit-button"
          })
        }, components.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: componentSettings,
          key: "transport-time"
        }))
      }
      return React.createElement("div", { className: "widget--date-time-picker" }, components)
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.components.widgetTimeDelay, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, utilsDateTime, servicesInternationalization, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        delayInSeconds: 0,
        iconLeft: servicesTheme.themeSettings.imagesClassNames.featureManualDelay.timeDelay,
        title: servicesInternationalization.localize("Time Delay"),
        showFAQlink: !0,
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var componentSettings, components = [], linkFAQ = servicesTheme.getFAQLink("manuallyDelayedTransits"), currentDelay = utilsDateTime.secondsToTimeString(settings.delayInSeconds, !0), originalThis = settings.initialComponent;
      return componentSettings = {
        iconLeft: settings.iconLeft,
        title: settings.title,
        rightColumnDataValue: currentDelay
      }, linkFAQ && settings.showFAQlink && (componentSettings.iconRight = "controls menu-info", componentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), components.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: componentSettings,
        key: "delayed-time"
      })), React.createElement("div", null, components)
    }
  })
}]);
xy.dStaticInjector.set(xy.dNames.components.widgetTimePicker, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.buttonMain, xy.dNames.components.alertTooltip, function(componentEngine, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsButtonMain, ComponentsAlertTooltip) {
  "use strict";
  return componentEngine.createClass({
    componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getInitialWidgetSettings(newProps), null)
    }, getInitialWidgetSettings: function(props) {
      var now = new Date, date = props.settings.currentTime || now;
      return { isEditingMode: !1, isError: !1, errorText: "", date: date }
    }, getInitialState: function() {
      return this.getInitialWidgetSettings(this.props)
    }, onInputFocusHandler: function() {
      this.setState({ isError: !1, errorText: "" }, null)
    }, onEditModeClick: function() {
      this.setState({ isEditingMode: !0 }, null)
    }, onCancelClick: function() {
      this.setState(this.getInitialWidgetSettings(this.props), null)
    }, onSubmitClick: function(event) {
      event.preventDefault();
      var currentDate, settings = this.props.settings, input = componentEngine.findDOMNode(this.refs.widgetTimeInput), timeValue = input.value;
      if (currentDate = settings.currentDate && settings.currentDate instanceof Date ? new Date(settings.currentDate.getTime()) : new Date, settingsGameConstant.PATTERNS.GET_TIME_FROM_INPUT_STRING.lastIndex = 0, settingsGameConstant.PATTERNS.GET_TIME_FROM_INPUT_STRING.test(timeValue) === !0) {
        settingsGameConstant.PATTERNS.GET_TIME_FROM_INPUT_STRING.lastIndex = 0;
        var matchesArray, hours, minutes;
        matchesArray = settingsGameConstant.PATTERNS.GET_TIME_FROM_INPUT_STRING.exec(timeValue), hours = +matchesArray[1], minutes = +matchesArray[2], currentDate.setHours(hours), currentDate.setMinutes(minutes), settings.onSubmit && settings.onSubmit(currentDate)
      } else this.setState({ isError: !0, errorText: "Wrong time format" }, null)
    }, render: function() {
      var settings = { classes: "", currentDate: null, onSubmit: null, isDisabled: !1 };
      Object.assign(settings, this.props.settings);
      var componentSettings, localComponent, state = this.state, components = [], iconThemeSettings = servicesTheme.themeSettings.imagesClassNames;
      if (state.isEditingMode) {
        componentSettings = { title: servicesInternationalization.localize("Time") }, components.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: componentSettings,
          key: "transport-time-title"
        }));
        var tooltipSettings, timeHTMLValue = utilsDateTime.getTimeHTML5InputFormat(state.date), alert = null;
        this.state.isError && (tooltipSettings = {
          position: "top",
          status: "in",
          text: this.state.errorText
        }, alert = React.createElement(ComponentsAlertTooltip, {
          settings: tooltipSettings,
          key: "tooltip"
        })), components.push(React.createElement("div", {
          className: "form--component form--inline inline--center",
          key: "time-inputs"
        }, alert, React.createElement("input", {
          ref: "widgetTimeInput",
          defaultValue: timeHTMLValue,
          className: "component--input time-width",
          type: "time",
          pattern: "[0-9]{1,2}:[0-9]{1,2}"
        })));
        var buttons = [];
        componentSettings = {
          onClick: this.onCancelClick,
          title: servicesInternationalization.localize("cancel")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-cancel"
        })), componentSettings = {
          onClick: this.onSubmitClick,
          title: servicesInternationalization.localize("ok")
        }, buttons.push(React.createElement(ComponentsButtonMain, {
          settings: componentSettings,
          key: "button-ok"
        })), components.push(React.createElement("div", {
          className: "form--component form--inline inline--center",
          key: "time-submit"
        }, buttons))
      } else localComponent = {
        isDisabled: settings.isDisabled,
        icon: "controls menu-bar-settings",
        onClick: this.onEditModeClick
      }, componentSettings = {
        disabled: settings.isDisabled,
        classes: settings.classes,
        iconLeft: iconThemeSettings.startTransit.transportTime,
        title: servicesInternationalization.localize("Time"),
        rightColumnDataValue: utilsDateTime.getLocaleTimeString(this.state.date),
        iconRight: React.createElement(ComponentsMenuListElementButtonAction, {
          settings: localComponent,
          key: "edit-button"
        })
      }, components.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: componentSettings,
        key: "transport-time"
      }));
      return React.createElement("div", null, components)
    }
  })
}]);
xy.dStaticInjector.set(xy.dNames.components.overviewWidgetConstructCost, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.utils.number, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.resourceIconAmount, xy.dNames.components.buttonMain, xy.dNames.components.menuListElementBasic, function(componentEngine, utilsDateTime, utilsNumber, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesTheme, ComponentsResourceIconAmount, ComponentsButtonMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        title: servicesInternationalization.localize("Cost"),
        externalRequirementsPassed: !0,
        constructingEntity: null,
        onConstructButtonClick: null,
        currentHabitat: {},
        initialComponent: null,
        disableRequiredSection: !1,
        multiplier: 1,
        showMissingResources: !1,
        onClick: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, className = "widget--construct--constructingEntity-cost ", constructingEntity = settings.constructingEntity, componentsSections = [], multiplier = settings.multiplier;
      !settings.disableRequiredSection && constructingEntity.requiredKnowledgeArray instanceof Array && constructingEntity.requiredKnowledgeArray.forEach(function(knowledgePK) {
        var classAvailabilityName, knowledge = servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: knowledgePK });
        settings.currentHabitat.habitatKnowledgesSet[knowledgePK] || (classAvailabilityName = "color-red"), sectionComponentSettings = {
          iconLeft: knowledge.icon,
          title: servicesInternationalization.localize("Required knowledge"),
          rightColumnDataValue: React.createElement("div", { className: classAvailabilityName }, knowledge.title),
          iconRight: "controls menu-next",
          onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
            next: xy.dNames.game.menuKnowledgeOverview.name,
            options: { knowledge: knowledge }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "required-section-" + knowledgePK
        }))
      }, this);
      var rows = [];
      rows.push(React.createElement("div", {
        className: "habitat-overview-title summary left",
        key: "cost-title"
      }, settings.title));
      var localResourceDictionary, isEnoughParticularResource, resourcesSettings, idResource, costs = [], buildResource = constructingEntity.buildResourceDictionary;
      for (idResource in buildResource)buildResource.hasOwnProperty(idResource) && (localResourceDictionary = {}, localResourceDictionary[idResource] = buildResource[idResource], isEnoughParticularResource = settings.currentHabitat.hasEnoughResources(localResourceDictionary), resourcesSettings = {
        icon: "icon-resource-" + idResource,
        amount: buildResource[idResource] * multiplier,
        showFill: !1,
        classes: "dark"
      }, settings.showMissingResources && !isEnoughParticularResource && (resourcesSettings.classes = "not-enough"), costs.push(React.createElement(ComponentsResourceIconAmount, {
        settings: resourcesSettings,
        key: "resource-" + idResource
      })));
      var correctAmount, upgradeOf, humanResourceId = servicesTheme.themeSettings.resources.humanResourceId;
      constructingEntity.volumeResource === humanResourceId && constructingEntity.volumeAmount && (localResourceDictionary = {}, correctAmount = constructingEntity.volumeAmount, constructingEntity.hasOwnProperty("upgradeOf") && (upgradeOf = servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: constructingEntity.upgradeOf }), correctAmount -= upgradeOf.volumeAmount || 0), localResourceDictionary[humanResourceId] = correctAmount, isEnoughParticularResource = settings.currentHabitat.hasEnoughResources(localResourceDictionary), resourcesSettings = {
        icon: "icon-resource-" + humanResourceId,
        amount: correctAmount * multiplier,
        showFill: !1,
        classes: "dark"
      }, settings.showMissingResources && !isEnoughParticularResource && (resourcesSettings.classes = "not-enough"), costs.push(React.createElement(ComponentsResourceIconAmount, {
        settings: resourcesSettings,
        key: "resource-" + humanResourceId
      })));
      var buildDuration = constructingEntity.buildDuration * multiplier;
      settings.performingBuilding && settings.performingBuilding.modifierArray instanceof Array && settings.performingBuilding.modifierArray.length && settings.performingBuilding.modifierArray.forEach(function(modifierPK) {
        var modifierModel = servicesGameDataManager.modifiersCollection.getModifier({ primaryKey: modifierPK });
        modifierModel.type === settingsGameConstant.MODIFIER_TYPE.BUILD_SPEED && (buildDuration = utilsNumber.roundGaussian(buildDuration * parseFloat(modifierModel.percentage)))
      }, this);
      var duration = React.createElement("div", {
        className: "icon-amount--widget dark wider",
        key: "resource-duration"
      }, React.createElement("div", { className: "icon icon-game icon-Duration" }), React.createElement("div", { className: "amount" }, utilsDateTime.secondsToTimeString(buildDuration, !0)));
      if (costs.push(duration), settings.onConstructButtonClick) {
        var constructingEntityIdentifier = constructingEntity.classIdentifier || constructingEntity.identifier, buttonSettings = {
          classes: "menu-element--button--action button--construct-" + constructingEntityIdentifier,
          icon: "icon-game white icon-Build",
          onClick: settings.onConstructButtonClick,
          isDisabled: !(settings.currentHabitat.canHabitatAffordUpgrade(constructingEntity) && settings.externalRequirementsPassed)
        };
        costs.push(React.createElement(ComponentsButtonMain, { settings: buttonSettings, key: "construct-button" }))
      }
      costs.length && rows.push(React.createElement("div", {
        className: "habitat-overview-row",
        key: "costs-row"
      }, costs));
      var rowsClasses = "menu-list-element habitat-overview--widget ";
      return settings.onClick && (rowsClasses += "clickable"), componentsSections.push(React.createElement("div", {
        className: rowsClasses,
        key: "cost-section-with-title",
        onClick: settings.onClick
      }, rows)), React.createElement("div", { className: className + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.buildingWidgetTradeRates, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.resourceIconAmount, xy.dNames.components.menuListElementBasic, function(componentEngine, utilsDateTime, servicesInternationalization, servicesTheme, ComponentsResourceIconAmount, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", tradeResourceId: null, ratesToOtherResources: {}, reverseRate: !1, onClick: null };
      Object.assign(settings, this.props.settings);
      var idResource, nameResource, settingsComponent, classes = "widget--trade-rates ", rightColumnRow = [];
      for (idResource in settings.ratesToOtherResources)settings.ratesToOtherResources.hasOwnProperty(idResource) && (settingsComponent = {
        icon: "icon-resource-" + idResource,
        amount: settings.reverseRate ? settings.ratesToOtherResources[idResource] + ":1" : "1:" + settings.ratesToOtherResources[idResource],
        showFill: !1,
        classes: "dark"
      }, rightColumnRow.push(React.createElement(ComponentsResourceIconAmount, {
        settings: settingsComponent,
        key: "resource-" + idResource
      })));
      return nameResource = servicesTheme.themeSettings.resources[settings.tradeResourceId], settingsComponent = {
        classes: classes,
        iconLeft: "icon-resource icon-resource-" + settings.tradeResourceId,
        title: servicesInternationalization.localize(nameResource),
        rightColumnDataValue: rightColumnRow,
        onClick: settings.onClick
      }, React.createElement(ComponentsMenuListElementBasic, { settings: settingsComponent })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.buildingUpgradesList, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.buildingUpgradesEntry, function(componentEngine, utilsDateTime, servicesInternationalization, servicesTheme, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsBuildingUpgradesEntry) {
  "use strict";
  return componentEngine.createClass({
    onCompleteAllUpgrades: function(event) {
      event.preventDefault(), event.stopPropagation();
      var options, settings = this.props.settings, originalThis = settings.initialComponent, habitatsObject = {};
      habitatsObject[settings.currentHabitat.id] = {
        upgrades: settings.upgrades,
        habitat: settings.currentHabitat
      }, options = { habitatsObject: habitatsObject }, originalThis.props.presenter.notify(xy.eNames.menuBuildingsList.completeAllUpgrades, options)
    }, render: function() {
      var settings = {
        classes: "",
        currentHabitat: null,
        firstUpgradeInQueueForBuilding: {},
        upgrades: [],
        onSpeedUpClick: null,
        onClick: null,
        showCompleteAllSection: !1,
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, themeIcon = servicesTheme.themeSettings.imagesClassNames, classes = "widget--upgrades-in-progress--list", componentsSections = [];
      return sectionComponentSettings = { title: servicesInternationalization.localize("Running Building Upgrades") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-habitat-current-constructions"
      })), settings.showCompleteAllSection && settings.upgrades.length > 1 && (sectionComponentSettings = {
        iconLeft: themeIcon.habitat.habitatByType[settings.currentHabitat.publicHabitatType],
        title: servicesInternationalization.localize("Complete all buildings"),
        rightColumnDataValue: settings.upgrades.length,
        onClick: this.onCompleteAllUpgrades
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "complete-all-section"
      }))), settings.upgrades.forEach(function(upgrade) {
        var settingsEntry = {
          currentHabitat: settings.currentHabitat,
          firstUpgradeInQueueForBuilding: settings.firstUpgradeInQueueForBuilding,
          onSpeedUpClick: settings.onSpeedUpClick,
          onClick: settings.onClick,
          upgrade: upgrade,
          initialComponent: settings.initialComponent
        };
        componentsSections.push(React.createElement(ComponentsBuildingUpgradesEntry, {
          settings: settingsEntry,
          key: "building-is-in-progress" + upgrade.resultBuilding.primaryKey
        }))
      }, this), React.createElement("div", { className: classes + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.buildingUpgradesEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListElementBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesLog, servicesInternationalization, servicesTheme, ComponentsMenuListElementButtonAction, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        timer = props.settings.upgrade.buildingUpgrade.complete, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Building is in progress timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = {
        currentHabitat: null,
        firstUpgradeInQueueForBuilding: {},
        onSpeedUpClick: null,
        onClick: null,
        upgrade: {},
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var isFirstInQueue, isInstantFinishingAvailable, rightIconButtonSettings, settingsEntry, upgrade = settings.upgrade, classIdentifier = upgrade.resultBuilding.classIdentifier;
      return isFirstInQueue = settings.firstUpgradeInQueueForBuilding[classIdentifier] === upgrade.buildingUpgrade.id, isInstantFinishingAvailable = upgrade.buildingUpgrade.isLessThanHalfConstructionTimeRemain(), rightIconButtonSettings = {
        icon: "icon-game white icon-" + (isInstantFinishingAvailable ? "BuildFinish" : "BuildSpeedup"),
        classes: "button--speed-up-finish--" + classIdentifier,
        onClick: settings.onSpeedUpClick.bind(settings.initialComponent, {
          buildingUpgrade: upgrade.buildingUpgrade,
          resultBuilding: upgrade.resultBuilding,
          habitat: settings.currentHabitat
        }),
        isDisabled: !(isInstantFinishingAvailable && isFirstInQueue || isInstantFinishingAvailable === !1)
      }, settingsEntry = {
        iconLeft: upgrade.resultBuilding.icon,
        title: servicesInternationalization.localize(upgrade.resultBuilding.title),
        description: servicesInternationalization.localize("Level %d done in %@", upgrade.resultBuilding.level, this.state.remainTimeString),
        onClick: settings.onClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuBuildingOverview.name,
          options: { classIdentifier: classIdentifier, title: upgrade.resultBuilding.title }
        }),
        iconRight: React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings })
      }, React.createElement(ComponentsMenuListElementBasic, { settings: settingsEntry })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.buildingTabularCell, [xy.dNames.componentsEngine, xy.dNames.services.gameDataManager, xy.dNames.components.menuListElementButtonAction, function(componentsEngine, servicesGameDataManager, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { building: null, habitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var upgradeBuilding, componentsSettings, building = settings.building, habitat = settings.habitat, components = [], originalThis = settings.initialComponent;
      return components.push(React.createElement("div", null, building.level)), building.isFurtherUpgradePossible && (componentsSettings = {
        icon: "icon-game white icon-Build",
        onClick: originalThis.onUpgradeButtonClick.bind(originalThis, {
          resultBuildingPK: building.getResultBuildingPK(),
          habitat: habitat,
          paymentGranted: !1
        }),
        isDisabled: !building.upgradeToArray.every(function(possibleUpgradeBuildingPK) {
          return upgradeBuilding = servicesGameDataManager.buildingsCollection.getBuilding({ pk: possibleUpgradeBuildingPK }), habitat.canHabitatAffordUpgrade(upgradeBuilding)
        })
      }, components.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: componentsSettings }))), React.createElement("div", { className: "upgrade-building--cell" }, components)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.buildingInProgressTabularCell, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.components.menuListElementButtonAction, function(componentsEngine, utilsDateTime, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = { upgradeObject: null, firstUpgradeInQueue: "", habitat: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var componentsSettings, upgrade = settings.upgradeObject, buildingUpgrade = upgrade.buildingUpgrade, resultBuilding = upgrade.resultBuilding, components = [], isFirstInQueue = settings.firstUpgradeInQueue === upgrade.buildingUpgrade.id, isInstantFinishingAvailable = upgrade.buildingUpgrade.isLessThanHalfConstructionTimeRemain(), originalThis = settings.initialComponent;
      return components.push(React.createElement("div", { className: "complete" }, utilsDateTime.remainTime(buildingUpgrade.complete))), components.push(React.createElement("div", null, resultBuilding.level)), componentsSettings = {
        icon: "icon-game white icon-" + (isInstantFinishingAvailable ? "BuildFinish" : "BuildSpeedup"),
        onClick: originalThis.onSpeedUpButtonClick.bind(originalThis, {
          buildingUpgrade: buildingUpgrade,
          resultBuilding: resultBuilding,
          habitat: settings.habitat
        }),
        isDisabled: !(isInstantFinishingAvailable && isFirstInQueue || isInstantFinishingAvailable === !1)
      }, components.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: componentsSettings })), React.createElement("div", { className: "upgrade-building--cell" }, components)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.overviewWidgetBattleAbilityList, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, utilsDateTime, servicesInternationalization, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", battleAbility: {} };
      Object.assign(settings, this.props.settings);
      var rightDataArray, rightData, componentsSectionsSettings, corpsKey, classes = "widget--battle-ability-list ", componentsSections = [], battleAbility = settings.battleAbility;
      for (corpsKey in battleAbility)battleAbility.hasOwnProperty(corpsKey) && (rightDataArray = [], rightData = React.createElement("div", {
        className: "icon-amount--widget dark wider",
        key: "battle-ability-offense"
      }, React.createElement("div", { className: "icon icon-game icon-AttackIcon" }), React.createElement("div", { className: "amount" }, battleAbility[corpsKey].offense)), rightDataArray.push(rightData), rightData = React.createElement("div", {
        className: "icon-amount--widget dark wider",
        key: "battle-ability-defense"
      }, React.createElement("div", { className: "icon icon-game icon-DefenseIcon" }), React.createElement("div", { className: "amount" }, battleAbility[corpsKey].defense)), rightDataArray.push(rightData), componentsSectionsSettings = {
        iconLeft: "icon-game icon-Corps" + corpsKey,
        title: servicesInternationalization.localize(corpsKey),
        rightColumnDataValue: rightDataArray
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: componentsSectionsSettings,
        key: "ability-against-" + corpsKey
      })));
      return React.createElement("div", { className: classes + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.overviewWidgetTreasureChest, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuListElementBasic, function(componentEngine, utilsDateTime, servicesGameDataManager, servicesInternationalization, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", initialComponent: null };
      Object.assign(settings, this.props.settings);
      var componentSettings, className = "widget--treasure-chest ", componentsSections = [], gold = servicesGameDataManager.playersCollection.getPlayer().gold;
      return componentSettings = {
        iconLeft: "icon-resource icon-resource-premium",
        title: servicesInternationalization.localize("Gold"),
        rightColumnDataValue: gold,
        iconRight: "controls menu-next",
        onClick: settings.initialComponent.handlerOpenWebShopClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: componentSettings,
        key: "gold"
      })), React.createElement("div", { className: className + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.overviewWidgetResourcesInHabitat, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.resourceIconAmount, function(componentEngine, servicesInternationalization, servicesTheme, ComponentsResourceIconAmount) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", title: servicesInternationalization.localize("Resources"), resourceDictionary: {} };
      Object.assign(settings, this.props.settings);
      var resourcesSettings, componentsSections = [], resourceDictionary = settings.resourceDictionary, rows = [];
      rows.push(React.createElement("div", {
        className: "habitat-overview-title summary left",
        key: "resources-in-habitat-title"
      }, settings.title));
      var resourceObjectId;
      for (resourceObjectId in resourceDictionary)if (resourceDictionary.hasOwnProperty(resourceObjectId) && resourceDictionary[resourceObjectId].resourceId !== servicesTheme.themeSettings.resources.humanResourceId) {
        var resourceAmountObject = resourceDictionary[resourceObjectId], resourceId = resourceAmountObject.resourceId, percent = resourceAmountObject.amount / resourceAmountObject.storeAmount * 100 | 0;
        resourcesSettings = {
          icon: "icon-resource-" + resourceId,
          amount: resourceAmountObject.amount + "/" + resourceAmountObject.storeAmount,
          showFill: !0,
          percent: percent,
          classes: "dark"
        }, rows.push(React.createElement(ComponentsResourceIconAmount, {
          settings: resourcesSettings,
          key: "resources-in-habitat-" + resourceId
        }))
      }
      return componentsSections.push(React.createElement("div", {
        className: "widget--resources-in-habitat",
        key: "resources-in-habitat-list"
      }, rows)), React.createElement("div", { className: "menu-list-element habitat-overview--widget " + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitsSummary, [xy.dNames.componentsEngine, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.icon, xy.dNames.components.resourceIconAmount, xy.dNames.components.unitIconAmount, function(componentEngine, utilsObject, settingsGameConstant, servicesGameDataManager, servicesTheme, ComponentsIcon, ComponentsResourceIconAmount, ComponentsUnitIconAmount) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", initialComponent: null, transits: [] };
      Object.assign(settings, this.props.settings);
      var sectionSettings, sectionComponents = [], transitsSummary = {}, themeIcons = servicesTheme.themeSettings.imagesClassNames;
      settings.transits.forEach(function(transitExtendedObject) {
        var transit = transitExtendedObject.transit, transitOrigin = transitExtendedObject.type, transitType = transit.transitType, currentHabitatId = servicesGameDataManager.habitatsCollection.getCurrentHabitatId(), isTransitSpy = transitType === settingsGameConstant.TRANSIT_TYPE.SPY || transitType === settingsGameConstant.TRANSIT_TYPE.SPY_RETURN, isOutgoingTransportReturn = transitType === settingsGameConstant.TRANSIT_TYPE.TRANSPORT_RETURN && transitOrigin === settingsGameConstant.TRANSIT_SUMMARY_TYPE.OUTGOING, isIncomingTransport = transitType === settingsGameConstant.TRANSIT_TYPE.TRANSPORT && transitOrigin === settingsGameConstant.TRANSIT_SUMMARY_TYPE.INCOMING, isForeignTransitAttack = transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK && currentHabitatId !== transit.destinationHabitat, isReturningTransport = transitType === settingsGameConstant.TRANSIT_TYPE.TRANSPORT_RETURN;
        if (!isTransitSpy && !isOutgoingTransportReturn) {
          if (isReturningTransport && (transitType = settingsGameConstant.TRANSIT_TYPE.TRANSPORT, transitOrigin = settingsGameConstant.TRANSIT_SUMMARY_TYPE.INCOMING), isForeignTransitAttack && (transitOrigin = settingsGameConstant.TRANSIT_SUMMARY_TYPE.OUTGOING), utilsObject.isEmpty(transitsSummary[transitOrigin]) && (transitsSummary[transitOrigin] = {}), utilsObject.isEmpty(transitsSummary[transitOrigin][transitType]) && (transitsSummary[transitOrigin][transitType] = {}), !utilsObject.isEmpty(transit.resourceDictionary)) {
            var recourseId;
            for (recourseId in transit.resourceDictionary)transit.resourceDictionary.hasOwnProperty(recourseId) && (transitsSummary[transitOrigin][transitType].hasOwnProperty("resourceDictionary") || (transitsSummary[transitOrigin][transitType].resourceDictionary = {}), transitsSummary[transitOrigin][transitType].resourceDictionary.hasOwnProperty(recourseId) || (transitsSummary[transitOrigin][transitType].resourceDictionary[recourseId] = 0), transitsSummary[transitOrigin][transitType].resourceDictionary[recourseId] += transit.resourceDictionary[recourseId])
          }
          if (!utilsObject.isEmpty(transit.unitDictionary) && !isIncomingTransport) {
            var unitId;
            for (unitId in transit.unitDictionary)transit.unitDictionary.hasOwnProperty(unitId) && (transitsSummary[transitOrigin][transitType].hasOwnProperty("unitDictionary") || (transitsSummary[transitOrigin][transitType].unitDictionary = {}), transitsSummary[transitOrigin][transitType].unitDictionary.hasOwnProperty(unitId) || (transitsSummary[transitOrigin][transitType].unitDictionary[unitId] = 0), transitsSummary[transitOrigin][transitType].unitDictionary[unitId] += transit.unitDictionary[unitId])
          }
        }
      });
      var transitsObject, addSummary = function(transitsObject, iconType) {
        var transitType, typeIcon, classes = "menu-list-element habitat-overview--widget transit-summary ";
        for (transitType in transitsObject)if (transitsObject.hasOwnProperty(transitType) && !utilsObject.isEmpty(transitsObject[transitType])) {
          sectionSettings = {
            classes: "transit-summary transit-type",
            icon: themeIcons.transitSummary[iconType][transitType]
          }, typeIcon = React.createElement(ComponentsIcon, { settings: sectionSettings });
          var resourcesRow = null;
          if (transitsObject[transitType].resourceDictionary) {
            var resourcesSettings, idResource, amount, resources = [], resourcesDictionary = transitsObject[transitType].resourceDictionary;
            for (idResource in resourcesDictionary)resourcesDictionary.hasOwnProperty(idResource) && (amount = resourcesDictionary[idResource], resourcesSettings = {
              icon: "icon-resource-" + idResource,
              amount: amount,
              showFill: !1,
              classes: "dark"
            }, resources.push(React.createElement(ComponentsResourceIconAmount, {
              settings: resourcesSettings,
              key: "resource-" + idResource
            })));
            resourcesRow = React.createElement("div", { className: "habitat-overview-row" }, resources)
          }
          var unitsRow = null;
          if (transitsObject[transitType].unitDictionary) {
            var unitKey, units = [];
            for (unitKey in transitsObject[transitType].unitDictionary)if (transitsObject[transitType].unitDictionary.hasOwnProperty(unitKey)) {
              var unitSettings = {
                icon: "icon-unit-" + unitKey,
                amount: transitsObject[transitType].unitDictionary[unitKey],
                classes: "dark"
              };
              units.push(React.createElement(ComponentsUnitIconAmount, {
                settings: unitSettings,
                key: "unit-" + unitKey
              }))
            }
            unitsRow = React.createElement("div", { className: "habitat-overview-row" }, units)
          }
          sectionComponents.push(React.createElement("div", {
            className: classes + settings.classes,
            onClick: settings.onClick
          }, typeIcon, resourcesRow, unitsRow))
        }
      };
      for (transitsObject in transitsSummary)transitsSummary.hasOwnProperty(transitsObject) && !utilsObject.isEmpty(transitsSummary[transitsObject]) && addSummary(transitsSummary[transitsObject], transitsObject);
      return React.createElement("div", null, sectionComponents)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitExternalListButton, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesLog, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer],
    speedUpTransit: function(modeledTransit, event) {
      event.preventDefault(), event.stopPropagation();
      var initialThis = this.props.settings.initialComponent;
      initialThis.props.presenter.notify(xy.eNames.menuTransitOverview.speedUpTransit, modeledTransit)
    },
    constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        timer = props.settings.habitat.nextTransitArrivalDate || null, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Transit timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    },
    render: function() {
      var settings = { classes: "", initialComponent: null, habitat: {}, relatedToCurrentHabitat: !1 };
      Object.assign(settings, this.props.settings);
      var transitSettings, habitat = settings.habitat, initialThis = settings.initialComponent, themeIcons = servicesTheme.themeSettings.imagesClassNames, description = "";
      return this.state.timer && (description = this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(this.state.timer)), transitSettings = {
        iconLeft: themeIcons.icon.showTransit,
        title: servicesInternationalization.localize("Transits"),
        rightColumnDataValue: habitat.transitCount || "",
        iconRight: themeIcons.controls.next,
        description: description,
        onClick: initialThis.handlerNextClick.bind(initialThis, {
          next: xy.dNames.game.menuHabitatTransitsListOverview.name,
          options: { habitatId: habitat.id || null, relatedToCurrentHabitat: settings.relatedToCurrentHabitat }
        })
      }, React.createElement(ComponentsMenuListElementBasic, { settings: transitSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitList, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.transitListEntry, function(componentEngine, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsTransitListEntry) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", showTitle: !1, initialComponent: null, transits: [], isCompletedExcluded: !1 };
      Object.assign(settings, this.props.settings);
      var componentSettings, initialThis = settings.initialComponent, className = "widget--transits-list ", componentsSections = [], amountOfTransits = 0;
      return settings.showTitle && (componentSettings = { title: servicesInternationalization.localize("Transits") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: componentSettings,
        key: "menu-title-transits"
      }))), settings.transits.forEach(function(transitConstructedObject, index) {
        if (!settings.isCompletedExcluded || transitConstructedObject.transit.isTransitActive()) {
          var transitSettings = { transit: transitConstructedObject, initialComponent: initialThis };
          amountOfTransits += 1, componentsSections.push(React.createElement(ComponentsTransitListEntry, {
            settings: transitSettings,
            key: "menu-transit-" + transitConstructedObject.transit.id + index
          }))
        }
      }, this), amountOfTransits || (componentSettings = { text: servicesInternationalization.localize("No transits") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: componentSettings,
        key: "no-transit-in-list"
      }))), React.createElement("div", { className: className + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitListEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesLog, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer],
    speedUpTransit: function(modeledTransit, event) {
      event.preventDefault(), event.stopPropagation();
      var initialThis = this.props.settings.initialComponent;
      initialThis.props.presenter.notify(xy.eNames.menuTransitOverview.speedUpTransit, modeledTransit)
    },
    constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        timer = props.settings.transit.transit.destinationETA, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Transit timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    },
    render: function() {
      var settings = { classes: "", initialComponent: null, transit: {} };
      Object.assign(settings, this.props.settings);
      var transitSettings, transitOrigin, transit = settings.transit, modeledTransit = settings.transit.transit, initialThis = settings.initialComponent, themeIcons = servicesTheme.themeSettings.imagesClassNames, currentHabitatId = servicesGameDataManager.habitatsCollection.getCurrentHabitatId(), transitOriginCondition = modeledTransit.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK ? servicesGameDataManager.habitatsCollection.isHabitatOwnByPlayer(modeledTransit.destinationHabitat) : currentHabitatId === modeledTransit.destinationHabitat;
      if (transitOrigin = transitOriginCondition ? settingsGameConstant.TRANSIT_SUMMARY_TYPE.INCOMING : settingsGameConstant.TRANSIT_SUMMARY_TYPE.OUTGOING, transitSettings = {
                title: transit.targetHabitatName,
                description: this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(modeledTransit.destinationETA),
                iconLeft: themeIcons.transitSummary[transitOrigin][modeledTransit.transitType],
                onClick: initialThis.handlerNextClick.bind(initialThis, {
                  next: xy.dNames.game.menuTransitOverview.name,
                  options: { transitId: modeledTransit.id }
                })
              }, transit.isReturning)transitSettings.iconRight = "icon-game icon-SpeedUpReturningTransits", transitSettings.iconRightIsButton = !0, transitSettings.iconRightOnClick = this.speedUpTransit.bind(this, modeledTransit); else if (transit.canHabitatSynchronizeWithTransit) {
        var mode;
        switch (modeledTransit.transitType) {
          case settingsGameConstant.TRANSIT_TYPE.ATTACK:
            mode = settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK_SYNC;
            break;
          case settingsGameConstant.TRANSIT_TYPE.DEFENSE:
            mode = settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT_SYNC
        }
        transitSettings.iconRight = themeIcons.featureSynchronizeTransit[mode], transitSettings.iconRightIsButton = !0, transitSettings.iconRightOnClick = initialThis.handlerNextClick.bind(initialThis, {
          next: xy.dNames.game.menuHabitatSendUnitsResources.name,
          options: { attackingHabitat: settings.habitat, transit: modeledTransit, mode: mode }
        })
      }
      return React.createElement(ComponentsMenuListElementBasic, { settings: transitSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitTabularCell, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesLog, servicesTheme, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], speedUpTransit: function(event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings, transitModel = settings.transitModel, originalThis = settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuTransitOverview.speedUpTransit, transitModel)
    }, constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        timer = props.settings.transitModel.destinationETA, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Transit timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = {
        classes: "",
        initialComponent: null,
        currentHabitatId: null,
        transitModel: {},
        habitatTitle: "",
        activated: !0
      };
      Object.assign(settings, this.props.settings);
      var transitOrigin, transitSettings, transitModel = settings.transitModel, themeIcons = servicesTheme.themeSettings.imagesClassNames, transitOriginCondition = transitModel.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK ? servicesGameDataManager.habitatsCollection.isHabitatOwnByPlayer(transitModel.destinationHabitat) : settings.currentHabitatId === transitModel.destinationHabitat;
      return transitOrigin = transitOriginCondition ? settingsGameConstant.TRANSIT_SUMMARY_TYPE.INCOMING : settingsGameConstant.TRANSIT_SUMMARY_TYPE.OUTGOING, transitSettings = {
        title: settings.habitatTitle,
        description: this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(transitModel.destinationETA),
        iconLeft: themeIcons.transitSummary[transitOrigin][transitModel.transitType],
        hideBorders: !0,
        activated: settings.activated
      }, transitModel.isReturning && (transitSettings.iconRight = "icon-game icon-SpeedUpReturningTransits", transitSettings.iconRightIsButton = !0, transitSettings.iconRightOnClick = this.speedUpTransit), React.createElement(ComponentsMenuListElementBasic, { settings: transitSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitMenuSendSpyButton, [xy.dNames.componentsEngine, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, function(componentsEngine, servicesTheme, servicesInternationalization, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        affectedHabitat: {},
        isHabitatToFarAway: !1,
        initialComponent: null,
        onClick: null,
        showAsMenuElement: !1
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, linkFAQ = servicesTheme.getFAQLink("sendSpy"), iconsTheme = servicesTheme.themeSettings.imagesClassNames;
      return sectionComponentSettings = {
        iconLeft: iconsTheme.startTransit.spy,
        iconRight: iconsTheme.controls.next,
        title: servicesInternationalization.localize("Send Spy")
      }, settings.onClick ? sectionComponentSettings.onClick = settings.onClick : sectionComponentSettings.onClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuHabitatSendSpy.name,
        options: { affectedHabitat: settings.affectedHabitat }
      }), linkFAQ && (sectionComponentSettings.iconRight = iconsTheme.controls.info, sectionComponentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), settings.isHabitatToFarAway && (sectionComponentSettings.disabled = !0), settings.showAsMenuElement ? React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings }) : React.createElement(ComponentsMenuListButtonBasic, { settings: sectionComponentSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitMenuSendResourcesButton, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, function(componentsEngine, settingsGameConstant, servicesTheme, servicesInternationalization, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        affectedHabitat: {},
        isHabitatToFarAway: !1,
        initialComponent: null,
        onClick: null,
        showAsMenuElement: !1
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, linkFAQ = servicesTheme.getFAQLink("sendResources"), iconsTheme = servicesTheme.themeSettings.imagesClassNames;
      return sectionComponentSettings = {
        iconLeft: iconsTheme.startTransit.transit,
        iconRight: iconsTheme.controls.next, title: servicesInternationalization.localize("Send Resources")
      }, settings.onClick ? sectionComponentSettings.onClick = settings.onClick : sectionComponentSettings.onClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuHabitatSendUnitsResources.name,
        options: {
          attackingHabitat: settings.affectedHabitat,
          mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SEND_RESOURCES
        }
      }), linkFAQ && (sectionComponentSettings.iconRight = iconsTheme.controls.info, sectionComponentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), settings.isHabitatToFarAway && (sectionComponentSettings.disabled = !0), settings.showAsMenuElement ? React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings }) : React.createElement(ComponentsMenuListButtonBasic, { settings: sectionComponentSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitMenuAttackButton, [xy.dNames.componentsEngine, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.settings.gameConstant, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, function(componentsEngine, servicesTheme, servicesInternationalization, servicesLog, settingsGameConstant, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        attackingHabitat: {},
        isHabitatToFarAway: !1,
        initialComponent: null,
        mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK,
        onClick: null,
        showAsMenuElement: !1
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, link, linkFAQ, title, originalThis = settings.initialComponent, iconsTheme = servicesTheme.themeSettings.imagesClassNames;
      switch (settings.mode) {
        case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK:
          link = "attack", title = "Attack Habitat";
          break;
        case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK_SYNC:
          link = "attackSync", title = "Synchronize battle";
          break;
        default:
          servicesLog("warn", "unknown attack mode")
      }
      return sectionComponentSettings = {
        classes: "menu--attack-button",
        iconLeft: iconsTheme.startTransit.attack,
        iconRight: iconsTheme.controls.next,
        title: servicesInternationalization.localize(title)
      }, settings.onClick ? sectionComponentSettings.onClick = settings.onClick : sectionComponentSettings.onClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuHabitatSendUnitsResources.name,
        options: { attackingHabitat: settings.attackingHabitat, mode: settings.mode }
      }), linkFAQ = servicesTheme.getFAQLink(link), linkFAQ && (sectionComponentSettings.iconRight = iconsTheme.controls.info, sectionComponentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), settings.isHabitatToFarAway && (sectionComponentSettings.disabled = !0), settings.showAsMenuElement ? React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings }) : React.createElement(ComponentsMenuListButtonBasic, { settings: sectionComponentSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.transitMenuSupportButton, [xy.dNames.componentsEngine, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.settings.gameConstant, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, function(componentsEngine, servicesTheme, servicesInternationalization, servicesLog, settingsGameConstant, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        habitat: {},
        isHabitatToFarAway: !1,
        mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT,
        initialComponent: null,
        onClick: null,
        showAsMenuElement: !1
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, linkFAQ, link, title, originalThis = settings.initialComponent, iconsTheme = servicesTheme.themeSettings.imagesClassNames;
      switch (settings.mode) {
        case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT:
          link = "supportHabitat", title = "Defend Habitat";
          break;
        case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT_SYNC:
          link = "attackSync", title = "Synchronize defence";
          break;
        default:
          servicesLog("warn", "unknown support mode")
      }
      return sectionComponentSettings = {
        iconLeft: iconsTheme.startTransit.defendHabitat,
        iconRight: iconsTheme.controls.next,
        title: servicesInternationalization.localize(title)
      }, settings.onClick ? sectionComponentSettings.onClick = settings.onClick : sectionComponentSettings.onClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuHabitatSendUnitsResources.name,
        options: { attackingHabitat: settings.habitat, mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT }
      }), linkFAQ = servicesTheme.getFAQLink(link), linkFAQ && (sectionComponentSettings.iconRight = iconsTheme.controls.info, sectionComponentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), settings.isHabitatToFarAway && (sectionComponentSettings.disabled = !0), settings.showAsMenuElement ? React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings }) : React.createElement(ComponentsMenuListButtonBasic, { settings: sectionComponentSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.overviewWidgetMovementWithLastFormation, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.icon, xy.dNames.components.unitIconAmount, xy.dNames.components.resourceIconAmount, function(gameInstance, componentEngine, utilsDateTime, servicesInternationalization, servicesTheme, ComponentsIcon, ComponentsUnitIconAmount, ComponentsResourceIconAmount) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        units: {},
        resources: {},
        arrivalDate: {},
        lastFormationMode: !1,
        onClick: null,
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var originalThis = settings.initialComponent, lang = gameInstance.getGameLanguage(), classes = "menu-list-element habitat-overview--widget ";
      settings.onClick && (classes += "clickable ");
      var componentSettings, components = [];
      classes += "with-icon-left ", componentSettings = {
        classes: "icon-left",
        icon: servicesTheme.themeSettings.imagesClassNames.movementWithLastFormation[settings.lastFormationMode]
      }, components.push(React.createElement(ComponentsIcon, {
        settings: componentSettings,
        key: "left-icon"
      })), classes += "with-icon-right ", componentSettings = {
        classes: "clickable icon-right",
        icon: "controls menu-info"
      };
      var settingsFaq = servicesTheme.themeSettings.faqLinks;
      settingsFaq && settingsFaq.attackWithLastFormation && (componentSettings.onClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: settingsFaq.baseURL + settingsFaq.attackWithLastFormation + "&l=" + lang }
      })), components.push(React.createElement(ComponentsIcon, { settings: componentSettings, key: "right-icon" }));
      var titleText = servicesInternationalization.localize(servicesTheme.themeSettings.movementWithLastFormation[settings.lastFormationMode]);
      components.push(React.createElement("div", {
        key: "title-section",
        className: "habitat-overview-title summary"
      }, titleText));
      var resourceId, resources = [];
      for (resourceId in settings.resources)settings.resources.hasOwnProperty(resourceId) && (componentSettings = {
        icon: "icon-resource-" + resourceId,
        amount: settings.resources[resourceId],
        showFill: !1,
        classes: "dark"
      }, resources.push(React.createElement(ComponentsResourceIconAmount, {
        settings: componentSettings,
        key: "resource-" + resourceId
      })));
      components.push(React.createElement("div", {
        key: "resources-section",
        className: "habitat-overview-row"
      }, resources));
      var unitId, units = [];
      for (unitId in settings.units)settings.units.hasOwnProperty(unitId) && (componentSettings = {
        icon: "icon-unit-" + unitId,
        amount: settings.units[unitId],
        classes: "dark"
      }, units.push(React.createElement(ComponentsUnitIconAmount, {
        settings: componentSettings,
        key: "unit-" + unitId
      })));
      components.push(React.createElement("div", { key: "units-section", className: "habitat-overview-row" }, units));
      var arrivalTime = utilsDateTime.getLocaleDateTimeString(settings.arrivalDate), arrivalCycle = utilsDateTime.getDayCycle(settings.arrivalDate);
      return components.push(React.createElement("div", {
        key: "arrival-time",
        className: "habitat-overview-row center-positioned first "
      }, React.createElement("div", {
        className: "icon icon-game colored icon-" + arrivalCycle + "Icon",
        onClick: settings.onClick
      }), arrivalTime)), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, components)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.protectionWidgetAttackProtectionButton, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListButtonBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesTheme, servicesInternationalization, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function() {
      var title, timerString, remainTimeString, status = servicesGameDataManager.playersCollection.getPlayersProtectiveShieldStatus(), player = servicesGameDataManager.playersCollection.getPlayer(), isDisabled = !0, timer = !1;
      switch (status) {
        case settingsGameConstant.PROTECTION_SHIELD_STATUS.UNAVAILABLE:
          title = "Start protective shield";
          break;
        case settingsGameConstant.PROTECTION_SHIELD_STATUS.AVAILABLE:
          title = "Start protective shield", isDisabled = !1;
          break;
        case settingsGameConstant.PROTECTION_SHIELD_STATUS.COOLDOWN:
          title = "Start protective shield", timer = player.attackProtectionCooldownEndDate, timerString = utilsDateTime.getLocaleDateTimeString(timer), remainTimeString = utilsDateTime.remainTime(timer, !0);
          break;
        case settingsGameConstant.PROTECTION_SHIELD_STATUS.ACTIVE:
          title = "Protective shield", timer = player.attackProtectionEndDate, timerString = utilsDateTime.getLocaleDateTimeString(timer), remainTimeString = utilsDateTime.remainTime(timer, !0)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        title: title,
        isDisabled: isDisabled,
        timer: timer,
        timerString: timerString,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { initialComponent: {}, classes: "", onClick: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, linkFAQ = servicesTheme.getFAQLink("protectiveShield"), iconsTheme = servicesTheme.themeSettings.imagesClassNames, state = this.state;
      return sectionComponentSettings = {
        title: servicesInternationalization.localize(state.title),
        disabled: state.isDisabled,
        onClick: settings.onClick
      }, state.timer && (sectionComponentSettings.description = state.remainTimeString + " - " + state.timerString), linkFAQ && (sectionComponentSettings.iconRight = iconsTheme.controls.info, sectionComponentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-attack"
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.protectionWidgetVacationButton, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListButtonBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesTheme, servicesInternationalization, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function() {
      var title, timerString, remainTimeString, status = servicesGameDataManager.playersCollection.getPlayersVacationShieldStatus(), player = servicesGameDataManager.playersCollection.getPlayer(), isDisabled = !0, timer = !1;
      switch (status) {
        case settingsGameConstant.VACATION_SHIELD_STATUS.UNAVAILABLE:
          title = "Start vacation";
          break;
        case settingsGameConstant.VACATION_SHIELD_STATUS.AVAILABLE:
          title = "Start vacation", isDisabled = !1;
          break;
        case settingsGameConstant.VACATION_SHIELD_STATUS.STARTING:
          title = "Vacation mode activated", timer = player.vacationStartDate, timerString = utilsDateTime.getLocaleDateTimeString(timer), remainTimeString = utilsDateTime.remainTime(timer, !0);
          break;
        case settingsGameConstant.VACATION_SHIELD_STATUS.ACTIVE:
          title = "Vacation mode is already active"
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        title: title,
        isDisabled: isDisabled,
        timer: timer,
        timerString: timerString,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { initialComponent: {}, classes: "", onClick: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, themeSettings = servicesTheme.themeSettings, linkFAQ = servicesTheme.getFAQLink(themeSettings.availableHelpShiftPages.vacationMode), state = this.state;
      return sectionComponentSettings = {
        title: servicesInternationalization.localize(state.title),
        disabled: state.isDisabled,
        onClick: settings.onClick
      }, state.timer && (sectionComponentSettings.description = state.remainTimeString + " - " + state.timerString), linkFAQ && (sectionComponentSettings.iconRight = "controls menu-info", sectionComponentSettings.iconRightOnClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: linkFAQ }
      })), React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-attack"
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.protectionWidgetNoobProtectionTeleportButton, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListButtonBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesTheme, servicesInternationalization, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        timer = props.settings.timer, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Transit timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { classes: "", onClick: null, timer: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, iconsTheme = servicesTheme.themeSettings.imagesClassNames, state = this.state;
      return sectionComponentSettings = {
        title: servicesInternationalization.localize("Relocate castle"),
        iconLeft: iconsTheme.featureRelocateHabitat.relocateHabitat,
        onClick: settings.onClick
      }, state.timer && (sectionComponentSettings.description = state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(state.timer)), React.createElement(ComponentsMenuListButtonBasic, { settings: sectionComponentSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuSection, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    getInitialState: function() {
      return this.getDimensions()
    }, getDimensions: function() {
      var topBarHeight, bottomBarHeight, container, el, windowHeight = window.innerHeight;
      return container = document.getElementById(xy.DomElements.gameBarTop), el = container.getElementsByClassName(xy.DomElements.gameBarTopContainerClass)[0], topBarHeight = el.clientHeight || el.scrollHeight || el.offsetHeight, container = document.getElementById(xy.DomElements.gameBarBottom), el = container.getElementsByClassName(xy.DomElements.gameBarBottomContainerClass)[0], bottomBarHeight = el.clientHeight || el.scrollHeight || el.offsetHeight, { height: windowHeight - topBarHeight - bottomBarHeight }
    }, updateDimensions: function() {
      this.setState(this.getDimensions(), null)
    }, componentWillMount: function() {
      this.updateDimensions()
    }, componentDidMount: function() {
      window.addEventListener("resize", this.updateDimensions)
    }, componentWillUnmount: function() {
      window.removeEventListener("resize", this.updateDimensions)
    }, render: function() {
      var settings = { titleBar: null, tapBar: null, searchBar: null, bottomBar: null, content: null };
      Object.assign(settings, this.props.settings);
      var menuSectionExtraClasses = "", contentComponent = null, bottomBarComponent = null;
      return settings.tapBar && (menuSectionExtraClasses += " with-fixed-tap-bar"), settings.searchBar && (menuSectionExtraClasses += " with-fixed-top-search"), settings.bottomBar && (menuSectionExtraClasses += " with-fixed-bottom-bar", bottomBarComponent = React.createElement("div", { className: "menu--bottom-bar-section" }, settings.bottomBar)), contentComponent = settings.content instanceof Array ? React.createElement("div", { className: "menu--content-section" }, settings.content) : settings.content, React.createElement("div", {
        className: "menu-section" + menuSectionExtraClasses,
        style: { height: this.state.height }
      }, React.createElement("div", { className: "menu--top-bar-section" }, settings.titleBar, settings.tapBar, settings.searchBar), contentComponent, bottomBarComponent)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuSectionContent, [xy.dNames.componentsEngine, function(componentEngine) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { content: null, classes: "" };
      return Object.assign(settings, this.props.settings), React.createElement("div", { className: "menu--content-section " + settings.classes }, settings.content)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuBottomBarMain, [xy.dNames.componentsEngine, xy.dNames.components.buttonMain, function(componentEngine, ComponentsButtonMain) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", leftButton: null, rightButton: null }, leftButton = [], rightButton = [];
      Object.assign(settings, this.props.settings);
      var addButtonToBar = function(btn, indx) {
        indx = indx || 0, this.isLeft ? (btn.classes = "menu--title-bar-main--button--left", leftButton.push(React.createElement(ComponentsButtonMain, {
          settings: btn,
          key: "title-left-button-" + indx
        }))) : (btn.classes = "menu--title-bar-main--button--right", rightButton.push(React.createElement(ComponentsButtonMain, {
          settings: btn,
          key: "title-right-button-" + indx
        })))
      };
      return settings.leftButton && (settings.leftButton instanceof Array ? settings.leftButton.forEach(addButtonToBar, { isLeft: !0 }) : addButtonToBar.call({ isLeft: !0 }, settings.leftButton)), settings.rightButton && (settings.rightButton instanceof Array ? settings.rightButton.forEach(addButtonToBar, { isLeft: !1 }) : addButtonToBar.call({ isLeft: !1 }, settings.rightButton)), React.createElement("div", { className: "menu--title-bar-main bottom " + settings.classes }, React.createElement("div", { className: "menu--title-bar-main--button-section-left" }, leftButton), React.createElement("div", { className: "menu--title-bar-main--button-section-right" }, rightButton))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuTitleBarMain, [xy.dNames.componentsEngine, xy.dNames.components.buttonMain, xy.dNames.utils.string, xy.dNames.settings.gameConstant, function(componentEngine, ComponentsButtonMain, utilsString, settingsGameConstant) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var title, settings = {
        classes: "",
        title: "",
        leftButton: null,
        leftButtonIcon: null,
        leftButtonTitle: null,
        leftButtonOnClick: null,
        rightButton: null
      }, leftButton = [], rightButton = [];
      Object.assign(settings, this.props.settings);
      var addToLeftButton = function(btn, index) {
        index = index || 0;
        var originalClasses = btn.classes || "";
        btn.classes = originalClasses + " menu--title-bar-main--button--left", leftButton.push(React.createElement(ComponentsButtonMain, {
          settings: btn,
          key: "title-left-button-" + index
        }))
      };
      settings.leftButton && (settings.leftButton instanceof Array ? settings.leftButton.forEach(addToLeftButton) : addToLeftButton({
        onClick: settings.leftButtonOnClick,
        icon: settings.leftButtonIcon,
        title: settings.leftButtonTitle
      }));
      var addToRightButton = function(btn, index) {
        index = index || 0;
        var originalClasses = btn.classes || "";
        btn.classes = originalClasses + " menu--title-bar-main--button--right", rightButton.push(React.createElement(ComponentsButtonMain, {
          settings: btn,
          key: "title-right-button-" + index
        }))
      };
      return settings.rightButton && (settings.rightButton instanceof Array ? settings.rightButton.forEach(addToRightButton) : addToRightButton(settings.rightButton)), title = utilsString.getStringWithValidLength(settings.title, settingsGameConstant.MAX_LENGTH_MENU_TITLE), React.createElement("div", { className: "menu--title-bar-main " + settings.classes }, React.createElement("div", { className: "menu--title-bar-main--button-section-left" }, leftButton), React.createElement("div", { className: "menu--title-bar-main--title" }, title), React.createElement("div", { className: "menu--title-bar-main--button-section-right" }, rightButton))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuListTitleBasic, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentEngine, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var iconSettings, settings = {
        title: "",
        iconLeft: null,
        classes: "",
        iconRight: "",
        onClick: null
      }, leftIcon = null, rightIcon = null;
      Object.assign(settings, this.props.settings);
      var classes = "menu-list-element menu-list-title-basic ";
      return settings.onClick && (classes += "clickable "), settings.iconLeft && (classes += "with-icon-left ", iconSettings = {
        classes: settings.iconLeftOnClick ? "clickable icon-left" : "icon-left",
        icon: settings.iconLeft,
        onClick: settings.iconLeftOnClick
      }, leftIcon = React.createElement(ComponentsIcon, { settings: iconSettings })), settings.iconRight && (classes += "with-icon-right ", "string" == typeof settings.iconRight ? (iconSettings = {
        classes: "icon-right",
        icon: settings.iconRight
      }, rightIcon = React.createElement(ComponentsIcon, { settings: iconSettings })) : rightIcon = settings.iconRight), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, leftIcon, " ", settings.title, " ", rightIcon)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuListElementBasic, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.components.icon, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var timer = null, timerString = null, remainTimeString = null;
      return props.settings.timer && utilsDateTime.remainTimeInSeconds(props.settings.timer) && (timer = props.settings.timer, timerString = utilsDateTime.getLocaleDateTimeString(timer), remainTimeString = utilsDateTime.remainTime(timer, !0)), this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        timerString: timerString,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = {
        title: "",
        description: null,
        rightColumnDataValue: null,
        rightColumnLeftIcon: null,
        classes: "",
        onClick: null,
        disabled: !1,
        activated: !1,
        iconLeft: null,
        iconLeftOnClick: null,
        iconRight: null,
        iconRightIsButton: !1,
        iconRightOnClick: null,
        isSelectable: !1,
        isSelected: !1,
        onSelect: null,
        timer: null,
        hideBorders: !1
      }, onClick = null, description = null, value = null, selecting = null, leftIcon = null, rightIcon = null, iconSettings = null;
      Object.assign(settings, this.props.settings);
      var classes = "menu-list-element menu-list-element-basic ", textBoxClasses = "menu-list-element-basic--content-box ";
      if (settings.disabled && (classes += "disabled ", settings.onClick = null), settings.onClick && (classes += "clickable "), settings.hideBorders && (classes += "no-borders "), settings.activated && (classes += "activated "), this.state.timer && (settings.description = this.state.remainTimeString + " - " + this.state.timerString), settings.description) {
        textBoxClasses += "with-description ";
        var extraDescriptionClass = " small-font ";
        settings.description.length > 40 && (extraDescriptionClass = " smaller-font"), settings.description.length > 60 && (extraDescriptionClass = " smallest-font"), description = React.createElement("div", { className: "menu-list-element-basic--description " + extraDescriptionClass }, settings.description)
      }
      if (settings.rightColumnDataValue) {
        textBoxClasses += "with-value ";
        var rightColumnText = settings.rightColumnDataValue, rightColumnLeftIcon = null, rightColumnExtraStyles = "";
        settings.rightColumnLeftIcon && (rightColumnText = React.createElement("div", { className: "text" }, settings.rightColumnDataValue), rightColumnExtraStyles = " with-icon", iconSettings = { icon: settings.rightColumnLeftIcon }, rightColumnLeftIcon = React.createElement(ComponentsIcon, { settings: iconSettings })), value = React.createElement("div", { className: "menu-list-element-basic--value" + rightColumnExtraStyles }, rightColumnLeftIcon, rightColumnText)
      }
      return settings.isSelectable && (classes += "selectable ", iconSettings = { icon: settings.isSelected ? "menu-selectable checked" : "menu-selectable" }, selecting = React.createElement("div", {
        className: "menu-list-element-selectable-area",
        onClick: settings.onSelect
      }, React.createElement(ComponentsIcon, { settings: iconSettings }))), settings.iconLeft && (classes += "with-icon-left ", "string" == typeof settings.iconLeft ? (iconSettings = {
        classes: settings.iconLeftOnClick ? "clickable icon-left" : "icon-left",
        icon: settings.iconLeft,
        onClick: settings.iconLeftOnClick
      }, leftIcon = React.createElement(ComponentsIcon, { settings: iconSettings })) : leftIcon = settings.iconLeft), settings.iconRight && !settings.isSelectable && (classes += "with-icon-right ", "string" == typeof settings.iconRight ? (iconSettings = {
        classes: settings.iconRightOnClick ? "clickable icon-right" : "icon-right",
        icon: settings.iconRight,
        onClick: settings.iconRightOnClick
      }, rightIcon = settings.iconRightIsButton ? React.createElement("div", { className: "icon-button" }, React.createElement(ComponentsIcon, { settings: iconSettings })) : React.createElement(ComponentsIcon, { settings: iconSettings })) : rightIcon = settings.iconRight), settings.onClick && !settings.isSelectable && (onClick = settings.onClick), React.createElement("div", {
        className: classes + settings.classes,
        onClick: onClick
      }, selecting, leftIcon, React.createElement("div", { className: textBoxClasses }, React.createElement("div", { className: "menu-list-element-basic--title-desc-box" }, React.createElement("div", { className: "menu-list-element-basic--title text-name-with-emo-icons" }, settings.title), description), value), rightIcon)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuListElementButtonAction, [xy.dNames.componentsEngine, xy.dNames.components.buttonMain, function(componentEngine, ComponentsButtonMain) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { icon: "", onClick: null, classes: "", isDisabled: !1 };
      Object.assign(settings, this.props.settings);
      var classes = "menu-element--button--action ";
      return settings.classes = classes + settings.classes, React.createElement(ComponentsButtonMain, { settings: settings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuListButtonBasic, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentEngine, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        title: "",
        description: null,
        rightColumnDataValue: null,
        classes: "",
        onClick: null,
        disabled: !1,
        iconLeft: null,
        iconLeftOnClick: null,
        iconRight: null,
        iconRightOnClick: null
      }, description = null, value = null, leftIcon = null, rightIcon = null, iconSettings = null;
      Object.assign(settings, this.props.settings);
      var classes = "menu-list-element  menu-list-button-basic ", textBoxClasses = "menu-list-element-basic--content-box ";
      return settings.disabled && (classes += "disabled ", settings.onClick = null), settings.onClick && (classes += "clickable "), settings.description && (textBoxClasses += "with-description ", description = React.createElement("div", { className: "menu-list-element-basic--description" }, settings.description)), settings.rightColumnDataValue && (textBoxClasses += "with-value ", value = React.createElement("div", { className: "menu-list-element-basic--value" }, settings.rightColumnDataValue)), settings.iconLeft && (classes += "with-icon-left ", "string" == typeof settings.iconLeft ? (iconSettings = {
        classes: settings.iconLeftOnClick ? "clickable icon-left" : "icon-left",
        icon: settings.iconLeft,
        onClick: settings.iconLeftOnClick
      }, leftIcon = React.createElement(ComponentsIcon, { settings: iconSettings })) : leftIcon = settings.iconLeft), settings.iconRight && (classes += "with-icon-right ", iconSettings = {
        classes: settings.iconRightOnClick ? "clickable icon-right " : "icon-right ",
        icon: settings.iconRight,
        onClick: settings.iconRightOnClick
      }, rightIcon = React.createElement(ComponentsIcon, { settings: iconSettings })), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, leftIcon, React.createElement("div", { className: textBoxClasses }, React.createElement("div", { className: "menu-list-element-basic--title-desc-box" }, React.createElement("div", { className: "menu-list-element-basic--title text-name-with-emo-icons" }, settings.title), description), value), rightIcon)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuListButtonDisplayLink, [xy.dNames.componentsEngine, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuListButtonBasic, function(componentEngine, servicesGameDataManager, servicesTheme, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { iconLeft: null, defaultTitle: "", onClick: null, targetModel: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, iconsTheme = servicesTheme.themeSettings.imagesClassNames;
      return sectionComponentSettings = {
        iconLeft: settings.iconLeft,
        onClick: settings.onClick,
        title: settings.defaultTitle
      }, servicesGameDataManager.isModelHasActiveLink(settings.targetModel) && (sectionComponentSettings.iconLeft = iconsTheme.icon.tickOff, sectionComponentSettings.title = servicesGameDataManager.getActiveModelLink(), sectionComponentSettings.classes = "game-link"), React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-copy-model-link"
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuListTextBasic, [xy.dNames.componentsEngine, xy.dNames.utils.string, xy.dNames.components.icon, function(componentEngine, utilsString, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var iconSettings, settings = { text: "", iconLeft: null, initialComponent: null, classes: "" }, leftIcon = null;
      Object.assign(settings, this.props.settings);
      var classes = "menu-list-element menu-list-text-basic ";
      settings.iconLeft && (classes += "withLeftIcon ", iconSettings = { icon: settings.iconLeft }, leftIcon = React.createElement(ComponentsIcon, { settings: iconSettings }));
      var contentText = utilsString.getHTMLOfString(settings.text, settings.initialComponent);
      return React.createElement("div", { className: classes + settings.classes }, leftIcon, React.createElement("div", { className: "text" }, contentText))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuSearchBar, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentEngine, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", value: "", onChange: null, onFocus: null, onBlur: null };
      Object.assign(settings, this.props.settings);
      var iconSettings, classes = "menu-search-bar ", leftIcon = null;
      return settings.iconLeft && (classes += "menu-search-bar--with-icon-search ", "string" == typeof settings.iconLeft ? (iconSettings = {
        classes: settings.iconLeftOnClick ? "clickable icon-left" : "icon-left",
        icon: settings.iconLeft,
        onClick: settings.iconLeftOnClick
      }, leftIcon = React.createElement(ComponentsIcon, { settings: iconSettings })) : leftIcon = settings.iconLeft),
              React.createElement("div", { className: classes + settings.classes }, leftIcon, React.createElement("input", {
                className: "menu-search-bar--input",
                type: "text",
                value: settings.value,
                onChange: settings.onChange,
                onFocus: settings.onFocus,
                onBlur: settings.onBlur
              }))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuTapBar, [xy.dNames.componentsEngine, xy.dNames.components.menuTapBarButton, function(componentEngine, ComponentsMenuTapBarButton) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", buttons: [] }, buttons = [];
      Object.assign(settings, this.props.settings);
      var classes = "menu-tap-bar buttons-" + settings.buttons.length + " ";
      return settings.buttons.forEach(function(btn) {
        buttons.push(React.createElement(ComponentsMenuTapBarButton, {
          settings: btn,
          key: "tap-button-" + (btn.name || btn.icon || btn.title)
        }))
      }), React.createElement("div", { className: classes + settings.classes }, buttons)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuTapBarButton, [xy.dNames.componentsEngine, xy.dNames.components.icon, function(componentEngine, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var iconSettings, settings = {
        isActive: !1,
        classes: "",
        icon: "",
        iconPlaceholder: "",
        title: null,
        onClick: null
      }, icon = null, title = null;
      Object.assign(settings, this.props.settings);
      var classes = "menu-tap-bar-button ";
      return settings.isActive ? (classes += "active ", settings.onClick = null) : settings.onClick && (classes += "clickable "), (settings.icon || settings.placeholder) && (settings.title || (classes += "with-icon-only "), iconSettings = { icon: settings.icon }, icon = React.createElement(ComponentsIcon, { settings: iconSettings })), settings.title && (classes += settings.icon || settings.placeholder ? "" : "with-title-only ", title = React.createElement("div", { className: "menu-tap-bar-title" }, settings.title)), React.createElement("div", {
        className: classes + settings.classes,
        onClick: settings.onClick
      }, icon, title)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.menuTapBarReportSwitcher, [xy.dNames.componentsEngine, xy.dNames.components.menuTapBarButton, function(componentEngine, ComponentsMenuTapBarButton) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", title: "", leftArrowOnClick: null, rightArrowOnClick: null }, buttons = [];
      Object.assign(settings, this.props.settings);
      var classes = "menu-tap-bar menu-switcher-buttons ", leftButtonSettings = {
        classes: "menu-report-switcher-arrow",
        iconPlaceholder: !0
      }, titleButtonSettings = {
        classes: "menu-report-switcher-title",
        title: settings.title
      }, rightButtonSettings = { classes: "menu-report-switcher-arrow", iconPlaceholder: !0 };
      return settings.leftArrowOnClick && (leftButtonSettings.icon = "controls arrow-left", leftButtonSettings.onClick = settings.leftArrowOnClick), settings.rightArrowOnClick && (rightButtonSettings.icon = "controls arrow-right", rightButtonSettings.onClick = settings.rightArrowOnClick), buttons.push(React.createElement(ComponentsMenuTapBarButton, {
        settings: leftButtonSettings,
        key: "tap-button-lef-arrow"
      })), buttons.push(React.createElement(ComponentsMenuTapBarButton, {
        settings: titleButtonSettings,
        key: "tap-button-title"
      })), buttons.push(React.createElement(ComponentsMenuTapBarButton, {
        settings: rightButtonSettings,
        key: "tap-button-right-arrows"
      })), React.createElement("div", { className: classes + settings.classes }, buttons)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.message, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.components.widgetContentText, xy.dNames.components.icon, function(componentEngine, utilsDateTime, ComponentsWidgetContentText, ComponentsIcon) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        title: "",
        date: null,
        content: "",
        executingComponent: null,
        isSelectable: !1,
        isSelected: !1,
        onSelect: null
      }, selecting = null, iconSettings = null;
      Object.assign(settings, this.props.settings);
      var classes = "menu-list-element menu-list-element-basic ", date = settings.date ? utilsDateTime.getLocaleDateTimeString(settings.date) : null, contentSettings = {
        content: settings.content,
        executingComponent: settings.executingComponent
      }, content = React.createElement(ComponentsWidgetContentText, { settings: contentSettings });
      return settings.isSelectable && (classes += "selectable ", iconSettings = { icon: settings.isSelected ? "menu-selectable checked" : "menu-selectable" }, selecting = React.createElement("div", {
        className: "menu-list-element-selectable-area",
        onClick: settings.onSelect
      }, React.createElement(ComponentsIcon, { settings: iconSettings }))), React.createElement("div", { className: classes + settings.classes }, selecting, React.createElement("div", null, content), React.createElement("div", { className: "message-element--last-entry-date" }, date))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.messageDiscussionEntry, [xy.dNames.componentsEngine, xy.dNames.components.message, xy.dNames.components.menuListTitleBasic, xy.dNames.services.gameDataManager, function(componentEngine, ComponentsMessageSystem, ComponentsMenuListTitleBasic, servicesGameDataManager) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { executingComponent: null, classes: "", forumMessage: null };
      Object.assign(settings, this.props.settings);
      var titleMessageSettings, player = servicesGameDataManager.playersCollection.getPlayer(settings.forumMessage.player), onClick = null, title = "", contentMessageSettings = {
        date: settings.forumMessage.creationDate,
        content: settings.forumMessage.content,
        executingComponent: settings.executingComponent
      };
      return player && (onClick = settings.executingComponent.handlerNextClick.bind(settings.executingComponent, {
        next: xy.dNames.game.menuPlayerProfileExternal.name,
        options: { playerId: player.id }
      }), title = player.nick), titleMessageSettings = {
        onClick: onClick,
        title: title,
        classes: "text-name-with-emo-icons"
      }, React.createElement("div", null, React.createElement(ComponentsMenuListTitleBasic, { settings: titleMessageSettings }), React.createElement(ComponentsMessageSystem, { settings: contentMessageSettings }))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.messageDiscussionMemberChange, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuListTextBasic, function(componentEngine, settingsGameConstant, servicesGameDataManager, servicesInternationalization, ComponentsMenuListTextBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { executingComponent: null, classes: "", changesModel: null };
      Object.assign(settings, this.props.settings);
      var text, textSettings, targetPlayerArray, isMultipleTargetPlayers, performingPlayer, targetPlayer, targetPlayersNameArray = [];
      if (targetPlayerArray = settings.changesModel.targetPlayerArray, performingPlayer = servicesGameDataManager.playersCollection.getPlayer(settings.changesModel.performingPlayer), isMultipleTargetPlayers = targetPlayerArray.length > 1) {
        var i, last = targetPlayerArray.length - 1;
        for (targetPlayer = servicesGameDataManager.playersCollection.getPlayer(targetPlayerArray[last]), i = 0; i < last; i += 1)targetPlayersNameArray.push(servicesGameDataManager.playersCollection.getPlayerProperty("nick", targetPlayerArray[i]));
        switch (settings.changesModel.actionType) {
          case settingsGameConstant.MESSAGE_MEMBER_CHANGE_ACTION.ADD:
            text = servicesInternationalization.localize("%1$@ and %2$@ have been added to the list of participants by %3$@", targetPlayersNameArray.join(", "), targetPlayer.nick, performingPlayer.nick);
            break;
          case settingsGameConstant.MESSAGE_MEMBER_CHANGE_ACTION.DELETE:
            text = servicesInternationalization.localize("%1$@ and %2$@ have been removed from the list of participants by %3$@", targetPlayersNameArray.join(", "), targetPlayer.nick, performingPlayer.nick);
            break;
          default:
            text = ""
        }
      } else switch (targetPlayer = servicesGameDataManager.playersCollection.getPlayer(targetPlayerArray[0]), settings.changesModel.actionType) {
        case settingsGameConstant.MESSAGE_MEMBER_CHANGE_ACTION.ADD:
          text = servicesInternationalization.localize("%1$@ has been added to the list of participants by %2$@", targetPlayer.nick, performingPlayer.nick);
          break;
        case settingsGameConstant.MESSAGE_MEMBER_CHANGE_ACTION.DELETE:
          text = targetPlayer.id === performingPlayer.id ? servicesInternationalization.localize("%1$@ left the discussion", targetPlayer.nick) : servicesInternationalization.localize("%1$@ has been removed from the list of participants by %2$@", targetPlayer.nick, performingPlayer.nick);
          break;
        default:
          text = ""
      }
      return textSettings = { text: text }, React.createElement(ComponentsMenuListTextBasic, { settings: textSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.components.messageForumEntry, [xy.dNames.componentsEngine, xy.dNames.components.message, xy.dNames.components.menuListTitleBasic, xy.dNames.services.gameDataManager, function(componentEngine, ComponentsMessageSystem, ComponentsMenuListTitleBasic, servicesGameDataManager) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        forumMessage: null,
        editMode: !1,
        selectedForumMessagesSet: {},
        initialComponent: null,
        threadStatus: !1
      };
      Object.assign(settings, this.props.settings);
      var contentMessageSettings, titleMessageSettings, forumMessage = settings.forumMessage, player = servicesGameDataManager.playersCollection.getPlayer(forumMessage.author), onClick = null, title = "", originalThis = settings.initialComponent;
      return player && (onClick = originalThis.handlerNextClick.bind(originalThis, {
        next: xy.dNames.game.menuPlayerProfileExternal.name,
        options: { playerId: player.id }
      }), title = player.nick), titleMessageSettings = {
        onClick: onClick,
        title: title,
        classes: "text-name-with-emo-icons"
      }, contentMessageSettings = {
        date: forumMessage.creationDate,
        content: forumMessage.content,
        executingComponent: originalThis
      }, settings.editMode && (contentMessageSettings.isSelectable = !settings.threadStatus, contentMessageSettings.onSelect = originalThis.onCheckboxClick.bind(originalThis, forumMessage), settings.selectedForumMessagesSet[settings.forumMessage.id] && (contentMessageSettings.isSelected = !0)), React.createElement("div", null, React.createElement(ComponentsMenuListTitleBasic, { settings: titleMessageSettings }), React.createElement(ComponentsMessageSystem, { settings: contentMessageSettings }))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneLogin.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElement, xy.dNames.settings.gameConstant, xy.dNames.utils.oop, xy.dNames.utils.string, xy.dNames.utils.network, xy.dNames.services.resourcesManager, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementScene, settingsGameConstant, utilsOop, utilsString, utilsNetwork, servicesResourcesManager, servicesInternationalization) {
  "use strict";
  function SceneLoginController(options) {
    SceneLoginController.__super__.constructor.call(this, options), this.peningNewLocale = null
  }

  return utilsOop.extend(SceneLoginController, CoreControllerElementScene), SceneLoginController.prototype.runScene = function(data) {
    var urlParams = utilsNetwork.getParamsFromURL(), paramName = settingsGameConstant.QUERY_PARAM_NAMES.LOGIN, paramPassword = settingsGameConstant.QUERY_PARAM_NAMES.PASSWORD, paramFacebookToken = settingsGameConstant.QUERY_PARAM_NAMES.FACEBOOK_TOKEN, paramGoogleToken = settingsGameConstant.QUERY_PARAM_NAMES.GOOGLE_TOKEN;
    urlParams[paramName] && urlParams[paramPassword] ? this.dataSource.checkCredential({
      name: urlParams[paramName],
      password: urlParams[paramPassword]
    }, { isPasswordHashed: !0 }) : urlParams[paramFacebookToken] ? this.dataSource.checkCredential({ facebookAccessToken: urlParams[paramFacebookToken] }) : urlParams[paramGoogleToken] ? this.dataSource.checkCredential({ googleAccessToken: urlParams[paramGoogleToken] }) : this.presenter.draw(data)
  }, SceneLoginController.prototype[xy.eNames.eventSceneLogin.formSubmit] = function(data) {
    data = data || {};
    var emailRegExp = utilsString.getRegExp("email");
    if (!data["login-name"] || !emailRegExp.test(data["login-name"]))return !1;
    var passwordRegExp = utilsString.getRegExp("not-empty");
    return !(!data["login-password"] || !passwordRegExp.test(data["login-password"])) && (this.dataSource.checkCredential({
              name: data["login-name"],
              password: data["login-password"]
            }), !0)
  }, SceneLoginController.prototype[xy.eNames.eventSceneLogin.changeLanguage] = function(options) {
    this.peningNewLocale = options.locale, servicesResourcesManager.reloadInternationalizationResources(options.locale, {
      context: this,
      onLoaded: this.onInternationalizationResourceReloaded
    })
  }, SceneLoginController.prototype.onInternationalizationResourceReloaded = function() {
    servicesInternationalization.updateLocale({
      main: servicesResourcesManager.getResourcesValue(xy.res.localizationMain),
      event: servicesResourcesManager.getResourcesValue(xy.res.localizationEvent)
    }), gameInstance.setGameLanguage(this.peningNewLocale.toLowerCase()), this.peningNewLocale = null, this.presenter.draw()
  }, SceneLoginController.prototype[xy.eNames.eventSceneLogin.successLogin] = function() {
    this.showNextScene(xy.dNames.game.sceneChooseWorld.name)
  }, SceneLoginController.prototype[xy.eNames.eventSceneLogin.failLogin] = function(data) {
    this.presenter.draw(data)
  }, SceneLoginController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneLogin.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.network, function(CoreDataSource, utilsOop, utilsNetwork, servicesNetwork) {
  "use strict";
  function SceneLoginDataSource(options) {
    SceneLoginDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneLoginDataSource, CoreDataSource), SceneLoginDataSource.prototype.checkCredential = function(data, options) {
    options = options || {}, servicesNetwork.credential = null;
    var params = {};
    params = data.facebookAccessToken ? { facebookAccessToken: data.facebookAccessToken } : data.googleAccessToken ? { googleAccessToken: data.googleAccessToken } : {
      login: decodeURIComponent(data.name),
      password: options.isPasswordHashed ? data.password : utilsNetwork.hash(data.password)
    }, this.credentialInProgress = params, this.request(params, "LoginAction/checkValidLoginBrowser", {
      callBack: this.credentialValid,
      errorCallBack: this.credentialIsNotValid,
      isLogin: !0
    })
  }, SceneLoginDataSource.prototype.credentialValid = function(data) {
    data.loginId && (this.credentialInProgress.loginId = data.loginId, servicesNetwork.credential = this.credentialInProgress, this.notify(xy.eNames.eventSceneLogin.successLogin, data))
  }, SceneLoginDataSource.prototype.credentialIsNotValid = function(data) {
    data.error && this.notify(xy.eNames.eventSceneLogin.failLogin, { name: this.credentialInProgress.login })
  }, SceneLoginDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneLogin.presenter, [xy.dNames.componentsEngine, xy.dNames.core.presenterElement, xy.dNames.utils.oop, xy.dNames.game.sceneLogin.component, function(componentsEngine, CorePresenterElement, utilsOop, SceneLoginComponent) {
  "use strict";
  function SceneLoginPresenter(options) {
    SceneLoginPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneLoginPresenter, CorePresenterElement), SceneLoginPresenter.prototype.draw = function(data) {
    componentsEngine.render(React.createElement(SceneLoginComponent, {
      presenter: this,
      settings: data || {}
    }), document.getElementById(xy.DomElements.gameFrame))
  }, SceneLoginPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneLogin.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.utils.string, xy.dNames.services.log, xy.dNames.services.internationalization, xy.dNames.components.inputTextField, xy.dNames.components.alertTooltip, xy.dNames.components.button, xy.dNames.components.containerWindowBox, xy.dNames.components.dropdownLanguage, function(gameInstance, componentsEngine, utilsString, servicesLog, servicesInternationalization, ComponentsInputTextField, ComponentsAlertTooltip, ComponentsControlButton, ComponentsContainerWindowBox, ComponentsDropdownLanguage) {
  "use strict";
  return componentsEngine.createClass({
    getInitialState: function() {
      return { emailErrorStatus: "", passwordErrorStatus: "" }
    }, handlerOnSubmit: function(event) {
      event.stopPropagation(), event.preventDefault();
      var form = event.currentTarget, data = { "login-name": "", "login-password": "" }, isValid = !0;
      try {
        data["login-name"] = form["login-name"].value, data["login-password"] = form["login-password"].value
      } catch (e) {
        servicesLog("error", e.toString())
      }
      utilsString.isValid(data["login-name"], "email") || (this.setState({ emailErrorStatus: "in" }, null), isValid = !1), utilsString.isValid(data["login-password"], "not-empty") || (this.setState({ passwordErrorStatus: "in" }, null), isValid = !1), isValid && this.props.presenter.notify(xy.eNames.eventSceneLogin.formSubmit, data)
    }, handlerOnFocusEmail: function() {
      this.setState({ emailErrorStatus: "" }, null)
    }, handlerOnFocusPassword: function() {
      this.setState({ passwordErrorStatus: "" }, null)
    }, handlerOnLanguageChange: function(item) {
      item && item.locale && this.props.presenter.notify(xy.eNames.eventSceneLogin.changeLanguage, item)
    }, render: function() {
      var settingsDropdownLanguage, settingsLoginName = {
        type: "text",
        name: "login-name",
        value: this.props.settings.name || "",
        placeHolder: servicesInternationalization.localize("Email"),
        handlerOnFocus: this.handlerOnFocusEmail
      }, settingsLoginPassword = {
        type: "password",
        name: "login-password",
        placeHolder: servicesInternationalization.localize("Password"),
        handlerOnFocus: this.handlerOnFocusPassword
      }, tooltipEmailSettings = {
        text: servicesInternationalization.localize("The email addresses do not match. Please check your input."),
        status: this.state.emailErrorStatus
      }, tooltipPasswordSettings = {
        text: servicesInternationalization.localize("Password"),
        status: this.state.passwordErrorStatus
      }, settingsSubmitButton = { type: "submit", title: servicesInternationalization.localize("Login") };
      return settingsDropdownLanguage = {
        initialComponent: this,
        onSelect: this.handlerOnLanguageChange
      }, React.createElement("div", { id: "login-scene" }, React.createElement(ComponentsContainerWindowBox, null, React.createElement("form", {
        id: "login-scene--form",
        onSubmit: this.handlerOnSubmit
      }, React.createElement("div", { className: "form--component" }, React.createElement(ComponentsAlertTooltip, { settings: tooltipEmailSettings }), React.createElement(ComponentsInputTextField, { settings: settingsLoginName })), React.createElement("div", { className: "form--component" }, React.createElement(ComponentsAlertTooltip, { settings: tooltipPasswordSettings }), React.createElement(ComponentsInputTextField, { settings: settingsLoginPassword })), React.createElement(ComponentsDropdownLanguage, { settings: settingsDropdownLanguage }), React.createElement(ComponentsControlButton, { settings: settingsSubmitButton }))))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneChooseWorld.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElement, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.storage, xy.dNames.services.network, xy.dNames.services.eventManager, function(gameInstance, CoreControllerElementScene, utilsOop, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesStorage, servicesNetwork, servicesEventManager) {
  "use strict";
  function ChooseWorldSceneController(options) {
    ChooseWorldSceneController.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ChooseWorldSceneController, CoreControllerElementScene), ChooseWorldSceneController.prototype.__initStorage = function() {
    servicesStorage.initLoginStorage({ game: gameInstance.getCurrentGame(), player: servicesNetwork.credential.login })
  }, ChooseWorldSceneController.prototype.start = function() {
    this.__initStorage(), this.dataSource.getWorldsListData()
  }, ChooseWorldSceneController.prototype[xy.eNames.sceneChooseWorld.drawWithWorldsListData] = function(data) {
    servicesEventManager.handleClientEvent(xy.eNames.eventListeners.googleAnalyticsIdentifiers.worldIndexViewed), this.runScene(data)
  }, ChooseWorldSceneController.prototype[xy.eNames.core.onTimerEnd] = function() {
    this.dataSource.prepareWorldsListData()
  }, ChooseWorldSceneController.prototype[xy.eNames.sceneChooseWorld.onWorldIsChosen] = function(world) {
    if (world.banned) {
      var text, title, callback = null;
      switch (text = world.banned.banNote + "\n", text += servicesInternationalization.localize("Active from %@ to %@.", utilsDateTime.getLocaleDateString(world.banned.startBanDate), utilsDateTime.getLocaleDateString(world.banned.endBanDate)), world.banned.warnLevel) {
        case settingsGameConstant.BAN_TYPE.WARNING:
          title = servicesInternationalization.localize("Warning For World"), callback = this.connectToWorld.bind(this, world);
          break;
        case settingsGameConstant.BAN_TYPE.TEMPORARY_DISABLED:
          title = servicesInternationalization.localize("Temporarily Banned From World");
          break;
        case settingsGameConstant.BAN_TYPE.COMPLETE_INHIBITED:
          title = servicesInternationalization.localize("Banned From World")
      }
      return this.showDialogAlert({ title: title, text: text, callback: callback, context: this }), !1
    }
    if (world.needToremoveVacationMode) {
      var daysLeft, hoursPassed, hoursLeft, vacationDate = world.vacationStartDate, secondsPassed = utilsDateTime.passedTimeInSeconds(vacationDate);
      return hoursPassed = Math.ceil(secondsPassed / 3600), hoursLeft = +world.remainingVacationHours - hoursPassed, daysLeft = hoursLeft / 24 | 0, hoursLeft -= 24 * daysLeft, this.showDialogDialog({
        title: servicesInternationalization.localize("Cancel vacation"),
        text: servicesInternationalization.localize("Do you like to enter the game and quit vacation mode? There are %1$d days and %2$d hours vacation left.", daysLeft, hoursLeft),
        callbackSuccess: this.connectToWorld.bind(this, world)
      }), !1
    }
    return this.connectToWorld(world), !0
  }, ChooseWorldSceneController.prototype[xy.eNames.sceneChooseWorld.onNewWorldIsChosen] = function(world) {
    this.dataSource.setGameWorld(world), this.showNextScene(xy.dNames.game.sceneNewPlayerInWorld.name)
  }, ChooseWorldSceneController.prototype.connectToWorld = function(world) {
    this.dataSource.setGameWorld(world), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.googleAnalyticsIdentifiers.worldChosen), this.showNextScene(xy.dNames.game.sceneGame.name)
  }, ChooseWorldSceneController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneChooseWorld.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.network, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, xy.dNames.services.storage, xy.dNames.services.groupable, function(CoreDataSource, utilsOop, utilsDateTime, utilsNetwork, settingsGameConstant, servicesInternationalization, servicesNetwork, servicesGameDataManager, servicesSortable, servicesStorage, servicesGroupable) {
  "use strict";
  function ChooseWorldSceneDataSource(options) {
    ChooseWorldSceneDataSource.__super__.constructor.call(this, options), this.worldsData = null
  }

  return utilsOop.extend(ChooseWorldSceneDataSource, CoreDataSource), ChooseWorldSceneDataSource.prototype.getWorldsListData = function() {
    this.request(null, "worlds", { callBack: this.prepareWorldsListData, isLogin: !0 })
  }, ChooseWorldSceneDataSource.prototype.prepareWorldsListData = function(data) {
    data && (this.worldsData = data);
    var worldId, world, playingWorld, isDenied, settingsCurrentWorlds = {
      title: servicesInternationalization.localize("Connected Worlds"),
      worlds: []
    }, settingsRecommendedWorlds = {
      title: servicesInternationalization.localize("Recommended Worlds"),
      worlds: []
    }, settingsOtherWorlds = {
      title: servicesInternationalization.localize("More Worlds"),
      worlds: []
    }, allAvailableWorlds = {}, connectedWorld = {}, language = "en-us" === servicesNetwork.lang ? "en" : servicesNetwork.lang, worldsData = this.worldsData, newWordPreparedDictionary = {}, ownWordPreparedDictionary = {};
    worldsData.allAvailableWorlds.forEach(function(world) {
      allAvailableWorlds[world.id] = world
    }), worldsData.loginConnectedWorlds.forEach(function(world) {
      connectedWorld[world.id] = world
    });
    for (worldId in allAvailableWorlds)allAvailableWorlds.hasOwnProperty(worldId) && (isDenied = servicesStorage.isWorldDenied(worldId), world = allAvailableWorlds[worldId], world.disabled = +world.worldStatus.id !== settingsGameConstant.WORLD_STATUS.ONLINE, world.description = world.language, playingWorld = connectedWorld[worldId] || null, playingWorld && !isDenied ? (playingWorld.banned && (world.banned = playingWorld.banned), playingWorld.vacationStartDate && utilsDateTime.remainTimeInSeconds(playingWorld.vacationStartDate) > 0 ? (world.timerDate = playingWorld.vacationStartDate, world.description = "Vacation mode starts in: %1$@", world.disabled = !1) : playingWorld.vacationEarliestEndDate && utilsDateTime.remainTimeInSeconds(playingWorld.vacationEarliestEndDate) > 0 ? (world.timerDate = playingWorld.vacationEarliestEndDate, world.description = "Minimum vacation time left: %1$@", world.disabled = !0) : playingWorld.vacationStartDate && utilsDateTime.isDatePassed(playingWorld.vacationStartDate) ? (world.description = servicesInternationalization.localize("Vacation mode active"), world.vacationStartDate = playingWorld.vacationStartDate, world.remainingVacationHours = playingWorld.remainingVacationHours, world.needToremoveVacationMode = !0, world.disabled = !1, world.timerDate = null) : playingWorld.lastLoginDate && (world.lastLoginDate = playingWorld.lastLoginDate, world.description = utilsDateTime.getLocaleDateTimeString(playingWorld.lastLoginDate)), settingsCurrentWorlds.worlds.push(world), ownWordPreparedDictionary[worldId] = world) : language === world.language ? (settingsRecommendedWorlds.worlds.push(world), newWordPreparedDictionary[worldId] = world) : (settingsOtherWorlds.worlds.push(world), newWordPreparedDictionary[worldId] = world));
    settingsCurrentWorlds.worlds.sort(servicesSortable.currentWorlds), settingsRecommendedWorlds.worlds = servicesGroupable.arrayByField(settingsRecommendedWorlds.worlds, {
      field: "country",
      sortGroups: !0,
      sortGroupsIsReverse: !1,
      sortWithinGroups: !0,
      sortWithinGroupsIsReverse: !0
    }), settingsOtherWorlds.worlds = servicesGroupable.arrayByField(settingsOtherWorlds.worlds, {
      field: "country",
      sortGroups: !0,
      sortGroupsIsReverse: !1,
      sortWithinGroups: !0,
      sortWithinGroupsIsReverse: !0
    });
    var urlParams = utilsNetwork.getParamsFromURL(), paramWorld = settingsGameConstant.QUERY_PARAM_NAMES.WORD_ID, queriedWorldId = urlParams[paramWorld] || null;
    if (!(queriedWorldId && ownWordPreparedDictionary[queriedWorldId] && this.notify(xy.eNames.sceneChooseWorld.onWorldIsChosen, ownWordPreparedDictionary[queriedWorldId])))return queriedWorldId && newWordPreparedDictionary[queriedWorldId] ? void this.notify(xy.eNames.sceneChooseWorld.onNewWorldIsChosen, newWordPreparedDictionary[queriedWorldId]) : void this.notify(xy.eNames.sceneChooseWorld.drawWithWorldsListData, {
      settingsCurrentWorlds: settingsCurrentWorlds,
      settingsRecommendedWorlds: settingsRecommendedWorlds,
      settingsOtherWorlds: settingsOtherWorlds
    })
  }, ChooseWorldSceneDataSource.prototype.setGameWorld = function(world) {
    servicesNetwork.worldName = world.name, servicesNetwork.worldMapUrl = world.mapURL, servicesNetwork.worldServerUrl = world.url + "/wa/", servicesNetwork.worldId = world.id, servicesGameDataManager.settings.worldId = +world.id
  }, ChooseWorldSceneDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneChooseWorld.presenter, [xy.dNames.core.presenterElement, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.graphicEngine.mainDirector, xy.dNames.game.sceneChooseWorld.component, function(CorePresenterElement, utilsOop, componentsEngine, graphicEngineMainDirector, ChooseWorldSceneComponent) {
  "use strict";
  function ChooseWorldScenePresenter(options) {
    ChooseWorldScenePresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(ChooseWorldScenePresenter, CorePresenterElement), ChooseWorldScenePresenter.prototype.draw = function(data) {
    this.domElement = xy.DomElements.gameFrame, componentsEngine.render(React.createElement(ChooseWorldSceneComponent, {
      presenter: this,
      settings: data
    }), document.getElementById(xy.DomElements.gameFrame)), graphicEngineMainDirector.clearScene()
  }, ChooseWorldScenePresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneChooseWorld.component, [xy.dNames.componentsEngine, xy.dNames.utils.string, xy.dNames.services.internationalization, xy.dNames.components.containerWindowBox, xy.dNames.components.listTitleMain, xy.dNames.components.listTitleDefault, xy.dNames.game.sceneChooseWorld.componentWorldButton, function(componentsEngine, utilsString, servicesInternationalization, ComponentsContainerWindowBox, ComponentsListTitleMain, ComponentsTitleListDefault, SceneChooseWorldComponentWorldButton) {
  "use strict";
  return componentsEngine.createClass({
    handlerOnClickToConnectedWorld: function(world, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneChooseWorld.onWorldIsChosen, world)
    }, handlerOnClickNewWorld: function(world, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneChooseWorld.onNewWorldIsChosen, world)
    }, render: function() {
      var settings = { settingsCurrentWorlds: {}, settingsRecommendedWorlds: {}, settingsOtherWorlds: {} };
      Object.assign(settings, this.props.settings);
      var titleSettings, titleMainSettings = { title: servicesInternationalization.localize("Choose a World") }, currentWorlds = [], recommendedWorlds = [], otherWorlds = [], currentWorldsSection = null, recommendedWorldsSection = null, otherWorldsSection = null;
      return settings.settingsCurrentWorlds.worlds.forEach(function(world) {
        var settings = { world: world, onClick: this.handlerOnClickToConnectedWorld, initialComponent: this };
        currentWorlds.push(React.createElement(SceneChooseWorldComponentWorldButton, {
          settings: settings,
          key: world.name
        }))
      }, this), currentWorlds.length > 0 && (titleSettings = {
        title: settings.settingsCurrentWorlds.title,
        classes: "choose-world-scene--section-title"
      }, currentWorldsSection = React.createElement("div", null, React.createElement(ComponentsTitleListDefault, { settings: titleSettings }), React.createElement("div", { className: "choose-world-scene--section" }, currentWorlds))), settings.settingsRecommendedWorlds.worlds.groups.forEach(function(worldGroup) {
        worldGroup.forEach(function(world) {
          var settings = { world: world, onClick: this.handlerOnClickNewWorld, initialComponent: this };
          recommendedWorlds.push(React.createElement(SceneChooseWorldComponentWorldButton, {
            settings: settings,
            key: world.name
          }))
        }, this)
      }, this), recommendedWorlds.length > 0 && (titleSettings = {
        title: settings.settingsRecommendedWorlds.title,
        classes: "choose-world-scene--section-title"
      }, recommendedWorldsSection = React.createElement("div", null, React.createElement(ComponentsTitleListDefault, { settings: titleSettings }), React.createElement("div", { className: "choose-world-scene--section" }, recommendedWorlds))), settings.settingsOtherWorlds.worlds.groups.forEach(function(worldGroup) {
        worldGroup.forEach(function(world) {
          var settings = { world: world, onClick: this.handlerOnClickNewWorld, initialComponent: this };
          otherWorlds.push(React.createElement(SceneChooseWorldComponentWorldButton, {
            settings: settings,
            key: world.name
          }))
        }, this)
      }, this), otherWorlds.length > 0 && (titleSettings = {
        title: settings.settingsOtherWorlds.title,
        classes: "choose-world-scene--section-title"
      }, otherWorldsSection = React.createElement("div", null, React.createElement(ComponentsTitleListDefault, { settings: titleSettings }), React.createElement("div", { className: "choose-world-scene--section" }, otherWorlds))), React.createElement("div", { id: "choose-world-scene" }, React.createElement(ComponentsListTitleMain, { settings: titleMainSettings }), currentWorldsSection, recommendedWorldsSection, otherWorldsSection)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneChooseWorld.componentWorldButton, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.mixins.menuComponentTimer, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.components.buttonBordered, function(componentsEngine, utilsDateTime, mixinsMenuComponentTimer, settingsGameConstant, servicesInternationalization, ComponentsControlButtonBordered) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var settings = props.settings, timer = null, remainTimeString = null;
      return this.countDownTimer && clearTimeout(this.countDownTimer), settings.world && settings.world.timerDate && utilsDateTime.remainTimeInSeconds(settings.world.timerDate) > 0 && (timer = settings.world.timerDate, remainTimeString = utilsDateTime.remainTime(timer, !0), this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { world: {}, initialComponent: {}, onClick: null };
      Object.assign(settings, this.props.settings);
      var componentSettings, description, world = settings.world, originalThis = settings.initialComponent, state = this.state;
      return description = state.timer ? servicesInternationalization.localize(world.description, state.remainTimeString) : world.description, componentSettings = {
        disabled: world.disabled,
        onClick: settings.onClick.bind(originalThis, world),
        title: world.name,
        description: description,
        classes: "choose-world-scene--world-button",
        id: world.id,
        iconLeft: "icon-flag flag-" + world.country
      }, React.createElement(ComponentsControlButtonBordered, { settings: componentSettings })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneNewPlayerInWorld.controller, [xy.dNames.core.controllerElement, xy.dNames.utils.oop, xy.dNames.services.eventManager, function(CoreControllerElementScene, utilsOop, servicesEventManager) {
  "use strict";
  function SceneNewPlayerInWorldController(options) {
    SceneNewPlayerInWorldController.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneNewPlayerInWorldController, CoreControllerElementScene), SceneNewPlayerInWorldController.prototype.start = function() {
    this.dataSource.prepareNewPLayerData()
  }, SceneNewPlayerInWorldController.prototype[xy.eNames.sceneNewPlayerInWorld.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, SceneNewPlayerInWorldController.prototype[xy.eNames.sceneNewPlayerInWorld.onNickSubmit] = function(options) {
    return servicesEventManager.handleClientEvent(xy.eNames.eventListeners.googleAnalyticsIdentifiers.fillFormNickname), this.dataSource.createNewPlayer(options), !0
  }, SceneNewPlayerInWorldController.prototype[xy.eNames.sceneNewPlayerInWorld.onSuccessCreating] = function() {
    servicesEventManager.handleClientEvent(xy.eNames.eventListeners.matAnalyticsIdentifiers.thirteenPointsEarned), this.showNextScene(xy.dNames.game.sceneGame.name)
  }, SceneNewPlayerInWorldController.prototype[xy.eNames.sceneNewPlayerInWorld.onCancelCreating] = function() {
    this.showNextScene(xy.dNames.game.sceneChooseWorld.name)
  }, SceneNewPlayerInWorldController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneNewPlayerInWorld.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.network, xy.dNames.services.eventManager, function(CoreDataSource, utilsOop, utilsObject, servicesNetwork, servicesEventManager) {
  "use strict";
  function SceneNewPlayerInWorldDataSource(options) {
    SceneNewPlayerInWorldDataSource.__super__.constructor.call(this, options), this.attemptNickName = null
  }

  return utilsOop.extend(SceneNewPlayerInWorldDataSource, CoreDataSource), SceneNewPlayerInWorldDataSource.prototype.prepareNewPLayerData = function(options) {
    options = options || {};
    var data = {};
    data.worldName = servicesNetwork.worldName, options.possibleNickname && (data.possibleNickname = options.possibleNickname, data.attemptNickName = this.attemptNickName), this.notify(xy.eNames.sceneNewPlayerInWorld.dataIsReady, data)
  }, SceneNewPlayerInWorldDataSource.prototype.createNewPlayer = function(data) {
    this.attemptNickName = data.nick, this.request({
      nick: data.nick,
      deviceType: "Email"
    }, "LoginAction/create", { isConnect: !0, callBack: this.onCreateResponseHandler })
  }, SceneNewPlayerInWorldDataSource.prototype.onCreateResponseHandler = function(data) {
    utilsObject.isEmpty(data) ? (servicesEventManager.handleClientEvent(xy.eNames.eventListeners.googleAnalyticsIdentifiers.nicknameChosen), this.notify(xy.eNames.sceneNewPlayerInWorld.onSuccessCreating)) : data.possibleNickname && this.prepareNewPLayerData({ possibleNickname: data.possibleNickname })
  }, SceneNewPlayerInWorldDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneNewPlayerInWorld.presenter, [xy.dNames.core.presenterElement, xy.dNames.utils.oop, xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.game.sceneNewPlayerInWorld.component, function(CorePresenterElement, utilsOop, gameInstance, componentsEngine, SceneNewPlayerInWorldComponent) {
  "use strict";
  function SceneNewPlayerInWorldPresenter(options) {
    SceneNewPlayerInWorldPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneNewPlayerInWorldPresenter, CorePresenterElement), SceneNewPlayerInWorldPresenter.prototype.draw = function(data) {
    componentsEngine.render(React.createElement(SceneNewPlayerInWorldComponent, {
      presenter: this,
      settings: data
    }), document.getElementById(xy.DomElements.gameFrame))
  }, SceneNewPlayerInWorldPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneNewPlayerInWorld.component, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.utils.string, xy.dNames.services.internationalization, xy.dNames.services.worldSettings, xy.dNames.components.listTitleMain, xy.dNames.components.buttonMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.alertTooltip, xy.dNames.components.inputTextField, function(componentsEngine, settingsGameConstant, utilsString, servicesInternationalization, servicesWorldSettings, ComponentsListTitleMain, ComponentsButtonMain, ComponentsMenuListTitleBasic, ComponentsAlertTooltip, ComponentsInputTextField) {
  "use strict";
  return componentsEngine.createClass({
    getInitialState: function() {
      return { isButtonActive: !1, tooltipStatus: null, validationErrorText: "", nickName: "" }
    }, onNickNameChanges: function(event) {
      event.preventDefault();
      var value = event.target.value, validatingString = value.replace(/\s/g, ""), tooltipStatus = "", validationErrorText = "", isButtonActive = !0;
      validatingString.length > servicesWorldSettings.settings.playerNameLengthMax ? (tooltipStatus = "in", isButtonActive = !1, validationErrorText = servicesInternationalization.localize("The name is too long")) : validatingString.length < servicesWorldSettings.settings.playerNameLengthMin && (tooltipStatus = "in", isButtonActive = !1, validationErrorText = servicesInternationalization.localize("The name is too short")), this.setState({
        isButtonActive: isButtonActive,
        tooltipStatus: tooltipStatus,
        validationErrorText: validationErrorText,
        nickName: value
      }, null)
    }, onCancelPlayerCreationClick: function() {
      this.props.presenter.notify(xy.eNames.sceneNewPlayerInWorld.onCancelCreating)
    }, onSubmitPlayerCreationClick: function() {
      this.props.presenter.notify(xy.eNames.sceneNewPlayerInWorld.onNickSubmit, { nick: this.state.nickName })
    }, render: function() {
      var settings = { worldName: "", possibleNickname: "", attemptNickName: "" };
      Object.assign(settings, this.props.settings);
      var titleMainSettings, sectionComponentSettings, componentsSections = [];
      titleMainSettings = { title: servicesInternationalization.localize('Please enter a nickname for the world \\"%@\\".', settings.worldName) }, settings.possibleNickname && (sectionComponentSettings = {
        classes: "center",
        title: servicesInternationalization.localize('The name \\"%@\\" is already taken. A possible name is \\"%@\\".', settings.attemptNickName, settings.possibleNickname)
      }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title"
      })));
      var inputs = [];
      sectionComponentSettings = {
        position: "top",
        status: this.state.tooltipStatus,
        text: this.state.validationErrorText
      }, inputs.push(React.createElement(ComponentsAlertTooltip, {
        settings: sectionComponentSettings,
        key: "tooltip"
      })), inputs.push(React.createElement("div", {
        className: "nick-name-label",
        key: "label"
      }, servicesInternationalization.localize("Nickname"))), sectionComponentSettings = {
        value: settings.possibleName,
        handlerOnChange: this.onNickNameChanges
      }, inputs.push(React.createElement(ComponentsInputTextField, {
        settings: sectionComponentSettings,
        key: "input"
      })), componentsSections.push(React.createElement("div", {
        className: "form--component input-new-player-name-section",
        key: "input-nick-name"
      }, inputs));
      var buttons = [];
      return sectionComponentSettings = {
        onClick: this.onCancelPlayerCreationClick,
        title: servicesInternationalization.localize("cancel")
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: sectionComponentSettings,
        key: "button-cancel"
      })), sectionComponentSettings = {
        onClick: this.onSubmitPlayerCreationClick,
        title: servicesInternationalization.localize("ok"),
        isDisabled: !this.state.isButtonActive
      }, buttons.push(React.createElement(ComponentsButtonMain, {
        settings: sectionComponentSettings,
        key: "button-ok"
      })), componentsSections.push(React.createElement("div", {
        className: "form--component form--inline inline--center",
        key: "button-submit"
      }, buttons)), React.createElement("div", { id: "scene-new-player-in-world" }, React.createElement(ComponentsListTitleMain, { settings: titleMainSettings }), componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGame.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElement, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.sessionUpdateSchedule, xy.dNames.services.gameDataManager, xy.dNames.services.network, xy.dNames.services.storage, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.services.eventManager, function(gameInstance, CoreControllerElementScene, utilsOop, settingsGameConstant, servicesInternationalization, servicesSessionUpdateSchedule, servicesGameDataManager, servicesNetwork, servicesStorage, servicesTheme, servicesLog, servicesEventManager) {
  "use strict";
  function SceneGameController(options) {
    SceneGameController.__super__.constructor.call(this, options), this.subSceneGlobalOverview = {
      1: null,
      2: null,
      3: null
    }, this.subSceneGlobalOverviewActiveMode = null, this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.onCurrentHabitatChanges
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.lostAllHabitats,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.onLostAllHabitats
    }, {
      entity: xy.eNames.dataListeners.dataEntity.resources,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setExtraResources,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.updateTopBar
    }, {
      entity: xy.eNames.dataListeners.dataEntity.bottomBar,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.updateBottomBar
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.afterDataUpdate
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.newPendingEvent,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.showEventPopUp
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.startTutorialEvent,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.showTutorialPopUp
    }], this.keyboardListneners = [{
      key: settingsGameConstant.KEYBOARD_KEYS.ARROW_LEFT,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onHabitatChooserArrowClick].bind(this, settingsGameConstant.SET_CURRENT_HABITAT_EVENT.PREV)
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.ARROW_RIGHT,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onHabitatChooserArrowClick].bind(this, settingsGameConstant.SET_CURRENT_HABITAT_EVENT.NEXT)
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_W,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardMoveMap]
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_A,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardMoveMap]
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_S,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardMoveMap]
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_D,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardMoveMap]
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_HABITAT,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardSetSceneMode]
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_GAME,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardSetSceneMode]
    }, {
      key: settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_POLITICAL,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.sceneGame.onKeyboardSetSceneMode]
    }], this.clientEventListneners = [{
      identifier: xy.eNames.eventListeners.identifier.habitatSceneClickOnBuilding,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.openBuildingOverview
    }], window.addEventListener("resize", this.resizeHandler.bind(this))
  }

  return utilsOop.extend(SceneGameController, CoreControllerElementScene), SceneGameController.prototype.initInstance = function() {
    this.sessionUpdateTimer = null, this.resizingCounter = 0, this.currentSceneMode = settingsGameConstant.SCENE_MODE.MAP, this.currentMenuView = null, this.currentMenuContainerKey = null, this.currentPopView = null, this.currentTutorialPopView = null, this.cachedMapCenter = null, this.subSceneMap = null, this.subSceneMapPolitical = null, this.subSceneHabitat = null, this.buttonsGameElementRelationsObject = {
      Title: xy.dNames.game.menuHabitatsList.name,
      HabitatBuildings: xy.dNames.game.menuBuildingsList.name,
      Troops: xy.dNames.game.menuUnitList.name,
      BuildingOverview: xy.dNames.game.menuBuildingOverview.name,
      GeneralFunctions: xy.dNames.game.menuMassFunctionList.name,
      Messages: xy.dNames.game.menuMessages.name,
      Profile: xy.dNames.game.menuPlayerProfile.name,
      Reports: xy.dNames.game.menuReports.name,
      Forum: xy.dNames.game.menuForum.name,
      Alliance: xy.dNames.game.menuAllianceManagement.name,
      HabitatOverview: xy.dNames.game.menuHabitatOverview.name
    }, this.menuContainer = {
      Title: null,
      GeneralFunctions: null,
      Messages: null,
      Profile: null,
      Reports: null,
      Forum: null,
      Alliance: null
    }, this.activeMenuFlag = !1, this.activeMenuContainer = {
      habitatId: null,
      building: null,
      menu: null
    }, this.habitatOverviewMenuContainer = {}, this.habitatMenuContainer = {
      HabitatBuildings: null,
      Troops: null,
      BuildingOverview: {}
    }, this.__initStorage()
  }, SceneGameController.prototype.__initStorage = function() {
    servicesStorage.initGameStorage({
      game: gameInstance.getCurrentGame(),
      world: servicesNetwork.worldId,
      player: servicesNetwork.credential.login
    })
  }, SceneGameController.prototype.start = function() {
    this.initInstance(), this.dataSource.connectToGameWorld(), this.registerAllDataListeners(), this.registerAllKeyboardListeners(), this.registerAllEventListeners(), servicesGameDataManager.registerDataUpdateListener({
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setInitialHabitatAction,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.onInitialHabitatSet
    }), this.resizeCanvas(), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToHabitatScene)
  }, SceneGameController.prototype.destroy = function() {
    this.currentMenuView && (this.currentMenuView.destroy(), this.currentMenuView = null), this.currentPopView && (this.currentPopView.destroy(), this.currentPopView = null), this.deRegisterAllDataListeners(), this.deRegisterAllKeyboardListeners(), this.deRegisterAllEventListeners(), servicesGameDataManager.initGameData(), this.presenter.clear()
  }, SceneGameController.prototype.initSessionTimer = function() {
    this.sessionUpdateTimer || (this.sessionUpdateTimer = !0, setTimeout(this.checkSchedule.bind(this), settingsGameConstant.SESSION_UPDATE_SCHEDULE_INTERVAL))
  }, SceneGameController.prototype.checkSchedule = function() {
    var status = servicesSessionUpdateSchedule.checkUpdateSchedule();
    switch (status) {
      case settingsGameConstant.SESSION_UPDATE_SCHEDULE_STATUS.STOP_TIMER:
        this.sessionUpdateTimer = !1;
        break;
      case settingsGameConstant.SESSION_UPDATE_SCHEDULE_STATUS.UPDATE:
        this.sessionUpdateTimer = !1, this[xy.eNames.sceneGame.requireSessionUpdate]();
        break;
      default:
        setTimeout(this.checkSchedule.bind(this), settingsGameConstant.SESSION_UPDATE_SCHEDULE_INTERVAL)
    }
  }, SceneGameController.prototype.showMenuView = function(options) {
    var initialData = options.data || {}, initialOptions = options.options || {}, buttonName = options.buttonName, viewName = options.viewName || this.buttonsGameElementRelationsObject[buttonName];
    if (initialOptions.isRoot = !0, !viewName && buttonName) {
      var settings = { title: "TODO Message", text: "Open Click on " + buttonName + " should be implemented" };
      return void this.showDialogAlert(settings)
    }
    var habitatId, buildingClassIdentifier, hideSync = this.hideMenuView();
    if ("Title" !== buttonName && (this.activeMenuFlag = !1), hideSync) {
      if (buttonName && this.menuContainer.hasOwnProperty(buttonName))return this.menuContainer[buttonName] && this.menuContainer[buttonName].start ? (this.currentMenuView = this.menuContainer[buttonName], this.currentMenuView.start({ isRestart: !0 })) : (this.currentMenuView = this.startController(viewName, this, initialData, initialOptions), this.menuContainer[buttonName] = this.currentMenuView), this.currentMenuContainerKey = buttonName, void this.updateBarActiveButton(buttonName);
      switch (buttonName) {
        case"HabitatOverview":
          habitatId = initialData.habitatId || this.activeMenuContainer.habitatId, this.habitatOverviewMenuContainer.hasOwnProperty(habitatId) && this.habitatOverviewMenuContainer[habitatId] ? (this.habitatOverviewMenuContainer[habitatId].start({ isRestart: !0 }), this.currentMenuView = this.habitatOverviewMenuContainer[habitatId]) : (this.currentMenuView = this.startController(viewName, this, initialData, initialOptions), this.habitatOverviewMenuContainer[habitatId] = this.currentMenuView), this.activeMenuContainer = {
            habitatId: habitatId,
            menu: buttonName
          }, this.activeMenuFlag = !0;
          break;
        case"HabitatBuildings":
        case"Troops":
          this.currentSceneMode !== settingsGameConstant.SCENE_MODE.HABITAT && (hideSync = this.switchScenes({ newSceneMode: settingsGameConstant.SCENE_MODE.HABITAT })), hideSync && (this.habitatMenuContainer[buttonName] ? (this.habitatMenuContainer[buttonName].start({ isRestart: !0 }), this.currentMenuView = this.habitatMenuContainer[buttonName]) : (this.currentMenuView = this.startController(viewName, this, initialData, initialOptions), this.habitatMenuContainer[buttonName] = this.currentMenuView), this.updateBarActiveButton(buttonName), this.activeMenuFlag = !0, this.activeMenuContainer.menu = buttonName);
          break;
        case"BuildingOverview":
          this.currentSceneMode !== settingsGameConstant.SCENE_MODE.HABITAT && (hideSync = this.switchScenes({ newSceneMode: settingsGameConstant.SCENE_MODE.HABITAT })), hideSync && (buildingClassIdentifier = initialOptions.classIdentifier || this.activeMenuContainer.activeBuilding, this.habitatMenuContainer.BuildingOverview[buildingClassIdentifier] ? (this.habitatMenuContainer.BuildingOverview[buildingClassIdentifier].start({ isRestart: !0 }), this.currentMenuView = this.habitatMenuContainer.BuildingOverview[buildingClassIdentifier]) : (this.currentMenuView = this.startController(viewName, this, initialData, initialOptions), this.habitatMenuContainer.BuildingOverview[buildingClassIdentifier] = this.currentMenuView), this.updateBarActiveButton(), this.activeMenuContainer = {
            building: buildingClassIdentifier,
            menu: buttonName
          }, this.activeMenuFlag = !0)
      }
    }
  }, SceneGameController.prototype.hideMenuView = function() {
    return null !== this.currentMenuView && (this.currentMenuView.hide(), this.currentMenuView = null), !0
  }, SceneGameController.prototype.removeMenuView = function() {
    return servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.menuCloseButtonClick), this.activeMenuFlag = !1, this.updateBarActiveButton(), null !== this.currentMenuView && (this.currentMenuView.destroy(), this.currentMenuView = null, this.menuContainer[this.currentMenuContainerKey] = null), !0
  }, SceneGameController.prototype.reopenLastActiveMenu = function() {
    this.activeMenuFlag ? (this.showMenuView({ buttonName: this.activeMenuContainer.menu }), this.updateBarActiveButton()) : this.removeMenuView()
  }, SceneGameController.prototype.switchScenes = function(options) {
    if (this.currentSceneMode !== options.newSceneMode)switch (this.switchScenesMode(options), options.newSceneMode) {
      case settingsGameConstant.SCENE_MODE.MAP:
        this.drawSceneMapGame(options), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToMapGameScene);
        break;
      case settingsGameConstant.SCENE_MODE.POLITICAL_MAP:
        this.drawSceneMapPolitical(), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToMapGameScene);
        break;
      case settingsGameConstant.SCENE_MODE.HABITAT:
        this.drawSceneHabitat(), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToHabitatScene);
        break;
      case settingsGameConstant.SCENE_MODE.GLOBAL_UNIT_OVERVIEW:
        this.drawSceneGlobalOverview(settingsGameConstant.GLOBAL_OVERVIEW_MODE.UNITS), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToGlobalOverviewsScene);
        break;
      case settingsGameConstant.SCENE_MODE.GLOBAL_BUILDING_OVERVIEW:
        this.drawSceneGlobalOverview(settingsGameConstant.GLOBAL_OVERVIEW_MODE.BUILDING), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToGlobalOverviewsScene);
        break;
      case settingsGameConstant.SCENE_MODE.GLOBAL_RECRUITMENT_OVERVIEW:
        this.drawSceneGlobalOverview(settingsGameConstant.GLOBAL_OVERVIEW_MODE.RECRUITMENT), servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.sceneSwitchToGlobalOverviewsScene)
    }
    return !0
  }, SceneGameController.prototype.switchScenesMode = function(options) {
    switch (this.hideMenuView(), this.updateBarActiveButton(), this.activeMenuFlag = !1, this.currentSceneMode = options.newSceneMode, options.newSceneMode) {
      case settingsGameConstant.SCENE_MODE.MAP:
        this.updateToggleBar({ activeSceneMode: settingsGameConstant.SCENE_MODE.MAP, showCenterMapButton: !0 });
        break;
      case settingsGameConstant.SCENE_MODE.POLITICAL_MAP:
        this.updateToggleBar({
          activeSceneMode: settingsGameConstant.SCENE_MODE.POLITICAL_MAP,
          showCenterMapButton: !0
        });
        break;
      case settingsGameConstant.SCENE_MODE.HABITAT:
        this.updateToggleBar({ activeSceneMode: settingsGameConstant.SCENE_MODE.HABITAT, showCenterMapButton: !1 });
        break;
      case settingsGameConstant.SCENE_MODE.GLOBAL_UNIT_OVERVIEW:
        this.updateToggleBar({
          activeSceneMode: settingsGameConstant.SCENE_MODE.GLOBAL_UNIT_OVERVIEW,
          showCenterMapButton: !1
        });
        break;
      case settingsGameConstant.SCENE_MODE.GLOBAL_BUILDING_OVERVIEW:
        this.updateToggleBar({
          activeSceneMode: settingsGameConstant.SCENE_MODE.GLOBAL_BUILDING_OVERVIEW,
          showCenterMapButton: !1
        });
        break;
      case settingsGameConstant.SCENE_MODE.GLOBAL_RECRUITMENT_OVERVIEW:
        this.updateToggleBar({
          activeSceneMode: settingsGameConstant.SCENE_MODE.GLOBAL_RECRUITMENT_OVERVIEW,
          showCenterMapButton: !1
        })
    }
    return !0
  }, SceneGameController.prototype.resizeHandler = function() {
    this.resizingCounter += 1, this[xy.eNames.core.pendingModeOn](), setTimeout(function() {
      this[xy.eNames.core.pendingModeOff](), this.resizingCounter -= 1, 0 === this.resizingCounter && (servicesLog("log", "Ready to resize screen"), this.resizeScene())
    }.bind(this), 1e3)
  }, SceneGameController.prototype.resizeCanvas = function() {
    var canvas = document.getElementById(xy.DomElements.gameCanvas);
    canvas.width = window.innerWidth, canvas.height = window.innerHeight
  }, SceneGameController.prototype.resizeScene = function() {
    switch (this.resizeCanvas(), this.currentSceneMode) {
      case settingsGameConstant.SCENE_MODE.MAP:
        this.drawSceneMapGame({ isResize: !0 });
        break;
      case settingsGameConstant.SCENE_MODE.POLITICAL_MAP:
        this.drawSceneMapPolitical({ isResize: !0 });
        break;
      case settingsGameConstant.SCENE_MODE.HABITAT:
        this.drawSceneHabitat({ isResize: !0 })
    }
    this.currentTutorialPopView && this.currentTutorialPopView.show({ isResize: !0 })
  }, SceneGameController.prototype.drawSceneHabitat = function(options) {
    this.subSceneHabitat ? this.subSceneHabitat.prepareDrawingData(options) : this.subSceneHabitat = this.showSubScene(xy.dNames.game.sceneHabitat.name)
  }, SceneGameController.prototype.drawSceneMapGame = function(options) {
    options = options || {};
    var newOptions = { coordinates: options.coordinates || this.cachedMapCenter, isResize: options.isResize || !1 };
    this.subSceneMap ? this.subSceneMap[xy.eNames.sceneMapGame.moveMapCenterToCoordinates](newOptions) : this.subSceneMap = this.showSubScene(xy.dNames.game.sceneMapGame.name, newOptions)
  }, SceneGameController.prototype.drawSceneMapPolitical = function(options) {
    options = options || {};
    var newOptions = { coordinates: options.coordinates || this.cachedMapCenter, isResize: options.isResize || !1 };
    this.subSceneMapPolitical ? this.subSceneMapPolitical[xy.eNames.sceneMapPolitical.moveMapCenterToCoordinates](newOptions) : this.subSceneMapPolitical = this.showSubScene(xy.dNames.game.sceneMapPolitical.name, newOptions)
  }, SceneGameController.prototype.drawSceneGlobalOverview = function(mode) {
    if (this.subSceneGlobalOverviewActiveMode = mode, this.subSceneGlobalOverview[mode])this.subSceneGlobalOverview[mode].start(); else switch (mode) {
      case settingsGameConstant.GLOBAL_OVERVIEW_MODE.UNITS:
        this.subSceneGlobalOverview[mode] = this.showSubScene(xy.dNames.game.sceneGlobalUnitOverview.name);
        break;
      case settingsGameConstant.GLOBAL_OVERVIEW_MODE.BUILDING:
        this.subSceneGlobalOverview[mode] = this.showSubScene(xy.dNames.game.sceneGlobalBuildingOverview.name);
        break;
      case settingsGameConstant.GLOBAL_OVERVIEW_MODE.RECRUITMENT:
        this.subSceneGlobalOverview[mode] = this.showSubScene(xy.dNames.game.sceneGlobalRecruitmentOverview.name)
    }
  }, SceneGameController.prototype.onLostAllHabitats = function() {
    var text = "You have no castle left. Do you want to start anew?";
    this.showDialogDialog({
      classes: "higher",
      title: "",
      text: servicesInternationalization.localize(text),
      callbackSuccess: this.onRemoveDeniedWorld.bind(this.dataSource),
      callbackCancel: this.onSetDeniedWorld.bind(this)
    })
  }, SceneGameController.prototype.onRemoveDeniedWorld = function() {
    return servicesStorage.removeDeniedWorld(servicesGameDataManager.settings.worldId), this.onLostAllHabitatsCreateNewHabitat()
  }, SceneGameController.prototype.onSetDeniedWorld = function() {
    return servicesStorage.addDeniedWorld(servicesGameDataManager.settings.worldId), this[xy.eNames.sceneGame.onSwitchWorldEvent]()
  }, SceneGameController.prototype[xy.eNames.sceneGame.onWorldIsConnected] = function() {
    this.controller.destroy(), this.runScene()
  }, SceneGameController.prototype[xy.eNames.sceneGame.onKeyboardSetSceneMode] = function(options) {
    if (!this[xy.eNames.core.isPendingModeOn]()) {
      var newSceneMode = settingsGameConstant.SCENE_MODE.MAP;
      switch (options.key) {
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_GAME:
          newSceneMode = settingsGameConstant.SCENE_MODE.MAP;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_MAP_POLITICAL:
          newSceneMode = settingsGameConstant.SCENE_MODE.POLITICAL_MAP;
          break;
        case settingsGameConstant.KEYBOARD_KEYS.KEY_SCENE_HABITAT:
          newSceneMode = settingsGameConstant.SCENE_MODE.HABITAT
      }
      this.currentSceneMode !== newSceneMode && this.switchScenes({ newSceneMode: newSceneMode })
    }
  }, SceneGameController.prototype[xy.eNames.core.onTimerEnd] = function() {
    this[xy.eNames.sceneGame.requireSessionUpdate]()
  }, SceneGameController.prototype[xy.eNames.sceneGame.requireSessionUpdate] = function() {
    servicesSessionUpdateSchedule.isSessionUpdatePossible() && (servicesSessionUpdateSchedule.setLastUpdateTime(), this.dataSource.doSessionUpdate())
  }, SceneGameController.prototype[xy.eNames.eventSceneGlobalOverview.globalOverviewIsDrawn] = function() {
    var mode = this.subSceneGlobalOverviewActiveMode;
    Object.keys(this.subSceneGlobalOverview).forEach(function(sceneModeKey) {
      mode !== +sceneModeKey && this.subSceneGlobalOverview[sceneModeKey] && this.subSceneGlobalOverview[sceneModeKey].shutDown()
    }, this), this.presenter.clearDirector()
  }, SceneGameController.prototype[xy.eNames.sceneGame.openHabitatOverview] = function(data) {
    this.switchScenesMode({ newSceneMode: settingsGameConstant.SCENE_MODE.MAP }), this.showMenuView({
      buttonName: "HabitatOverview",
      data: data
    })
  }, SceneGameController.prototype[xy.eNames.sceneGame.onOpenClickBarButton] = function(buttonName) {
    this.showMenuView({ buttonName: buttonName })
  }, SceneGameController.prototype[xy.eNames.sceneGame.onCloseClickBarButton] = function(buttonName) {
    if ("Title" === buttonName ? this.reopenLastActiveMenu() : this.removeMenuView(), buttonName) {
      var gameElement = this.buttonsGameElementRelationsObject[buttonName];
      if (!gameElement) {
        var settings = { title: "Error", text: "Close Click on " + buttonName + " should be implemented" };
        this.showDialogAlert(settings)
      }
    }
  }, SceneGameController.prototype[xy.eNames.sceneGame.onHabitatChooserArrowClick] = function(direction) {
    servicesGameDataManager.changeCurrentHabitat(direction)
  }, SceneGameController.prototype[xy.eNames.sceneGame.onSwitchWorldEvent] = function() {
    this.destroy(), this.showNextScene(xy.dNames.game.sceneChooseWorld.name)
  }, SceneGameController.prototype[xy.eNames.sceneGame.onLogoutEvent] = function() {
    this.destroy(), this.showNextScene(xy.dNames.game.sceneLogin.name)
  }, SceneGameController.prototype[xy.eNames.popUpEvent.popUp] = function(data) {
    this.showEventPopUp(data)
  }, SceneGameController.prototype[xy.eNames.popUpEvent.onDestroy] = function() {
    this.clearPopUp()
  }, SceneGameController.prototype[xy.eNames.sceneGame.onCanvasDrawn] = function() {
    this.closeGlobalOverview()
  }, SceneGameController.prototype[xy.eNames.sceneGame.cacheCenterMapCoordinates] = function(coordinates) {
    this.cachedMapCenter = coordinates
  }, SceneGameController.prototype[xy.eNames.sceneGame.centerMapByCurrentHabitatCoordinates] = function() {
    var currentHabitat = servicesGameDataManager.habitatsCollection.getHabitat(), coordinates = {
      mapX: currentHabitat.mapX,
      mapY: currentHabitat.mapY
    };
    return this[xy.eNames.sceneGame.centerMapByCoordinates](coordinates), !0
  }, SceneGameController.prototype[xy.eNames.sceneGame.onKeyboardMoveMap] = function(options) {
    switch (this.currentSceneMode) {
      case settingsGameConstant.SCENE_MODE.MAP:
        this.subSceneMap[xy.eNames.sceneMapGame.onKeyboardMoveMap](options);
        break;
      case settingsGameConstant.SCENE_MODE.POLITICAL_MAP:
        this.subSceneMapPolitical[xy.eNames.sceneMapPolitical.onKeyboardMoveMap](options)
    }
  }, SceneGameController.prototype[xy.eNames.sceneGame.updateMap] = function() {
    switch (this.currentSceneMode) {
      case settingsGameConstant.SCENE_MODE.MAP:
        this.drawSceneMapGame();
        break;
      case settingsGameConstant.SCENE_MODE.POLITICAL_MAP:
        this.drawSceneMapPolitical()
    }
  }, SceneGameController.prototype[xy.eNames.sceneGame.centerMapByCoordinates] = function(coordinates) {
    switch (this.currentSceneMode) {
      case settingsGameConstant.SCENE_MODE.POLITICAL_MAP:
        this.updateBarActiveButton(), this.hideMenuView(), this.drawSceneMapPolitical({ coordinates: coordinates });
        break;
      case settingsGameConstant.SCENE_MODE.MAP:
        this.updateBarActiveButton(), this.hideMenuView(), this.drawSceneMapGame({ coordinates: coordinates });
        break;
      default:
        this.switchScenes({ newSceneMode: settingsGameConstant.SCENE_MODE.MAP, coordinates: coordinates })
    }
  }, SceneGameController.prototype[xy.eNames.sceneGame.goToWebShop] = function() {
    var url = servicesTheme.getWebShopLink({
      addPlayer: !0,
      playerId: servicesGameDataManager.getPlayerId(),
      worldId: servicesGameDataManager.settings.worldId
    });
    this.openUrlInNewTab(url)
  }, SceneGameController.prototype[xy.eNames.sceneGame.needMoreGold] = function(missedCost) {
    var settings = {
      title: servicesInternationalization.localize("Not enough gold"),
      text: servicesInternationalization.localize("PopupTitle", missedCost),
      callback: this.notify.bind(this, xy.eNames.sceneGame.goToWebShop),
      context: this
    };
    this.showDialogNotEnoughSource(settings)
  }, SceneGameController.prototype[xy.eNames.sceneGame.onNewSceneChoosing] = function(options) {
    this.switchScenes(options)
  }, SceneGameController.prototype[xy.eNames.sceneGame.requestBuildingObjectToHighlight] = function(options) {
    return this.subSceneHabitat.getBuildingObjectToHighlight(options.buildingClassIdentifier)
  }, SceneGameController.prototype[xy.eNames.sceneGame.onPickHabitatFromHabitatList] = function(options) {
    if (options = options || {}, options.habitatId)return servicesGameDataManager.habitatsCollection.setCurrentHabitatId(options.habitatId), this.reopenLastActiveMenu(), !0
  }, SceneGameController.prototype.onCurrentHabitatChanges = function(data) {
    this.updateTopBar(data)
  }, SceneGameController.prototype.onInitialHabitatSet = function(data) {
    servicesGameDataManager.removeDataUpdateListener({
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setInitialHabitatAction,
      listenerUniqueId: this.instanceId
    }), this.openInitialHabitatScene(), this[xy.eNames.sceneGame.cacheCenterMapCoordinates]({
      mapX: data.mapX,
      mapY: data.mapY
    })
  }, SceneGameController.prototype.openInitialHabitatScene = function() {
    this.drawSceneHabitat(), this.switchScenesMode({ newSceneMode: settingsGameConstant.SCENE_MODE.HABITAT })
  }, SceneGameController.prototype.updateBarActiveButton = function(data) {
    data = data || "none", this.updateTopBar({ activeButton: data }), this.updateBottomBar({
      activeButton: data
    })
  }, SceneGameController.prototype.closeGlobalOverview = function() {
    var globalOverviewMode;
    for (globalOverviewMode in this.subSceneGlobalOverview)this.subSceneGlobalOverview.hasOwnProperty(globalOverviewMode) && this.subSceneGlobalOverview[globalOverviewMode] && this.subSceneGlobalOverview[globalOverviewMode].hide();
    this.subSceneGlobalOverviewActiveMode = null
  }, SceneGameController.prototype.updateBottomBar = function(data) {
    this.presenter.drawBottomBar(data)
  }, SceneGameController.prototype.updateTopBar = function(data) {
    this.presenter.drawUpperBar(data)
  }, SceneGameController.prototype.updateToggleBar = function(data) {
    this.presenter.drawToggleBar(data)
  }, SceneGameController.prototype.afterDataUpdate = function() {
    this.initSessionTimer(), this.updateTopBar({
      habitatAmount: servicesGameDataManager.habitatsCollection.getOwnHabitatsAmount(),
      habitat: servicesGameDataManager.habitatsCollection.getHabitat()
    }), this.updateToggleBar({ ownHabitatsUnderAttackAmount: servicesGameDataManager.habitatsCollection.getOwnHabitatsUnderAttackAmount() })
  }, SceneGameController.prototype.showTutorialPopUp = function(data) {
    this.currentTutorialPopView ? this.currentTutorialPopView.show({ event: data }) : this.currentTutorialPopView = this.showSubScene(xy.dNames.game.popUpTutorial.name, { event: data })
  }, SceneGameController.prototype.showEventPopUp = function(data) {
    this.currentPopView || (this.currentPopView = !0, this.currentPopView = this.showSubScene(xy.dNames.game.popUpEvent.name, { event: data }))
  }, SceneGameController.prototype.clearPopUp = function() {
    this.currentPopView && (this.currentPopView = null)
  }, SceneGameController.prototype.openBuildingOverview = function(options) {
    options.title = servicesGameDataManager.buildingsCollection.getBuildingTitle(options.classIdentifier), this.showMenuView({
      buttonName: "BuildingOverview",
      options: options
    })
  }, SceneGameController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGame.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesInternationalization) {
  "use strict";
  function SceneGameDataSource(options) {
    SceneGameDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGameDataSource, CoreDataSource), SceneGameDataSource.prototype.connectToGameWorld = function() {
    this.doToken()
  }, SceneGameDataSource.prototype.doToken = function() {
    this.request(null, "LoginAction/token", { callBack: this.doLogin, isConnect: !0 })
  }, SceneGameDataSource.prototype.doLogin = function() {
    this.request(null, "LoginAction/login", { callBack: this.handleGameConnectedResponse, isConnect: !0 })
  }, SceneGameDataSource.prototype.handleGameConnectedResponse = function(data) {
    servicesGameDataManager.receiveGameData(data), this.notify(xy.eNames.sceneGame.onWorldIsConnected)
  }, SceneGameDataSource.prototype.onLostAllHabitatsCreateNewHabitat = function() {
    this.request(null, "HabitatAction/createNewHabitat", { callBack: this.handleGameConnectedResponse })
  }, SceneGameDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGame.presenter, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.graphicEngine.mainDirector, xy.dNames.core.presenterElement, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.game.sceneGame.componentTopBar, xy.dNames.game.sceneGame.componentBottomBar, xy.dNames.game.sceneGame.componentToggleBar, function(gameInstance, ComponentsEngine, graphicEngineMainDirector, CorePresenterElement, utilsOop, settingsGameConstant, GameSceneComponentTopBar, GameSceneComponentBottomBar, GameSceneComponentToggleBar) {
  "use strict";
  function SceneGamePresenter(options) {
    SceneGamePresenter.__super__.constructor.call(this, options), this.topBarComponentCache = {
      habitatAmount: 0,
      activeButton: null,
      currentHabitat: null,
      extraResources: { conquest: 0, premium: 0 }
    }, this.bottomBarComponentCache = {
      alerts: null,
      activeButton: null
    }, this.toggleBarComponentCache = { activeButton: null, buttonAlert: {}, showCenterMapButton: !1 }
  }

  return utilsOop.extend(SceneGamePresenter, CorePresenterElement), SceneGamePresenter.prototype.draw = function() {
    document.getElementById(xy.DomElements.gameFrame).innerHTML = '<div class="menu-box"><div id="' + xy.DomElements.gameMenuRoot + '"></div><div id="' + xy.DomElements.gameMenuDrillDown + '"></div></div>'
  }, SceneGamePresenter.prototype.clear = function() {
    ComponentsEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gameBarBottom)), ComponentsEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gameBarTop)), ComponentsEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gameGlobalOverview)), document.getElementById(xy.DomElements.gameFrame).innerHTML = "", graphicEngineMainDirector.clearScene()
  }, SceneGamePresenter.prototype.clearDirector = function() {
    graphicEngineMainDirector.clearScene()
  }, SceneGamePresenter.prototype.drawBottomBar = function(data) {
    data.activeButton && (this.bottomBarComponentCache.activeButton = data.activeButton), data.alerts && (this.bottomBarComponentCache.alerts = data.alerts), (data.alerts || null !== this.bottomBarComponentCache.alerts) && ComponentsEngine.render(React.createElement(GameSceneComponentBottomBar, {
      presenter: this,
      settings: this.bottomBarComponentCache
    }), document.getElementById(xy.DomElements.gameBarBottom))
  }, SceneGamePresenter.prototype.drawUpperBar = function(data) {
    data.habitatAmount && (this.topBarComponentCache.habitatAmount = data.habitatAmount), data.habitat && (this.topBarComponentCache.habitat = data.habitat), data.activeButton && (this.topBarComponentCache.activeButton = data.activeButton), data.extraResources && (this.topBarComponentCache.extraResources = data.extraResources), ComponentsEngine.render(React.createElement(GameSceneComponentTopBar, {
      presenter: this,
      settings: this.topBarComponentCache
    }), document.getElementById(xy.DomElements.gameBarTop))
  }, SceneGamePresenter.prototype.drawToggleBar = function(data) {
    data.activeSceneMode && (this.toggleBarComponentCache.activeSceneMode = data.activeSceneMode), void 0 !== data.showCenterMapButton && (this.toggleBarComponentCache.showCenterMapButton = data.showCenterMapButton), data.hasOwnProperty("ownHabitatsUnderAttackAmount") && (this.toggleBarComponentCache.buttonAlert[settingsGameConstant.SCENE_MODE.HABITAT] = data.ownHabitatsUnderAttackAmount || 0), this.toggleBarComponentCache.activeSceneMode && ComponentsEngine.render(React.createElement(GameSceneComponentToggleBar, {
      presenter: this,
      settings: this.toggleBarComponentCache
    }), document.getElementById(xy.DomElements.gameBarToggle))
  }, SceneGamePresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGame.componentTopBar, [xy.dNames.componentsEngine, xy.dNames.utils.number, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.eventManager, xy.dNames.components.resourceProgressBar, xy.dNames.components.resourceIconAmount, xy.dNames.components.buttonForBars, function(componentsEngine, utilsNumber, settingsGameConstant, servicesInternationalization, servicesTheme, servicesEventManager, ComponentsResourceProgressBar, ComponentsResourceIconAmount, ComponentsButtonForBars) {
  "use strict";
  return componentsEngine.createClass({
    handlerButtonClick: function(buttonKey, isActive, event) {
      servicesEventManager.handleClientEvent(buttonKey + "-top-bar-button-click"), event.preventDefault(), isActive ? this.props.presenter.notify(xy.eNames.sceneGame.onCloseClickBarButton, buttonKey) : this.props.presenter.notify(xy.eNames.sceneGame.onOpenClickBarButton, buttonKey)
    }, handleArrowsClick: function(direction, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneGame.onHabitatChooserArrowClick, direction)
    }, handlerOpenWebShopClick: function() {
      this.props.presenter.notify(xy.eNames.sceneGame.goToWebShop)
    }, render: function() {
      var resourcesThemeSettings = servicesTheme.themeSettings.resources, buttonsList = ["Habitat Buildings", "Troops"], buttons = [], resourcesList = resourcesThemeSettings.resourcesList, resources = [], extraResourcesList = resourcesThemeSettings.extraResourcesList, extraResources = [], settings = this.props.settings, habitat = settings.habitat;
      buttonsList.forEach(function(buttonName) {
        var buttonKey = buttonName.replace(" ", ""), isActive = buttonName === settings.activeButton ? " active" : "", settingsButton = {
          icon: "icon-game white icon-" + buttonKey,
          title: servicesInternationalization.localize(buttonName),
          classes: isActive + " top-bar-button--" + buttonKey,
          onClick: this.handlerButtonClick.bind(this, buttonKey, isActive)
        };
        buttons.push(React.createElement(ComponentsButtonForBars, {
          settings: settingsButton,
          key: "top-button-" + buttonKey
        }))
      }, this);
      var resourcesCache = habitat.habitatResourceDictionary;
      resourcesList.forEach(function(idResource) {
        var percent, amount, settingsResources;
        resourcesThemeSettings.humanResourceId === idResource ? (amount = resourcesCache[idResource].storeAmount - resourcesCache[idResource].amount, percent = 100 - (amount / resourcesCache[idResource].storeAmount * 100 | 0)) : (amount = resourcesCache[idResource].amount, percent = amount / resourcesCache[idResource].storeAmount * 100 | 0), settingsResources = {
          icon: "icon-resource-" + idResource,
          amount: utilsNumber.shortWithSuffixes(amount),
          percent: percent
        }, resources.push(React.createElement(ComponentsResourceProgressBar, {
          settings: settingsResources,
          key: "resource-" + idResource
        }))
      }, this), extraResourcesList.forEach(function(idResource, index) {
        var amount = +settings.extraResources[idResource] || 0, settingsResources = {
          icon: "icon-resource-" + idResource,
          amount: utilsNumber.shortWithSuffixes(amount),
          showFill: !1
        };
        idResource === settingsGameConstant.PREMIUM_RESOURCE && (settingsResources.onClick = this.handlerOpenWebShopClick, settingsResources.classes = "clickable"), extraResources.push(React.createElement(ComponentsResourceIconAmount, {
          settings: settingsResources,
          key: "extra-resource-" + index
        }))
      }, this);
      var leftArrow = null, rightArrow = null;
      settings.habitatAmount > 1 && (leftArrow = React.createElement("div", {
        className: "habitat-chooser--arrow controls arrow-left",
        onClick: this.handleArrowsClick.bind(this, settingsGameConstant.SET_CURRENT_HABITAT_EVENT.PREV)
      }, " "), rightArrow = React.createElement("div", {
        className: "habitat-chooser--arrow controls arrow-right",
        onClick: this.handleArrowsClick.bind(this, settingsGameConstant.SET_CURRENT_HABITAT_EVENT.NEXT)
      }, " "));
      var titleActiveClass = "Title" === settings.activeButton ? " active" : "", titleArrowClass = leftArrow ? "" : " no-arrows-title", titleComponent = React.createElement("div", {
        className: "habitat-chooser--title text-name-with-emo-icons" + titleActiveClass + titleArrowClass,
        onClick: this.handlerButtonClick.bind(this, "Title", titleActiveClass)
      }, React.createElement("span", null, habitat.name), React.createElement("span", { className: "font-oblique" }, " (" + habitat.points + ")"));
      return React.createElement("div", { className: "bar-top--content" }, React.createElement("div", { className: "bar-top--left-column" }, buttons), React.createElement("div", { className: "bar-top--center-column" }, React.createElement("div", { className: "habitat-chooser" }, React.createElement("div", { className: "habitat-chooser--title-row" }, leftArrow, titleComponent, rightArrow), React.createElement("div", { className: "habitat-chooser--resources-row" }, resources))), React.createElement("div", { className: "bar-top--right-column" }, extraResources))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGame.componentBottomBar, [xy.dNames.componentsEngine, xy.dNames.components.buttonForBars, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(componentsEngine, ComponentsButtonForBars, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  return componentsEngine.createClass({
    handlerButtonClick: function(buttonKey, isActive, event) {
      event.preventDefault(), isActive ? this.props.presenter.notify(xy.eNames.sceneGame.onCloseClickBarButton, buttonKey) : this.props.presenter.notify(xy.eNames.sceneGame.onOpenClickBarButton, buttonKey)
    }, render: function() {
      var settingsButton, settings = this.props.settings, buttonsList = ["General Functions", "Messages", "Reports"], buttonAlert = {
        Reports: settings.alerts.unreadReportCount || 0,
        Messages: settings.alerts.unreadDiscussionCount || 0,
        Forum: settings.alerts.unreadThreadCount || 0,
        Profile: settings.alerts.successEvents || 0
      }, buttons = [];
      return servicesGameDataManager.getAllianceId() && buttonsList.push("Forum"), buttonsList.push("Alliance"), buttonsList.push("Profile"), buttonsList.forEach(function(buttonName) {
        var buttonKey = buttonName.replace(" ", ""), isActive = buttonName === settings.activeButton ? " active" : "";
        settingsButton = {
          icon: "icon-game white icon-" + buttonKey,
          title: servicesInternationalization.localize(buttonName),
          classes: isActive,
          alertNumber: buttonAlert[buttonKey] || 0,
          onClick: this.handlerButtonClick.bind(this, buttonKey, isActive)
        }, buttons.push(React.createElement(ComponentsButtonForBars, {
          settings: settingsButton,
          key: "bottom-button-" + buttonKey
        }))
      }, this), React.createElement("div", { className: "bar-bottom--content" }, buttons)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGame.componentToggleBar, [xy.dNames.componentsEngine, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.components.buttonMain, xy.dNames.components.buttonForBars, function(componentsEngine, settingsGameConstant, servicesTheme, ComponentsButtonMain) {
  "use strict";
  return componentsEngine.createClass({
    handlerButtonClick: function(newSceneMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.sceneGame.onNewSceneChoosing, { newSceneMode: newSceneMode })
    }, handlerCenterHabitatButtonClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.sceneGame.centerMapByCurrentHabitatCoordinates)
    }, render: function() {
      var settings = { activeSceneMode: settingsGameConstant.SCENE_MODE.MAP, showCenterMapButton: !0, buttonAlert: {} };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeIconsSettings = servicesTheme.themeSettings.imagesClassNames.icon, centerButton = null;
      settings.showCenterMapButton && (sectionComponentSettings = {
        classes: "round",
        icon: themeIconsSettings["toggle-button-icon-center-current-habitat"],
        onClick: this.handlerCenterHabitatButtonClick
      }, centerButton = React.createElement(ComponentsButtonMain, { settings: sectionComponentSettings }), componentsSections.push(React.createElement("div", {
        className: "toggle-buttons--center-map",
        key: "toggle-button-center-map"
      }, centerButton)));
      var mapSceneKey, mapSceneCode, toggleButtons = [];
      for (mapSceneKey in settingsGameConstant.SCENE_MODE)settingsGameConstant.SCENE_MODE.hasOwnProperty(mapSceneKey) && (mapSceneCode = settingsGameConstant.SCENE_MODE[mapSceneKey], sectionComponentSettings = {
        classes: "toggle-button--" + mapSceneKey,
        icon: themeIconsSettings["toggle-button-icon-" + mapSceneKey],
        onClick: this.handlerButtonClick.bind(this, mapSceneCode),
        alertNumber: settings.buttonAlert[mapSceneCode] || 0,
        alertNumberPosition: " left"
      }, settingsGameConstant.SCENE_MODE[mapSceneKey] === settings.activeSceneMode && (sectionComponentSettings.isActive = !0), toggleButtons.push(React.createElement(ComponentsButtonMain, {
        settings: sectionComponentSettings,
        key: "toggle-button-" + mapSceneKey
      })));
      return componentsSections.push(React.createElement("div", { className: "toggle-buttons--content" }, toggleButtons)), React.createElement("div", null, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapGame.controller, [xy.dNames.core.controllerCanvas, xy.dNames.utils.oop, function(CoreControllerCanvas, utilsOop) {
  "use strict";
  function SceneMapGameController(options) {
    SceneMapGameController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.afterDataUpdate
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.onActiveHabitatUpdate
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.changesInHighlighting,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.onSoftUpdate
    }], this.screenPosition = null, this.tileOffset = null, this.isActive = !0
  }

  return utilsOop.extend(SceneMapGameController, CoreControllerCanvas), SceneMapGameController.prototype.start = function() {
    this.registerAllDataListeners(), this[xy.eNames.sceneMapGame.moveMapCenterToCoordinates](this.initialData)
  }, SceneMapGameController.prototype[xy.eNames.sceneMapGame.moveMapCenterToCoordinates] = function(options) {
    options = options || {};
    var fixedCoordinates = options.coordinates || options;
    fixedCoordinates.mapX && fixedCoordinates.mapY && (options.isResize && this.presenter.clearScene(), this.dataSource.getMapData({
      mapX: fixedCoordinates.mapX,
      mapY: fixedCoordinates.mapY
    }))
  }, SceneMapGameController.prototype[xy.eNames.sceneMapGame.onMapBoarderReached] = function(coordinates) {
    this[xy.eNames.sceneMapGame.moveMapCenterToCoordinates](coordinates)
  }, SceneMapGameController.prototype[xy.eNames.sceneMapGame.onMapDataIsPrepared] = function(data) {
    var sync;
    sync = this.presenter.drawMapGameWithData(data), sync && this.presenter.runScene()
  }, SceneMapGameController.prototype[xy.eNames.sceneMapGame.onClickOnMap] = function(data) {
    var habitatId = this.dataSource.isHabitatOnCoordinates(data);
    habitatId && this.notify(xy.eNames.sceneGame.openHabitatOverview, { habitatId: habitatId })
  }, SceneMapGameController.prototype.onActiveHabitatUpdate = function(data) {
    data && data.habitat && this.presenter.isDrawn && this.presenter.updateMapWithNewNavigationalArrow({
      currentHabitat: data.habitat,
      currentHabitatCoordinates: { mapX: data.habitat.mapX, mapY: data.habitat.mapY }
    })
  }, SceneMapGameController.prototype.onSoftUpdate = function() {
    this.presenter.isDrawn && this[xy.eNames.sceneMapGame.moveMapCenterToCoordinates](this.controller.cachedMapCenter)
  }, SceneMapGameController.prototype.afterDataUpdate = function() {
    this.presenter.isDrawn && (this.dataSource.flushCache(), this[xy.eNames.sceneMapGame.moveMapCenterToCoordinates](this.controller.cachedMapCenter))
  }, SceneMapGameController.prototype[xy.eNames.sceneMapGame.onKeyboardMoveMap] = function(options) {
    this.presenter.moveMapBufferByDirectionFromKeyboard(options)
  }, SceneMapGameController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapGame.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesLog, servicesTheme, servicesGameDataManager) {
  "use strict";
  function SceneMapGameDataSource(options) {
    SceneMapGameDataSource.__super__.constructor.call(this, options), this.cachedHabitats = {}, this.cachedTiles = {}, this.themeMapSettings = servicesTheme.themeSettings.settings.map
  }

  return utilsOop.extend(SceneMapGameDataSource, CoreDataSource), SceneMapGameDataSource.prototype.getMapFromCache = function(params) {
    var x, y, tileSectorSize = this.themeMapSettings.tileSector.gameMapSize, originX = params.mapX, originY = params.mapY, rightX = originX + params.mapWidth, bottomY = originY + params.mapHeight, tileArrayCacheData = [];
    for (y = originY; y < bottomY; y += tileSectorSize)for (x = originX; x < rightX; x += tileSectorSize) {
      if (!this.cachedTiles[y] || !this.cachedTiles[y][x])return null;
      tileArrayCacheData.push(this.cachedTiles[y][x])
    }
    return tileArrayCacheData
  }, SceneMapGameDataSource.prototype.getBufferSectorSize = function(dimensionScreen, dimensionTile) {
    var canvasMapGameRatio = this.themeMapSettings.canvasMapGameRatio, tileSectorSize = this.themeMapSettings.tileSector.gameMapSize, requestPXSize = canvasMapGameRatio * Math.max(dimensionScreen, 1024), requestTileSectorSize = 1 + (requestPXSize / dimensionTile / tileSectorSize | 0);
    return requestTileSectorSize * tileSectorSize
  }, SceneMapGameDataSource.prototype.getBufferOrigin = function(mapCenter, dimensionSize) {
    var tileSectorSize = this.themeMapSettings.tileSector.gameMapSize;
    return ((mapCenter - dimensionSize / 2) / tileSectorSize | 0) * tileSectorSize
  }, SceneMapGameDataSource.prototype.getMapData = function(coordinates) {
    var mapRequestSizeWidth, mapRequestSizeHeight, params, mapFromCacheData, width = this.themeMapSettings.tileGameMap.width, height = this.themeMapSettings.tileGameMap.height;
    mapRequestSizeWidth = this.getBufferSectorSize(window.innerWidth, width), mapRequestSizeHeight = this.getBufferSectorSize(window.innerHeight, height), params = {
      mapX: this.getBufferOrigin(coordinates.mapX, mapRequestSizeWidth),
      mapY: this.getBufferOrigin(coordinates.mapY, mapRequestSizeHeight),
      mapWidth: mapRequestSizeWidth,
      mapHeight: mapRequestSizeHeight
    }, this.requestedMapCenter = {
      mapX: coordinates.mapX,
      mapY: coordinates.mapY
    }, mapFromCacheData = this.getMapFromCache(params), mapFromCacheData ? this.handleMapCacheResponse(mapFromCacheData, params) : this.request(params, "MapAction/map", { callBack: this.handleMapDataResponse })
  }, SceneMapGameDataSource.prototype.handleMapCacheResponse = function(tileArrayCacheData, params) {
    var currentHabitat = servicesGameDataManager.habitatsCollection.getHabitat();
    this.notify(xy.eNames.sceneMapGame.onMapDataIsPrepared, {
      frame: {
        origin: { x: params.mapX, y: params.mapY },
        size: { width: params.mapWidth, height: params.mapHeight }
      },
      mapCenter: this.requestedMapCenter,
      tileArray: tileArrayCacheData,
      worldTime: this.worldTime,
      currentHabitatCoordinates: { mapX: currentHabitat.mapX, mapY: currentHabitat.mapY }
    })
  }, SceneMapGameDataSource.prototype.handleMapDataResponse = function(data) {
    servicesGameDataManager.sceneMapDataLoaded = !0, this.worldTime = {
      time: data.time,
      worldDawn: data.worldDawn,
      worldDusk: data.worldDusk
    };
    var tileArray = data.map.tileArray || [], mapFrame = data.map.frame || [], currentHabitat = servicesGameDataManager.habitatsCollection.getHabitat();
    data && data.Data && (servicesGameDataManager.habitatsCollection.updateWithHabitatMapResponse(data.Data.Habitat), servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), servicesGameDataManager.updateAlliancesData(data.Data.Alliance, { isPeripheral: !0 })), this.updateTilesCache(tileArray), this.notify(xy.eNames.sceneMapGame.onMapDataIsPrepared, {
      frame: mapFrame,
      mapCenter: this.requestedMapCenter,
      tileArray: tileArray,
      worldTime: this.worldTime,
      currentHabitat: currentHabitat,
      currentHabitatCoordinates: { mapX: currentHabitat.mapX, mapY: currentHabitat.mapY }
    })
  }, SceneMapGameDataSource.prototype.updateTilesCache = function(tileArray) {
    tileArray.forEach(function(tileArrayObject) {
      this.updateTileInCache(tileArrayObject)
    }, this)
  }, SceneMapGameDataSource.prototype.updateTileInCache = function(tileObject) {
    var tileSectorSize = this.themeMapSettings.tileSector.gameMapSize, originX = tileObject.frame.origin.x, originY = tileObject.frame.origin.y, width = +tileObject.frame.size.width, height = +tileObject.frame.size.height;
    return tileSectorSize !== width || tileSectorSize !== height ? void servicesLog("error", "Tile sector size for game map diff from theme settings") : (this.cachedTiles.hasOwnProperty(originY) || (this.cachedTiles[originY] = {}), this.cachedTiles[originY][originX] = tileObject, void tileObject.habitatArray.forEach(function(habitatId) {
      var habitatsCoordinates = servicesGameDataManager.habitatsCollection.getHabitatMapCoordinates(habitatId);
      this.cachedHabitats.hasOwnProperty(habitatsCoordinates.mapY) || (this.cachedHabitats[habitatsCoordinates.mapY] = {}), this.cachedHabitats[habitatsCoordinates.mapY][habitatsCoordinates.mapX] = +habitatId
    }, this))
  }, SceneMapGameDataSource.prototype.flushCache = function() {
    this.cachedTiles = {}, this.cachedHabitats = {}
  }, SceneMapGameDataSource.prototype.isHabitatOnCoordinates = function(coordinates) {
    return this.cachedHabitats[coordinates.mapY] && this.cachedHabitats[coordinates.mapY][coordinates.mapX] ? this.cachedHabitats[coordinates.mapY][coordinates.mapX] : null
  }, SceneMapGameDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapGame.presenter, [xy.dNames.core.presenterGraphicEngine, xy.dNames.graphicEngine.mainDirector, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.game.sceneMapGame.componentMapBuffer, xy.dNames.game.sceneMapGame.componentMapArrow, function(CorePresenterGraphicEngine, graphicEngineMainDirector, utilsOop, settingsGameConstant, SceneMapGameComponentMapBuffer, SceneMapGameComponentMapArrow) {
  "use strict";
  function SceneMapGamePresenter(options) {
    SceneMapGamePresenter.__super__.constructor.call(this, options), this.isDrawn = !1, this.mapBuffer = new SceneMapGameComponentMapBuffer, this.mapBuffer.init({
      noBufferInitialisation: !0,
      presenter: this
    }), this.arrowBuffer = new SceneMapGameComponentMapArrow, this.arrowBuffer.init({ presenter: this }), this.addChild(this.mapBuffer, { z: settingsGameConstant.SCENE_MAP_Z_LEVELS.MAP }), this.addChild(this.arrowBuffer, { z: settingsGameConstant.SCENE_MAP_Z_LEVELS.NAVIGATION_ARROW })
  }

  return utilsOop.extend(SceneMapGamePresenter, CorePresenterGraphicEngine), SceneMapGamePresenter.prototype.drawMapGameWithData = function(data) {
    return this.mapBuffer.update(data), data.mapCenter && (this.localMapCenter = {
      mapX: data.mapCenter.mapX,
      mapY: data.mapCenter.mapY
    }), this.mapBuffer.setMapCenter(this.localMapCenter), this.arrowBuffer.update({
      mapCenter: this.localMapCenter,
      currentHabitat: data.currentHabitat,
      currentHabitatCoordinates: data.currentHabitatCoordinates
    }), !0
  }, SceneMapGamePresenter.prototype.updateMapWithNewNavigationalArrow = function(data) {
    this.arrowBuffer.update({
      mapCenter: this.localMapCenter,
      currentHabitat: data.currentHabitat,
      currentHabitatCoordinates: data.currentHabitatCoordinates
    }), graphicEngineMainDirector.renew()
  }, SceneMapGamePresenter.prototype.moveMapBufferByDirectionFromKeyboard = function(options) {
    this.isDrawn && this.mapBuffer.moveMapByKeyboard(options)
  }, SceneMapGamePresenter.prototype.onMapMove = function(centerMapGameCoordinates) {
    this.isDrawn && (this.localMapCenter = centerMapGameCoordinates, this.notify(xy.eNames.sceneGame.cacheCenterMapCoordinates, centerMapGameCoordinates), this.arrowBuffer.update({ mapCenter: this.localMapCenter }), graphicEngineMainDirector.renew())
  }, SceneMapGamePresenter.prototype.onMapClick = function(gameCoordinates) {
    gameCoordinates && this.notify(xy.eNames.sceneMapGame.onClickOnMap, gameCoordinates)
  }, SceneMapGamePresenter.prototype.onMapBorderReached = function(gameCoordinates) {
    gameCoordinates && this.notify(xy.eNames.sceneMapGame.onMapBoarderReached, gameCoordinates)
  }, SceneMapGamePresenter.prototype.runScene = function() {
    this.isDrawn ? graphicEngineMainDirector.renew() : graphicEngineMainDirector.playScene(this), this.notify(xy.eNames.sceneGame.onCanvasDrawn)
  }, SceneMapGamePresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapGame.componentMapBuffer, [xy.dNames.core.graphicalEngineMapCanvasBuffer, xy.dNames.utils.oop, xy.dNames.services.theme, xy.dNames.services.sortable, xy.dNames.game.sceneMapGame.componentMapLocalTile, function(CoreGraphicalEngineMapCanvasBuffer, utilsOop, servicesTheme, servicesSortable, SceneMapGameComponentMapLocalTile) {
  "use strict";
  function BufferMapGame(options) {
    BufferMapGame.__super__.constructor.call(this, options), this.children = {}, this.mapThemeSettings = servicesTheme.themeSettings.settings.map, this.tileMap = this.mapThemeSettings.tileGameMap, this.borderOffset = 200, this.buffer = null, this.tileComponents = [], this.isAnimationVisible = !1
  }

  return utilsOop.extend(BufferMapGame, CoreGraphicalEngineMapCanvasBuffer), BufferMapGame.prototype.render = function(options) {
    this.isAnimationVisible = !1;
    var ctx = options.context;
    return this.tileComponents.forEach(function(tile) {
      var image, rect;
      if (tile.isTileVisible())return tile.isTileAnimated ? (this.isAnimationVisible = !0, image = tile.getUpdatedCanvasWithAnimation()) : image = tile.buffer, rect = tile.getVisibleArea(), ctx.drawImage(image, rect.x, rect.y, rect.width, rect.height, rect.screenX, rect.screenY, rect.width, rect.height)
    }, this), !0
  }, BufferMapGame.prototype.__drawMap = function(data) {
    this.tileComponents = [];
    var frameSize = data.frame.size;
    this.gameCoordinates.origin = {
      mapX: data.frame.origin.x,
      mapY: data.frame.origin.y
    }, this.gameCoordinates.frameSize = {
      width: frameSize.width,
      height: frameSize.height
    }, this.size = {
      width: frameSize.width * this.tileMap.width,
      height: frameSize.height * this.tileMap.height
    }, data.tileArray.sort(servicesSortable.mapTiles), data.tileArray.forEach(function(tileObject) {
      var localTile = new SceneMapGameComponentMapLocalTile;
      localTile.parentMapComponent = this, localTile.__drawGroundAndHabitats({
        tileObject: tileObject,
        worldTime: data.worldTime
      }) && this.tileComponents.push(localTile)
    }, this)
  }, BufferMapGame
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapGame.componentMapArrow, [xy.dNames.core.graphicalEngineNode, xy.dNames.utils.oop, xy.dNames.services.theme, xy.dNames.services.internationalization, function(CoreGraphicalEngineNode, utilsOop, servicesTheme, servicesInternationalization) {
  "use strict";
  function MapGameArrow(data, presenter) {
    MapGameArrow.__super__.constructor.call(this, data, presenter), this.mapArrowThemeSettings = servicesTheme.themeSettings.settings.map.arrowSettings, this.currentHabitat = null, this.currentHabitatCoordinates = null
  }

  return utilsOop.extend(MapGameArrow, CoreGraphicalEngineNode), MapGameArrow.prototype.__initBufferCanvas = function() {
    this.buffer = document.createElement("canvas"), this.size = this.mapArrowThemeSettings.size, this.tileMap = servicesTheme.themeSettings.settings.map.tileGameMap, this.x = 0, this.y = 0, this.screenX = window.innerWidth / 2 | 0, this.screenY = window.innerHeight / 2 | 0
  }, MapGameArrow.prototype.update = function(options) {
    options.currentHabitatCoordinates && (this.currentHabitatCoordinates = options.currentHabitatCoordinates), options.currentHabitat && (this.currentHabitat = options.currentHabitat);
    var closestVisibleMapTile = this.presenter.mapBuffer.getClosestVisibleMapTile(this.currentHabitatCoordinates);
    closestVisibleMapTile ? this.__drawArrow(closestVisibleMapTile) : this.__clear()
  }, MapGameArrow.prototype.__drawArrow = function(closestVisibleMapTile) {
    var bufferCanvas, ctx;
    bufferCanvas = this.buffer, bufferCanvas.width = this.size.width, bufferCanvas.height = this.size.height, ctx = bufferCanvas.getContext("2d"), ctx.clearRect(0, 0, this.size.width, this.size.height);
    var dx, dy, rotationRadians, distance = closestVisibleMapTile.distance, isArrowToFarAway = this.currentHabitat.isAnotherHabitatToFarAway(distance), height = this.size.height, width = this.size.width, lineWidth = this.mapArrowThemeSettings.lineThickness, bodyThickness = this.mapArrowThemeSettings.bodyThickness, backGroundColor = isArrowToFarAway ? this.mapArrowThemeSettings.backGroundColorToFarAway : this.mapArrowThemeSettings.backGroundColorReachable, frameColor = this.mapArrowThemeSettings.frameColor, habitatCoordinates = this.currentHabitatCoordinates, centerCoordinates = closestVisibleMapTile;
    dx = 128 * (habitatCoordinates.mapX - centerCoordinates.mapX), dy = 48 * (habitatCoordinates.mapY - centerCoordinates.mapY), rotationRadians = Math.atan2(dy, dx);
    var screenX, screenY, screenPosition = this.presenter.mapBuffer.convertGameCoordinatesToScreenCoordinates(closestVisibleMapTile), minWidth = 0, maxWidth = window.innerWidth - width, minHeight = this.mapArrowThemeSettings.gapY, maxHeight = window.innerHeight - minHeight - height, halfXOddOffset = this.tileMap.widthOodOffset / 2, xOddOffset = this.tileMap.width / 2 + (closestVisibleMapTile.mapY % 2 ? -halfXOddOffset : halfXOddOffset);
    switch (closestVisibleMapTile.screenXCase) {
      case"min":
        screenX = minWidth;
        break;
      case"max":
        screenX = maxWidth;
        break;
      case"none":
        screenX = screenPosition.x + xOddOffset, screenX < minWidth && (screenX = minWidth), screenX > maxWidth && (screenX = maxWidth)
    }
    switch (closestVisibleMapTile.screenYCase) {
      case"min":
        screenY = minHeight;
        break;
      case"max":
        screenY = maxHeight;
        break;
      case"none":
        screenY = screenPosition.y, screenY < minHeight && (screenY = minHeight), screenY > maxHeight && (screenY = maxHeight)
    }
    this.screenX = screenX, this.screenY = screenY;
    var xLocalCenter = width / 2, yLocalCenter = height / 2, lineWidth2x = 2 * lineWidth, y = bodyThickness / 2, x1 = xLocalCenter - lineWidth2x, x2 = x1 - 10;
    ctx.translate(xLocalCenter, yLocalCenter), ctx.rotate(rotationRadians), ctx.beginPath(), ctx.moveTo(x1, 0), ctx.lineTo(x2, y), ctx.lineTo(-x1, y), ctx.lineTo(-x1, y), ctx.lineTo(-x1, -y), ctx.lineTo(x2, -y), ctx.closePath(), ctx.fillStyle = backGroundColor, ctx.fill(), ctx.lineWidth = lineWidth, ctx.strokeStyle = frameColor, ctx.stroke();
    var distanceText = servicesInternationalization.localize("%d fields", distance), reflexTextFlag = !1;
    (rotationRadians < -1.6 || rotationRadians > 1.6) && (reflexTextFlag = !0), reflexTextFlag && ctx.rotate(Math.PI), ctx.font = "12px Lucida Grande", ctx.textAlign = "center", ctx.fillStyle = frameColor, ctx.fillText(distanceText, 0, 4), reflexTextFlag && ctx.rotate(-Math.PI), ctx.rotate(-rotationRadians), ctx.translate(-xLocalCenter, -yLocalCenter)
  }, MapGameArrow
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapGame.componentMapLocalTile, [xy.dNames.core.graphicalEngineNode, xy.dNames.core.graphicalEngineAnimation, xy.dNames.settings.gameConstant, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.utils.string, xy.dNames.services.log, xy.dNames.services.sortable, xy.dNames.services.theme, xy.dNames.services.gameDataManager, function(CoreGraphicalEngineNode, CoreGraphicalEngineAnimation, settingsGameConstant, utilsOop, utilsDateTime, utilsString, servicesLog, servicesSortable, servicesTheme, servicesGameDataManager) {
  "use strict";
  function MapLocalTile(options) {
    MapLocalTile.__super__.constructor.call(this, options), this.habitatUnderAttackCache = {}, this.habitatThemeSettings = servicesTheme.themeSettings.habitat, this.publicHabitatTypeNames = this.habitatThemeSettings.publicHabitatTypeNames, this.mapThemeSettings = servicesTheme.themeSettings.settings.map, this.tileMap = this.mapThemeSettings.tileGameMap, this.lightSwitcher = "", this.aniamtionLightSwitcher = "", this.initFramesManager(), this.addImageFrames({
      image: xy.res.mapImages,
      frameSetName: "mapGame",
      framesData: xy.res.mapPlist
    }), this.isTileAnimated = !1, this.buffer = null, this.parentMapComponent = null
  }

  return utilsOop.extend(MapLocalTile, CoreGraphicalEngineNode), MapLocalTile.prototype.__drawGroundAndHabitats = function(options) {
    var localCanvas, localCtx, localCanvasWidth, localCanvasHeight, tileSectorSize, widthOodOffset, tileWidth, tileHeight, tileSectorOriginX, tileSectorOriginY, x, y, xRight, yBottom, xCurrentTile, groundType, frameName, origin, yCurrentTile = settingsGameConstant.ANIMATION_GAP, tileObject = options.tileObject;
    for (this.lightSwitcher = utilsDateTime.isNight(options.worldTime) ? "N" : "", this.aniamtionLightSwitcher = utilsDateTime.isNight(options.worldTime) ? "N-" : "", tileSectorSize = this.mapThemeSettings.tileSector.gameMapSize, widthOodOffset = this.tileMap.widthOodOffset, tileWidth = this.tileMap.width, tileHeight = this.tileMap.height, tileSectorOriginX = tileObject.frame.origin.x, tileSectorOriginY = tileObject.frame.origin.y, xRight = tileSectorOriginX + tileSectorSize, yBottom = tileSectorOriginY + tileSectorSize, origin = this.parentMapComponent.gameCoordinates.origin, localCanvas = document.createElement("canvas"), localCanvasWidth = (tileSectorSize + 1) * tileWidth, localCanvasHeight = (tileSectorSize + 1) * tileHeight + settingsGameConstant.ANIMATION_GAP, localCanvas.width = localCanvasWidth, localCanvas.height = localCanvasHeight, localCtx = localCanvas.getContext("2d"), this.x = (tileSectorOriginX - origin.mapX) * tileWidth, this.y = (tileSectorOriginY - origin.mapY) * tileHeight - settingsGameConstant.ANIMATION_GAP, this.size = {
      width: localCanvasWidth,
      height: localCanvasHeight
    }, this.isTileAnimated = !1, this.habitatUnderAttackCache = servicesGameDataManager.habitatsCollection.habitatUnderAttack, y = tileSectorOriginY; y < yBottom; y += 1) {
      for (xCurrentTile = y % 2 ? widthOodOffset : 0, x = tileSectorOriginX; x < xRight; x += 1)groundType = this.__nextGround(x * y), frameName = "Ground" + groundType + this.lightSwitcher, this.addImageFrame({
        imageName: "mapGame",
        frameName: frameName,
        x: xCurrentTile,
        y: yCurrentTile
      }, localCtx), xCurrentTile += tileWidth;
      yCurrentTile += tileHeight
    }
    var unknownHabitatsToDraw = [], knownHabitatsToDraw = [];
    return tileObject.habitatArray.forEach(function(habitatId) {
      var habitat = servicesGameDataManager.habitatsCollection.getHabitatDataForMap(habitatId);
      habitat ? knownHabitatsToDraw.push(habitat) : unknownHabitatsToDraw.push(habitatId)
    }, this), unknownHabitatsToDraw.length && (servicesLog("warn", "Sync issue there are habitats to draw which are null"), servicesLog("debug", unknownHabitatsToDraw.slice())), knownHabitatsToDraw.sort(servicesSortable.habitatOnMapTile), knownHabitatsToDraw.forEach(function(habitatForMap) {
      var yPos, xPos;
      yPos = (habitatForMap.mapY - tileSectorOriginY) * tileHeight, xPos = habitatForMap.mapY % 2 ? widthOodOffset : 0, xPos += (habitatForMap.mapX - tileSectorOriginX) * tileWidth, this.__addHabitat({
        habitat: habitatForMap,
        x: xPos,
        y: yPos + settingsGameConstant.ANIMATION_GAP
      }, localCtx)
    }, this), this.buffer = localCanvas, !0
  }, MapLocalTile.prototype.__addHabitat = function(options, ctx) {
    var frameNameAnPosition = this.__getHabitatFrameNameAndPosition(options);
    this.addImageFrame({
      imageName: "mapGame",
      frameName: frameNameAnPosition.name,
      x: frameNameAnPosition.x,
      y: frameNameAnPosition.y
    }, ctx), options.habitat.badgeType && this.__addHabitatReservationBadges(options, ctx);
    var habitatId = options.habitat.id, isHabitatGoingForBattle = servicesGameDataManager.habitatsCollection.isHabitatGoingToHaveBattle(habitatId);
    isHabitatGoingForBattle && this.__addHabitatAnimation(options);
    var label, warLabelsColors, i, labelWidth = this.tileMap.width, labelHeight = this.tileMap.height, labelY = options.y + 38, warLabelSettings = this.tileMap.habitatColors.warLabelSettings, lengthOfAnimationSequence = warLabelSettings.lengthOfAnimationSequence;
    if (this.habitatUnderAttackCache[habitatId] || isHabitatGoingForBattle) {
      for (label = [], label.push(this.__getHabitatInfo(options)), warLabelsColors = options.habitat.isOwnByPlayer ? warLabelSettings.ownUnderAttack : warLabelSettings.ownAttack, i = 0; i < lengthOfAnimationSequence; i += 1)label.push(this.__getHabitatInfo(options, warLabelsColors[i]));
      this.__addBlinkingHabitatLabelAnimation({
        imagesArray: label,
        parentX: options.x,
        parentY: labelY,
        width: labelWidth,
        height: labelHeight
      })
    } else label = this.__getHabitatInfo(options), ctx.drawImage(label, 0, 0, labelWidth, labelHeight, options.x, labelY, labelWidth, labelHeight)
  }, MapLocalTile.prototype.__getHabitatInfo = function(options, warLabelColor) {
    var localCtx, localCanvas = document.createElement("canvas"), width = this.tileMap.width, height = this.tileMap.height;
    localCanvas.width = width, localCanvas.height = height, localCtx = localCanvas.getContext("2d");
    var habitatName, textWidth;
    habitatName = utilsString.getStringWithValidLength(options.habitat.name, settingsGameConstant.MAX_LENGTH_HABITAT_NAME_TITLE), textWidth = localCtx.measureText(habitatName).width;
    var xCenter = width / 2, xLeft = xCenter - textWidth / 2 - 10, xLeftCenter = xCenter - 16, xRight = xCenter + textWidth / 2 + 10, xRightCenter = xCenter + 16, yTop = 0, yCenter = yTop + this.tileMap.heightOffset, yBottom = yCenter + this.tileMap.heightOffset;
    localCtx.beginPath(), localCtx.moveTo(xLeft, yTop), localCtx.lineTo(xRight, yTop), localCtx.lineTo(xRight, yCenter), localCtx.lineTo(xRightCenter, yBottom), localCtx.lineTo(xLeftCenter, yBottom), localCtx.lineTo(xLeft, yCenter), localCtx.closePath(), localCtx.fillStyle = this.tileMap.habitatColors[options.habitat.habitatColorType], localCtx.fill(), warLabelColor && (localCtx.fillStyle = warLabelColor, localCtx.fill());
    var textColor = "black";
    return options.habitat.habitatColorType !== settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALL && options.habitat.habitatColorType !== settingsGameConstant.ALLIANCE_RELATIONSHIPS.RENEGADE || (textColor = "white"), localCtx.fillStyle = textColor, localCtx.lineWidth = 1, localCtx.textAlign = "center", localCtx.font = "12px sans-serif", localCtx.fillText(habitatName, xCenter, yTop + 12), localCtx.font = "10px sans-serif", localCtx.fillText(options.habitat.points, xCenter, yTop + 23), localCanvas
  }, MapLocalTile.prototype.__addHabitatReservationBadges = function(options, ctx) {
    var badge = options.habitat.badgeType;
    badge.left && this.addImageFrame({
      imageName: "mapGame",
      frameName: "reserved-" + badge.left,
      x: options.x + 15,
      y: options.y + 10
    }, ctx), badge.right && this.addImageFrame({
      imageName: "mapGame",
      frameName: "reserved-" + badge.right,
      x: options.x + 80,
      y: options.y + 10
    }, ctx)
  }, MapLocalTile.prototype.__addBlinkingHabitatLabelAnimation = function(options) {
    var labelAnimation = new CoreGraphicalEngineAnimation;
    labelAnimation.init(), labelAnimation.setFramesFromImageArray({ imagesArray: options.imagesArray }), labelAnimation.setSize(options.width, options.height), labelAnimation.setPosition(options.parentX, options.parentY), this.addChild(labelAnimation, { z: settingsGameConstant.SCENE_MAP_Z_LEVELS.MAP_LABEL_ANIMATION }), this.isTileAnimated = !0
  }, MapLocalTile.prototype.__addHabitatAnimation = function(options) {
    if (4 !== options.habitat.habitatType) {
      var warAnimation = new CoreGraphicalEngineAnimation;
      warAnimation.init(), warAnimation.setFrameSet({
        image: xy.res.mapAnimationHabitatUnderAttackImages,
        frameSetName: "mapAnimation",
        framesData: xy.res.mapAnimationHabitatUnderAttackPlist
      }), warAnimation.setFrames({
        name: "habitat-" + options.habitat.habitatType + "-under-attack-" + this.aniamtionLightSwitcher,
        framesLength: 25
      }), warAnimation.setPosition(options.x, options.y - 10), this.addChild(warAnimation, { z: settingsGameConstant.SCENE_MAP_Z_LEVELS.MAP_WAR_ANIMATION }), this.isTileAnimated = !0
    }
  }, MapLocalTile.prototype.__nextGround = function(seed) {
    return seed = seed || 0, seed = seed + 2127912214 + (seed << 12) & 4294967295, seed = 4294967295 & (3345072700 ^ seed ^ seed >> 19), seed = seed + 374761393 + (seed << 5) & 4294967295, seed = 4294967295 & (seed + 3550635116 ^ seed << 9), seed = seed + 4251993797 + (seed << 3) & 4294967295, seed = 4294967295 & (3042594569 ^ seed ^ seed >> 16), ((2147483647 & seed) >> 0) % this.tileMap.groundTypeNum
  }, MapLocalTile.prototype.__getHabitatFrameNameAndPosition = function(options) {
    var name, ownerType, habitat = options.habitat, habitatType = habitat.habitatType, publicHabitatTypeNames = this.publicHabitatTypeNames[habitatType], mapSettingsHabitat = this.mapThemeSettings.habitat[habitatType], level = habitat.points > mapSettingsHabitat.highLevelHabitatPoints ? "1" : "0", habitatGroundType = habitat.mapX * habitat.mapY % mapSettingsHabitat.groundTypeNum, x = options.x + mapSettingsHabitat.offsetX, y = options.y + mapSettingsHabitat.offsetY;
    switch (habitatType) {
      case 0:
        ownerType = habitat.isRenegade ? "N" : "P", name = publicHabitatTypeNames + habitatGroundType + this.lightSwitcher + "-" + ownerType + "-" + level;
        break;
      case 2:
        ownerType = habitat.isRenegade ? "_N" : "", name = publicHabitatTypeNames + level + this.lightSwitcher + ownerType;
        break;
      case 4:
        ownerType = habitat.isRenegade ? "N" : "P", name = publicHabitatTypeNames + habitatGroundType + this.lightSwitcher + "-" + ownerType + "-" + level;
        break;
      default:
        name = "unknown-habitat-type-" + habitatType
    }
    return { name: name, x: x, y: y }
  }, MapLocalTile.prototype.__drawDebugGround = function(options, ctx) {
    ctx.lineWidth = 1, ctx.strokeStyle = "#FFFFFF", ctx.beginPath(), ctx.moveTo(options.xCurrentTile, options.yCurrentTile), ctx.lineTo(options.xCurrentTile + 128, options.yCurrentTile), ctx.lineTo(options.xCurrentTile + 128, options.yCurrentTile + 48), ctx.lineTo(options.xCurrentTile, options.yCurrentTile + 48), ctx.lineTo(options.xCurrentTile, options.yCurrentTile), ctx.stroke(), ctx.strokeText(options.x + ", " + options.y, options.xCurrentTile + 10, options.yCurrentTile + 10)
  }, MapLocalTile.prototype.isTileVisible = function() {
    var width = this.size.width, height = this.size.height, x = this.x, y = this.y;
    return this.isAxisVisible(x, x + width, this.parentMapComponent.x, this.parentMapComponent.x + window.innerWidth) && this.isAxisVisible(y, y + height, this.parentMapComponent.y, this.parentMapComponent.y + window.innerHeight)
  }, MapLocalTile.prototype.isAxisVisible = function(minTile, maxTile, minFrame, maxFrame) {
    return maxTile > minFrame && minTile < maxFrame
  }, MapLocalTile.prototype.isCornerVisible = function(x, y) {
    return x > this.parentMapComponent.x && x < this.parentMapComponent.x + window.innerWidth && y > this.parentMapComponent.y && y < this.parentMapComponent.y + window.innerHeight
  }, MapLocalTile.prototype.getVisibleArea = function() {
    var screenX, xPos, visibleWidth, yPos, screenY, visibleHeight, parent = this.parentMapComponent, parentX = parent.x, parentY = parent.y, windowsWidth = window.innerWidth, windowsHeight = window.innerHeight, x = this.x, y = this.y, width = this.size.width, height = this.size.height, x1 = x + width, y1 = y + height;
    return x <= parentX ? (xPos = parentX - x, visibleWidth = x1 - parentX, screenX = 0) : (xPos = 0, visibleWidth = x1 <= parentX + windowsWidth ? width : width - (x1 - (parentX + windowsWidth)), screenX = x - parentX), y <= parentY ? (yPos = parentY - y, visibleHeight = y1 - parentY, screenY = 0) : (yPos = 0, visibleHeight = y1 < parentY + windowsHeight ? height : height - (y1 - (parentY + windowsHeight)), screenY = y - parentY), {
      x: xPos,
      y: yPos,
      width: visibleWidth,
      height: visibleHeight,
      screenX: screenX,
      screenY: screenY
    }
  }, MapLocalTile.prototype.getUpdatedCanvasWithAnimation = function() {
    var localCtx, localCanvas = document.createElement("canvas");
    localCanvas.width = this.size.width, localCanvas.height = this.size.height, localCtx = localCanvas.getContext("2d"), localCtx.drawImage(this.buffer, 0, 0, this.size.width, this.size.height);
    var z, childrenAtZ, childInstanceId, child, sync, frame, children = this.children;
    for (z in children)if (children.hasOwnProperty(z)) {
      childrenAtZ = children[z];
      for (childInstanceId in childrenAtZ)childrenAtZ.hasOwnProperty(childInstanceId) && (sync = !1, child = childrenAtZ[childInstanceId], child.isAnimation ? (frame = child.canDrawNextFrame() ? child.getNextFrame() : child.getCurrentFrame(), this.addImageFrame({
        frame: frame,
        x: child.x,
        y: child.y
      }, localCtx)) : sync = localCtx.drawImage(child.buffer, child.x, child.y), sync = !0)
    }
    return sync || (servicesLog("warn", "Issue in animation synchronization in MapLocalTile"), servicesLog("debug", this)), localCanvas
  }, MapLocalTile
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapPolitical.controller, [xy.dNames.core.controllerCanvas, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, function(CoreControllerCanvas, utilsOop, settingsGameConstant) {
  "use strict";
  function SceneMapPoliticalController(options) {
    SceneMapPoliticalController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.afterDataUpdate
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.afterDataUpdate
    }]
  }

  return utilsOop.extend(SceneMapPoliticalController, CoreControllerCanvas), SceneMapPoliticalController.prototype.start = function() {
    this.registerAllDataListeners(), this[xy.eNames.sceneMapPolitical.moveMapCenterToCoordinates]({ coordinates: this.initialData.coordinates })
  }, SceneMapPoliticalController.prototype[xy.eNames.sceneMapPolitical.moveMapCenterToCoordinates] = function(options) {
    options = options || {}, options.isResize && this.presenter.clearScene(), this.dataSource.getMapData({ mapCenter: options.coordinates })
  }, SceneMapPoliticalController.prototype[xy.eNames.sceneMapPolitical.onMapDataIsPrepared] = function(data) {
    var sync;
    sync = this.presenter.drawMapPoliticalWithData(data), sync && this.presenter.runScene()
  }, SceneMapPoliticalController.prototype[xy.eNames.sceneMapPolitical.onClickOnMap] = function(coordinates) {
    this.notify(xy.eNames.sceneGame.cacheCenterMapCoordinates, coordinates), this.notify(xy.eNames.sceneGame.onNewSceneChoosing, { newSceneMode: settingsGameConstant.SCENE_MODE.MAP })
  }, SceneMapPoliticalController.prototype[xy.eNames.sceneMapPolitical.onMapBoarderReached] = function(coordinates) {
    this[xy.eNames.sceneMapPolitical.moveMapCenterToCoordinates]({ coordinates: coordinates })
  }, SceneMapPoliticalController.prototype[xy.eNames.sceneMapPolitical.onKeyboardMoveMap] = function(options) {
    this.presenter.moveMapBufferByDirectionFromKeyboard(options)
  }, SceneMapPoliticalController.prototype.afterDataUpdate = function() {
    this.presenter.isDrawn && this.dataSource.prepareMapPoliticalDataForDrawing({ isForcedRedraw: !0 })
  }, SceneMapPoliticalController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapPolitical.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.network, function(CoreDataSource, utilsOop, servicesLog, servicesTheme, servicesGameDataManager, servicesNetwork) {
  "use strict";
  function SceneMapPoliticalDataSource(options) {
    SceneMapPoliticalDataSource.__super__.constructor.call(this, options), this.cachedSectors = {}, window[servicesTheme.themeSettings.settings.map.callBackNameMapPolitical] = function(response) {
      var data = response;
      if ("string" == typeof response)try {
        data = JSON.parse(response)
      } catch (Exception) {
        servicesLog("debug", Exception)
      }
      this.mapServerResponseHandler(data)
    }.bind(this)
  }

  return utilsOop.extend(SceneMapPoliticalDataSource, CoreDataSource), SceneMapPoliticalDataSource.prototype.isCached = function(sectorId) {
    return this.cachedSectors.hasOwnProperty(sectorId) && this.cachedSectors[sectorId]
  }, SceneMapPoliticalDataSource.prototype.getMapData = function(options) {
    var minDrawingArea, centralSectorOrigin, sectorSizeInPixel, mapThemeSettings = servicesTheme.themeSettings.settings.map, mapCenterY = options.mapCenter.mapY, mapCenterX = options.mapCenter.mapX, size = mapThemeSettings.tileSector.politicalMapSize, tilePoliticalMap = mapThemeSettings.tilePoliticalMap, leftTopSectorOrigin = {}, bottomRightSectorOrigin = {};
    minDrawingArea = {
      width: window.innerWidth * mapThemeSettings.canvasMapPoliticalRatio | 0,
      height: window.innerHeight * mapThemeSettings.canvasMapPoliticalRatio | 0
    }, centralSectorOrigin = {
      x: mapCenterX - mapCenterX % size,
      y: mapCenterY - mapCenterY % size
    }, sectorSizeInPixel = { width: size * tilePoliticalMap.width, height: size * tilePoliticalMap.height };
    var gapGameX, gapPxX, gapGameY, gapPxY, halfDrawingAreaWidth = minDrawingArea.width / 2, halfDrawingAreaHeight = minDrawingArea.height / 2;
    gapGameX = mapCenterX - centralSectorOrigin.x, gapPxX = gapGameX * tilePoliticalMap.width, leftTopSectorOrigin.x = centralSectorOrigin.x, gapPxX < halfDrawingAreaWidth && (leftTopSectorOrigin.x -= Math.ceil((halfDrawingAreaWidth - gapPxX) / sectorSizeInPixel.width) * size), gapGameX = centralSectorOrigin.x + size - mapCenterX, gapPxX = gapGameX * tilePoliticalMap.width, bottomRightSectorOrigin.x = centralSectorOrigin.x, gapPxX < halfDrawingAreaWidth && (bottomRightSectorOrigin.x += Math.ceil((halfDrawingAreaWidth - gapPxX) / sectorSizeInPixel.width) * size), gapGameY = mapCenterY - centralSectorOrigin.y, gapPxY = gapGameY * tilePoliticalMap.height, leftTopSectorOrigin.y = centralSectorOrigin.y, gapPxY < halfDrawingAreaHeight && (leftTopSectorOrigin.y -= Math.ceil((halfDrawingAreaHeight - gapPxY) / sectorSizeInPixel.height) * size), gapGameY = centralSectorOrigin.y + size - mapCenterY, gapPxY = gapGameY * tilePoliticalMap.height, bottomRightSectorOrigin.y = centralSectorOrigin.y, gapPxY < halfDrawingAreaHeight && (bottomRightSectorOrigin.y += Math.ceil((halfDrawingAreaHeight - gapPxY) / sectorSizeInPixel.height) * size);
    var x, y, widthInSectors, heightInSectors = 0, loadingSectorsId = [];
    for (y = leftTopSectorOrigin.y; y <= bottomRightSectorOrigin.y; y += size)for (heightInSectors += 1, widthInSectors = 0, x = leftTopSectorOrigin.x; x <= bottomRightSectorOrigin.x; x += size)widthInSectors += 1, loadingSectorsId.push(x + "_" + y + "_" + size + "x" + size);
    this.mapSectors = loadingSectorsId, this.mapSize = {
      width: widthInSectors * sectorSizeInPixel.width,
      height: heightInSectors * sectorSizeInPixel.height
    }, this.mapCenter = options.mapCenter || null, this.origin = {
      mapX: leftTopSectorOrigin.x,
      mapY: leftTopSectorOrigin.y
    }, this.resetMap = !0;
    var sectorsToRequest = loadingSectorsId.filter(function(sectorId) {
      return !this.isCached(sectorId)
    }, this);
    sectorsToRequest.length && this.requestMissingSectors(sectorsToRequest), this.prepareMapPoliticalDataForDrawing()
  }, SceneMapPoliticalDataSource.prototype.requestMissingSectors = function(sectorsToRequest) {
    sectorsToRequest.forEach(function(requestedSectorId) {
      servicesNetwork.innerMapRequest({ id: requestedSectorId })
    }, this)
  }, SceneMapPoliticalDataSource.prototype.mapServerResponseHandler = function(data) {
    var redesignHabitatList = [], cachedHabitat = [];
    if (data) {
      data.habitatArray instanceof Array && data.habitatArray.forEach(function(habitatInstance) {
        var rawHabitat = {
          id: habitatInstance.id,
          alliance: habitatInstance.alliance || null,
          publicHabitatType: habitatInstance.publicHabitatType,
          mapX: habitatInstance.mapX,
          mapY: habitatInstance.mapY,
          name: habitatInstance.name || null,
          player: habitatInstance.player,
          points: habitatInstance.points
        };
        redesignHabitatList.push(rawHabitat), cachedHabitat.push(habitatInstance.id)
      }), servicesGameDataManager.habitatsCollection.updateWithHabitatMapResponse(redesignHabitatList, { isPoliticalMapResponse: !0 });
      var matches, sectorOriginX, sectorOriginY, sectorWidth, sectorHeight, sectorId, parsingRegExp = /\{\{(\d{1,7})\,(\d{1,7})\}\,\{(\d{1,7})\,(\d{1,7})\}\}/g;
      matches = parsingRegExp.exec(data.rect), sectorOriginX = +matches[1], sectorOriginY = +matches[2], sectorWidth = +matches[3], sectorHeight = +matches[4], sectorId = sectorOriginX + "_" + sectorOriginY + "_" + sectorWidth + "x" + sectorHeight, this.cachedSectors[sectorId] = {
        frame: {
          origin: {
            mapX: sectorOriginX,
            mapY: sectorOriginY
          }, size: { width: sectorWidth, height: sectorHeight }
        }, habitats: cachedHabitat
      }, this.controller.presenter.isDrawn && this.prepareMapPoliticalDataForDrawing()
    }
  }, SceneMapPoliticalDataSource.prototype.prepareMapPoliticalDataForDrawing = function(options) {
    options = options || {};
    var mapCenter = null, resetMap = this.resetMap || options.isForcedRedraw || null;
    this.mapCenter && (mapCenter = {
      mapX: this.mapCenter.mapX,
      mapY: this.mapCenter.mapY
    }), this.notify(xy.eNames.sceneMapPolitical.onMapDataIsPrepared, {
      sectors: this.cachedSectors,
      mapSectors: this.mapSectors,
      mapSize: this.mapSize,
      origin: this.origin,
      mapCenter: mapCenter,
      resetMap: resetMap
    }), this.resetMap = !1, this.mapCenter = null
  }, SceneMapPoliticalDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapPolitical.presenter, [xy.dNames.core.presenterGraphicEngine, xy.dNames.graphicEngine.mainDirector, xy.dNames.utils.oop, xy.dNames.game.sceneMapPolitical.componentMapBuffer, function(CorePresenterGraphicEngine, graphicEngineMainDirector, utilsOop, SceneMapPoliticalComponentMapBuffer) {
  "use strict";
  function SceneMapPoliticalPresenter(options) {
    SceneMapPoliticalPresenter.__super__.constructor.call(this, options), this.isDrawn = !1, this.mapBuffer = new SceneMapPoliticalComponentMapBuffer, this.mapBuffer.init({ presenter: this }), this.addChild(this.mapBuffer, { z: 0 })
  }

  return utilsOop.extend(SceneMapPoliticalPresenter, CorePresenterGraphicEngine), SceneMapPoliticalPresenter.prototype.drawMapPoliticalWithData = function(data) {
    return this.mapBuffer.update(data), data.mapCenter && (this.localMapCenter = {
      mapX: data.mapCenter.mapX,
      mapY: data.mapCenter.mapY
    }), this.mapBuffer.setMapCenter(this.localMapCenter), !0
  }, SceneMapPoliticalPresenter.prototype.onMapDrawn = function() {
    graphicEngineMainDirector.renew(), this.notify(xy.eNames.sceneGame.onCanvasDrawn)
  }, SceneMapPoliticalPresenter.prototype.onMapMove = function(centerMapGameCoordinates) {
    this.localMapCenter = centerMapGameCoordinates, this.notify(xy.eNames.sceneGame.cacheCenterMapCoordinates, centerMapGameCoordinates), graphicEngineMainDirector.renew()
  }, SceneMapPoliticalPresenter.prototype.moveMapBufferByDirectionFromKeyboard = function(options) {
    this.isDrawn && this.mapBuffer.moveMapByKeyboard(options)
  }, SceneMapPoliticalPresenter.prototype.onMapClick = function(gameCoordinates) {
    gameCoordinates && this.notify(xy.eNames.sceneMapPolitical.onClickOnMap, gameCoordinates)
  }, SceneMapPoliticalPresenter.prototype.onMapBorderReached = function(gameCoordinates) {
    gameCoordinates && this.notify(xy.eNames.sceneMapPolitical.onMapBoarderReached, gameCoordinates)
  }, SceneMapPoliticalPresenter.prototype.runScene = function() {
    this.isDrawn ? graphicEngineMainDirector.renew() : graphicEngineMainDirector.playScene(this)
  }, SceneMapPoliticalPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneMapPolitical.componentMapBuffer, [xy.dNames.core.graphicalEngineMapCanvasBuffer, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, function(CoreGraphicalEngineMapCanvasBuffer, utilsOop, settingsGameConstant, servicesTheme, servicesGameDataManager) {
  "use strict";
  function BufferMapPolitical(options) {
    BufferMapPolitical.__super__.constructor.call(this, options), this.mapThemeSettings = servicesTheme.themeSettings.settings.map, this.tileMap = this.mapThemeSettings.tilePoliticalMap, this.borderOffset = 20, this.drawnSectors = {}
  }

  return utilsOop.extend(BufferMapPolitical, CoreGraphicalEngineMapCanvasBuffer), BufferMapPolitical.prototype.__drawMap = function(data) {
    var bufferCanvas, ctx;
    this.gameCoordinates.origin = data.origin, this.size = data.mapSize, bufferCanvas = this.buffer, bufferCanvas.width = this.size.width, bufferCanvas.height = this.size.height, ctx = bufferCanvas.getContext("2d"), data.resetMap && (this.drawnSectors = {}), ctx.fillStyle = this.tileMap.baseColor, ctx.fillRect(0, 0, this.size.width, this.size.height), this.__drawDistanceRings(), data.mapSectors instanceof Array && data.mapSectors.forEach(function(mapSectorId) {
      var sectorBuffer, mapSector = data.sectors[mapSectorId];
      mapSector && (this.drawnSectors[mapSectorId] || (this.drawnSectors[mapSectorId] = this.__drawBufferMapSector(mapSector)), sectorBuffer = this.drawnSectors[mapSectorId], ctx.drawImage(sectorBuffer.sectorBuffer, sectorBuffer.offsetCoordinatesX, sectorBuffer.offsetCoordinatesY), this.__drawDistanceRings())
    }, this)
  }, BufferMapPolitical.prototype.__drawBufferMapSector = function(mapSector) {
    var hiddenCanvas = document.createElement("canvas"), sectorSize = mapSector.frame.size, xOffsetForOddY = this.tileMap.widthOodOffset, hiddenCanvasWidth = sectorSize.width * this.tileMap.width + xOffsetForOddY, hiddenCanvasHeight = sectorSize.height * this.tileMap.height;
    if (mapSector) {
      hiddenCanvas.width = hiddenCanvasWidth, hiddenCanvas.height = hiddenCanvasHeight;
      var j, habitat, xOffset, x0, y0, baseX0, baseY0, ctx = hiddenCanvas.getContext("2d"), habitatsInSector = mapSector.habitats, lenJ = habitatsInSector.length, tileW = this.tileMap.width, tileH = this.tileMap.height, tileR = this.tileMap.radius, leftTopMapX = mapSector.frame.origin.mapX, leftTopMapY = mapSector.frame.origin.mapY, habitatTypes = settingsGameConstant.HABITAT_TYPE;
      for (j = 0; j < lenJ; j += 1)if (habitat = servicesGameDataManager.habitatsCollection.getHabitatDataForMap(habitatsInSector[j]), xOffset = 0, habitat)switch (habitat.mapY % 2 && (xOffset = xOffsetForOddY), baseX0 = (habitat.mapX - leftTopMapX) * tileW + xOffset, baseY0 = (habitat.mapY - leftTopMapY) * tileH, habitat.isCurrent && (ctx.fillStyle = this.tileMap.habitatColors.currentFrame, x0 = baseX0 + tileW / 2, y0 = baseY0 + tileH / 2, ctx.beginPath(), ctx.arc(x0, y0, tileR, 0, 2 * Math.PI, !1), ctx.fill()), ctx.fillStyle = this.tileMap.habitatColors[habitat.habitatColorType], habitat.habitatType) {
        case habitatTypes.CITY:
          x0 = baseX0, y0 = baseY0, ctx.beginPath(), ctx.moveTo(x0, y0 + tileH), ctx.lineTo(x0 + tileW, y0 + tileH), ctx.lineTo(x0 + tileW / 2, y0), ctx.closePath(), ctx.fill();
          break;
        case habitatTypes.FORTRESS:
          x0 = baseX0 + tileW / 2, y0 = baseY0 + tileH / 2, ctx.beginPath(), ctx.arc(x0, y0, tileR, 0, 2 * Math.PI, !1), ctx.fill();
          break;
        case habitatTypes.CASTLE:
          x0 = baseX0, y0 = baseY0, ctx.fillRect(x0 + 3, y0 + 3, tileW - 6, tileH - 6)
      }
      var bufferOffsetCoordinates = this.convertGameCoordinatesToBufferCoordinates({
        mapX: leftTopMapX,
        mapY: leftTopMapY
      });
      return {
        sectorBuffer: hiddenCanvas,
        offsetCoordinatesX: bufferOffsetCoordinates.x,
        offsetCoordinatesY: bufferOffsetCoordinates.y,
        width: hiddenCanvasWidth,
        height: hiddenCanvasHeight
      }
    }
    return null
  }, BufferMapPolitical.prototype.__drawDebugCoordinates = function(options, ctx) {
    ctx.lineWidth = 1, ctx.strokeStyle = "#FFFFFF", ctx.strokeText(options.mapX, options.x, options.y), ctx.strokeText(options.mapY, options.x, options.y + 12)
  }, BufferMapPolitical.prototype.__drawDistanceRings = function() {
    var offsetFromOriginInTiles, centerX, centerY, lastRing, ringsN, currentHabitatId = servicesGameDataManager.habitatsCollection.currentHabitatId, habitat = servicesGameDataManager.habitatsCollection.getHabitatDataForMap(currentHabitatId), origin = this.gameCoordinates.origin;
    offsetFromOriginInTiles = {
      x: habitat.mapX - origin.mapX,
      y: habitat.mapY - origin.mapY
    }, centerX = offsetFromOriginInTiles.x * this.tileMap.width + this.tileMap.widthOodOffset, centerY = offsetFromOriginInTiles.y * this.tileMap.height + this.tileMap.height / 2, habitat.mapY % 2 && (centerX += this.tileMap.widthOodOffset), ringsN = (habitat.points / 10 | 0) - 1, lastRing = habitat.points % 10 + 10;
    var i;
    for (i = 0; i < ringsN; i += 1)this.__addDistanceRing({
      centerX: centerX,
      centerY: centerY,
      distance: 10 * (i + 1)
    });
    this.__addDistanceRing({ centerX: centerX, centerY: centerY, distance: 10 * ringsN + lastRing, forceRedraw: !0 })
  }, BufferMapPolitical.prototype.__addDistanceRing = function(options) {
    var xLeft, xLeftCenter, xRight, xRightCenter, xDelta, yTop, yBottom, yDelta, ctx = this.buffer.getContext("2d"), centerX = options.centerX, centerY = options.centerY, distance = options.distance, distanceString = distance.toString(), tileW = this.tileMap.width, tileH = this.tileMap.height, textOffset = 10, textOffsetDbld = 20;
    xDelta = distance * tileW | 0, xRight = centerX + xDelta, xRightCenter = centerX + xDelta / 2, xLeft = centerX - xDelta, xLeftCenter = centerX - xDelta / 2, yDelta = distance * tileH | 0, yTop = centerY - yDelta, yBottom = centerY + yDelta, ctx.font = "14px serif", ctx.lineWidth = 1, ctx.strokeStyle = "#FFFFFF", ctx.beginPath(), ctx.moveTo(xRight, centerY), ctx.strokeText(distanceString, xRight + textOffset, centerY), ctx.lineTo(xRightCenter, yTop), ctx.strokeText(distanceString, xRightCenter + textOffset, yTop - textOffset), ctx.lineTo(xLeftCenter, yTop), ctx.strokeText(distanceString, xLeftCenter - textOffset, yTop - textOffset), ctx.lineTo(xLeft, centerY), ctx.strokeText(distanceString, xLeft - textOffsetDbld, centerY), ctx.lineTo(xLeftCenter, yBottom), ctx.strokeText(distanceString, xLeftCenter - textOffsetDbld, yBottom + textOffset), ctx.lineTo(xRightCenter, yBottom), ctx.strokeText(distanceString, xRightCenter + textOffset, yBottom + textOffset), ctx.closePath(), ctx.stroke(), options.forceRedraw && this.presenter.onMapDrawn()
  }, BufferMapPolitical
}]), xy.dStaticInjector.set(xy.dNames.game.sceneHabitat.controller, [xy.dNames.core.controllerCanvas, xy.dNames.utils.oop, function(CoreControllerCanvas, utilsOop) {
  "use strict";
  function SceneHabitatController(options) {
    SceneHabitatController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.afterDataUpdate.bind(this, { keepAnimation: !0 })
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.afterDataUpdate
    }]
  }

  return utilsOop.extend(SceneHabitatController, CoreControllerCanvas), SceneHabitatController.prototype.start = function() {
    this.registerAllDataListeners(), this.prepareDrawingData()
  }, SceneHabitatController.prototype.getBuildingObjectToHighlight = function(buildingClassInstance) {
    return this.presenter.getCenterAndRadiusOfBuildingImage(buildingClassInstance)
  }, SceneHabitatController.prototype[xy.eNames.sceneHabitat.dataIsReady] = function(data) {
    var sync;
    sync = this.presenter.drawHabitatWithData(data), sync && this.presenter.runScene()
  }, SceneHabitatController.prototype.prepareDrawingData = function(options) {
    options = options || {}, options.isResize && this.presenter.clearScene(), this.dataSource.prepareHabitatData(options)
  }, SceneHabitatController.prototype.afterDataUpdate = function(options) {
    options = options || {}, this.presenter.isDrawn && this.dataSource.prepareHabitatData(options)
  }, SceneHabitatController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneHabitat.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.theme, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesTheme, servicesGameDataManager) {
  "use strict";
  function SceneHabitatDataSource(options) {
    SceneHabitatDataSource.__super__.constructor.call(this, options), this.cachedHabitats = {}, this.cachedTiles = {}
  }

  return utilsOop.extend(SceneHabitatDataSource, CoreDataSource), SceneHabitatDataSource.prototype.prepareHabitatData = function(options) {
    options = options || {};
    var data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getHabitat(), buildingsSet = {}, buildingCollection = servicesGameDataManager.buildingsCollection, buildingUnderConstructionSet = buildingCollection.getHabitatBuildingsInUpgradeSet({ habitat: currentHabitat });
    currentHabitat.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var modeledBuilding = buildingCollection.getBuilding({ primaryKey: buildingPK }), classIdentifier = modeledBuilding.classIdentifier;
      buildingsSet[classIdentifier] = {
        classIdentifier: classIdentifier,
        maxLevel: buildingCollection.buildingsMaxLevel[classIdentifier],
        level: modeledBuilding.level,
        isInProgress: buildingUnderConstructionSet[classIdentifier] || !1
      }
    }), data.buildingsSet = buildingsSet, data.currentHabitat = currentHabitat, data.options = options, servicesGameDataManager.sceneHabitatDataLoaded = !0, this.notify(xy.eNames.sceneHabitat.dataIsReady, data)
  }, SceneHabitatDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneHabitat.presenter, [xy.dNames.core.presenterGraphicEngine, xy.dNames.graphicEngine.mainDirector, xy.dNames.utils.oop, xy.dNames.services.eventManager, xy.dNames.game.sceneHabitat.componentHabitatBuffer, function(CorePresenterGraphicEngine, graphicEngineMainDirector, utilsOop, servicesEventManager, SceneMapGameComponentHabitatBuffer) {
  "use strict";
  function SceneHabitatPresenter(options) {
    SceneHabitatPresenter.__super__.constructor.call(this, options), this.isDrawn = !1, this.sceneBuffer = new SceneMapGameComponentHabitatBuffer, this.sceneBuffer.init(this), this.addChild(this.sceneBuffer, { z: 0 })
  }

  return utilsOop.extend(SceneHabitatPresenter, CorePresenterGraphicEngine), SceneHabitatPresenter.prototype.drawHabitatWithData = function(data) {
    return this.sceneBuffer.update(data), !0
  }, SceneHabitatPresenter.prototype.getCenterAndRadiusOfBuildingImage = function(buildingClassIdentifier) {
    var buildingInfo, scaleRatio = this.sceneBuffer.scaleRatio, bufferX = this.sceneBuffer.x, bufferY = this.sceneBuffer.y, offsetBufferX = this.sceneBuffer.nodeOnScreenOffset.x, offsetBufferY = this.sceneBuffer.nodeOnScreenOffset.y;
    return buildingInfo = this.sceneBuffer.buildingOnSceneInfo[buildingClassIdentifier], {
      x: (buildingInfo.x + buildingInfo.width / 2) * scaleRatio - bufferX + offsetBufferX,
      y: (buildingInfo.y + buildingInfo.height / 2) * scaleRatio - bufferY + offsetBufferY,
      r: Math.max(buildingInfo.width / 2, buildingInfo.height / 2) * scaleRatio,
      scaleX: 1,
      scaleY: 1
    }
  }, SceneHabitatPresenter.prototype.onSceneDrawn = function() {
    this.isDrawn && graphicEngineMainDirector.renew()
  }, SceneHabitatPresenter.prototype.onSceneMove = function() {
    this.isDrawn && graphicEngineMainDirector.renew()
  }, SceneHabitatPresenter.prototype.runScene = function() {
    this.isDrawn ? graphicEngineMainDirector.renew() : graphicEngineMainDirector.playScene(this), this.notify(xy.eNames.sceneGame.onCanvasDrawn)
  }, SceneHabitatPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneHabitat.componentHabitatBuffer, [xy.dNames.core.graphicalEngineNode, xy.dNames.core.graphicalEngineAnimation, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.eventManager, function(CoreGraphicalEngineNode, CoreGraphicalEngineAnimation, utilsOop, utilsObject, settingsGameConstant, servicesLog, servicesTheme, servicesEventManager) {
  "use strict";
  function BufferHabitatBackground(options) {
    BufferHabitatBackground.__super__.constructor.call(this, options), this.enableEvents = !0, this.scaleRatio = 1, this.habitatPublicType = 0, this.animationsByBuilding = servicesTheme.themeSettings.sceneHabitat.animationByHabitatType[0], this.animationsDictionary = servicesTheme.themeSettings.sceneHabitat.animations, this.initFramesManager(), this.addImageFrames({
      image: xy.res.habitat0Images,
      frameSetName: "habitat0",
      framesData: xy.res.habitat0Plist
    }), this.addImageFrames({
      image: xy.res.habitat0AnimationImages,
      frameSetName: "animation-habitat0",
      framesData: xy.res.habitat0AnimationPlist
    }), this.addImageFrames({
      image: xy.res.habitat2Images,
      frameSetName: "habitat2",
      framesData: xy.res.habitat2Plist
    }), this.addImageFrames({
      image: xy.res.habitat2AnimationImages,
      frameSetName: "animation-habitat2",
      framesData: xy.res.habitat2AnimationPlist
    }), this.addImageFrames({
      image: xy.res.textureCanvasImages,
      frameSetName: "textures",
      framesData: xy.res.textureCanvasPlist
    }), this.nodeOnScreenOffset = { x: 0, y: 0 }, this.buildingOnSceneInfo = {}
  }

  return utilsOop.extend(BufferHabitatBackground, CoreGraphicalEngineNode), BufferHabitatBackground.prototype.init = function(presenter) {
    this.presenter = presenter, this.__initBufferCanvas()
  }, BufferHabitatBackground.prototype.__initBufferCanvas = function() {
    this.buffer = null, this.bufferScene = document.createElement("canvas")
  }, BufferHabitatBackground.prototype.update = function(data) {
    this.__drawScene(data)
  }, BufferHabitatBackground.prototype.__drawScene = function(data) {
    var sceneCanvas, ctx, sceneRealSize, sceneThemeSettings = servicesTheme.themeSettings.sceneHabitat, habitatPublicType = data.currentHabitat.publicHabitatType, sceneSizeThemeSettings = sceneThemeSettings.sceneSizeByHabitatType[habitatPublicType], paddingThemeSettings = sceneSizeThemeSettings.padding;
    switch (this.children = {}, this.isAnimationVisible = !1, this.habitatPublicType = habitatPublicType, this.animationsByBuilding = servicesTheme.themeSettings.sceneHabitat.animationByHabitatType[habitatPublicType], this.animationsDictionary = servicesTheme.themeSettings.sceneHabitat.animations, habitatPublicType) {
      case 0:
        this.animationFrameSetByCurrentHabitatType = {
          image: xy.res.habitat0AnimationImages,
          frameSetName: "animation-habitat0",
          framesData: xy.res.habitat0AnimationPlist
        };
        break;
      case 2:
        this.animationFrameSetByCurrentHabitatType = {
          image: xy.res.habitat2AnimationImages,
          frameSetName: "animation-habitat2",
          framesData: xy.res.habitat2AnimationPlist
        };
        break;
      default:
        servicesLog("warn", "Unknown habitat type during animations frame set caching")
    }
    sceneRealSize = {
      width: sceneSizeThemeSettings.width,
      height: sceneSizeThemeSettings.height
    }, sceneCanvas = document.createElement("canvas"), sceneCanvas.width = sceneRealSize.width, sceneCanvas.height = sceneRealSize.height, ctx = sceneCanvas.getContext("2d");
    var drawingList = sceneThemeSettings.drawingOrderByHabitatType[habitatPublicType], framesThemeSettings = sceneThemeSettings.frameSettingsByHabitatType[habitatPublicType];
    drawingList.forEach(function(buildingImageKey) {
      var building, frame = framesThemeSettings[buildingImageKey], frameLevel = 0;
      data.buildingsSet.hasOwnProperty(buildingImageKey) ? building = data.buildingsSet[buildingImageKey] : frame.hasOwnProperty("relativeBuildingIdentifier") && data.buildingsSet.hasOwnProperty(frame.relativeBuildingIdentifier) && (building = data.buildingsSet[frame.relativeBuildingIdentifier]), building && frame.frames > 1 && (frameLevel = this.__getFrameLevel({
        buildingLevel: building.level,
        buildingLevelMax: building.maxLevel,
        framesAmount: frame.frames
      })), this.buildingOnSceneInfo[buildingImageKey] = this.addImageFrame({
        imageName: "habitat" + habitatPublicType,
        frameName: frame.key + frameLevel,
        x: frame.x,
        y: frame.y
      }, ctx), building && (building.isInProgress ? this.__addConstructionAnimation({
        buildingImageKey: buildingImageKey,
        habitatPublicType: habitatPublicType,
        buildingLevel: frameLevel,
        ctx: ctx
      }) : (this.__addPermanentAnimation({
        buildingImageKey: buildingImageKey,
        buildingLevel: frameLevel,
        habitatPublicType: habitatPublicType
      }), this.__addRandomAnimation({
        buildingImageKey: buildingImageKey,
        buildingLevel: frameLevel,
        habitatPublicType: habitatPublicType
      })))
    }, this);
    var sceneScaledSize, winHeight = window.innerHeight, winWidth = window.innerWidth, availableHeight = winHeight - (paddingThemeSettings.top + paddingThemeSettings.bottom), availableWidth = winWidth, scaleThresholdMax = sceneThemeSettings.scaleThresholdMax, scaleThresholdMin = sceneThemeSettings.scaleThresholdMin, scaleRatio = 1;
    this.nodeOnScreenOffset = {
      x: 0,
      y: 0
    }, availableHeight > sceneRealSize.height ? (scaleRatio = availableHeight / sceneRealSize.height, scaleRatio > scaleThresholdMax && (scaleRatio = scaleThresholdMax)) : availableHeight < sceneRealSize.height && (scaleRatio = availableHeight / sceneRealSize.height, scaleRatio < scaleThresholdMin && (scaleRatio = scaleThresholdMin)), this.scaleRatio = scaleRatio, sceneScaledSize = {
      width: sceneRealSize.width * scaleRatio | 0,
      height: sceneRealSize.height * scaleRatio | 0
    };
    var size = { width: 0 | sceneScaledSize.width, height: 0 | sceneScaledSize.height };
    availableHeight > size.height && (this.nodeOnScreenOffset.y = .5 * (availableHeight - size.height) | 0, size.height = availableHeight), this.nodeOnScreenOffset.y += paddingThemeSettings.top, size.height += paddingThemeSettings.top + paddingThemeSettings.bottom, availableWidth > size.width && (this.nodeOnScreenOffset.x = .5 * (availableWidth - size.width) | 0, size.width = availableWidth);
    var bufferCanvas, bufferCtx;
    this.size = size, bufferCanvas = this.bufferScene, bufferCanvas.width = this.size.width, bufferCanvas.height = this.size.height, bufferCtx = bufferCanvas.getContext("2d");
    var backgroundTexture, backgroundPattern;
    backgroundTexture = this.getImageFromFrame({
      imageName: "textures",
      frameName: "Texture_Habitat_Pergament"
    }), backgroundPattern = ctx.createPattern(backgroundTexture, "repeat"), bufferCtx.fillStyle = backgroundPattern, bufferCtx.fillRect(0, 0, this.size.width, this.size.height), bufferCtx.drawImage(sceneCanvas, 0, 0, sceneRealSize.width, sceneRealSize.height, this.nodeOnScreenOffset.x, this.nodeOnScreenOffset.y, sceneScaledSize.width, sceneScaledSize.height), (0 === this.x || 0 === this.y || data.options && data.options.isResize) && (this.x = sceneScaledSize.width <= availableWidth ? 0 : parseInt((sceneScaledSize.width - availableWidth) / 2), this.y = sceneScaledSize.height <= availableHeight ? 0 : parseInt((sceneScaledSize.height - availableHeight) / 2))
  }, BufferHabitatBackground.prototype.__addConstructionAnimation = function(options) {
    var constructionSiteName, constructionSiteSettings, buildingAnimationSettings = this.animationsByBuilding[options.buildingImageKey];
    try {
      constructionSiteName = buildingAnimationSettings.constructionSite, constructionSiteSettings = this.animationsDictionary[constructionSiteName], constructionSiteSettings && this.addImageFrame({
        imageName: "animation-habitat" + options.habitatPublicType,
        frameName: constructionSiteSettings.frameName,
        x: constructionSiteSettings.x,
        y: constructionSiteSettings.y
      }, options.ctx), buildingAnimationSettings.constructionAnimation && (utilsObject.isPlainObject(buildingAnimationSettings.constructionAnimation) ? this.addBuildingAnimationAsAnimatedChild(buildingAnimationSettings.constructionAnimation[options.buildingLevel]) : this.addBuildingAnimationAsAnimatedChild(buildingAnimationSettings.constructionAnimation))
    } catch (eX) {
      servicesLog("warn", "Can not add construction animation"), servicesLog("debug", eX)
    }
  }, BufferHabitatBackground.prototype.__addPermanentAnimation = function(options) {
    var buildingAnimationList;
    try {
      buildingAnimationList = this.animationsByBuilding[options.buildingImageKey].permanent[options.buildingLevel], buildingAnimationList && buildingAnimationList.forEach(this.addBuildingAnimationAsAnimatedChild, this)
    } catch (eX) {
      servicesLog("warn", "Can not add permanent animation for " + options.buildingImageKey), servicesLog("debug", eX)
    }
  }, BufferHabitatBackground.prototype.__addRandomAnimation = function(options) {
    var buildingAnimationList, randThreshold = settingsGameConstant.ANIMATION_BUILDING_POSSIBILITY;
    try {
      buildingAnimationList = this.animationsByBuilding[options.buildingImageKey].random[options.buildingLevel], buildingAnimationList && buildingAnimationList.forEach(function(buildingAnimation) {
        var rand = Math.random();
        rand <= randThreshold && this.addBuildingAnimationAsAnimatedChild(buildingAnimation)
      }, this)
    } catch (eX) {
      servicesLog("warn", "Can not add random animation for " + options.buildingImageKey), servicesLog("debug", eX)
    }
  }, BufferHabitatBackground.prototype.addBuildingAnimationAsAnimatedChild = function(animationName) {
    var buildingAnimation, animationSettings = this.animationsDictionary[animationName] || null;
    animationSettings && (buildingAnimation = new CoreGraphicalEngineAnimation, buildingAnimation.init(), buildingAnimation.setFrameSet(this.animationFrameSetByCurrentHabitatType), buildingAnimation.setFrames({
      name: animationSettings.frameName,
      initialFrame: animationSettings.initialFrame,
      framesLength: animationSettings.framesLength,
      animationSettings: animationSettings
    }), buildingAnimation.setPosition(animationSettings.x, animationSettings.y), this.addChild(buildingAnimation, { z: 0 }), this.isAnimationVisible = !0, buildingAnimation.parent = this)
  }, BufferHabitatBackground.prototype.__drawDebugClickArea = function(drawingList, ctx) {
    var habitatPublicType = this.habitatPublicType, sceneThemeSettings = servicesTheme.themeSettings.sceneHabitat, clickAreaCoordinates = sceneThemeSettings.buildingClickAreaByHabitatType[habitatPublicType];
    ctx.fillStyle = "rgba(255, 255, 255, 0.5)", drawingList.forEach(function(buildingImageKey) {
      if (clickAreaCoordinates.hasOwnProperty(buildingImageKey)) {
        var i, x, y, list = clickAreaCoordinates[buildingImageKey], len = list.length;
        for (ctx.beginPath(), x = list[0], y = list[1], ctx.moveTo(x, y), i = 2; i < len; i += 2)x = list[i], y = list[i + 1], ctx.lineTo(x, y);
        ctx.closePath(), ctx.fill()
      }
    }, this)
  }, BufferHabitatBackground.prototype.isClickOnBuilding = function(pointCoordinates) {
    var buildingKey, testPolygon, habitatPublicType = this.habitatPublicType, sceneThemeSettings = servicesTheme.themeSettings.sceneHabitat, clickAreaCoordinates = sceneThemeSettings.buildingClickAreaByHabitatType[habitatPublicType];
    testPolygon = function(pointX, pointY, coordinates) {
      var i, iX, iY, len = coordinates.length, jX = len - 2, jY = len - 1, oddNodes = !1;
      for (i = 0; i < len; i += 2)iX = i, iY = i + 1, (coordinates[iY] < pointY && coordinates[jY] >= pointY || coordinates[jY] < pointY && coordinates[iY] >= pointY) && (coordinates[iX] <= pointX || coordinates[jX] <= pointX) && (oddNodes ^= coordinates[iX] + (pointY - coordinates[iY]) / (coordinates[jY] - coordinates[iY]) * (coordinates[jX] - coordinates[iX]) < pointX), jX = iX, jY = iY;
      return oddNodes
    };
    var adjustedX = pointCoordinates.x / this.scaleRatio | 0, adjustedY = pointCoordinates.y / this.scaleRatio | 0;
    for (buildingKey in clickAreaCoordinates)if (clickAreaCoordinates.hasOwnProperty(buildingKey) && testPolygon(adjustedX, adjustedY, clickAreaCoordinates[buildingKey]))return buildingKey;
    return !1
  }, BufferHabitatBackground.prototype.__getFrameLevel = function(options) {
    var interval = options.buildingLevelMax / (options.framesAmount - 1);
    return Math.floor(options.buildingLevel / interval)
  }, BufferHabitatBackground.prototype.removeEvents = function() {
    this.eventInitialized = !1
  }, BufferHabitatBackground.prototype.initEvents = function(target) {
    target.addEventListener("mousedown", this.__mouseMouseDownEventHandler.bind(this)), target.addEventListener("mouseup", this.__mouseMouseUpEventHandler.bind(this)), target.addEventListener("mouseleave", this.__mouseMouseLeaveEventHandler.bind(this)), target.addEventListener("mousemove", this.__mouseMouseMoveEventHandler.bind(this)), target.addEventListener("touchstart", this.__touchDownEventHandler.bind(this)), target.addEventListener("touchend", this.__mouseMouseUpEventHandler.bind(this)), target.addEventListener("touchleave", this.__mouseMouseLeaveEventHandler.bind(this)), target.addEventListener("touchcancel", this.__mouseMouseLeaveEventHandler.bind(this)), target.addEventListener("touchmove", this.__touchMoveEventHandler.bind(this))
  }, BufferHabitatBackground.prototype.__mouseMouseDownEventHandler = function(e) {
    this.mouseDown = !0, this.lastSceenX = e.screenX, this.lastSceenY = e.screenY
  }, BufferHabitatBackground.prototype.__touchDownEventHandler = function(e) {
    this.mouseDown = !0;
    var touchEvent = e.targetTouches[0];
    this.lastSceenX = touchEvent.screenX, this.lastSceenY = touchEvent.screenY
  }, BufferHabitatBackground.prototype.__mouseMouseLeaveEventHandler = function() {
    this.mouseDown = !1, this.draging = !1
  }, BufferHabitatBackground.prototype.__mouseMouseUpEventHandler = function(e) {
    if (this.mouseDown || e.isTutorialFake)if (this.mouseDown = !1, this.draging)this.draging = !1; else {
      var building, mouseX = e.clientX, mouseY = e.clientY;
      building = this.isClickOnBuilding(this.convertScreenCoordinatesToNodeCoordinates({
        x: mouseX,
        y: mouseY
      })), building && servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.habitatSceneClickOnBuilding, { classIdentifier: building })
    }
  }, BufferHabitatBackground.prototype.__touchMoveEventHandler = function(e) {
    var x, y, xMax, yMax;
    if (this.mouseDown) {
      this.draging = !0, e.preventDefault();
      var touchEvent = e.targetTouches[0], screenX = touchEvent.screenX, screenY = touchEvent.screenY, movementX = touchEvent.screenX - (this.lastSceenX || screenX), movementY = touchEvent.screenY - (this.lastSceenY || screenY);
      x = this.x - movementX, y = this.y - movementY, this.lastSceenX = screenX, this.lastSceenY = screenY, xMax = this.size.width - window.innerWidth, yMax = this.size.height - window.innerHeight, x > 0 && x < xMax && (this.x = x), y > 0 && y < yMax && (this.y = y), this.presenter.onSceneMove()
    }
  }, BufferHabitatBackground.prototype.__mouseMouseMoveEventHandler = function(e) {
    var x, y, xMax, yMax;
    if (this.mouseDown) {
      this.draging = !0;
      var movementX = e.movementX || e.screenX - this.lastSceenX, movementY = e.movementY || e.screenY - this.lastSceenY;
      x = this.x - movementX, y = this.y - movementY, this.lastSceenX = e.screenX, this.lastSceenY = e.screenY, xMax = this.size.width - window.innerWidth, yMax = this.size.height - window.innerHeight, x > 0 && x < xMax && (this.x = x), y > 0 && y < yMax && (this.y = y), this.presenter.onSceneMove()
    }
  }, BufferHabitatBackground.prototype.render = function(options) {
    var ctx = options.context, width = options.width, height = options.height, image = this.bufferScene;
    if (width > this.size.width && (width = this.size.width), height > this.size.height && (height = this.size.height), ctx.drawImage(image, this.x, this.y, width, height, 0, 0, width, height), this.isAnimationVisible) {
      var z, childrenAtZ, childInstanceId, child, frame, children = this.children;
      for (z in children)if (children.hasOwnProperty(z)) {
        childrenAtZ = children[z];
        for (childInstanceId in childrenAtZ)childrenAtZ.hasOwnProperty(childInstanceId) && (child = childrenAtZ[childInstanceId], child.isAnimation ? (frame = child.canDrawNextFrame() ? child.getNextFrame() : child.getCurrentFrame(), this.addImageFrame({
          frame: frame,
          x: child.x,
          y: child.y,
          scaleRatio: this.scaleRatio,
          offsetX: this.nodeOnScreenOffset.x - this.x,
          offsetY: this.nodeOnScreenOffset.y - this.y
        }, ctx)) : ctx.drawImage(child.buffer, child.x + this.nodeOnScreenOffset.x, child.y + this.nodeOnScreenOffset.y))
      }
    }
    return !0
  }, BufferHabitatBackground
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementGlobalOverview, xy.dNames.settings.gameConstant, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementGlobalOverview, settingsGameConstant, utilsOop, servicesInternationalization) {
  "use strict";
  function SceneGlobalUnitOverviewController(options) {
    var menuBuildingOverviewController = gameInstance.injector.get(xy.dNames.game.menuBuildingOverview.controller), menuUnitDefendersLocalController = gameInstance.injector.get(xy.dNames.game.menuUnitsDefendersLocal.controller), menuTransitOverviewController = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.controller), menuUnitAttackersExternalController = gameInstance.injector.get(xy.dNames.game.menuUnitsAttackersExternal.controller);
    this.forLinking = [{
      resourceClass: menuBuildingOverviewController,
      methodName: xy.eNames.menuBuildingOverview.missionSpeedUp
    }, {
      resourceClass: menuBuildingOverviewController,
      methodName: xy.eNames.menuBuildingOverview.missionCancel
    }, {
      resourceClass: menuUnitDefendersLocalController,
      methodName: xy.eNames.menuUnitDefenderLocal.sendUnitsBack
    }, {
      resourceClass: menuTransitOverviewController,
      methodName: xy.eNames.menuTransitOverview.speedUpTransit
    }, {
      resourceClass: menuUnitAttackersExternalController,
      methodName: xy.eNames.menuUnitAttackersExternal.recallUnits
    }], SceneGlobalUnitOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.habitatsSorted,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }, {
      entity: xy.eNames.dataListeners.dataEntity.transitsCache,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }], this.currentTabMode = settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.LOCAL_DEFENDERS, this.currentGroupingModeByTab = {}, this.localizedName = servicesInternationalization.localize("Troop overview"), this.currentGroupingModeByTab[settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.EXTERNAL_DEFENDERS] = settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET, this.currentGroupingModeByTab[settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.IN_TRANSIT] = settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET, this.currentGroupingModeByTab[settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.MY_TROOPS_IN_ATTACK] = settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET, this.currentGroupingModeByTab[settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.OFFENDERS] = settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET
  }

  return utilsOop.extend(SceneGlobalUnitOverviewController, CoreControllerElementGlobalOverview), SceneGlobalUnitOverviewController.prototype.prepareDataForDraw = function() {
    this.dataSource.prepareGlobalUnitOverviewData({
      currentTabMode: this.currentTabMode,
      currentGroupingModeByTab: this.currentGroupingModeByTab[this.currentTabMode]
    })
  }, SceneGlobalUnitOverviewController.prototype[xy.eNames.eventSceneGlobalUnitOverview.tableIsLoaded] = function() {
    this[xy.eNames.eventSceneGlobalOverview.releasePendingMode]()
  }, SceneGlobalUnitOverviewController.prototype[xy.eNames.eventSceneGlobalUnitOverview.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, SceneGlobalUnitOverviewController.prototype[xy.eNames.eventSceneGlobalUnitOverview.switchCurrentTab] = function(options) {
    this.currentTabMode = options.newTabMode, this.requestPendingMode()
  }, SceneGlobalUnitOverviewController.prototype[xy.eNames.eventSceneGlobalUnitOverview.switchGroupingDirection] = function(options) {
    this.currentGroupingModeByTab[this.currentTabMode] = options.newGroupingDirection, this.requestPendingMode()
  }, SceneGlobalUnitOverviewController.prototype[xy.eNames.eventSceneGlobalUnitOverview.sendForeignerDefendersBack] = function(options) {
    this[xy.eNames.menuUnitDefenderLocal.sendUnitsBack](options)
  }, SceneGlobalUnitOverviewController.prototype[xy.eNames.eventSceneGlobalUnitOverview.callAttackersBack] = function(options) {
    this[xy.eNames.menuUnitAttackersExternal.recallUnits](options)
  }, SceneGlobalUnitOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, xy.dNames.services.groupable, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesLog, servicesTheme, servicesGameDataManager, servicesSortable, servicesGroupable) {
  "use strict";
  function SceneGlobalUnitOverviewDataSource(options) {
    var menuBuildingOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuBuildingOverview.dataSource), menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource), menuUnitDefendersLocalDataSource = gameInstance.injector.get(xy.dNames.game.menuUnitsDefendersLocal.dataSource), menuUnitAttackersExternalDataSource = gameInstance.injector.get(xy.dNames.game.menuUnitsAttackersExternal.dataSource);
    this.forLinking = [{
      resourceClass: menuUnitDefendersLocalDataSource,
      methodName: "sendUnitsBackToOriginHabitat"
    }, {
      resourceClass: menuUnitAttackersExternalDataSource,
      methodName: "recallUnitsFromWar"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransitResponse"
    }, {
      resourceClass: menuBuildingOverviewDataSource,
      methodName: "missionSpeedUp"
    }, {
      resourceClass: menuBuildingOverviewDataSource,
      methodName: "missionCancel"
    }], SceneGlobalUnitOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGlobalUnitOverviewDataSource, CoreDataSource), SceneGlobalUnitOverviewDataSource.prototype.prepareGlobalUnitOverviewData = function(options) {
    options = options || {};
    var activeTabButton = options.currentTabMode, data = {
      availableHabitatTypes: servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(),
      activeTabButton: activeTabButton,
      currentGroupingModeByTab: options.currentGroupingModeByTab
    };
    switch (activeTabButton) {
      case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.LOCAL_DEFENDERS:
        this.prepareDefendingData(data);
        break;
      case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.EXTERNAL_DEFENDERS:
        this.prepareExternalDefendingData(data);
        break;
      case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.IN_TRANSIT:
        !servicesGameDataManager.transitsCollection.isAllTransitCached() && servicesGameDataManager.transitsCollection.isPartialTransitMode() ? this.requestAllTransitData(data) : this.prepareInTransitData(data);
        break;
      case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.ON_MISSION:
        this.prepareMissionsData(data);
        break;
      case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.MY_TROOPS_IN_ATTACK:
        this.prepareMyAttackersData(data);
        break;
      case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.OFFENDERS:
        this.prepareMeUnderAttackerData(data);
        break;
      default:
        servicesLog("warn", "Unknown tab mode for global unit overview"), this.prepareDefendingData(data)
    }
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareDefendingData = function(data) {
    var unitsDictionary = servicesGameDataManager.unitsCollection.units, headerList = [], habitatsList = [], unitsGlobalSummary = {}, battleType = {}, extendableHabitats = [], maximumRowsAmount = 0;
    Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      unitsGlobalSummary[unitPrimaryKey] = 0
    }), battleType[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0;
    var habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList();
    habitatIds.forEach(function(id) {
      var allDefenders, iterationHabitat = servicesGameDataManager.habitatsCollection.getHabitatModel(id), hasExternalDefenders = !1, unitsHabitatSummary = {}, subHabitats = [];
      if (iterationHabitat.localHabitatUnitArray && iterationHabitat.localHabitatUnitArray.length && (allDefenders = servicesGameDataManager.unitsCollection.getDefendersUnits({ habitatUnitArray: iterationHabitat.localHabitatUnitArray }), allDefenders.forEach(function(unitObject) {
                var unitKey = unitObject.unit.primaryKey, unitAmount = unitObject.amount;
                unitsGlobalSummary[unitKey] = unitAmount + (unitsGlobalSummary[unitKey] || 0), unitsHabitatSummary[unitKey] = unitAmount + (unitsHabitatSummary[unitKey] || 0)
              }), allDefenders.length)) {
        if (hasExternalDefenders = servicesGameDataManager.unitsCollection.doesHabitatHasExternalDefendersUnits(iterationHabitat.localHabitatUnitArray)) {
          extendableHabitats.push(id);
          var ownLocalUnitsObject = {}, ownLocalUnitsList = servicesGameDataManager.unitsCollection.getOwnDefendersUnits({ habitatUnitArray: iterationHabitat.localHabitatUnitArray });
          ownLocalUnitsList.forEach(function(unitObject) {
            var unitKey = unitObject.unit.primaryKey, unitAmount = unitObject.amount;
            ownLocalUnitsObject[unitKey] = unitAmount
          }), subHabitats.push({
            isSelf: !0,
            habitatModel: iterationHabitat,
            unitsHabitatSummary: ownLocalUnitsObject
          });
          var otherHabitatUnitsObject = servicesGameDataManager.unitsCollection.getGroupedUnitsByHabitat({
            habitatUnitArray: iterationHabitat.localHabitatUnitArray,
            battleTypes: battleType,
            groupingField: "sourceHabitat"
          });
          otherHabitatUnitsObject.groups.forEach(function(group, index) {
            var otherLocalUnitsObject = {};
            group.forEach(function(huObject) {
              otherLocalUnitsObject[huObject.habitatUnit.unitId] = huObject.habitatUnit.amount
            }), subHabitats.push({
              isSelf: !1,
              habitatModel: servicesGameDataManager.habitatsCollection.getHabitatModel(otherHabitatUnitsObject.groupsKeys[index]),
              unitsHabitatSummary: otherLocalUnitsObject
            })
          })
        }
        maximumRowsAmount += 1 + subHabitats.length, habitatsList.push({
          habitatModel: iterationHabitat,
          unitsHabitatSummary: unitsHabitatSummary,
          hasUnits: !0,
          hasSubHabitatsRows: hasExternalDefenders,
          subHabitats: subHabitats
        })
      }
    }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      headerList.push({
        unit: unitsDictionary[unitPrimaryKey],
        primaryKey: unitPrimaryKey,
        amount: unitsGlobalSummary[unitPrimaryKey]
      })
    }), headerList.sort(servicesSortable.byField("unit", "order")), data.habitatsList = habitatsList, data.header = headerList, data.extendableHabitats = extendableHabitats, data.extendableHabitatsLength = extendableHabitats.length, data.isExpandAllButtonVisible = maximumRowsAmount < settingsGameConstant.TABLE.ROWS_LIMIT || !1, this.notify(xy.eNames.eventSceneGlobalUnitOverview.dataIsReady, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareExternalDefendingData = function(data) {
    var habitatUnitIdsList = [], habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), battleType = {};
    battleType[settingsGameConstant.BATTLE_TYPE.OWN_HABITAT] = !0, battleType[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0, habitatIds.forEach(function(habitatId) {
      var habitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(habitatId);
      habitatModel.remoteHabitatUnitArray && habitatModel.remoteHabitatUnitArray.length && habitatModel.remoteHabitatUnitArray.forEach(function(habitatUnitId) {
        habitatUnitIdsList.push(habitatUnitId)
      })
    });
    var groupingField, otherHabitatField;
    switch (data.currentGroupingModeByTab) {
      case settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET:
        groupingField = "habitat", otherHabitatField = "sourceHabitat";
        break;
      case settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET:
        groupingField = "sourceHabitat", otherHabitatField = "habitat";
        break;
      default:
        servicesLog("warn", "Unknown grouping direction for in transit tab, global unit overview"), servicesLog("debug", Object.assign({}, data))
    }
    this.prepareGeneralUnitGlobalOverviewData({
      habitatUnitIdsList: habitatUnitIdsList,
      groupingField: groupingField,
      otherHabitatField: otherHabitatField,
      showResources: !1,
      isSendUnitsBackAvailable: !0,
      battleType: battleType,
      isAttackTab: !1
    }, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareInTransitData = function(data) {
    var groupingField, otherHabitatField;
    switch (data.currentGroupingModeByTab) {
      case settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET:
        groupingField = "destinationHabitat", otherHabitatField = "groupingSourceHabitat";
        break;
      case settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET:
        groupingField = "groupingSourceHabitat", otherHabitatField = "destinationHabitat";
        break;
      default:
        servicesLog("warn", "Unknown grouping direction for in transit tab, global unit overview"), servicesLog("debug", Object.assign({}, data))
    }
    var transitsIdDictionary = {}, transitsIdsList = [], habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList();
    habitatIds.forEach(function(habitatId) {
      var habitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(habitatId);
      habitatModel.habitatTransitArray && habitatModel.habitatTransitArray.length && habitatModel.habitatTransitArray.forEach(function(transitId) {
        transitsIdDictionary[transitId] = !0
      })
    }), Object.keys(transitsIdDictionary).forEach(function(transitId) {
      transitsIdsList.push(transitId)
    });
    var unitsDictionary = servicesGameDataManager.unitsCollection.units, transportableResourcesDictionary = servicesTheme.themeSettings.resources.transitPossibleResources, groupedTransits = servicesGameDataManager.transitsCollection.getAllTransitsGroupedBy({ groupingField: groupingField }), headerList = [], habitatsList = [], unitsGlobalSummary = {}, resourcesGlobalSummary = {}, extendableHabitats = [], maximumRowsAmount = 0;
    Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      unitsGlobalSummary[unitPrimaryKey] = 0
    }), transportableResourcesDictionary.forEach(function(resourcePrimaryKey) {
      resourcesGlobalSummary[resourcePrimaryKey] = 0
    }), groupedTransits.groupsKeys.forEach(function(habitatId, index) {
      var habitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(habitatId), unitsHabitatSummary = {}, resourcesHabitatSummary = {}, subTransits = [];
      extendableHabitats.push(habitatId), groupedTransits.groups[index].forEach(function(transitModel) {
        var unitsTransitSummary = transitModel.unitDictionary || {}, resourcesTransitSummary = transitModel.resourceDictionary || {}, otherHabitat = servicesGameDataManager.habitatsCollection.getHabitatModel(transitModel[otherHabitatField] || transitModel[groupingField]);
        Object.keys(unitsTransitSummary).forEach(function(unitPrimaryKey) {
          unitsGlobalSummary[unitPrimaryKey] += unitsTransitSummary[unitPrimaryKey], unitsHabitatSummary[unitPrimaryKey] = unitsTransitSummary[unitPrimaryKey] + (unitsHabitatSummary[unitPrimaryKey] || 0)
        }), Object.keys(resourcesTransitSummary).forEach(function(resourcePrimaryKey) {
          resourcesGlobalSummary[resourcePrimaryKey] += resourcesTransitSummary[resourcePrimaryKey], resourcesHabitatSummary[resourcePrimaryKey] = resourcesTransitSummary[resourcePrimaryKey] + (resourcesHabitatSummary[resourcePrimaryKey] || 0)
        }), subTransits.push({
          transitModel: transitModel,
          unitsTransitSummary: unitsTransitSummary,
          resourcesTransitSummary: resourcesTransitSummary,
          habitatTitle: otherHabitat.name
        })
      }), maximumRowsAmount += 1 + subTransits.length, habitatsList.push({
        habitatModel: habitatModel,
        unitsHabitatSummary: unitsHabitatSummary,
        resourcesHabitatSummary: resourcesHabitatSummary,
        hasSubRows: !0,
        subTransits: subTransits
      })
    }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      headerList.push({
        unit: unitsDictionary[unitPrimaryKey],
        primaryKey: unitPrimaryKey,
        amount: unitsGlobalSummary[unitPrimaryKey]
      })
    }), headerList.sort(servicesSortable.byField("unit", "order")), transportableResourcesDictionary.forEach(function(resourcePrimaryKey) {
      headerList.push({ primaryKey: resourcePrimaryKey, amount: resourcesGlobalSummary[resourcePrimaryKey] })
    }), data.habitatsList = habitatsList, data.header = headerList, data.extendableHabitats = extendableHabitats, data.extendableHabitatsLength = extendableHabitats.length, data.isExpandAllButtonVisible = maximumRowsAmount < settingsGameConstant.TABLE.ROWS_LIMIT || !1, this.notify(xy.eNames.eventSceneGlobalUnitOverview.dataIsReady, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareMissionsData = function(data) {
    var unitsDictionary = servicesGameDataManager.unitsCollection.units, headerList = [], habitatsList = [], extendableHabitats = [], maximumRowsAmount = 0, unitsGlobalSummary = {};
    Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      unitsGlobalSummary[unitPrimaryKey] = 0;
    });
    var habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList();
    habitatIds.forEach(function(id) {
      var iterationHabitat = servicesGameDataManager.habitatsCollection.getHabitatModel(id), activeMissions = [], unitsHabitatSummary = {}, resourcesHabitatSummary = {};
      iterationHabitat.habitatMissionArray.length && (extendableHabitats.push(id), iterationHabitat.habitatMissionArray.forEach(function(missionInProgressId) {
        var modeledMissionInProgress = servicesGameDataManager.missionsCollection.getMissionInProgress(missionInProgressId), modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: modeledMissionInProgress.missionId });
        Object.keys(modeledMission.unitConsumption).forEach(function(unitKey) {
          var unitAmount = modeledMission.unitConsumption[unitKey];
          unitsGlobalSummary[unitKey] += unitAmount, unitsHabitatSummary[unitKey] = unitAmount + (unitsHabitatSummary[unitKey] || 0)
        }), activeMissions.push({ mission: modeledMission, missionInProgress: modeledMissionInProgress })
      }), activeMissions.sort(servicesSortable.byField("mission", "order")), maximumRowsAmount += 1 + activeMissions.length, habitatsList.push({
        habitatModel: iterationHabitat,
        hasMission: !0,
        unitsHabitatSummary: unitsHabitatSummary,
        resourcesHabitatSummary: resourcesHabitatSummary,
        missions: activeMissions
      }))
    }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      headerList.push({
        unit: unitsDictionary[unitPrimaryKey],
        primaryKey: unitPrimaryKey,
        amount: unitsGlobalSummary[unitPrimaryKey]
      })
    }), headerList.sort(servicesSortable.byField("unit", "order")), data.habitatsList = habitatsList, data.header = headerList, data.extendableHabitats = extendableHabitats, data.extendableHabitatsLength = extendableHabitats.length, data.isExpandAllButtonVisible = maximumRowsAmount < settingsGameConstant.TABLE.ROWS_LIMIT || !1, this.notify(xy.eNames.eventSceneGlobalUnitOverview.dataIsReady, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareMyAttackersData = function(data) {
    var habitatUnitIdsList = [], habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), battleType = {};
    battleType[settingsGameConstant.BATTLE_TYPE.ATTACKER] = !0, habitatIds.forEach(function(habitatId) {
      var habitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(habitatId);
      habitatModel.remoteHabitatUnitArray && habitatModel.remoteHabitatUnitArray.length && habitatModel.remoteHabitatUnitArray.forEach(function(habitatUnitId) {
        habitatUnitIdsList.push(habitatUnitId)
      })
    });
    var groupingField, otherHabitatField;
    switch (data.currentGroupingModeByTab) {
      case settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET:
        groupingField = "habitat", otherHabitatField = "sourceHabitat";
        break;
      case settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET:
        groupingField = "sourceHabitat", otherHabitatField = "habitat";
        break;
      default:
        servicesLog("warn", "Unknown grouping direction for in transit tab, global unit overview"), servicesLog("debug", Object.assign({}, data))
    }
    this.prepareGeneralUnitGlobalOverviewData({
      habitatUnitIdsList: habitatUnitIdsList,
      groupingField: groupingField,
      otherHabitatField: otherHabitatField,
      showResources: !0,
      isSendUnitsBackAvailable: !0,
      battleType: battleType,
      isAttackTab: !0
    }, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareMeUnderAttackerData = function(data) {
    var habitatUnitIdsList = [], habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), battleType = {};
    battleType[settingsGameConstant.BATTLE_TYPE.ATTACKER] = !0, habitatIds.forEach(function(habitatId) {
      var habitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArray && habitatModel.localHabitatUnitArray.length && habitatModel.localHabitatUnitArray.forEach(function(habitatUnitId) {
        habitatUnitIdsList.push(habitatUnitId)
      })
    });
    var groupingField, otherHabitatField;
    switch (data.currentGroupingModeByTab) {
      case settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET:
        groupingField = "habitat", otherHabitatField = "sourceHabitat";
        break;
      case settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET:
        groupingField = "sourceHabitat", otherHabitatField = "habitat";
        break;
      default:
        servicesLog("warn", "Unknown grouping direction for in transit tab, global unit overview"), servicesLog("debug", Object.assign({}, data))
    }
    this.prepareGeneralUnitGlobalOverviewData({
      habitatUnitIdsList: habitatUnitIdsList,
      groupingField: groupingField,
      otherHabitatField: otherHabitatField,
      showResources: !1,
      isSendUnitsBackAvailable: !1,
      battleType: battleType,
      isAttackTab: !0
    }, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.prepareGeneralUnitGlobalOverviewData = function(options, data) {
    var groupedHabitatUnits, habitatUnitIdsList = options.habitatUnitIdsList, groupingField = options.groupingField, otherHabitatField = options.otherHabitatField, playerModel = servicesGameDataManager.playersCollection.getPlayer(), unitsDictionary = servicesGameDataManager.unitsCollection.units, conquestResourcePrimaryKey = servicesTheme.themeSettings.resources.conquestResourceId, combineConquestResourceAmountAtSubHabitat = data.currentGroupingModeByTab === settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET, combineConquestResourcesAmountOnTopLevel = data.currentGroupingModeByTab === settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET, headerList = [], habitatsList = [], unitsGlobalSummary = {}, resourcesGlobalSummary = playerModel.getAmountOfSentConquerResources(), extendableHabitats = [], battleType = options.battleType, maximumRowsAmount = 0;
    groupedHabitatUnits = servicesGameDataManager.unitsCollection.getAllHabitatUnitsGroupedBy({
      groupingField: groupingField,
      habitatUnitsIdsList: habitatUnitIdsList,
      battleType: battleType
    }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      unitsGlobalSummary[unitPrimaryKey] = 0
    }), groupedHabitatUnits.groupsKeys.forEach(function(habitatId, index) {
      var habitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(habitatId), habitatUnitsModelList = groupedHabitatUnits.groups[index], unitsHabitatSummary = {}, resourcesHabitatSummary = 0;
      extendableHabitats.push(habitatId);
      var groupedSubHabitatUnits, subHabitats = [];
      groupedSubHabitatUnits = servicesGroupable.byField(habitatUnitsModelList, {
        field: otherHabitatField,
        sortWithinGroups: !1
      }), combineConquestResourcesAmountOnTopLevel && (resourcesHabitatSummary = playerModel.amountOfSentConquerResourcesToHabitat(habitatId)), groupedSubHabitatUnits.groupsKeys.forEach(function(subHabitatId, subIndex) {
        var subHabitatModel = servicesGameDataManager.habitatsCollection.getHabitatModel(subHabitatId), subHabitatUnitsModelList = groupedSubHabitatUnits.groups[subIndex], subUnitsHabitatSummary = {}, subResourcesHabitatSummary = 0;
        combineConquestResourceAmountAtSubHabitat && (subResourcesHabitatSummary = playerModel.amountOfSentConquerResourcesToHabitat(subHabitatId)), subHabitatUnitsModelList.forEach(function(habitatUnitModel) {
          var unitPrimaryKey = habitatUnitModel.unitId, unitAmount = habitatUnitModel.amount;
          unitsGlobalSummary[unitPrimaryKey] += unitAmount, unitsHabitatSummary[unitPrimaryKey] = unitAmount + (unitsHabitatSummary[unitPrimaryKey] || 0), subUnitsHabitatSummary[unitPrimaryKey] = unitAmount + (subUnitsHabitatSummary[unitPrimaryKey] || 0)
        }), subHabitats.push({
          habitatModel: subHabitatModel,
          unitsHabitatSummary: subUnitsHabitatSummary,
          resourcesHabitatSummary: subResourcesHabitatSummary
        })
      }), maximumRowsAmount += 1 + subHabitats.length, habitatsList.push({
        habitatModel: habitatModel,
        unitsHabitatSummary: unitsHabitatSummary,
        resourcesHabitatSummary: resourcesHabitatSummary,
        hasSubRows: !0,
        subHabitats: subHabitats
      })
    }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      headerList.push({
        unit: unitsDictionary[unitPrimaryKey],
        primaryKey: unitPrimaryKey,
        amount: unitsGlobalSummary[unitPrimaryKey]
      })
    }), headerList.sort(servicesSortable.byField("unit", "order")), headerList.push({
      primaryKey: conquestResourcePrimaryKey,
      amount: resourcesGlobalSummary
    }), data.habitatsList = habitatsList, data.header = headerList, data.extendableHabitats = extendableHabitats, data.extendableHabitatsLength = extendableHabitats.length, data.showResources = options.showResources || !1, data.isSendUnitsBackAvailable = options.isSendUnitsBackAvailable || !1, data.isAttackTab = options.isAttackTab || !1, data.isExpandAllButtonVisible = maximumRowsAmount < settingsGameConstant.TABLE.ROWS_LIMIT || !1, this.notify(xy.eNames.eventSceneGlobalUnitOverview.dataIsReady, data)
  }, SceneGlobalUnitOverviewDataSource.prototype.requestAllTransitData = function(options) {
    this.notify(xy.eNames.eventSceneGlobalOverview.releasePendingMode), this.request({}, "HabitatAction/allVisibleTransits", { callBack: this.onAllTransitDataReceived.bind(this, options) })
  }, SceneGlobalUnitOverviewDataSource.prototype.onAllTransitDataReceived = function(options, data) {
    var playerData = data.Data || {};
    servicesGameDataManager.transitsCollection.globalUpdateAllTransits(playerData.Transit || []), servicesGameDataManager.updateHabitatsData(playerData.Habitat, { isPeripheral: !0 }), servicesGameDataManager.updatePlayersData(playerData.Player, { isPeripheral: !0 }), servicesGameDataManager.updateAlliancesData(playerData.Alliance, { isPeripheral: !0 }), servicesGameDataManager.updateHabitatsUnits(playerData.HabitatUnit)
  }, SceneGlobalUnitOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.presenter, [xy.dNames.componentsEngine, xy.dNames.core.presenterElementGlobalOverview, xy.dNames.utils.oop, xy.dNames.game.sceneGlobalUnitOverview.component, function(componentsEngine, CorePresenterElementGlobalOverview, utilsOop, SceneGlobalUnitOverviewComponent) {
  "use strict";
  function SceneGlobalUnitOverviewPresenter(options) {
    SceneGlobalUnitOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGlobalUnitOverviewPresenter, CorePresenterElementGlobalOverview), SceneGlobalUnitOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = { localizedTitle: this.controller.localizedName };
    componentsEngine.render(React.createElement(SceneGlobalUnitOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data || {}
    }), document.getElementById(xy.DomElements.gameGlobalOverview))
  }, SceneGlobalUnitOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuSearchBarHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuTapBar, xy.dNames.components.menuSearchBar, xy.dNames.game.sceneGlobalUnitOverview.componentTableDefending, xy.dNames.game.sceneGlobalUnitOverview.componentTableTransits, xy.dNames.game.sceneGlobalUnitOverview.componentTableMissions, xy.dNames.game.sceneGlobalUnitOverview.componentTableGeneralCase, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers, settingsGameConstant, servicesTheme, servicesLog, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuTapBar, ComponentsMenuSearchBar, SceneGlobalUnitOverviewComponentTableDefending, SceneGlobalUnitOverviewComponentTableTransits, SceneGlobalUnitOverviewComponentTableMissions, SceneGlobalUnitOverviewComponentTableGeneralCase) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers],
    getInitialState: function() {
      var publicHabitatTypeFilter = {};
      return publicHabitatTypeFilter[settingsGameConstant] = !0, {
        searchQueryString: "",
        publicHabitatTypeFilter: publicHabitatTypeFilter,
        showIcon: !0
      }
    },
    componentDidUpdate: function() {
      this.dataRepresented()
    },
    componentDidMount: function() {
      this.dataRepresented()
    },
    dataRepresented: function() {
      this.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.tableIsLoaded)
    },
    onTabButtonClick: function(btnIndex) {
      this.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.switchCurrentTab, { newTabMode: btnIndex })
    },
    onTargetInDirectionGroupingButtonClick: function() {
      this.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.switchGroupingDirection, { newGroupingDirection: settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET })
    },
    onTargetOutDirectionGroupingButtonClick: function() {
      this.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.switchGroupingDirection, { newGroupingDirection: settingsGameConstant.GROUPING_DIRECTION_MODE.OUT_TARGET })
    },
    render: function() {
      var settings = {
        initialComponent: this,
        header: [],
        habitatsList: [],
        activeTabButton: null,
        extendableHabitatsLength: 0
      };
      Object.assign(settings, this.props.settings);
      var habitats = [], themeIconSettings = servicesTheme.themeSettings.imagesClassNames, globalUnitOverviewIcons = themeIconSettings.globalUnitOverview, titleSettings = {
        title: this.props.settingsTitle.localizedTitle,
        leftButton: [],
        rightButton: [{
          icon: "controls jump-to-top-button",
          onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.GLOBAL_OVERVIEW.CONTAINER)
        }]
      }, tapBarSettings = { buttons: habitats }, activeSortingButton = settings.activeTabButton;
      Object.keys(settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE).forEach(function(tabButtonKey) {
        var tabIndex = settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE[tabButtonKey], lSettings = { icon: globalUnitOverviewIcons["topBar-" + tabIndex] };
        activeSortingButton === tabIndex ? (lSettings.ref = "first-in-list", lSettings.index = this.renderIndex, lSettings.isActive = !0) : lSettings.onClick = this.onTabButtonClick.bind(this, tabIndex), tapBarSettings.buttons.push(lSettings)
      }, this);
      var searchBarSettings = {
        value: this.state.searchQueryString,
        onChange: this.updateSearchQuery,
        onFocus: this.onSearchFieldFocus,
        onBlur: this.onSearchFieldBlur
      };
      this.state.showIcon && (searchBarSettings.iconLeft = "controls menu-search");
      var newHabitatList, searchFilter = this.state.searchQueryString ? this.state.searchQueryString.toLowerCase() : null;
      searchFilter && (newHabitatList = settings.habitatsList.filter(function(habitatObject) {
        return !!~habitatObject.habitatModel.name.toLowerCase().indexOf(searchFilter)
      }), settings.habitatsList = newHabitatList);
      var menuSectionContentSettings, content = [];
      switch (settings.activeTabButton) {
        case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.LOCAL_DEFENDERS:
          content.push(React.createElement(SceneGlobalUnitOverviewComponentTableDefending, {
            settings: settings,
            key: "defending-tab"
          }));
          break;
        case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.EXTERNAL_DEFENDERS:
          content.push(React.createElement(SceneGlobalUnitOverviewComponentTableGeneralCase, {
            settings: settings,
            key: "external-defending-tab"
          }));
          break;
        case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.IN_TRANSIT:
          content.push(React.createElement(SceneGlobalUnitOverviewComponentTableTransits, {
            settings: settings,
            key: "in-transit-tab"
          }));
          break;
        case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.ON_MISSION:
          content.push(React.createElement(SceneGlobalUnitOverviewComponentTableMissions, {
            settings: settings,
            presenter: this.props.presenter,
            key: "on-mission-tab"
          }));
          break;
        case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.MY_TROOPS_IN_ATTACK:
          content.push(React.createElement(SceneGlobalUnitOverviewComponentTableGeneralCase, {
            settings: settings,
            key: "on-player-attack"
          }));
          break;
        case settingsGameConstant.GLOBAL_UNIT_OVERVIEW_MODE.OFFENDERS:
          content.push(React.createElement(SceneGlobalUnitOverviewComponentTableGeneralCase, {
            settings: settings,
            key: "player-under-attack"
          }));
          break;
        default:
          servicesLog("warn", "Unknown tab mode for global unit overview"), content.push(React.createElement(SceneGlobalUnitOverviewComponentTableDefending, {
            settings: settings,
            key: "default-tab"
          }))
      }
      menuSectionContentSettings = { content: content, classes: "global-unit-overview" };
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: React.createElement(ComponentsMenuSearchBar, { settings: searchBarSettings }),
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.GLOBAL_OVERVIEW.CONTAINER
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.componentTableDefending, [xy.dNames.componentsEngine, xy.dNames.mixins.tableToggleAllHandler, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.tabular, xy.dNames.components.habitatTabularCell, xy.dNames.components.toggleAllTabularHeader, xy.dNames.components.unitIconAmount, xy.dNames.components.inputTextTabularCell, xy.dNames.components.menuListElementButtonAction, function(componentEngine, mixinsTableToggleAllHandler, servicesTheme, servicesInternationalization, ComponentTabular, ComponentsHabitatTabularCell, ComponentsToggleAllTabularHeader, ComponentsUnitIconAmount, ComponentsInputTextTabularCell, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsTableToggleAllHandler],
    unitToSendBack: {},
    getInitialState: function() {
      return this.prepareInitialData()
    },
    prepareInitialData: function() {
      return this.unitToSendBack = {}, { extendedHabitats: {} }
    },
    onRendered: function() {
      this.props.settings.initialComponent.onRendered.call(this.props.settings.initialComponent)
    },
    onSendUnitsBackClick: function(sourceHabitat, destinationHabitat) {
      var originalThis = this.props.settings.initialComponent, habitatId = destinationHabitat.id;
      originalThis.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.sendForeignerDefendersBack, {
        habitatId: habitatId,
        sourceHabitat: sourceHabitat,
        destinationHabitat: destinationHabitat,
        units: this.unitToSendBack[habitatId]
      })
    },
    onChangeUnitAmountToSendBack: function(habitatId, unitPk, newValue) {
      newValue = +newValue, this.unitToSendBack[habitatId][unitPk] = newValue
    },
    render: function() {
      var settings = {
        initialComponent: null,
        header: [],
        habitatsList: [],
        extendableHabitats: [],
        extendableHabitatsLength: 0,
        isExpandAllButtonVisible: !1
      };
      Object.assign(settings, this.props.settings);
      var themeIconSettings = servicesTheme.themeSettings.imagesClassNames, globalUnitOverviewIcons = themeIconSettings.globalUnitOverview, rows = [], componentTableSetting = {
        classes: "table--global-overview table--global-overview--units--defending",
        header: [],
        rows: [],
        emptyText: servicesInternationalization.localize("There are currently no defenders")
      };
      settings.habitatsList.forEach(function(listObject) {
        var iterationRow = [], habitat = listObject.habitatModel, isExtended = this.state.extendedHabitats[habitat.id] || !1, habitatElementSettings = {
          onExtendClick: this.onExtendClick.bind(this, habitat.id),
          isExtendable: listObject.hasSubHabitatsRows,
          isExtended: isExtended && listObject.hasSubHabitatsRows,
          habitat: habitat
        };
        iterationRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: habitatElementSettings }) }), settings.header.forEach(function(headerUnitObject) {
          iterationRow.push({ value: listObject.unitsHabitatSummary[headerUnitObject.primaryKey] || "" })
        }), rows.push({
          isExtendable: listObject.hasSubHabitatsRows,
          cells: iterationRow
        }), isExtended && listObject.subHabitats.length && listObject.subHabitats.forEach(function(subHabitatObject) {
          var actionButtonSettings, iterationSubRow = [], subHabitat = subHabitatObject.habitatModel, subHabitatId = subHabitat.id, actionButtons = [];
          subHabitatObject.isSelf || (actionButtonSettings = {
            icon: globalUnitOverviewIcons.sendUnitsBackButton,
            onClick: this.onSendUnitsBackClick.bind(this, habitat, subHabitat)
          }, actionButtons.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: actionButtonSettings })));
          var habitatElementSettings = { isSubHabitat: !0, habitat: subHabitat, actionButtons: actionButtons };
          iterationSubRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: habitatElementSettings }) }), subHabitatObject.isSelf ? settings.header.forEach(function(headerUnitObject) {
            iterationSubRow.push({ value: subHabitatObject.unitsHabitatSummary[headerUnitObject.primaryKey] || "" })
          }) : (this.unitToSendBack[subHabitatId] = {}, settings.header.forEach(function(headerUnitObject) {
            var cell, inputCellSettings, unitPk = headerUnitObject.primaryKey, unitsAmount = subHabitatObject.unitsHabitatSummary[unitPk];
            unitsAmount ? (this.unitToSendBack[subHabitatId][unitPk] = unitsAmount, inputCellSettings = {
              classes: "",
              title: unitsAmount,
              maxValue: unitsAmount,
              value: unitsAmount,
              handlerOnChange: this.onChangeUnitAmountToSendBack.bind(this, subHabitatId, unitPk)
            }, cell = React.createElement(ComponentsInputTextTabularCell, { settings: inputCellSettings })) : cell = "", iterationSubRow.push({ value: cell })
          }, this)), rows.push({ isExtendable: !1, isExtended: !0, cells: iterationSubRow })
        }, this)
      }, this), componentTableSetting.rows = rows;
      var headerCells = [], headerFirstCellSettings = {
        initialComponent: this,
        extendableHabitatsLength: settings.extendableHabitatsLength
      }, firstCellValues = [];
      return settings.isExpandAllButtonVisible && firstCellValues.push(React.createElement(ComponentsToggleAllTabularHeader, {
        settings: headerFirstCellSettings,
        key: "toggle-section-buttons"
      })), headerCells.push({
        classes: "tabular-header-th-cell ",
        value: firstCellValues
      }), settings.header.forEach(function(headerUnitObject) {
        var headerCellsSettings = {
          icon: headerUnitObject.unit.icon,
          amount: headerUnitObject.amount,
          classes: "dark"
        };
        headerCells.push({ value: React.createElement(ComponentsUnitIconAmount, { settings: headerCellsSettings }) })
      }), componentTableSetting.header = {
        classes: "global-overview--table--header ",
        cells: headerCells
      }, React.createElement(ComponentTabular, { settings: componentTableSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.componentTableMissions, [xy.dNames.componentsEngine, xy.dNames.mixins.tableToggleAllHandler, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.tabular, xy.dNames.components.toggleAllTabularHeader, xy.dNames.components.habitatTabularCell, xy.dNames.components.unitIconAmount, xy.dNames.components.missionTabularCell, function(componentEngine, mixinsTableToggleAllHandler, servicesTheme, servicesInternationalization, ComponentTabular, ComponentsToggleAllTabularHeader, ComponentsHabitatTabularCell, ComponentsUnitIconAmount, ComponentsMissionTabularCell) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsTableToggleAllHandler], getInitialState: function() {
      return { extendedHabitats: {} }
    }, onRendered: function() {
      this.props.settings.initialComponent.onRendered.call(this.props.settings.initialComponent)
    }, onMissionSpeedUpClick: function(options) {
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.missionSpeedUp, options)
    }, onMissionCancelClick: function(options) {
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.missionCancel, options)
    }, render: function() {
      var settings = {
        initialComponent: null,
        header: [],
        habitatsList: [],
        extendableHabitats: [],
        extendableHabitatsLength: 0,
        isExpandAllButtonVisible: !1
      };
      Object.assign(settings, this.props.settings);
      var rows = [], componentTableSetting = {
        classes: "table--global-overview table--global-overview--units--missions",
        header: [],
        rows: [],
        emptyText: servicesInternationalization.localize("There are currently no active missions")
      };
      settings.habitatsList.forEach(function(listObject) {
        var iterationRow = [], habitat = listObject.habitatModel, isExtended = this.state.extendedHabitats[habitat.id] || !1, habitatElementSettings = {
          onExtendClick: this.onExtendClick.bind(this, habitat.id),
          isExtendable: !0,
          isExtended: isExtended,
          habitat: habitat
        };
        iterationRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: habitatElementSettings }) }), settings.header.forEach(function(headerUnitObject) {
          iterationRow.push({ value: listObject.unitsHabitatSummary[headerUnitObject.primaryKey] || "" })
        }), rows.push({
          isExtendable: !isExtended,
          cells: iterationRow
        }), isExtended && listObject.missions.forEach(function(missionObject) {
          var iterationMissionRow = [], mission = missionObject.mission, missionElementSettings = {
            initialComponent: this,
            habitat: habitat,
            mission: mission,
            missionInProgress: missionObject.missionInProgress,
            activated: !0
          };
          iterationMissionRow.push({ value: React.createElement(ComponentsMissionTabularCell, { settings: missionElementSettings }) }), settings.header.forEach(function(headerUnitObject) {
            iterationMissionRow.push({ value: mission.unitConsumption[headerUnitObject.primaryKey] || "" })
          }), rows.push({ isExtendable: !1, isExtended: !0, cells: iterationMissionRow })
        }, this)
      }, this), componentTableSetting.rows = rows;
      var headerCells = [], headerFirstCellSettings = {
        initialComponent: this,
        extendableHabitatsLength: settings.extendableHabitatsLength
      }, firstCellValues = [];
      return settings.isExpandAllButtonVisible && firstCellValues.push(React.createElement(ComponentsToggleAllTabularHeader, {
        settings: headerFirstCellSettings,
        key: "toggle-section-buttons"
      })), headerCells.push({
        classes: "tabular-header-th-cell ",
        value: firstCellValues
      }), settings.header.forEach(function(headerUnitObject) {
        var headerCellsSettings = {
          icon: headerUnitObject.unit.icon,
          amount: headerUnitObject.amount,
          classes: "dark"
        };
        headerCells.push({ value: React.createElement(ComponentsUnitIconAmount, { settings: headerCellsSettings }) })
      }), componentTableSetting.header = {
        classes: "global-overview--table--header ",
        cells: headerCells
      }, React.createElement(ComponentTabular, { settings: componentTableSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.componentTableTransits, [xy.dNames.componentsEngine, xy.dNames.mixins.tableToggleAllHandler, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.tabular, xy.dNames.components.habitatTabularCell, xy.dNames.components.toggleAllTabularHeader, xy.dNames.components.changeGroupingDirectionTabularHeader, xy.dNames.components.unitIconAmount, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.transitTabularCell, xy.dNames.components.resourceIconAmount, function(componentEngine, mixinsTableToggleAllHandler, servicesTheme, servicesInternationalization, ComponentTabular, ComponentsHabitatTabularCell, ComponentsToggleAllTabularHeader, ComponentsChangeGroupingDirectionTabularHeader, ComponentsUnitIconAmount, ComponentsMenuListElementButtonAction, ComponentsTransitTabularCell, ComponentsResourceIconAmount) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsTableToggleAllHandler],
    unitToSendBack: {},
    getInitialState: function() {
      return this.prepareInitialData()
    },
    prepareInitialData: function() {
      return this.unitToSendBack = {}, { extendedHabitats: {} }
    },
    onRendered: function() {
      this.props.settings.initialComponent.onRendered.call(this.props.settings.initialComponent)
    },
    onSendOwnUnitsBackHomeClick: function(sourceHabitat, destinationHabitat) {
      var originalThis = this.props.settings.initialComponent, habitatId = sourceHabitat.id;
      originalThis.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.sendForeignerDefendersBack, {
        habitatId: habitatId,
        sourceHabitat: sourceHabitat,
        destinationHabitat: destinationHabitat,
        units: this.unitToSendBack[habitatId]
      })
    },
    onChangeUnitAmountToSendBack: function(habitatId, unitPk, newValue) {
      newValue = +newValue, this.unitToSendBack[habitatId][unitPk] = newValue
    },
    render: function() {
      var settings = {
        initialComponent: null,
        header: [],
        habitatsList: [],
        extendableHabitats: [],
        extendableHabitatsLength: 0,
        isExpandAllButtonVisible: !1
      };
      Object.assign(settings, this.props.settings);
      var originalThis = settings.initialComponent, themeIconSettings = servicesTheme.themeSettings.imagesClassNames, resourcesIcons = themeIconSettings.resources, rows = (themeIconSettings.globalUnitOverview, []), componentTableSetting = {
        classes: "table--global-overview table--global-overview--units--defending",
        header: [],
        rows: [],
        emptyText: servicesInternationalization.localize("There are currently no transits")
      };
      settings.habitatsList.forEach(function(listObject) {
        var iterationRow = [], habitat = listObject.habitatModel, isExtended = this.state.extendedHabitats[habitat.id] || !1, habitatElementSettings = {
          onExtendClick: this.onExtendClick.bind(this, habitat.id),
          isExtendable: listObject.hasSubRows,
          isExtended: isExtended && listObject.hasSubRows,
          habitat: habitat
        };
        iterationRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: habitatElementSettings }) }), settings.header.forEach(function(headerObject) {
          var value;
          value = headerObject.unit ? listObject.unitsHabitatSummary[headerObject.primaryKey] || "" : listObject.resourcesHabitatSummary[headerObject.primaryKey] || "", iterationRow.push({ value: value })
        }), rows.push({
          isExtendable: listObject.hasSubRows,
          cells: iterationRow
        }), isExtended && listObject.subTransits.length && listObject.subTransits.forEach(function(subTransitObject) {
          var transitSubRow = [], transitElementSettings = {
            initialComponent: settings.initialComponent,
            currentHabitatId: habitat.id,
            transitModel: subTransitObject.transitModel,
            habitatTitle: subTransitObject.habitatTitle
          };
          transitSubRow.push({ value: React.createElement(ComponentsTransitTabularCell, { settings: transitElementSettings }) }), settings.header.forEach(function(headerObject) {
            var value;
            value = headerObject.unit ? subTransitObject.unitsTransitSummary[headerObject.primaryKey] || "" : subTransitObject.resourcesTransitSummary[headerObject.primaryKey] || "", transitSubRow.push({ value: value })
          }), rows.push({ isExtendable: !1, isExtended: !0, cells: transitSubRow })
        }, this)
      }, this), componentTableSetting.rows = rows;
      var headerCells = [], headerToggleSettings = {
        initialComponent: this,
        extendableHabitatsLength: settings.extendableHabitatsLength
      }, headerSwitchDirectionSettings = {
        initialComponent: originalThis,
        activeDirection: settings.currentGroupingModeByTab
      }, firstCellValues = [];
      return settings.isExpandAllButtonVisible && firstCellValues.push(React.createElement(ComponentsToggleAllTabularHeader, {
        settings: headerToggleSettings,
        key: "toggle-section-buttons"
      })), firstCellValues.push(React.createElement(ComponentsChangeGroupingDirectionTabularHeader, {
        settings: headerSwitchDirectionSettings,
        key: "grouping-direction"
      })), headerCells.push({
        classes: "tabular-header-th-cell ",
        value: firstCellValues
      }), settings.header.forEach(function(headerObject) {
        var headerCellsSettings = { amount: headerObject.amount, classes: "dark", showFill: !1 };
        headerObject.unit ? (headerCellsSettings.icon = headerObject.unit.icon, headerCells.push({ value: React.createElement(ComponentsUnitIconAmount, { settings: headerCellsSettings }) })) : (headerCellsSettings.icon = resourcesIcons[headerObject.primaryKey], headerCells.push({ value: React.createElement(ComponentsResourceIconAmount, { settings: headerCellsSettings }) }))
      }), componentTableSetting.header = {
        classes: "global-overview--table--header ",
        cells: headerCells
      }, React.createElement(ComponentTabular, { settings: componentTableSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalUnitOverview.componentTableGeneralCase, [xy.dNames.componentsEngine, xy.dNames.mixins.tableToggleAllHandler, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.tabular, xy.dNames.components.habitatTabularCell, xy.dNames.components.toggleAllTabularHeader, xy.dNames.components.changeGroupingDirectionTabularHeader, xy.dNames.components.unitIconAmount, xy.dNames.components.inputTextTabularCell, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.transitTabularCell, xy.dNames.components.resourceIconAmount, function(componentEngine, mixinsTableToggleAllHandler, settingsGameConstant, servicesTheme, servicesInternationalization, ComponentTabular, ComponentsHabitatTabularCell, ComponentsToggleAllTabularHeader, ComponentsChangeGroupingDirectionTabularHeader, ComponentsUnitIconAmount, ComponentsInputTextTabularCell, ComponentsMenuListElementButtonAction, ComponentsTransitTabularCell, ComponentsResourceIconAmount) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsTableToggleAllHandler], unitToSendBack: {}, getInitialState: function() {
      return this.prepareInitialData()
    }, prepareInitialData: function() {
      return this.unitToSendBack = {}, { extendedHabitats: {} }
    }, onRendered: function() {
      this.props.settings.initialComponent.onRendered.call(this.props.settings.initialComponent)
    }, onSendOwnDefendersUnitsBackHomeClick: function(sourceHabitat, destinationHabitat) {
      var originalThis = this.props.settings.initialComponent, habitatId = sourceHabitat.id;
      originalThis.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.sendForeignerDefendersBack, {
        habitatId: habitatId,
        sourceHabitat: sourceHabitat,
        destinationHabitat: destinationHabitat,
        units: this.unitToSendBack[habitatId]
      })
    }, onCallOwnAttackersUnitsBackHomeClick: function(sourceHabitat, destinationHabitat) {
      var originalThis = this.props.settings.initialComponent, habitatId = sourceHabitat.id;
      originalThis.props.presenter.notify(xy.eNames.eventSceneGlobalUnitOverview.callAttackersBack, {
        habitatId: habitatId,
        sourceHabitat: sourceHabitat,
        destinationHabitat: destinationHabitat,
        units: this.unitToSendBack[habitatId]
      })
    }, onChangeUnitAmountToSendBack: function(habitatId, unitPk, newValue) {
      newValue = +newValue, this.unitToSendBack[habitatId][unitPk] = newValue
    }, render: function() {
      var settings = {
        initialComponent: null,
        currentGroupingModeByTab: null,
        header: [],
        habitatsList: [],
        extendableHabitats: [],
        extendableHabitatsLength: 0,
        showResources: !1,
        isSendUnitsBackAvailable: !1,
        isAttackTab: !1,
        isExpandAllButtonVisible: !1
      };
      Object.assign(settings, this.props.settings);
      var originalThis = settings.initialComponent, themeIconSettings = servicesTheme.themeSettings.imagesClassNames, resourcesIcons = themeIconSettings.resources, globalUnitOverviewIcons = themeIconSettings.globalUnitOverview, rows = [], componentTableSetting = {
        classes: "table--global-overview table--global-overview--units--defending",
        header: [],
        rows: [],
        emptyText: servicesInternationalization.localize("There are currently no units to show")
      };
      settings.habitatsList.forEach(function(listObject) {
        var iterationRow = [], habitat = listObject.habitatModel, isExtended = this.state.extendedHabitats[habitat.id] || !1, habitatElementSettings = {
          onExtendClick: this.onExtendClick.bind(this, habitat.id),
          isExtendable: listObject.hasSubRows,
          isExtended: isExtended && listObject.hasSubRows,
          habitat: habitat
        };
        iterationRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: habitatElementSettings }) }), settings.header.forEach(function(headerObject) {
          var value;
          if (headerObject.unit)value = listObject.unitsHabitatSummary[headerObject.primaryKey] || ""; else {
            if (!settings.showResources)return;
            value = listObject.resourcesHabitatSummary || ""
          }
          iterationRow.push({ value: value })
        }), rows.push({
          isExtendable: listObject.hasSubRows,
          cells: iterationRow
        }), isExtended && listObject.subHabitats.length && listObject.subHabitats.forEach(function(subHabitatObject) {
          var sourceHabitat, destinationHabitat, transitSubRow = [];
          settings.currentGroupingModeByTab === settingsGameConstant.GROUPING_DIRECTION_MODE.IN_TARGET ? (sourceHabitat = habitat, destinationHabitat = subHabitatObject.habitatModel) : (sourceHabitat = subHabitatObject.habitatModel, destinationHabitat = habitat);
          var subHabitatSettings, actionButtonSettings, actionButtons = [];
          settings.isSendUnitsBackAvailable && (actionButtonSettings = settings.isAttackTab ? {
            icon: globalUnitOverviewIcons.recallAttackerUnitsBackButton,
            onClick: this.onCallOwnAttackersUnitsBackHomeClick.bind(this, sourceHabitat, destinationHabitat)
          } : {
            icon: globalUnitOverviewIcons.sendUnitsBackButton,
            onClick: this.onSendOwnDefendersUnitsBackHomeClick.bind(this, sourceHabitat, destinationHabitat)
          }, actionButtons.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: actionButtonSettings }))), subHabitatSettings = {
            isSubHabitat: !0,
            habitat: subHabitatObject.habitatModel,
            actionButtons: actionButtons
          }, transitSubRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: subHabitatSettings }) }), this.unitToSendBack[sourceHabitat.id] = {}, settings.header.forEach(function(headerObject) {
            var value, unitsAmount, inputCellSettings, unitPrimaryKey = headerObject.primaryKey;
            if (headerObject.unit)unitsAmount = subHabitatObject.unitsHabitatSummary[unitPrimaryKey] || "", unitsAmount ? settings.isSendUnitsBackAvailable ? (this.unitToSendBack[sourceHabitat.id][unitPrimaryKey] = unitsAmount, inputCellSettings = {
              classes: "",
              title: unitsAmount,
              maxValue: unitsAmount,
              value: unitsAmount,
              handlerOnChange: this.onChangeUnitAmountToSendBack.bind(this, sourceHabitat.id, unitPrimaryKey)
            }, value = React.createElement(ComponentsInputTextTabularCell, { settings: inputCellSettings })) : value = unitsAmount : value = ""; else {
              if (!settings.showResources)return;
              value = subHabitatObject.resourcesHabitatSummary || ""
            }
            transitSubRow.push({ value: value })
          }, this), rows.push({ isExtendable: !1, isExtended: !0, cells: transitSubRow })
        }, this)
      }, this), componentTableSetting.rows = rows;
      var headerCells = [], headerToggleSettings = {
        initialComponent: this,
        extendableHabitatsLength: settings.extendableHabitatsLength
      }, headerSwitchDirectionSettings = {
        initialComponent: originalThis,
        activeDirection: settings.currentGroupingModeByTab
      }, firstCellValues = [];
      return settings.isExpandAllButtonVisible && firstCellValues.push(React.createElement(ComponentsToggleAllTabularHeader, {
        settings: headerToggleSettings,
        key: "toggle-section-buttons"
      })), firstCellValues.push(React.createElement(ComponentsChangeGroupingDirectionTabularHeader, {
        settings: headerSwitchDirectionSettings,
        key: "grouping-direction"
      })), headerCells.push({
        classes: "tabular-header-th-cell ",
        value: firstCellValues
      }), settings.header.forEach(function(headerObject) {
        var headerCellsSettings = { amount: headerObject.amount, classes: "dark", showFill: !1 };
        headerObject.unit ? (headerCellsSettings.icon = headerObject.unit.icon, headerCells.push({ value: React.createElement(ComponentsUnitIconAmount, { settings: headerCellsSettings }) })) : settings.showResources && (headerCellsSettings.icon = resourcesIcons[headerObject.primaryKey], headerCells.push({ value: React.createElement(ComponentsResourceIconAmount, { settings: headerCellsSettings }) }))
      }), componentTableSetting.header = {
        classes: "global-overview--table--header ",
        cells: headerCells
      }, React.createElement(ComponentTabular, { settings: componentTableSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalBuildingOverview.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementGlobalOverview, xy.dNames.settings.gameConstant, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(gameInstance, CoreControllerElementGlobalOverview, settingsGameConstant, utilsOop, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  function SceneGlobalBuildingOverviewController(options) {
    var menuBuildingsListController = gameInstance.injector.get(xy.dNames.game.menuBuildingsList.controller);
    this.forLinking = [{
      resourceClass: menuBuildingsListController,
      methodName: xy.eNames.menuBuildingsList.upgradeBuilding
    }, {
      resourceClass: menuBuildingsListController,
      methodName: xy.eNames.menuBuildingsList.speedUpUpgrade
    }, {
      resourceClass: menuBuildingsListController,
      methodName: xy.eNames.menuBuildingsList.completeAllUpgrades
    }], SceneGlobalBuildingOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.habitatsSorted,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }], this.currentTabMode = servicesGameDataManager.habitatsCollection.getDefaultHabitatTabMode(), this.localizedName = servicesInternationalization.localize("Running Building Upgrades")
  }

  return utilsOop.extend(SceneGlobalBuildingOverviewController, CoreControllerElementGlobalOverview), SceneGlobalBuildingOverviewController.prototype.prepareDataForDraw = function() {
    this.dataSource.prepareGlobalBuildingOverviewData({ currentTabMode: this.currentTabMode })
  }, SceneGlobalBuildingOverviewController.prototype[xy.eNames.eventSceneGlobalBuildingOverview.tableIsLoaded] = function() {
    this[xy.eNames.eventSceneGlobalOverview.releasePendingMode]()
  }, SceneGlobalBuildingOverviewController.prototype[xy.eNames.eventSceneGlobalBuildingOverview.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, SceneGlobalBuildingOverviewController.prototype[xy.eNames.eventSceneGlobalBuildingOverview.switchCurrentMode] = function(options) {
    this.currentTabMode = options.newTabMode, this.requestPendingMode()
  }, SceneGlobalBuildingOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalBuildingOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, xy.dNames.services.theme, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesLog, servicesGameDataManager, servicesSortable, servicesTheme) {
  "use strict";
  function SceneGlobalBuildingOverviewDataSource(options) {
    var menuBuildingsListDataSource = gameInstance.injector.get(xy.dNames.game.menuBuildingsList.dataSource);
    this.forLinking = [{
      resourceClass: menuBuildingsListDataSource,
      methodName: "upgradeBuilding"
    }, {
      resourceClass: menuBuildingsListDataSource,
      methodName: "onUpgradeConstructionResponse"
    }, {
      resourceClass: menuBuildingsListDataSource,
      methodName: "speedUpConstruction"
    }, {
      resourceClass: menuBuildingsListDataSource,
      methodName: "onSpeedUpConstructionResponse"
    }, {
      resourceClass: menuBuildingsListDataSource,
      methodName: "finishConstruction"
    }, {
      resourceClass: menuBuildingsListDataSource,
      methodName: "batchBuildingUpgrade"
    }], SceneGlobalBuildingOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGlobalBuildingOverviewDataSource, CoreDataSource), SceneGlobalBuildingOverviewDataSource.prototype.prepareGlobalBuildingOverviewData = function(options) {
    var buildingClassIdentifierLocal, properHabitatTypes, availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), headerList = [], habitatsList = [], buildingsTitlesList = servicesTheme.themeSettings.buildings.titlesListsByHabitatType[options.currentTabMode], habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), data = { activeTabButton: options.currentTabMode };
    switch (options.currentTabMode) {
      case settingsGameConstant.HABITAT_TYPE.CASTLE:
        properHabitatTypes = [settingsGameConstant.HABITAT_TYPE.CASTLE, settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER];
        break;
      case settingsGameConstant.HABITAT_TYPE.FORTRESS:
        properHabitatTypes = [settingsGameConstant.HABITAT_TYPE.FORTRESS, settingsGameConstant.HABITAT_TYPE.CITY_CENTER];
        break;
      case settingsGameConstant.HABITAT_TYPE.CITY:
        properHabitatTypes = [settingsGameConstant.HABITAT_TYPE.CITY]
    }
    habitatIds.forEach(function(id) {
      var iterationHabitat = servicesGameDataManager.habitatsCollection.getHabitatModel(id);
      if (properHabitatTypes.indexOf(iterationHabitat.habitatType) !== -1) {
        var building, habitatBuildingsData = {}, currentConstructionsList = servicesGameDataManager.buildingsCollection.getHabitatBuildingUpgrades({ habitat: iterationHabitat }), currentConstructionsListLength = currentConstructionsList.length;
        iterationHabitat.habitatBuildingKeyArray.forEach(function(buildingPK) {
          building = servicesGameDataManager.buildingsCollection.getBuilding({ pk: buildingPK }), habitatBuildingsData[building.classIdentifier] = { modeledBuilding: building }
        }), currentConstructionsListLength && currentConstructionsList.forEach(function(upgrade) {
          habitatBuildingsData[upgrade.resultBuilding.classIdentifier].lastUpgrade = { resultBuilding: upgrade.resultBuilding }, habitatBuildingsData[upgrade.resultBuilding.classIdentifier].firstUpgradeInQueue || (habitatBuildingsData[upgrade.resultBuilding.classIdentifier].firstUpgradeInQueue = upgrade.buildingUpgrade.id)
        }), habitatsList.push({
          habitatModel: iterationHabitat,
          currentConstructionsList: currentConstructionsList,
          habitatBuildingsData: habitatBuildingsData
        })
      }
    }), buildingsTitlesList.forEach(function(buildingTitle) {
      buildingClassIdentifierLocal = buildingTitle.replace(/\s/g, "").toLowerCase(), headerList.push({ buildingClassIdentifier: buildingClassIdentifierLocal })
    }, this), data.habitatsList = habitatsList, data.header = headerList, data.availableHabitatTypes = availableHabitatTypes, this.notify(xy.eNames.eventSceneGlobalBuildingOverview.dataIsReady, data)
  }, SceneGlobalBuildingOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalBuildingOverview.presenter, [xy.dNames.componentsEngine, xy.dNames.core.presenterElementGlobalOverview, xy.dNames.utils.oop, xy.dNames.game.sceneGlobalBuildingOverview.component, function(componentsEngine, CorePresenterElementGlobalOverview, utilsOop, SceneGlobalBuildingOverviewComponent) {
  "use strict";
  function SceneGlobalBuildingOverviewPresenter(options) {
    SceneGlobalBuildingOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGlobalBuildingOverviewPresenter, CorePresenterElementGlobalOverview), SceneGlobalBuildingOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = { localizedTitle: this.controller.localizedName };
    componentsEngine.render(React.createElement(SceneGlobalBuildingOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data || {}
    }), document.getElementById(xy.DomElements.gameGlobalOverview))
  }, SceneGlobalBuildingOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalBuildingOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuSearchBarHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuSearchBar, xy.dNames.game.sceneGlobalBuildingOverview.componentTableBuildings, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers, settingsGameConstant, servicesTheme, servicesLog, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuSearchBar, SceneGlobalBuildingOverviewComponentTableBuildings) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers],
    getInitialState: function() {
      var publicHabitatTypeFilter = {};
      return publicHabitatTypeFilter[settingsGameConstant] = !0, {
        searchQueryString: "",
        publicHabitatTypeFilter: publicHabitatTypeFilter,
        showIcon: !0
      }
    },
    componentDidUpdate: function() {
      this.dataRepresented()
    },
    componentDidMount: function() {
      this.dataRepresented()
    },
    dataRepresented: function() {
      this.props.presenter.notify(xy.eNames.eventSceneGlobalBuildingOverview.tableIsLoaded)
    },
    render: function() {
      var settings = {
        initialComponent: this,
        header: [],
        availableHabitatTypes: {},
        habitatsList: [],
        activeTabButton: null
      };
      Object.assign(settings, this.props.settings);
      var titleSettings = {
        title: this.props.settingsTitle.localizedTitle,
        leftButton: [],
        rightButton: [{
          icon: "controls jump-to-top-button",
          onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.GLOBAL_OVERVIEW.CONTAINER)
        }]
      }, searchBarSettings = {
        value: this.state.searchQueryString,
        onChange: this.updateSearchQuery,
        onFocus: this.onSearchFieldFocus,
        onBlur: this.onSearchFieldBlur
      };
      this.state.showIcon && (searchBarSettings.iconLeft = "controls menu-search");
      var newHabitatList, searchFilter = this.state.searchQueryString ? this.state.searchQueryString.toLowerCase() : null;
      searchFilter && (newHabitatList = settings.habitatsList.filter(function(habitatObject) {
        return !!~habitatObject.habitatModel.name.toLowerCase().indexOf(searchFilter)
      }), settings.habitatsList = newHabitatList);
      var menuSectionContentSettings, content = [];
      content.push(React.createElement(SceneGlobalBuildingOverviewComponentTableBuildings, {
        settings: settings,
        key: "table-buildings"
      })), menuSectionContentSettings = { content: content, classes: "global-building-overview" };
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: React.createElement(ComponentsMenuSearchBar, { settings: searchBarSettings }),
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.GLOBAL_OVERVIEW.CONTAINER
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalBuildingOverview.componentTableBuildings, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.components.tabular, xy.dNames.components.habitatTabularCell, xy.dNames.components.icon, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.habitatTypesTabularHeader, xy.dNames.components.buildingTabularCell, xy.dNames.components.buildingInProgressTabularCell, xy.dNames.components.menuListButtonBasic, function(componentEngine, servicesInternationalization, ComponentTabular, ComponentsHabitatTabularCell, ComponentsIcon, ComponentsMenuListElementButtonAction, ComponentsHabitatTypesTabularHeader, ComponentsBuildingTabularCell, ComponentsBuildingInProgressTabularCell, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    onRendered: function() {
      this.props.settings.initialComponent.onRendered.call(this.props.settings.initialComponent)
    }, onUpgradeButtonClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingsList.upgradeBuilding, options)
    }, onSpeedUpButtonClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingsList.speedUpUpgrade, options)
    }, onCompleteAllHabitatUpgrades: function(habitatId, event) {
      event.preventDefault(), event.stopPropagation();
      var options, settings = this.props.settings, originalThis = settings.initialComponent, habitatsObject = {};
      habitatsObject[habitatId] = this.objectForFinishAll[habitatId], options = { habitatsObject: habitatsObject }, originalThis.props.presenter.notify(xy.eNames.menuBuildingsList.completeAllUpgrades, options)
    }, onCompleteAllUpgrades: function(event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings, originalThis = settings.initialComponent, options = { habitatsObject: this.objectForFinishAll };
      originalThis.props.presenter.notify(xy.eNames.menuBuildingsList.completeAllUpgrades, options)
    }, onBarButtonClick: function(btnIndex) {
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.eventSceneGlobalBuildingOverview.switchCurrentMode, { newTabMode: btnIndex })
    }, render: function() {
      var settings = {
        initialComponent: null,
        header: [],
        availableHabitatTypes: {},
        habitatsList: [],
        activeTabButton: 0
      };
      Object.assign(settings, this.props.settings);
      var iterationRowSettings, button, buttonSettings, upgradeBuldingCell, rows = [], componentTableSetting = {
        classes: "table--global-overview table--global-overview--buildings",
        header: [],
        rows: [],
        emptyText: servicesInternationalization.localize("There are currently no buildings")
      };
      this.objectForFinishAll = {}, this.buildingsInProgressAmount = 0, settings.habitatsList.forEach(function(listObject) {
        var actionButtonSettings, iterationRow = [], habitat = listObject.habitatModel, actionButtons = [];
        listObject.currentConstructionsList && listObject.currentConstructionsList.length && (this.objectForFinishAll[habitat.id] = {
          habitat: habitat,
          upgrades: listObject.currentConstructionsList
        }, this.buildingsInProgressAmount += listObject.currentConstructionsList.length, actionButtonSettings = {
          icon: "icon-game white icon-BuildFinish",
          onClick: this.onCompleteAllHabitatUpgrades.bind(this, habitat.id)
        }, actionButtons.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: actionButtonSettings }))), iterationRowSettings = {
          showResources: !0,
          habitat: habitat,
          actionButtons: actionButtons
        }, iterationRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: iterationRowSettings }) }), settings.header.forEach(function(headerBuildingObject) {
          if (listObject.habitatBuildingsData[headerBuildingObject.buildingClassIdentifier]) {
            var habitatCellSettings, classIdentifier = headerBuildingObject.buildingClassIdentifier, habitatBuildingsData = listObject.habitatBuildingsData[classIdentifier], building = habitatBuildingsData.modeledBuilding, habitatCells = [];
            habitatBuildingsData.lastUpgrade && (building = habitatBuildingsData.lastUpgrade.resultBuilding), habitatCellSettings = {
              building: building,
              habitat: habitat,
              initialComponent: this
            }, habitatCells.push(React.createElement(ComponentsBuildingTabularCell, { settings: habitatCellSettings })), listObject.currentConstructionsList && listObject.currentConstructionsList.length && listObject.currentConstructionsList.forEach(function(upgrade) {
              upgrade.resultBuilding.classIdentifier === classIdentifier && (habitatCellSettings = {
                upgradeObject: upgrade,
                firstUpgradeInQueue: habitatBuildingsData.firstUpgradeInQueue,
                habitat: habitat,
                initialComponent: this
              }, habitatCells.push(React.createElement(ComponentsBuildingInProgressTabularCell, { settings: habitatCellSettings })))
            }, this), upgradeBuldingCell = React.createElement("div", { className: "tabular-cell--upgrade-building" }, habitatCells), iterationRow.push({ value: upgradeBuldingCell })
          } else iterationRow.push({ value: 0 })
        }, this), rows.push({ cells: iterationRow })
      }, this), componentTableSetting.rows = rows;
      var headerCells = [], headerFirstCellSettings = {
        tabMode: settings.activeTabButton,
        availableHabitatTypes: settings.availableHabitatTypes,
        initialComponent: this
      };
      return headerCells.push({
        classes: "tabular-header-th-cell ",
        value: React.createElement(ComponentsHabitatTypesTabularHeader, { settings: headerFirstCellSettings })
      }), settings.header.forEach(function(headerBuildingObject) {
        var headerCellsSettings = { icon: "icon-building icon-building-" + headerBuildingObject.buildingClassIdentifier };
        headerCells.push({ value: React.createElement(ComponentsIcon, { settings: headerCellsSettings }) })
      }), this.buildingsInProgressAmount && (buttonSettings = {
        title: servicesInternationalization.localize("Complete all buildings"),
        iconLeft: "icon-game icon-BuildFinish",
        rightColumnDataValue: "(" + this.buildingsInProgressAmount + ")",
        classes: "finish-all-button",
        onClick: this.onCompleteAllUpgrades
      }, button = React.createElement(ComponentsMenuListButtonBasic, { settings: buttonSettings })), componentTableSetting.header = {
        classes: "global-overview--table--header ",
        cells: headerCells
      }, React.createElement("div", null, button, React.createElement(ComponentTabular, { settings: componentTableSetting }), ";")
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalRecruitmentOverview.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementGlobalOverview, xy.dNames.settings.gameConstant, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(gameInstance, CoreControllerElementGlobalOverview, settingsGameConstant, utilsOop, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  function SceneGlobalRecruitmentOverviewController(options) {
    var menuUnitConstructionController = gameInstance.injector.get(xy.dNames.game.menuUnitConstruction.controller);
    this.forLinking = [{
      resourceClass: menuUnitConstructionController,
      methodName: xy.eNames.menuUnitConstruction.construct
    }, {
      resourceClass: menuUnitConstructionController,
      methodName: xy.eNames.menuUnitConstruction.speedUpRecruitment
    }, {
      resourceClass: menuUnitConstructionController,
      methodName: xy.eNames.menuUnitConstruction.completeAllRecruitment
    }], SceneGlobalRecruitmentOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.habitatsSorted,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.requestPendingMode
    }], this.currentTabMode = servicesGameDataManager.habitatsCollection.getDefaultHabitatTabMode(), this.localizedName = servicesInternationalization.localize("Unit Orders")
  }

  return utilsOop.extend(SceneGlobalRecruitmentOverviewController, CoreControllerElementGlobalOverview), SceneGlobalRecruitmentOverviewController.prototype.prepareDataForDraw = function() {
    this.dataSource.prepareGlobalRecruitmentOverviewData({ currentTabMode: this.currentTabMode })
  }, SceneGlobalRecruitmentOverviewController.prototype[xy.eNames.eventSceneGlobalRecruitmentOverview.tableIsLoaded] = function() {
    this[xy.eNames.eventSceneGlobalOverview.releasePendingMode]()
  }, SceneGlobalRecruitmentOverviewController.prototype[xy.eNames.eventSceneGlobalRecruitmentOverview.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, SceneGlobalRecruitmentOverviewController.prototype[xy.eNames.eventSceneGlobalRecruitmentOverview.switchCurrentMode] = function(options) {
    this.currentTabMode = options.newTabMode, this.requestPendingMode()
  }, SceneGlobalRecruitmentOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalRecruitmentOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, xy.dNames.services.theme, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesLog, servicesGameDataManager, servicesSortable, servicesTheme) {
  "use strict";
  function SceneGlobalRecruitmentOverviewDataSource(options) {
    var menuUnitConstructionDataSource = gameInstance.injector.get(xy.dNames.game.menuUnitConstruction.dataSource);
    this.forLinking = [{
      resourceClass: menuUnitConstructionDataSource,
      methodName: "buildUnit"
    }, {
      resourceClass: menuUnitConstructionDataSource,
      methodName: "speedUpUnit"
    }, {
      resourceClass: menuUnitConstructionDataSource,
      methodName: "finishUnit"
    }, {
      resourceClass: menuUnitConstructionDataSource,
      methodName: "batchRecruitmentActions"
    }], SceneGlobalRecruitmentOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGlobalRecruitmentOverviewDataSource, CoreDataSource), SceneGlobalRecruitmentOverviewDataSource.prototype.prepareGlobalRecruitmentOverviewData = function(options) {
    var unitsGlobalSummary, properHabitatTypes, availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), unitsDictionary = servicesGameDataManager.unitsCollection.units, availableForRecruitUnitsPrimaryKeys = servicesGameDataManager.unitsCollection.availableForRecruitUnitsPrimaryKeys, headerList = [], habitatsList = [], habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), data = { activeTabButton: options.currentTabMode };
    switch (options.currentTabMode) {
      case settingsGameConstant.HABITAT_TYPE.CASTLE:
        properHabitatTypes = [settingsGameConstant.HABITAT_TYPE.CASTLE, settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER];
        break;
      case settingsGameConstant.HABITAT_TYPE.FORTRESS:
        properHabitatTypes = [settingsGameConstant.HABITAT_TYPE.FORTRESS, settingsGameConstant.HABITAT_TYPE.CITY_CENTER];
        break;
      case settingsGameConstant.HABITAT_TYPE.CITY:
        properHabitatTypes = [settingsGameConstant.HABITAT_TYPE.CITY]
    }
    habitatIds.forEach(function(id) {
      var localUnits, iterationHabitat = servicesGameDataManager.habitatsCollection.getHabitatModel(id), unitsInProgress = [];
      unitsGlobalSummary = {}, properHabitatTypes.indexOf(iterationHabitat.habitatType) !== -1 && (iterationHabitat.habitatUnitOrderArray instanceof Array && iterationHabitat.habitatUnitOrderArray.forEach(function(unitInProgressId) {
        var modeledUnitInProgress = servicesGameDataManager.unitsCollection.getUnitInProgress(unitInProgressId), modeledUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: modeledUnitInProgress.unitId });
        unitsInProgress.push({ inProgressModel: modeledUnitInProgress, unitModel: modeledUnit })
      }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
        availableForRecruitUnitsPrimaryKeys[unitPrimaryKey] && (localUnits = iterationHabitat.unitRecruitmentInHabitat(unitsDictionary[unitPrimaryKey]), unitsGlobalSummary[unitPrimaryKey] = {
          unit: unitsDictionary[unitPrimaryKey],
          maxForRecruitment: localUnits.amountPossible,
          amount: localUnits.currentAmount
        })
      }), habitatsList.push({
        habitatModel: iterationHabitat,
        unitsInProgress: unitsInProgress,
        unitsGlobalSummary: unitsGlobalSummary
      }))
    }), Object.keys(unitsDictionary).forEach(function(unitPrimaryKey) {
      availableForRecruitUnitsPrimaryKeys[unitPrimaryKey] && headerList.push({ primaryKey: unitPrimaryKey })
    }), data.habitatsList = habitatsList, data.header = headerList, data.availableHabitatTypes = availableHabitatTypes, this.notify(xy.eNames.eventSceneGlobalRecruitmentOverview.dataIsReady, data)
  }, SceneGlobalRecruitmentOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalRecruitmentOverview.presenter, [xy.dNames.componentsEngine, xy.dNames.core.presenterElementGlobalOverview, xy.dNames.utils.oop, xy.dNames.game.sceneGlobalRecruitmentOverview.component, function(componentsEngine, CorePresenterElementGlobalOverview, utilsOop, SceneGlobalRecruitmentOverviewComponent) {
  "use strict";
  function SceneGlobalRecruitmentOverviewPresenter(options) {
    SceneGlobalRecruitmentOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(SceneGlobalRecruitmentOverviewPresenter, CorePresenterElementGlobalOverview), SceneGlobalRecruitmentOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = { localizedTitle: this.controller.localizedName };
    componentsEngine.render(React.createElement(SceneGlobalRecruitmentOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data || {}
    }), document.getElementById(xy.DomElements.gameGlobalOverview))
  }, SceneGlobalRecruitmentOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalRecruitmentOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuSearchBarHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuSearchBar, xy.dNames.game.sceneGlobalRecruitmentOverview.componentTableUnits, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers, settingsGameConstant, servicesTheme, servicesLog, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuSearchBar, SceneGlobalRecruitmentOverviewComponentTableUnits) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers],
    getInitialState: function() {
      var publicHabitatTypeFilter = {};
      return publicHabitatTypeFilter[settingsGameConstant] = !0, {
        searchQueryString: "",
        publicHabitatTypeFilter: publicHabitatTypeFilter,
        showIcon: !0
      }
    },
    componentDidUpdate: function() {
      this.dataRepresented()
    },
    componentDidMount: function() {
      this.dataRepresented()
    },
    dataRepresented: function() {
      this.props.presenter.notify(xy.eNames.eventSceneGlobalRecruitmentOverview.tableIsLoaded)
    },
    render: function() {
      var settings = {
        initialComponent: this,
        header: [],
        availableHabitatTypes: {},
        habitatsList: [],
        activeTabButton: null
      };
      Object.assign(settings, this.props.settings);
      var titleSettings = {
        title: this.props.settingsTitle.localizedTitle,
        leftButton: [],
        rightButton: [{
          icon: "controls jump-to-top-button",
          onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.GLOBAL_OVERVIEW.CONTAINER)
        }]
      }, searchBarSettings = {
        value: this.state.searchQueryString,
        onChange: this.updateSearchQuery,
        onFocus: this.onSearchFieldFocus,
        onBlur: this.onSearchFieldBlur
      };
      this.state.showIcon && (searchBarSettings.iconLeft = "controls menu-search");
      var newHabitatList, searchFilter = this.state.searchQueryString ? this.state.searchQueryString.toLowerCase() : null;
      searchFilter && (newHabitatList = settings.habitatsList.filter(function(habitatObject) {
        return !!~habitatObject.habitatModel.name.toLowerCase().indexOf(searchFilter)
      }), settings.habitatsList = newHabitatList);
      var menuSectionContentSettings, content = [];
      content.push(React.createElement(SceneGlobalRecruitmentOverviewComponentTableUnits, {
        settings: settings,
        key: "table-recruitment"
      })), menuSectionContentSettings = { content: content, classes: "global-recruitment-overview" };
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: React.createElement(ComponentsMenuSearchBar, { settings: searchBarSettings }),
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.GLOBAL_OVERVIEW.CONTAINER
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.sceneGlobalRecruitmentOverview.componentTableUnits, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.utils.object, xy.dNames.components.tabular, xy.dNames.components.habitatTabularCell, xy.dNames.components.icon, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.habitatTypesTabularHeader, xy.dNames.components.unitTabularCell, xy.dNames.components.unitInProgressTabularCell, xy.dNames.components.menuListButtonBasic, function(componentEngine, servicesInternationalization, utilsObject, ComponentTabular, ComponentsHabitatTabularCell, ComponentsIcon, ComponentsMenuListElementButtonAction, ComponentsHabitatTypesTabularHeader, ComponentsUnitTabularCell, ComponentsUnitInProgressTabularCell, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    unitToConstruct: {}, onRendered: function() {
      this.props.settings.initialComponent.onRendered.call(this.props.settings.initialComponent)
    }, onConstructClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var presenter = this.props.settings.initialComponent.props.presenter, habitat = options.habitat, unit = options.unit;
      presenter.notify(xy.eNames.menuUnitConstruction.construct, {
        amountForRecruitment: this.unitToConstruct[habitat.id][unit.primaryKey],
        unit: unit,
        habitat: habitat,
        paymentGranted: !1,
        globalRecruitmentView: !0
      })
    }, onSpeedUpClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var presenter = this.props.settings.initialComponent.props.presenter;
      presenter.notify(xy.eNames.menuUnitConstruction.speedUpRecruitment, options)
    }, onBarButtonClick: function(btnIndex) {
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.eventSceneGlobalRecruitmentOverview.switchCurrentMode, { newTabMode: btnIndex })
    }, onChangeUnitAmountToSendBack: function(habitatId, unitId, newValue) {
      this.unitToConstruct[habitatId][unitId] = +newValue
    }, onCompleteAllUnits: function(event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings, originalThis = settings.initialComponent, options = { habitatsObject: this.objectForFinishAll };
      originalThis.props.presenter.notify(xy.eNames.menuUnitConstruction.completeAllRecruitment, options)
    }, onCompleteAllHabitatUnits: function(habitatId, event) {
      event.preventDefault(), event.stopPropagation();
      var options, settings = this.props.settings, originalThis = settings.initialComponent, habitatsObject = {};
      habitatsObject[habitatId] = this.objectForFinishAll[habitatId], options = { habitatsObject: habitatsObject }, originalThis.props.presenter.notify(xy.eNames.menuUnitConstruction.completeAllRecruitment, options)
    }, render: function() {
      var settings = {
        initialComponent: null,
        header: [],
        availableHabitatTypes: {},
        habitatsList: [],
        activeTabButton: 0
      };
      Object.assign(settings, this.props.settings);
      var iterationRowSettings, button, buttonSettings, recruitmentCell, rows = [], componentTableSetting = {
        classes: "table--global-overview table--global-overview--recruitment",
        header: [],
        rows: [],
        emptyText: servicesInternationalization.localize("There are currently no units")
      };
      this.objectForFinishAll = {}, this.unitsInProgressAmount = 0, settings.habitatsList.forEach(function(listObject) {
        var actionButtonSettings, iterationRow = [], habitat = listObject.habitatModel, actionButtons = [];
        this.unitToConstruct[habitat.id] = {}, listObject.unitsInProgress && listObject.unitsInProgress.length && (this.objectForFinishAll[habitat.id] = {
          habitat: habitat,
          upgrades: listObject.unitsInProgress
        }, actionButtonSettings = {
          icon: "icon-game white icon-RecruitFinish",
          onClick: this.onCompleteAllHabitatUnits.bind(this, habitat.id)
        }, actionButtons.push(React.createElement(ComponentsMenuListElementButtonAction, { settings: actionButtonSettings }))), iterationRowSettings = {
          showResources: !0,
          habitat: habitat,
          actionButtons: actionButtons
        }, iterationRow.push({ value: React.createElement(ComponentsHabitatTabularCell, { settings: iterationRowSettings }) }), settings.header.forEach(function(headerUnitObject) {
          var habitatCellSettings, unitPk = +headerUnitObject.primaryKey, habitatCells = [];
          this.unitToConstruct[habitat.id][unitPk] = listObject.unitsGlobalSummary[unitPk].maxForRecruitment, habitatCellSettings = {
            unitObject: listObject.unitsGlobalSummary[unitPk],
            habitat: habitat,
            initialComponent: this
          }, habitatCells.push(React.createElement(ComponentsUnitTabularCell, { settings: habitatCellSettings })), listObject.unitsInProgress && listObject.unitsInProgress.length && listObject.unitsInProgress.forEach(function(unitInProgress) {
            unitInProgress.unitModel.primaryKey === unitPk && (this.unitsInProgressAmount += unitInProgress.inProgressModel.unitsLeft, habitatCellSettings = {
              unitInProgress: unitInProgress,
              habitat: habitat,
              initialComponent: this
            }, habitatCells.push(React.createElement(ComponentsUnitInProgressTabularCell, { settings: habitatCellSettings })))
          }, this), recruitmentCell = React.createElement("div", { className: "tabular-cell--recruitment" }, habitatCells), iterationRow.push({ value: recruitmentCell })
        }, this), rows.push({ cells: iterationRow })
      }, this), componentTableSetting.rows = rows;
      var headerCells = [], headerFirstCellSettings = {
        tabMode: settings.activeTabButton,
        availableHabitatTypes: settings.availableHabitatTypes,
        initialComponent: this
      };
      return headerCells.push({
        classes: "tabular-header-th-cell ",
        value: React.createElement(ComponentsHabitatTypesTabularHeader, { settings: headerFirstCellSettings })
      }), settings.header.forEach(function(headerUnitObject) {
        var headerCellsSettings = { icon: "icon-unit icon-unit-" + headerUnitObject.primaryKey };
        headerCells.push({ value: React.createElement(ComponentsIcon, { settings: headerCellsSettings }) })
      }), this.unitsInProgressAmount && (buttonSettings = {
        title: servicesInternationalization.localize("Complete all recruitments"),
        iconLeft: "icon-game icon-RecruitFinish",
        rightColumnDataValue: "(" + this.unitsInProgressAmount + ")",
        classes: "finish-all-button",
        onClick: this.onCompleteAllUnits
      }, button = React.createElement(ComponentsMenuListButtonBasic, { settings: buttonSettings })), componentTableSetting.header = {
        classes: "global-overview--table--header ",
        cells: headerCells
      }, React.createElement("div", null, button, React.createElement(ComponentTabular, { settings: componentTableSetting }), ";")
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessages.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuBottomBarMain, xy.dNames.components.menuListTextBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuBottomBarMain, ComponentsMenuListTextBasic) {
  "use strict";
  return componentsEngine.createClass({
    selectedMessagesIdsSet: {},
    mixins: [mixinsMenuComponentHandlers],
    getNewState: function() {
      return this.selectedMessagesIdsSet = {}, { editMode: !1, selectedAmount: 0 }
    },
    getInitialState: function() {
      return this.getNewState()
    },
    componentWillReceiveProps: function(newProps) {
      var isMessagesMissing = newProps.settings.discussionMessages.length < 1 && newProps.settings.systemMessages.length < 1;
      isMessagesMissing && this.setState(this.getNewState(), null)
    },
    determineEditingMode: function() {
      this.state.editMode || (this.selectedMessagesIdsSet = {}), this.setState({
        editMode: !this.state.editMode,
        selectedAmount: 0
      }, null)
    },
    onCheckboxClick: function(messageTitle, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedAmount = +this.state.selectedAmount;
      this.selectedMessagesIdsSet[messageTitle.id] ? (this.selectedMessagesIdsSet[messageTitle.id] = !1, selectedAmount -= 1) : (this.selectedMessagesIdsSet[messageTitle.id] = messageTitle, selectedAmount += 1), this.setState({ selectedAmount: selectedAmount }, null)
    },
    deleteSelectedEntries: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuMessages.deleteMessages, this.selectedMessagesIdsSet), this.selectedMessagesIdsSet = {}, this.setState({ selectedAmount: 0 })
    },
    deleteAllEntries: function(event) {
      event.preventDefault(), event.stopPropagation();
      var messagesIdSet;
      messagesIdSet = servicesGameDataManager.messagesCollection.getMessagesSet(), this.props.presenter.notify(xy.eNames.menuMessages.deleteAllMessages, messagesIdSet)
    },
    render: function() {
      var settings = {
        systemMessages: [],
        discussionMessages: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], bottomBarSection = null, buildTitlesList = function(message) {
        var messagesTitleSettings = {
          title: message.title,
          description: utilsDateTime.getLocaleDateTimeString(message.lastEntryDate),
          iconLeft: "icon-game icon-MessageUnread",
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuMessagesThread.name,
            options: { message: message }
          })
        };
        message.isRead && (messagesTitleSettings.iconLeft = "icon-game icon-MessageRead"), this.state.editMode && (messagesTitleSettings.isSelectable = !0, messagesTitleSettings.onSelect = this.onCheckboxClick.bind(this, message), this.selectedMessagesIdsSet[message.id] && (messagesTitleSettings.isSelected = !0)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: messagesTitleSettings,
          key: "menu-element-messages-list-" + message.id
        }))
      };
      if (this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], this.state.editMode) {
        titleSettings.rightButton.push({
          title: servicesInternationalization.localize("cancel"),
          onClick: this.determineEditingMode
        });
        var bottomBarSectionSettings = {
          leftButton: {
            onClick: this.deleteSelectedEntries,
            title: servicesInternationalization.localize("Delete entries (%ld)", +this.state.selectedAmount),
            isDisabled: this.state.selectedAmount < 1
          }, rightButton: { onClick: this.deleteAllEntries, icon: "controls menu-bar-delete" }
        };
        bottomBarSection = React.createElement(ComponentsMenuBottomBarMain, { settings: bottomBarSectionSettings })
      } else titleSettings.rightButton.push({
        icon: "controls menu-bar-edit",
        onClick: this.determineEditingMode,
        isDisabled: settings.discussionMessages.length < 1 && settings.systemMessages.length < 1
      });
      settings.systemMessages.length && (sectionComponentSettings = { title: servicesInternationalization.localize("System messages") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-system-messages"
      })), settings.systemMessages.forEach(buildTitlesList, this)), settings.discussionMessages.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Private messages") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-discussion-messages"
      })), settings.discussionMessages.forEach(buildTitlesList, this)), 0 === settings.discussionMessages.length && 0 === settings.systemMessages.length && (sectionComponentSettings = { text: servicesInternationalization.localize("You don't have any messages") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-no-messages"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: bottomBarSection,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessages.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, utilsObject, servicesInternationalization) {
  "use strict";
  function MenuMessagesController(options) {
    MenuMessagesController.__super__.constructor.call(this, options), this.isDelayedChildrenLoading = !0, this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.messages,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuMessages.dataIsReady]
    }], this.localizedName = servicesInternationalization.localize("Messages")
  }

  return utilsOop.extend(MenuMessagesController, CoreControllerElementMenu), MenuMessagesController.prototype[xy.eNames.menuMessages.dataIsReady] = function() {
    this.isActive && (this.presenter.draw(this.dataSource.prepareMessagesTitles()), this.isRestart && (this.isRestart = !1, this.restoreLastInStack()))
  }, MenuMessagesController.prototype[xy.eNames.menuMessages.deleteMessages] = function(selectedMessagesSet) {
    this.showDialogDialog({
      title: "Delete message?",
      text: servicesInternationalization.localize("Do you want to delete %1$ld messages?", utilsObject.effectiveLength(selectedMessagesSet)),
      callbackSuccess: this.dataSource.deleteMessages.bind(this.dataSource, selectedMessagesSet)
    })
  }, MenuMessagesController.prototype[xy.eNames.menuMessages.deleteAllMessages] = function(messagesSet) {
    this.showDialogDialog({
      title: "Delete message?",
      text: servicesInternationalization.localize("Are you sure you want to delete all of your messages?"),
      callbackSuccess: this.dataSource.deleteMessages.bind(this.dataSource, messagesSet)
    })
  }, MenuMessagesController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getMessages()
  }, MenuMessagesController
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessages.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuMessagesDataSource(options) {
    MenuMessagesDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMessagesDataSource, CoreDataSource), MenuMessagesDataSource.prototype.getMessages = function() {
    this.request(null, "MessageAction/messageTitleArray", { callBack: this.receiveMessages })
  }, MenuMessagesDataSource.prototype.receiveMessages = function(data) {
    servicesGameDataManager.messagesCollection.updateMessages(data)
  }, MenuMessagesDataSource.prototype.prepareMessagesTitles = function() {
    var data = {
      systemMessages: servicesGameDataManager.messagesCollection.getSystemMessagesTitles(),
      discussionMessages: servicesGameDataManager.messagesCollection.getDiscussionMessagesTitles()
    };
    return data
  }, MenuMessagesDataSource.prototype.deleteMessages = function(selectedMessagesSet) {
    var key, systemMessagesIdsArray = [], discussionMessagesIdsArray = [];
    for (key in selectedMessagesSet)selectedMessagesSet.hasOwnProperty(key) && selectedMessagesSet[key] !== !1 && (selectedMessagesSet[key].isSystemMessage ? systemMessagesIdsArray.push(key) : discussionMessagesIdsArray.push(key));
    this.request({
      discussionIdArray: discussionMessagesIdsArray,
      systemMessageIdArray: systemMessagesIdsArray
    }, "MessageAction/releaseFromMessageArray", { callBack: this.onDeleteMessages.bind(this, systemMessagesIdsArray, discussionMessagesIdsArray) })
  }, MenuMessagesDataSource.prototype.onDeleteMessages = function(discussionMessagesIdsArray, systemMessagesIdsArray, updatedMessages) {
    servicesGameDataManager.messagesCollection.onDeleteMessagesThread({
      updatedMessages: updatedMessages,
      discussionMessagesIdsArray: discussionMessagesIdsArray,
      systemMessagesIdsArray: systemMessagesIdsArray
    })
  }, MenuMessagesDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessages.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMessages.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMessagesComponent) {
  "use strict";
  function MenuMessagesPresenter(options) {
    MenuMessagesPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMessagesPresenter, CorePresenterElementMenu), MenuMessagesPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMessagesComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMessagesPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessagesNew.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.worldSettings, xy.dNames.utils.object, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListButtonBasic, xy.dNames.components.inputContent, xy.dNames.components.inputSubject, xy.dNames.components.menuListTitleBasic, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesWorldSettings, utilsObject, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListButtonBasic, ComponentsInputContent, ComponentsInputSubject, ComponentsMenuListTitleBasic) {
  "use strict";
  return componentsEngine.createClass({
    showRecipient: !1,
    showSubject: !1,
    showContent: !1,
    subjectLimit: "",
    contentLimit: "",
    mixins: [mixinsMenuComponentHandlers],
    getNewState: function(settings) {
      this.showRecipient = !1, this.showSubject = !1, this.showContent = !1, this.subjectLimit = "", this.contentLimit = "";
      var cachedMessage, correctTitle = "", contentObject = {}, subjectObject = {};
      switch (settings.mode) {
        case settingsGameConstant.NEW_MESSAGE_MODE.CREATE:
          this.subjectLimit = servicesWorldSettings.settings["Discussion.title.length"], this.contentLimit = servicesWorldSettings.settings["DiscussionEntry.content.length"], this.showRecipient = !0, this.showSubject = !0, this.showContent = !0, this.cacheIdentifier = settings.mode, cachedMessage = servicesGameDataManager.messagesCollection.getDiscussionMessageContent(this.cacheIdentifier) || {}, correctTitle = "New Message";
          break;
        case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_DISCUSSION:
          this.contentLimit = servicesWorldSettings.settings["DiscussionEntry.content.length"], this.showContent = !0, this.cacheIdentifier = settings.message.id, cachedMessage = servicesGameDataManager.messagesCollection.getDiscussionMessageContent(this.cacheIdentifier) || {}, correctTitle = "Reply";
          break;
        case settingsGameConstant.NEW_MESSAGE_MODE.POST_IN_FORUM:
          this.subjectLimit = servicesWorldSettings.settings["Forum.name.length"], this.contentLimit = servicesWorldSettings.settings["ForumMessage.content.length"], this.showSubject = !0, this.showContent = !0, this.cacheIdentifier = settings.mode, cachedMessage = servicesGameDataManager.forumsCollection.getThreadMessageContent(this.cacheIdentifier) || {}, correctTitle = "New Thread";
          break;
        case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_FORUM:
          this.contentLimit = servicesWorldSettings.settings["ForumMessage.content.length"], this.showContent = !0, this.cacheIdentifier = settings.message.id, cachedMessage = servicesGameDataManager.forumsCollection.getThreadMessageContent(this.cacheIdentifier) || {}, correctTitle = "Reply"
      }
      return cachedMessage.content && (contentObject = this.getContentState(cachedMessage.content)), cachedMessage.subject && (subjectObject = this.getSubjectState(cachedMessage.subject)), {
        title: correctTitle,
        subject: subjectObject.subject || "",
        subjectCounter: subjectObject.subjectCounter || servicesInternationalization.localize("Subject (%d/%d)", "0", this.subjectLimit),
        isSubjectValid: subjectObject.isSubjectValid || !1,
        content: contentObject.content || "",
        contentCounter: contentObject.contentCounter || servicesInternationalization.localize("Message (%d/%d)", "0", this.contentLimit),
        isContentValid: contentObject.isContentValid || !1
      }
    },
    getContentState: function(value) {
      value = value || "";
      var isContentValid, valueLength = value.length;
      return valueLength > +this.contentLimit && (value = value.substr(0, +this.contentLimit), valueLength = this.contentLimit), isContentValid = valueLength >= settingsGameConstant.MIN_LENGTH_CONTENT && valueLength <= this.contentLimit, {
        content: value,
        contentCounter: servicesInternationalization.localize("Message (%d/%d)", valueLength, this.contentLimit),
        isContentValid: isContentValid
      }
    },
    getSubjectState: function(value) {
      value = value || "";
      var valueLength = value.length, isSubjectValid = valueLength >= settingsGameConstant.MIN_LENGTH_SUBJECT && valueLength <= this.subjectLimit;
      return {
        subject: value,
        subjectCounter: servicesInternationalization.localize("Subject (%d/%d)", valueLength, this.subjectLimit),
        isSubjectValid: isSubjectValid
      }
    },
    getInitialState: function() {
      return this.getNewState(this.props.settings)
    },
    componentWillReceiveProps: function(newProps) {
      newProps.settings.mode !== this.props.settings.mode && this.setState(this.getNewState(newProps.settings), null)
    },
    cacheMessageContent: function() {
      switch (this.props.settings.mode) {
        case settingsGameConstant.NEW_MESSAGE_MODE.CREATE:
        case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_DISCUSSION:
          servicesGameDataManager.messagesCollection.cacheDiscussionMessageContent({
            identifier: this.cacheIdentifier,
            content: this.state.content,
            subject: this.state.subject
          });
          break;
        case settingsGameConstant.NEW_MESSAGE_MODE.POST_IN_FORUM:
        case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_FORUM:
          servicesGameDataManager.forumsCollection.cacheThreadMessageContent({
            identifier: this.cacheIdentifier,
            content: this.state.content,
            subject: this.state.subject
          })
      }
    },
    onContentChange: function(event, newContent) {
      var value = newContent || event.target.value;
      this.setState(this.getContentState(value), this.cacheMessageContent)
    },
    onSubjectChange: function(event) {
      var value = event.target.value;
      this.setState(this.getSubjectState(value), this.cacheMessageContent)
    },
    onSubmit: function() {
      switch (this.props.presenter.notify(xy.eNames.menuMessagesNew.onMessageSubmit, {
        newMessage: {
          recipient: this.props.settings.recipient,
          recipients: this.props.settings.recipients,
          subject: this.state.subject,
          content: this.state.content
        }, options: { mode: this.props.settings.mode, message: this.props.settings.message }
      }), this.props.settings.mode) {
        case settingsGameConstant.NEW_MESSAGE_MODE.CREATE:
        case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_DISCUSSION:
          servicesGameDataManager.messagesCollection.deleteDiscussionMessageContent(this.cacheIdentifier);
          break;
        case settingsGameConstant.NEW_MESSAGE_MODE.POST_IN_FORUM:
        case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_FORUM:
          servicesGameDataManager.forumsCollection.deleteThreadMessageContent(this.cacheIdentifier)
      }
    },
    render: function() {
      var settings = {
        mode: null,
        message: null,
        recipient: null,
        recipients: null,
        showRecipient: !1,
        subject: null,
        content: null
      }, titleSettings = {};
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      if (titleSettings.title = servicesInternationalization.localize(this.state.title), titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, this.showRecipient) {
        var recipient = "";
        settings.recipient && (recipient = servicesInternationalization.localize("Receiver") + ": " + settings.recipient.nick), settings.recipients && (recipient = servicesInternationalization.localize("Receiver") + ": " + utilsObject.effectiveLength(settings.recipients)), sectionComponentSettings = { title: recipient }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "component-recipient"
        }))
      }
      this.showSubject && (sectionComponentSettings = {
        counter: this.state.subjectCounter,
        maxLength: this.subjectLimit,
        value: this.state.subject !== !1 ? this.state.subject : settings.subject,
        onChange: this.onSubjectChange
      }, componentsSections.push(React.createElement(ComponentsInputSubject, {
        settings: sectionComponentSettings,
        key: "component-subject"
      }))), this.showContent && (sectionComponentSettings = {
        counter: this.state.contentCounter,
        value: this.state.content !== !1 ? this.state.content : settings.content,
        onChange: this.onContentChange
      }, componentsSections.push(React.createElement(ComponentsInputContent, {
        settings: sectionComponentSettings,
        key: "component-content"
      })));
      var isSubjectValid = !1;
      (this.showSubject === !1 || this.showSubject === !0 && this.state.isSubjectValid === !0) && (isSubjectValid = !0), sectionComponentSettings = {
        onClick: this.onSubmit,
        title: servicesInternationalization.localize("Send Message"),
        disabled: !(this.state.isContentValid && isSubjectValid)
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-send"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessagesNew.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuMessagesNewController(options) {
    MenuMessagesNewController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Messages")
  }

  return utilsOop.extend(MenuMessagesNewController, CoreControllerElementMenu), MenuMessagesNewController.prototype[xy.eNames.menuMessagesNew.onMessageSubmit] = function(data) {
    this.dataSource.prepareNewMessageToSend(data)
  }, MenuMessagesNewController.prototype[xy.eNames.menuMessagesNew.sent] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuMessagesNewController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.initialOptions)
  }, MenuMessagesNewController
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessagesNew.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.log, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesLog) {
  "use strict";
  function MenuMessagesNewDataSource(options) {
    MenuMessagesNewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMessagesNewDataSource, CoreDataSource), MenuMessagesNewDataSource.prototype.prepareNewMessageToSend = function(data) {
    switch (data.options.mode) {
      case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_DISCUSSION:
        this.replyDiscussion(data.newMessage, data.options);
        break;
      case settingsGameConstant.NEW_MESSAGE_MODE.CREATE:
        this.createDiscussion(data.newMessage);
        break;
      case settingsGameConstant.NEW_MESSAGE_MODE.POST_IN_FORUM:
        this.createThread(data.newMessage);
        break;
      case settingsGameConstant.NEW_MESSAGE_MODE.REPLY_FORUM:
        this.replyToThread(data.newMessage, data.options);
        break;
      default:
        servicesLog("warn", "Unknown mode for new message: " + data.options.mode)
    }
  }, MenuMessagesNewDataSource.prototype.replyDiscussion = function(newMessage, options) {
    options.message || servicesLog("warn", "Tying to reply in unknown discussion"), this.request({
      discussionId: options.message.id,
      content: newMessage.content
    }, "DiscussionAction/addDiscussionEntry", { callBack: this.onSentToDiscussion })
  }, MenuMessagesNewDataSource.prototype.createDiscussion = function(newMessage) {
    var recipient = null;
    if (newMessage.recipient && (recipient = newMessage.recipient.id), newMessage.recipients) {
      var id;
      recipient = [];
      for (id in newMessage.recipients)newMessage.recipients.hasOwnProperty(id) && newMessage.recipients[id] && recipient.push(id)
    }
    this.request({
      receivingPlayerArray: recipient,
      subject: newMessage.subject,
      content: newMessage.content
    }, "DiscussionAction/createDiscussion", { callBack: this.onSentToDiscussion })
  }, MenuMessagesNewDataSource.prototype.createThread = function(newMessage) {
    this.request({
      topic: newMessage.subject,
      content: newMessage.content
    }, "ForumAction/createForumThread", { callBack: this.handleSessionUpdateResponse }), this.onPostToForum()
  }, MenuMessagesNewDataSource.prototype.replyToThread = function(newMessage, options) {
    options.message || servicesLog("warn", "Tying to reply in unknown discussion"), this.request({
      id: options.message.id,
      content: newMessage.content
    }, "ForumAction/createForumMessage", { callBack: this.handleSessionUpdateResponse }), this.onPostToForum()
  }, MenuMessagesNewDataSource.prototype.onSentToDiscussion = function(data) {
    servicesGameDataManager.messagesCollection.updateMessageContent(data.Data), this.notify(xy.eNames.menuMessagesNew.sent)
  }, MenuMessagesNewDataSource.prototype.onPostToForum = function() {
    this.notify(xy.eNames.menuMessagesNew.sent)
  }, MenuMessagesNewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessagesNew.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMessagesNew.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMessagesNewComponent) {
  "use strict";
  function MenuMessagesNewPresenter(options) {
    MenuMessagesNewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMessagesNewPresenter, CorePresenterElementMenu), MenuMessagesNewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMessagesNewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMessagesNewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessagesThread.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.message, xy.dNames.components.messageDiscussionEntry, xy.dNames.components.messageDiscussionMemberChange, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsMessageSystem, ComponentsMessageDiscussionEntry, ComponentsMessageDiscussionMemberChange) {
  "use strict";
  return componentsEngine.createClass({
    shouldComponentScroll: !1, mixins: [mixinsMenuComponentHandlers], setScrollPosition: function() {
      this.scrollToMenuElement({
        container: settingsGameConstant.COMPONENTS_REFS.MESSAGES.CONTAINER,
        target: settingsGameConstant.COMPONENTS_REFS.MESSAGES.TARGET
      })
    }, componentDidMount: function() {
      this.setScrollPosition()
    }, componentWillReceiveProps: function(newProps) {
      this.shouldComponentScroll = newProps.settings.message.id !== this.props.settings.message.id
    }, componentDidUpdate: function() {
      this.shouldComponentScroll && (this.shouldComponentScroll = !1, this.setScrollPosition())
    }, sendNewMessage: function(originalMessage, newMessage, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuMessagesThread.sendMessage, {
        originalMessage: originalMessage,
        newMessage: newMessage
      })
    }, deleteMessage: function(message, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuMessagesThread.deleteMessage, message)
    }, render: function() {
      var settings = {
        message: null,
        recipientsList: [],
        possibleRecipientsToAdd: [],
        isMassMailSender: !1
      }, titleSettings = {};
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, message = settings.message, componentsSections = [];
      if (titleSettings.title = message.title, this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], message.isSystemMessage)sectionComponentSettings = {
        date: message.lastEntryDate,
        content: message.content
      }, componentsSections.push(React.createElement(ComponentsMessageSystem, {
        settings: sectionComponentSettings,
        key: "messages=system-component"
      })); else {
        settings.isMassMailSender && titleSettings.rightButton.push({
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuPlayersList.name,
            options: {
              message: settings.message,
              playersList: settings.possibleRecipientsToAdd,
              mode: settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_ADD_RECIPIENTS,
              customLocalizedTitle: servicesInternationalization.localize("Add recipient")
            }
          }), icon: "controls menu-bar-add-member"
        }), message.discussionListenerArray && (sectionComponentSettings = {
          rightColumnDataValue: message.discussionListenerArray.length,
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuPlayersList.name,
            options: {
              message: settings.message,
              playersList: settings.recipientsList,
              mode: settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_OVERVIEW_RECIPIENTS,
              customLocalizedTitle: servicesInternationalization.localize("Participants")
            }
          }),
          title: servicesInternationalization.localize("Participants")
        }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "menu-button-show-participants"
        })));
        var isLastReadMessage = !1;
        message.discussionEvents.forEach(function(eventEntry, index) {
          var settings, isLast;
          switch (eventEntry.entityName) {
            case"DiscussionEntry":
              settings = {
                executingComponent: this,
                forumMessage: eventEntry
              }, isLast = message.discussionEntryArray.length - 1 === index, !isLastReadMessage && !eventEntry.isRead || !isLastReadMessage && isLast ? (isLastReadMessage = !0, componentsSections.push(React.createElement(ComponentsMessageDiscussionEntry, {
                ref: settingsGameConstant.COMPONENTS_REFS.MESSAGES.TARGET,
                settings: settings,
                key: "discussion-entry-" + index
              }))) : componentsSections.push(React.createElement(ComponentsMessageDiscussionEntry, {
                settings: settings,
                key: "discussion-entry-" + index
              }));
              break;
            case"DiscussionMemberChange":
              settings = {
                executingComponent: this,
                changesModel: eventEntry
              }, componentsSections.push(React.createElement(ComponentsMessageDiscussionMemberChange, {
                settings: settings,
                key: "discussion-members-changes-entry-" + index
              }))
          }
        }, this), sectionComponentSettings = {
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuMessagesNew.name,
            options: {
              message: this.props.settings.message,
              mode: settingsGameConstant.NEW_MESSAGE_MODE.REPLY_DISCUSSION
            }
          }), title: servicesInternationalization.localize("Reply")
        }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "menu-button-reply"
        }))
      }
      titleSettings.rightButton.push({
        onClick: this.deleteMessage.bind(this, message),
        icon: "controls menu-bar-delete"
      });
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MESSAGES.CONTAINER
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuMessagesThread.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, utilsObject, servicesGameDataManager, servicesInternationalization) {
  "use strict";
  function MenuMessagesThreadController(options) {
    MenuMessagesThreadController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.messages,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Messages")
  }

  return utilsOop.extend(MenuMessagesThreadController, CoreControllerElementMenu), MenuMessagesThreadController.prototype[xy.eNames.menuMessagesThread.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuMessagesThreadController.prototype[xy.eNames.menuMessagesThread.onRecipientWereManaged] = function(options) {
    options = options || {}, options.selfDeleteFromRecipient ? this.notify(xy.eNames.menu.closeViewUpToRoot) : this.notify(xy.eNames.menu.closeViewUpToSelf, { key: this.instanceId })
  }, MenuMessagesThreadController.prototype[xy.eNames.menuMessagesThread.addRecipients] = function(options) {
    this.dataSource.addPLayersToDiscussion(options)
  }, MenuMessagesThreadController.prototype[xy.eNames.menuMessagesThread.deleteRecipients] = function(options) {
    this.showDialogDialog({
      title: servicesInternationalization.localize("Verify"),
      text: servicesInternationalization.localize("Remove participants (%1$ld)", utilsObject.effectiveLength(options.recipients)),
      callbackSuccess: this.dataSource.deletePLayersFromDiscussion.bind(this.dataSource, options)
    })
  }, MenuMessagesThreadController.prototype[xy.eNames.menuMessagesThread.deleteAllRecipients] = function(options) {
    this.showDialogDialog({
      title: servicesInternationalization.localize("Verify"),
      text: servicesInternationalization.localize("Remove all participants"),
      callbackSuccess: this.dataSource.deletePLayersFromDiscussion.bind(this.dataSource, options)
    })
  }, MenuMessagesThreadController.prototype[xy.eNames.menuMessagesThread.deleteMessage] = function(message) {
    this.showDialogDialog({
      callbackSuccess: function() {
        this.dataSource.deleteMessage(message), this[xy.eNames.menu.openPrevView]()
      }.bind(this),
      title: servicesInternationalization.localize("Verify"),
      text: servicesInternationalization.localize("Delete message?")
    })
  }, MenuMessagesThreadController.prototype.prepareDataForDraw = function() {
    this.isActive && (servicesGameDataManager.messagesCollection.isMessageThreadDeleted(this.initialOptions.message.id) ? this[xy.eNames.menu.openPrevView]() : this.dataSource.getMessageThread(this.initialOptions.message))
  }, MenuMessagesThreadController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMessagesThread.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.log, function(gameInstance, CoreDataSource, utilsOop, servicesGameDataManager, servicesLog) {
  "use strict";
  function MenuMessagesThreadDataSource(options) {
    var menuMessageDataSource = gameInstance.injector.get(xy.dNames.game.menuMessages.dataSource);
    this.forLinking = [{
      resourceClass: menuMessageDataSource,
      methodName: "deleteMessages"
    }, { resourceClass: menuMessageDataSource, methodName: "onDeleteMessages" }, {
      resourceClass: menuMessageDataSource,
      methodName: "receiveMessages"
    }], MenuMessagesThreadDataSource.__super__.constructor.call(this, options), this.selfDeleteFromRecipientFlag = !1
  }

  return utilsOop.extend(MenuMessagesThreadDataSource, CoreDataSource), MenuMessagesThreadDataSource.prototype.getMessageThread = function(message) {
    var action, params = {};
    if (this.initialMessage = message, message.isSystemMessage) {
      if (message.isRead && message.content)return void this.notify(xy.eNames.menuMessagesThread.dataIsReady, { message: message });
      action = "SystemMessageAction/displaySystemMessage", params.systemMessageId = message.id
    } else action = "DiscussionAction/discussion", params.discussionId = message.id;
    this.request(params, action, { callBack: this.receiveThreadData })
  }, MenuMessagesThreadDataSource.prototype.receiveThreadData = function(data) {
    servicesGameDataManager.messagesCollection.updateMessageContent(data.Data);
    var message = servicesGameDataManager.messagesCollection.getMessage(this.initialMessage), isMassMailSender = servicesGameDataManager.playersCollection.getPlayer().canMassMail(), alliance = servicesGameDataManager.alliancesCollection.getAlliance(), possibleRecipientsToAdd = [], messageListenersSet = {};
    message && message.discussionListenerArray instanceof Array && message.discussionListenerArray.forEach(function(playerId) {
      messageListenersSet[playerId] = !0
    }), alliance && alliance.playerArray instanceof Array && alliance.playerArray.forEach(function(playerId) {
      messageListenersSet.hasOwnProperty(playerId) || possibleRecipientsToAdd.push(playerId)
    }), this.notify(xy.eNames.menuMessagesThread.dataIsReady, {
      message: message,
      isMassMailSender: isMassMailSender,
      recipientsList: message.discussionListenerArray,
      possibleRecipientsToAdd: possibleRecipientsToAdd
    })
  }, MenuMessagesThreadDataSource.prototype.deleteMessage = function(message) {
    var messagesSet = {};
    messagesSet[message.id] = message, this.deleteMessages(messagesSet)
  }, MenuMessagesThreadDataSource.prototype.addPLayersToDiscussion = function(options) {
    var key, newRecipients = [];
    for (key in options.recipients)options.recipients.hasOwnProperty(key) && options.recipients[key] && newRecipients.push(options.recipients[key].id);
    this.request({
      discussionId: options.message.id,
      playerIDArray: newRecipients
    }, "DiscussionAction/addDiscussionMembers", { callBack: this.onRecipientManagementCallback })
  }, MenuMessagesThreadDataSource.prototype.deletePLayersFromDiscussion = function(options) {
    var key, recipients = [], playerId = servicesGameDataManager.getPlayerId();
    for (key in options.recipients)options.recipients.hasOwnProperty(key) && options.recipients[key] && (recipients.push(+key), playerId === +key && (this.selfDeleteFromRecipientFlag = !0));
    this.request({
      discussionId: options.message.id,
      playerIDArray: recipients
    }, "DiscussionAction/releaseFromDiscussionV2", { callBack: this.onRecipientManagementCallback })
  }, MenuMessagesThreadDataSource.prototype.onRecipientManagementCallback = function(data) {
    var selfDeleteFromRecipient = !1;
    this.selfDeleteFromRecipientFlag && (selfDeleteFromRecipient = !0, this.selfDeleteFromRecipientFlag = !1);
    var discussion = [];
    try {
      discussion = data.Data.Discussion
    } catch (ex) {
      servicesLog("warn", "Discussions Array is absent in server response")
    }
    servicesGameDataManager.messagesCollection.updateDiscussions(discussion, {
      isResetOnUpdate: selfDeleteFromRecipient,
      fireMessageChecking: !0
    }), this.notify(xy.eNames.menuMessagesThread.onRecipientWereManaged, { selfDeleteFromRecipient: selfDeleteFromRecipient })
  }, MenuMessagesThreadDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMessagesThread.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMessagesThread.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMessagesThreadComponent) {
  "use strict";
  function MenuMessagesThreadPresenter(options) {
    MenuMessagesThreadPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMessagesThreadPresenter, CorePresenterElementMenu), MenuMessagesThreadPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMessagesThreadComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMessagesThreadPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuReports.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuBottomBarMain, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuTapBar, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuBottomBarMain, ComponentsMenuListTextBasic, ComponentsMenuTapBar) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function() {
      return this.selectedReportsIdsSet = {}, { editMode: !1, selectedAmount: 0 }
    }, getInitialState: function() {
      return this.getNewState()
    }, componentWillReceiveProps: function(newProps) {
      var isReportsMissing = newProps.settings.groupedReportsList.groupsKeys && newProps.settings.groupedReportsList.groupsKeys.length < 1;
      (newProps.settings.currentReportGroup !== this.props.settings.currentReportGroup || isReportsMissing) && this.setState(this.getNewState(), null)
    }, determineEditingMode: function(event) {
      event.preventDefault(), event.stopPropagation(), this.state.editMode || (this.selectedReportsIdsSet = {}), this.setState({
        editMode: !this.state.editMode,
        selectedAmount: 0
      }, null)
    }, onCheckboxClick: function(report, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedAmount = +this.state.selectedAmount;
      this.selectedReportsIdsSet[report.id] ? (this.selectedReportsIdsSet[report.id] = !1, selectedAmount -= 1) : (this.selectedReportsIdsSet[report.id] = report, selectedAmount += 1), this.setState({ selectedAmount: selectedAmount }, null)
    }, deleteSelectedEntries: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuReports.deleteReports, this.selectedReportsIdsSet), this.selectedReportsIdsSet = {}, this.setState({ selectedAmount: 0 }, null)
    }, deleteAllEntries: function(event) {
      event.preventDefault(), event.stopPropagation();
      var reportsIdsSet;
      reportsIdsSet = servicesGameDataManager.reportsCollection.getReportsSetOfGroup({ onlyReportGroup: this.props.settings.currentReportGroup }), this.props.presenter.notify(xy.eNames.menuReports.deleteAllReports, reportsIdsSet)
    }, updateReportType: function(reportType, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuReports.setCurrentReportGroup, { newCurrentReportGroup: reportType })
    }, render: function() {
      var settings = {
        groupButtons: [],
        currentReportGroup: 0,
        groupedReportsList: {},
        groupsAmount: {}
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], bottomBarSection = null, buildReportList = function(report) {
        var reportSettings = {
          title: report.title,
          description: report.description,
          classes: report.extraClasses,
          iconLeft: report.icon,
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuReportsOverview.name,
            options: { reportId: report.id, currentReportGroup: settings.currentReportGroup }
          })
        };
        this.state.editMode && (reportSettings.isSelectable = !0, reportSettings.onSelect = this.onCheckboxClick.bind(this, report), this.selectedReportsIdsSet[report.id] && (reportSettings.isSelected = !0)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: reportSettings,
          key: "menu-element-report-in-list-" + report.id
        }))
      };
      if (this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
                icon: "controls menu-bar-settings",
                onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuReportsSettings.name })
              }), this.state.editMode) {
        titleSettings.rightButton.push({
          title: servicesInternationalization.localize("cancel"),
          onClick: this.determineEditingMode
        });
        var bottomBarSectionSettings = {
          leftButton: {
            onClick: this.deleteSelectedEntries,
            title: servicesInternationalization.localize("Delete entries (%ld)", +this.state.selectedAmount),
            isDisabled: this.state.selectedAmount < 1
          }, rightButton: { onClick: this.deleteAllEntries, icon: "controls menu-bar-delete" }
        };
        bottomBarSection = React.createElement(ComponentsMenuBottomBarMain, { settings: bottomBarSectionSettings })
      } else titleSettings.rightButton.push({
        icon: "controls menu-bar-edit",
        onClick: this.determineEditingMode,
        isDisabled: settings.groupedReportsList.groupsKeys && settings.groupedReportsList.groupsKeys.length < 1
      });
      var tapBarSettings = { buttons: [] }, activeGroupId = settings.currentReportGroup;
      settings.groupButtons.forEach(function(group) {
        tapBarSettings.buttons.push({
          isActive: activeGroupId === group.id,
          icon: group.icon,
          title: settings.groupsAmount.hasOwnProperty(group.id) ? settings.groupsAmount[group.id] : "0",
          onClick: this.updateReportType.bind(this, group.id)
        })
      }, this), settings.groupedReportsList.groupsKeys && settings.groupedReportsList.groupsKeys.length ? settings.groupedReportsList.groupsKeys.forEach(function(groupKey, index) {
        var date = settings.groupedReportsList.humanKeysSet[groupKey], titleSettings = { title: utilsDateTime.getLocaleDateString(date) };
        componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: titleSettings,
          key: "menu-title-date-" + date.toISOString()
        })), settings.groupedReportsList.groups[index].forEach(buildReportList, this)
      }, this) : (sectionComponentSettings = { text: servicesInternationalization.localize("You don't have any reports in this category.") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-no-messages"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: null,
        bottomBar: bottomBarSection,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuReports.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuReportsController(options) {
    MenuReportsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.report,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuReports.dataIsAvailable]
    }, {
      entity: xy.eNames.dataListeners.dataEntity.report,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Reports"), this.currentReportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE
  }

  return utilsOop.extend(MenuReportsController, CoreControllerElementMenu), MenuReportsController.prototype[xy.eNames.menuReports.dataIsAvailable] = function() {
    this.isActive && this.presenter.draw(this.dataSource.prepareReportsList({ currentReportGroup: this.currentReportGroup }))
  }, MenuReportsController.prototype[xy.eNames.menuReports.deleteReports] = function(selectedReportsSet) {
    this.dataSource.deleteReports(selectedReportsSet)
  }, MenuReportsController.prototype[xy.eNames.menuReports.deleteAllReports] = function(reportsSet) {
    this.showDialogDialog({
      title: "Verify",
      text: servicesInternationalization.localize("Delete reports?"),
      callbackSuccess: this.dataSource.deleteReports.bind(this.dataSource, reportsSet)
    })
  }, MenuReportsController.prototype[xy.eNames.menuReports.setCurrentReportGroup] = function(data) {
    data.newCurrentReportGroup && this.currentReportGroup !== data.newCurrentReportGroup && (this.currentReportGroup = data.newCurrentReportGroup, this[xy.eNames.menuReports.dataIsAvailable]())
  }, MenuReportsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getReports()
  }, MenuReportsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuReports.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, settingsGameConstant) {
  "use strict";
  function MenuReportsDataSource(options) {
    MenuReportsDataSource.__super__.constructor.call(this, options), this.generateGroupsForTabs()
  }

  return utilsOop.extend(MenuReportsDataSource, CoreDataSource), MenuReportsDataSource.prototype.generateGroupsForTabs = function() {
    var key, id, reportsTabs = [];
    for (key in settingsGameConstant.REPORT_GROUP)settingsGameConstant.REPORT_GROUP.hasOwnProperty(key) && (id = settingsGameConstant.REPORT_GROUP[key], reportsTabs.push({
      id: id,
      icon: servicesTheme.getImageClassName("topBar-" + id, "report"),
      amount: 0
    }));
    this.reportsTabs = reportsTabs
  }, MenuReportsDataSource.prototype.getReports = function() {
    servicesGameDataManager.reportsCollection.updated ? this.notify(xy.eNames.menuReports.dataIsAvailable) : this.request({}, "ReportAction/habitatReportArray", { callBack: this.receiveReports })
  }, MenuReportsDataSource.prototype.receiveReports = function(data) {
    servicesGameDataManager.reportsCollection.updateReportsData(data)
  }, MenuReportsDataSource.prototype.prepareReportsList = function(options) {
    var response = {}, group = null;
    return options.currentReportGroup && (response.currentReportGroup = group = options.currentReportGroup), response.groupedReportsList = servicesGameDataManager.reportsCollection.getGroupedReportsList({ onlyReportGroup: group }), response.groupButtons = this.reportsTabs, response.groupsAmount = servicesGameDataManager.reportsCollection.groupsAmount, servicesGameDataManager.reportsCollection.onShow(), response
  }, MenuReportsDataSource.prototype.deleteReports = function(selectedReportsSet) {
    var key, reportsIdsArray = [];
    for (key in selectedReportsSet)selectedReportsSet.hasOwnProperty(key) && selectedReportsSet[key] !== !1 && reportsIdsArray.push(key);
    this.request({ idArray: reportsIdsArray }, "ReportAction/deleteHabitatReportArray", { callBack: this.onDeleteReports.bind(this, reportsIdsArray) })
  }, MenuReportsDataSource.prototype.onDeleteReports = function(deletedReportsId, updatedReports) {
    servicesGameDataManager.reportsCollection.onDeleteReports({
      updatedReports: updatedReports,
      deletedReportsId: deletedReportsId
    })
  }, MenuReportsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuReports.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuReports.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuReportsComponent) {
  "use strict";
  function MenuReportsPresenter(options) {
    MenuReportsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuReportsPresenter, CorePresenterElementMenu), MenuReportsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuReportsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuReportsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTapBarReportSwitcher, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListButtonDisplayLink, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetBatchResourcesUnits, xy.dNames.components.widgetResourcesList, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, utilsObject, settingsGameConstant, servicesTheme, servicesGameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsWidgetReportSwitcher, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsMenuListButtonDisplayLink, ComponentMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsWidgetBatchResourcesUnits, ComponentsWidgetResourcesList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { activeModelLinkClicker: 0 }
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.report.id === this.props.settings.report.id && newProps.settings.report.published !== this.props.settings.report.published && servicesGameDataManager.isModelHasActiveLink(newProps.settings.report) && this.clearActiveModelLink()
    }, deleteReport: function(event) {
      event.preventDefault();
      var selectedReportsSet = {};
      selectedReportsSet[this.props.settings.report.id] = !0, this.props.presenter.notify(xy.eNames.eventsMenuReportsOverview.deleteReportsOverview, selectedReportsSet)
    }, switchReport: function(reportId, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.eventsMenuReportsOverview.switchReport, { reportId: reportId })
    }, onPublishBtnClickHandler: function(reportId, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.eventsMenuReportsOverview.publishReportClick, { reportId: reportId })
    }, onUnPublishBtnClickHandler: function(reportId, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.eventsMenuReportsOverview.unPublishReportClick, { reportId: reportId })
    }, onCopyLinkBtnClick: function(reportId, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.eventsMenuReportsOverview.copyReportLink, { reportId: reportId })
    }, render: function() {
      var settings = {
        report: {},
        reportIndexInGroup: 0,
        reportsInGroupLength: 0,
        prevReportsId: 0,
        nextReportsId: 0,
        isReportExternal: !1
      }, titleSettings = {};
      Object.assign(settings, this.props.settings);
      var sectionSettings, componentsSections = [], tapBar = null, report = settings.report || {}, habitat = servicesGameDataManager.habitatsCollection.getHabitatDataForReport(report.habitat);
      if (titleSettings.title = servicesInternationalization.localize(settingsGameConstant.REPORT_GROUP_NAME[report.reportGroup]), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, !settings.isReportExternal) {
        titleSettings.rightButton = [], titleSettings.rightButton.push({
          onClick: this.deleteReport,
          icon: "controls menu-bar-delete"
        });
        var tapBarSettings = { title: settings.reportIndexInGroup + "/" + settings.reportsInGroupLength };
        settings.prevReportsId && (tapBarSettings.leftArrowOnClick = this.switchReport.bind(this, settings.prevReportsId)), settings.nextReportsId && (tapBarSettings.rightArrowOnClick = this.switchReport.bind(this, settings.nextReportsId)), tapBar = React.createElement(ComponentsWidgetReportSwitcher, { settings: tapBarSettings })
      }
      sectionSettings = {
        title: habitat.name,
        description: utilsDateTime.getLocaleDateTimeString(report.date),
        iconLeft: "icon-game icon-CenterHabitat-" + habitat.publicHabitatType,
        onClick: this.handlerCenterMap.bind(this, habitat)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionSettings,
        key: "menu-element-report-habitat"
      })), sectionSettings = {
        title: report.title,
        description: report.fullDescription,
        iconLeft: report.icon
      }, report.centerMapOnDescriptionCooredinates && (sectionSettings.onClick = this.handlerCenterMap.bind(this, report.centerMapOnDescriptionCooredinates)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionSettings,
        key: "menu-element-missions-description"
      })), settings.isReportExternal || (report.published ? (sectionSettings = {
        title: servicesInternationalization.localize("Publish report"),
        onClick: this.onUnPublishBtnClickHandler.bind(this, report.id),
        iconLeft: "icon-game icon-BuffActivate"
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionSettings,
        key: "report-overview-un-publish-btn"
      })), sectionSettings = {
        onClick: this.onGetModelLinkClick.bind(this, report),
        targetModel: report,
        defaultTitle: servicesInternationalization.localize("Display report link")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonDisplayLink, {
        settings: sectionSettings,
        key: "report-overview-copy-btn"
      }))) : (sectionSettings = {
        title: servicesInternationalization.localize("Publish report"),
        onClick: this.onPublishBtnClickHandler.bind(this, report.id)
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionSettings,
        key: "report-overview-publish-btn"
      })))), report.content.destinationETA && (sectionSettings = { title: servicesInternationalization.localize("Destination ETA") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionSettings,
        key: "component-title-offenders-eta"
      })), sectionSettings = {
        title: utilsDateTime.getLocaleDateTimeString(report.content.destinationETA),
        iconLeft: "icon-game icon-" + (utilsDateTime.isNight({ time: report.content.destinationETA }) ? "Arrive_Day" : "Arrive_Night")
      }, componentsSections.push(React.createElement(ComponentMenuListElementBasic, {
        settings: sectionSettings,
        key: "component-offenders-eta"
      }))), report.content.silverAmount && (sectionSettings = { title: servicesInternationalization.localize("Cost") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionSettings,
        key: "component-title-sent-silver-production"
      })), sectionSettings = {
        title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[servicesTheme.themeSettings.resources.conquestResourceId]),
        iconLeft: "icon-resource icon-resource-" + servicesTheme.themeSettings.resources.conquestResourceId,
        rightColumnDataValue: report.content.silverAmount
      }, componentsSections.push(React.createElement(ComponentMenuListElementBasic, {
        settings: sectionSettings,
        key: "component-spent-silver-production"
      }))), report.content.copperAmount && (sectionSettings = { title: servicesInternationalization.localize("Cost") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionSettings,
        key: "component-title-spent-spy-resources"
      })), sectionSettings = {
        title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[servicesTheme.themeSettings.resources.spyResourceId]),
        iconLeft: "icon-resource icon-resource-" + servicesTheme.themeSettings.resources.spyResourceId,
        rightColumnDataValue: report.content.copperAmount
      }, componentsSections.push(React.createElement(ComponentMenuListElementBasic, {
        settings: sectionSettings,
        key: "component-spent-spy-resources"
      })));
      var buildingsTile, buildingId, buildingSet, building;
      switch (report.type) {
        case settingsGameConstant.REPORT_TYPE.SPY_FINISHED:
          buildingsTile = "Spied Buildings", utilsObject.isEmpty(report.content.buildings) || (buildingSet = report.content.buildings)
      }
      if (buildingSet) {
        sectionSettings = { title: servicesInternationalization.localize(buildingsTile) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-buildings"
        }));
        for (buildingId in buildingSet)buildingSet.hasOwnProperty(buildingId) && (building = servicesGameDataManager.buildingsCollection.getBuilding({ pk: buildingId }), sectionSettings = {
          title: servicesInternationalization.localize(building.title),
          iconLeft: building.icon,
          rightColumnDataValue: buildingSet[buildingId]
        }, componentsSections.push(React.createElement(ComponentMenuListElementBasic, {
          settings: sectionSettings,
          key: "component-report-building-" + buildingId
        })))
      }
      var resourceTile, resourceSet;
      switch (report.type) {
        case settingsGameConstant.REPORT_TYPE.SPY_FINISHED:
          resourceTile = "Spied Resources", utilsObject.isEmpty(report.content.resourceDictionary) || (resourceSet = report.content.resourceDictionary);
          break;
        case settingsGameConstant.REPORT_TYPE.MISSION_FINISHED:
          resourceTile = "Carried resources", utilsObject.isEmpty(report.content.resourceProduction) || (resourceSet = report.content.resourceProduction);
          break;
        case settingsGameConstant.REPORT_TYPE.TRANSIT_RETURNED:
        case settingsGameConstant.REPORT_TYPE.DELIVERED_DEFENSE:
        case settingsGameConstant.REPORT_TYPE.DELIVERED_RESOURCES:
          resourceTile = "Transit resources", utilsObject.isEmpty(report.content.resourceDictionary) || (resourceSet = report.content.resourceDictionary)
      }
      resourceSet && (sectionSettings = { title: servicesInternationalization.localize(resourceTile) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionSettings,
        key: "component-title-resource-production"
      })), sectionSettings = { resourcesDictionary: resourceSet }, componentsSections.push(React.createElement(ComponentsWidgetResourcesList, {
        settings: sectionSettings,
        key: "component-resource-list-widget"
      })));
      var unitTitle, unitId, unitsSet;
      switch (report.type) {
        case settingsGameConstant.REPORT_TYPE.SPY_FINISHED:
          unitTitle = "Spied Units", utilsObject.isEmpty(report.content.unitDictionary) || (unitsSet = report.content.unitDictionary);
          break;
        case settingsGameConstant.REPORT_TYPE.MISSION_FINISHED:
          unitTitle = "Units produced", utilsObject.isEmpty(report.content.unitProduction) || (unitsSet = report.content.unitProduction);
          break;
        case settingsGameConstant.REPORT_TYPE.TRANSIT_RETURNED:
        case settingsGameConstant.REPORT_TYPE.DELIVERED_DEFENSE:
        case settingsGameConstant.REPORT_TYPE.DELIVERED_RESOURCES:
          unitTitle = "Troops", utilsObject.isEmpty(report.content.unitDictionary) || (unitsSet = report.content.unitDictionary)
      }
      if (unitsSet) {
        sectionSettings = { title: servicesInternationalization.localize(unitTitle) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-report-units"
        }));
        for (unitId in unitsSet)unitsSet.hasOwnProperty(unitId) && (sectionSettings = {
          title: servicesInternationalization.localize(servicesGameDataManager.unitsCollection.getUnitProperty("identifier", { primaryKey: unitId })),
          iconLeft: "icon-unit icon-unit-" + unitId,
          rightColumnDataValue: unitsSet[unitId]
        }, componentsSections.push(React.createElement(ComponentMenuListElementBasic, {
          settings: sectionSettings,
          key: "component-report-unit-" + unitId
        })))
      }
      var warOwnUnitsAllTitle, warOwnUnitsAllSet = [];
      switch (report.reportGroup) {
        case settingsGameConstant.REPORT_GROUP.DEFENSE:
          warOwnUnitsAllTitle = "All defending units", utilsObject.isEmpty(report.content.unitDictionary) || warOwnUnitsAllSet.push({
            title: servicesInternationalization.localize("Defending Survivors"),
            units: report.content.unitDictionary
          }), utilsObject.isEmpty(report.content.lossDictionary) || warOwnUnitsAllSet.push({
            title: servicesInternationalization.localize("Defending Losses"),
            units: report.content.lossDictionary
          })
      }
      if (warOwnUnitsAllSet.length && (sectionSettings = { title: servicesInternationalization.localize(warOwnUnitsAllTitle) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionSettings,
                key: "component-title-own-units-all"
              })), warOwnUnitsAllSet.forEach(function(unitsSettings, index) {
                componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
                  settings: unitsSettings,
                  key: "own-units-all" + index
                }))
              })), report.content.offenderUnitDictionary && (sectionSettings = { title: servicesInternationalization.localize("All attacking units") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionSettings,
                key: "component-title-all-attacking-unit"
              })), utilsObject.isEmpty(report.content.offenderUnitDictionary.unitDictionary) || (sectionSettings = {
                title: servicesInternationalization.localize("Survivors"),
                units: report.content.offenderUnitDictionary.unitDictionary
              }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
                settings: sectionSettings,
                key: "all-attackers-units-survivors"
              }))), utilsObject.isEmpty(report.content.offenderUnitDictionary.lossDictionary) || (sectionSettings = {
                title: servicesInternationalization.localize("Losses"),
                units: report.content.offenderUnitDictionary.lossDictionary
              }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
                settings: sectionSettings,
                key: "all-attacker-unit-losses"
              })))), !utilsObject.isEmpty(report.content.ownOffenderUnitDictionary)) {
        var ownAttackingHabitatKey, ownHabitat;
        sectionSettings = { text: servicesInternationalization.localize("Your attacking units") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionSettings,
          key: "component-title-own-attacking-unit"
        }));
        for (ownAttackingHabitatKey in report.content.ownOffenderUnitDictionary)report.content.ownOffenderUnitDictionary.hasOwnProperty(ownAttackingHabitatKey) && (ownHabitat = report.content.ownOffenderUnitDictionary[ownAttackingHabitatKey], sectionSettings = { title: ownHabitat.habitatDictionary.name || servicesGameDataManager.habitatsCollection.getHabitatProperty("name", ownHabitat.habitatDictionary.id, { isReportRequest: !0 }) }, ownHabitat.habitatDictionary && (sectionSettings.onClick = this.handlerCenterMap.bind(this, ownHabitat.habitatDictionary)), componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-own-offender-losses-" + ownAttackingHabitatKey
        })), utilsObject.isEmpty(ownHabitat.unitDictionary) || (sectionSettings = {
          title: servicesInternationalization.localize("Survivors"),
          units: ownHabitat.unitDictionary
        }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
          settings: sectionSettings,
          key: "component-own-offender-survivors" + ownAttackingHabitatKey
        }))), utilsObject.isEmpty(ownHabitat.lossDictionary) || (sectionSettings = {
          title: servicesInternationalization.localize("Losses"),
          units: ownHabitat.lossDictionary
        }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
          settings: sectionSettings,
          key: "component-own-offender-losses" + ownAttackingHabitatKey
        }))))
      }
      if (!utilsObject.isEmpty(report.content.defenderUnitDictionary)) {
        var defenderHabitatKey, defenderHabitat;
        sectionSettings = { text: servicesInternationalization.localize("All defending units") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionSettings,
          key: "component-title-defender-losses"
        }));
        for (defenderHabitatKey in report.content.defenderUnitDictionary)report.content.defenderUnitDictionary.hasOwnProperty(defenderHabitatKey) && (defenderHabitat = report.content.defenderUnitDictionary[defenderHabitatKey], sectionSettings = { title: defenderHabitat.habitatDictionary.name || servicesGameDataManager.habitatsCollection.getHabitatProperty("name", defenderHabitat.habitatDictionary.id, { isReportRequest: !0 }) }, defenderHabitat.habitatDictionary && (sectionSettings.onClick = this.handlerCenterMap.bind(this, defenderHabitat.habitatDictionary)), componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-defender-losses-" + defenderHabitatKey
        })), utilsObject.isEmpty(defenderHabitat.unitDictionary) || (sectionSettings = {
          title: servicesInternationalization.localize("Survivors"),
          units: defenderHabitat.unitDictionary
        }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
          settings: sectionSettings,
          key: "component-defender-survivors-" + defenderHabitatKey
        }))), utilsObject.isEmpty(defenderHabitat.lossDictionary) || (sectionSettings = {
          title: servicesInternationalization.localize("Losses"),
          units: defenderHabitat.lossDictionary
        }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
          settings: sectionSettings,
          key: "component-defender-losses-" + defenderHabitatKey
        }))))
      }
      if (report.content.battlePartyDictionary && utilsObject.length(report.content.battlePartyDictionary) > 2) {
        var battlePartyHabitatKey, battleParty, battlePartySettings, battleType, battlePartyByBattleType = {};
        for (battlePartyHabitatKey in report.content.battlePartyDictionary)report.content.battlePartyDictionary.hasOwnProperty(battlePartyHabitatKey) && (battleParty = report.content.battlePartyDictionary[battlePartyHabitatKey], battlePartyByBattleType[battleParty.battleType] || (battlePartyByBattleType[battleParty.battleType] = []), battlePartySettings = {
          key: battlePartyHabitatKey,
          habitat: battleParty.habitatDictionary.name,
          onClick: this.handlerCenterMap.bind(this, battleParty.habitatDictionary)
        }, utilsObject.isEmpty(battleParty.unitDictionary) || (battlePartySettings.survivors = {
          title: servicesInternationalization.localize("Survivors"),
          units: battleParty.unitDictionary
        }), utilsObject.isEmpty(battleParty.lossDictionary) || (battlePartySettings.losses = {
          title: servicesInternationalization.localize("Losses"),
          units: battleParty.lossDictionary
        }), battlePartyByBattleType[battleParty.battleType].push(battlePartySettings));
        for (battleType in battlePartyByBattleType)if (battlePartyByBattleType.hasOwnProperty(battleType)) {
          switch (battleType = +battleType) {
            case settingsGameConstant.BATTLE_TYPE.OWN_HABITAT:
              sectionSettings = { text: servicesInternationalization.localize("Your defending units") };
              break;
            case settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE:
              sectionSettings = { text: servicesInternationalization.localize("Outbound defending troops") };
              break;
            case settingsGameConstant.BATTLE_TYPE.ATTACKER:
              sectionSettings = { text: servicesInternationalization.localize("Offending troops") };
              break;
            default:
              sectionSettings = { text: servicesInternationalization.localize("Your defending units") }
          }
          componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
            settings: sectionSettings,
            key: "component-battle-type-" + battleType
          })), battlePartyByBattleType[battleType].forEach(function(partySettings) {
            sectionSettings = {
              title: partySettings.habitat,
              onClick: partySettings.onClick
            }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
              settings: sectionSettings,
              key: "component-title-battle-party-" + partySettings.key
            })), partySettings.survivors && componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
              settings: partySettings.survivors,
              key: "component-battle-party-survivors" + partySettings.key
            })), partySettings.losses && componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
              settings: partySettings.losses,
              key: "component-battle-party-losses" + partySettings.key
            }))
          })
        }
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: tapBar,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesGameDataManager, servicesInternationalization) {
  "use strict";
  function MenuReportsOverviewController(options) {
    MenuReportsOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw.bind(this, !0)
    }, {
      entity: xy.eNames.dataListeners.dataEntity.report,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.report,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = ""
  }

  return utilsOop.extend(MenuReportsOverviewController, CoreControllerElementMenu), MenuReportsOverviewController.prototype[xy.eNames.menuReports.dataIsAvailable] = function() {
    this.isActive && this.presenter.draw(this.dataSource.prepareOverviewReportData({
      reportId: this.initialOptions.reportId,
      currentReportGroup: this.initialOptions.currentReportGroup,
      isReportExternal: this.initialOptions.isReportExternal
    }))
  }, MenuReportsOverviewController.prototype[xy.eNames.eventsMenuReportsOverview.deleteReportsOverview] = function(selectedReportsSet) {
    this.showDialogDialog({
      title: servicesInternationalization.localize("DeleteReportButtonTitle"),
      text: servicesInternationalization.localize("Delete report?"),
      callbackSuccess: this.deleteReport.bind(this, selectedReportsSet)
    })
  }, MenuReportsOverviewController.prototype[xy.eNames.eventsMenuReportsOverview.switchReport] = function(options) {
    this.initialOptions.reportId = options.reportId, this[xy.eNames.menuReports.dataIsAvailable]()
  }, MenuReportsOverviewController.prototype[xy.eNames.eventsMenuReportsOverview.publishReportClick] = function(data) {
    this.dataSource.publishReport(data)
  }, MenuReportsOverviewController.prototype[xy.eNames.eventsMenuReportsOverview.unPublishReportClick] = function(data) {
    this.dataSource.unPublishReport(data)
  }, MenuReportsOverviewController.prototype.deleteReport = function(selectedReportsSet) {
    this.dataSource.deleteReports(selectedReportsSet)
  }, MenuReportsOverviewController.prototype.prepareDataForDraw = function(isSessionUpdate) {
    this.isActive && (servicesGameDataManager.reportsCollection.isReportDeleted(this.initialOptions.reportId) ? this[xy.eNames.menu.openPrevView]() : this.initialOptions.isReportExternal ? this.dataSource.getExternalReport({
      reportId: this.initialOptions.reportId,
      habitatId: this.initialOptions.habitatId
    }) : this.dataSource.getReports(isSessionUpdate))
  }, MenuReportsOverviewController
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(gameInstance, CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuReportsOverviewDataSource(options) {
    var menuReportsDataSource = gameInstance.injector.get(xy.dNames.game.menuReports.dataSource);
    this.forLinking = [{
      resourceClass: menuReportsDataSource,
      methodName: "getReports"
    }, { resourceClass: menuReportsDataSource, methodName: "deleteReports" }, {
      resourceClass: menuReportsDataSource,
      methodName: "onDeleteReports"
    }, {
      resourceClass: menuReportsDataSource,
      methodName: "receiveReports"
    }], MenuReportsOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuReportsOverviewDataSource, CoreDataSource), MenuReportsOverviewDataSource.prototype.getExternalReport = function(data) {
    servicesGameDataManager.reportsCollection.isExternalReportCached(data.reportId) ? this.notify(xy.eNames.menuReports.dataIsAvailable) : this.request({
      id: data.reportId,
      habitatID: data.habitatId
    }, "ReportAction/reportInformation", { callBack: this.receiveExternalReportResponse })
  }, MenuReportsOverviewDataSource.prototype.prepareOverviewReportData = function(data) {
    return servicesGameDataManager.reportsCollection.getReportsOverview(data)
  }, MenuReportsOverviewDataSource.prototype.receivePublishReportResponse = function(data) {
    servicesGameDataManager.reportsCollection.updateReportsData(data, { softUpdate: !0 })
  }, MenuReportsOverviewDataSource.prototype.receiveExternalReportResponse = function(data) {
    servicesGameDataManager.reportsCollection.updateReportsData(data, { softUpdate: !0, isReportExternal: !0 })
  }, MenuReportsOverviewDataSource.prototype.publishReport = function(data) {
    this.request({
      id: data.reportId,
      published: !0
    }, "ReportAction/setReportPublished", { callBack: this.receivePublishReportResponse })
  }, MenuReportsOverviewDataSource.prototype.unPublishReport = function(data) {
    this.request({
      id: data.reportId,
      published: !1
    }, "ReportAction/setReportPublished", { callBack: this.receivePublishReportResponse })
  }, MenuReportsOverviewDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuReportsOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuReportsOverviewComponent) {
  "use strict";
  function MenuReportsOverviewPresenter(options) {
    MenuReportsOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuReportsOverviewPresenter, CorePresenterElementMenu), MenuReportsOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuReportsOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuReportsOverviewPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsSettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { selectedReportsTypesIdsSet: {} }
    }, onCheckboxClick: function(reportType, event) {
      event.preventDefault();
      var selectedReportsTypesIdsSet = this.state.selectedReportsTypesIdsSet, status = selectedReportsTypesIdsSet.hasOwnProperty(reportType.type) ? selectedReportsTypesIdsSet[reportType.type] : reportType.isActive;
      selectedReportsTypesIdsSet[reportType.type] = !status, this.setState({ selectedReportsTypesIdsSet: selectedReportsTypesIdsSet }, null)
    }, onDoneClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuReportsSettings.saveReportsSettings, {
        initialSettings: this.props.settings.settingsList,
        changesInSettings: this.state.selectedReportsTypesIdsSet
      })
    }, render: function() {
      var settings = { settingsList: [] }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var componentsSections = [];
      titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.onDoneClick,
        title: servicesInternationalization.localize("Finish")
      }), settings.settingsList.forEach(function(reportType) {
        var reportSettings = {
          title: servicesInternationalization.localize(reportType.name),
          iconLeft: reportType.icon,
          isSelectable: !0,
          isSelected: this.state.selectedReportsTypesIdsSet.hasOwnProperty(reportType.type) ? this.state.selectedReportsTypesIdsSet[reportType.type] : reportType.isActive,
          onSelect: this.onCheckboxClick.bind(this, reportType)
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: reportSettings,
          key: "menu-element-report-type-in-list-" + reportType.name
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuReportsSettingsController(options) {
    MenuReportsSettingsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw.bind(this, !0)
    }], this.localizedName = servicesInternationalization.localize("Report Preferences"), this.currentReportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE
  }

  return utilsOop.extend(MenuReportsSettingsController, CoreControllerElementMenu), MenuReportsSettingsController.prototype[xy.eNames.menuReportsSettings.saveReportsSettings] = function(data) {
    this.dataSource.saveReportsSettings(data)
  }, MenuReportsSettingsController.prototype[xy.eNames.menuReportsSettings.onSavedSettings] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuReportsSettingsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.getSettingsList())
  }, MenuReportsSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, settingsGameConstant) {
  "use strict";
  function MenuReportsSettingsDataSource(options) {
    MenuReportsSettingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuReportsSettingsDataSource, CoreDataSource), MenuReportsSettingsDataSource.prototype.getSettingsList = function() {
    var currentSetupValue = servicesGameDataManager.playersCollection.getPlayer().reportSetup, reportType = settingsGameConstant.REPORT_TYPE, settingsList = [{
      icon: "icon-game icon-DefenseIcon",
      name: "Attack Warning",
      type: reportType.ATTACK_WARNING,
      isActive: !1
    }, {
      icon: "icon-game icon-DefenseIcon",
      name: "Lost foreign defenders",
      type: reportType.LOST_FOREIGN_DEFENDER,
      isActive: !1
    }, {
      icon: "icon-game icon-DefenseIcon",
      name: "Lost castle",
      type: reportType.CASTLE_LOST,
      isActive: !1
    }, {
      icon: "icon-game icon-AttackIcon",
      name: "Battle Report",
      type: reportType.BATTLE_ROUND_FINISHED,
      isActive: !1
    }, {
      icon: "icon-game icon-AttackIcon",
      name: "Successful Conquest",
      type: reportType.CONQUEST,
      isActive: !1
    }, {
      icon: "icon-game icon-AttackIcon",
      name: "Failed Conquest",
      type: reportType.CONQUEST_FAILED,
      isActive: !1
    }, {
      icon: "icon-game icon-TransitTransport",
      name: "Transit Report",
      type: reportType.TRANSIT_RETURNED,
      isActive: !1
    }, {
      icon: "icon-game icon-TransitTransport",
      name: "Delivered Resources",
      type: reportType.DELIVERED_RESOURCES,
      isActive: !1
    }, {
      icon: "icon-game icon-TransitTransport",
      name: "Delivered Defense",
      type: reportType.DELIVERED_DEFENSE,
      isActive: !1
    }, {
      icon: "icon-game icon-Research",
      name: "Knowledge researched report",
      type: reportType.KNOWLEDGE_RESEARCHED,
      isActive: !1
    }, {
      icon: "icon-game icon-Mission",
      name: "Mission Report",
      type: reportType.MISSION_FINISHED,
      isActive: !1
    }, {
      icon: "icon-game icon-TransitSpy",
      name: "Spy Report",
      type: reportType.SPY_FINISHED,
      isActive: !1
    }, { icon: "icon-game icon-TransitSpy", name: "Spy captured report", type: reportType.SPY_CAPTURED, isActive: !1 }];
    return settingsList.forEach(function(transitType) {
      currentSetupValue & 1 << transitType.type && (transitType.isActive = !0)
    }), { settingsList: settingsList }
  }, MenuReportsSettingsDataSource.prototype.receiveSettings = function(data) {
    servicesGameDataManager.playersCollection.updatePlayersProperty({
      property: "reportSetup",
      value: data.reportSetup
    }), this.notify(xy.eNames.menuReportsSettings.onSavedSettings)
  }, MenuReportsSettingsDataSource.prototype.saveReportsSettings = function(data) {
    var newSetupValue = 0;
    data.initialSettings.forEach(function(reportsType) {
      var isChecked = data.changesInSettings.hasOwnProperty(reportsType.type) ? data.changesInSettings[reportsType.type] : reportsType.isActive;
      isChecked && (newSetupValue += Math.pow(2, reportsType.type))
    }), this.request({ reportSetup: newSetupValue }, "ReportAction/changeReportSetup", { callBack: this.receiveSettings })
  }, MenuReportsSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuReportsSettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuReportsSettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuReportsSettingsComponent) {
  "use strict";
  function MenuReportsSettingsPresenter(options) {
    MenuReportsSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuReportsSettingsPresenter, CorePresenterElementMenu), MenuReportsSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuReportsSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuReportsSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuForum.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.worldSettings, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuBottomBarMain, xy.dNames.components.menuListTextBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesWorldSettings, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuBottomBarMain, ComponentsMenuListTextBasic) {
  "use strict";
  return componentsEngine.createClass({
    selectedThreadsIdsSet: {},
    mixins: [mixinsMenuComponentHandlers],
    getNewState: function() {
      return this.selectedThreadsIdsSet = {}, { editMode: !1, selectedAmount: 0 }
    },
    getInitialState: function() {
      return this.getNewState()
    },
    componentWillReceiveProps: function(newProps) {
      var isForumThreadsMissing = newProps.settings.threads.length < 1;
      isForumThreadsMissing && this.setState(this.getNewState(), null)
    },
    determineEditingMode: function(event) {
      event.preventDefault(), event.stopPropagation(), this.state.editMode || (this.selectedThreadsIdsSet = {}), this.setState({
        editMode: !this.state.editMode,
        selectedAmount: 0
      }, null)
    },
    onCheckboxClick: function(thread, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedAmount = +this.state.selectedAmount;
      this.selectedThreadsIdsSet[thread.id] ? (this.selectedThreadsIdsSet[thread.id] = !1, selectedAmount -= 1) : (this.selectedThreadsIdsSet[thread.id] = thread, selectedAmount += 1), this.setState({ selectedAmount: selectedAmount }, null)
    },
    deleteSelectedEntries: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuForum.deleteThreads, this.selectedThreadsIdsSet), this.selectedThreadsIdsSet = {}, this.setState({ selectedAmount: 0 }, null)
    },
    deleteAllEntries: function(event) {
      event.preventDefault(), event.stopPropagation();
      var threadsIdSet;
      threadsIdSet = servicesGameDataManager.forumsCollection.getThreadsSet(), this.props.presenter.notify(xy.eNames.menuForum.deleteAllThreads, threadsIdSet)
    },
    render: function() {
      var settings = {
        threads: [],
        canPlayerModerateForum: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], bottomBarSection = null, buildTitlesList = function(forumThread) {
        var threadTitleSettings = {
          title: forumThread.topic,
          description: utilsDateTime.getLocaleDateTimeString(forumThread.lastMessageDate),
          iconLeft: "icon-game icon-MessageUnread",
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuForumThread.name,
            options: { forumThread: forumThread }
          })
        };
        forumThread.isRead && (threadTitleSettings.iconLeft = "icon-game icon-MessageRead"), forumThread.closed && (threadTitleSettings.iconLeft = "icon-game icon-ThreadClosed"), this.state.editMode && (threadTitleSettings.isSelectable = !0, threadTitleSettings.onSelect = this.onCheckboxClick.bind(this, forumThread), this.selectedThreadsIdsSet[forumThread.id] && (threadTitleSettings.isSelected = !0)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: threadTitleSettings,
          key: "menu-element-threads-list-" + forumThread.id
        }))
      };
      if (this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], this.state.editMode) {
        titleSettings.rightButton.push({
          title: servicesInternationalization.localize("cancel"),
          onClick: this.determineEditingMode
        });
        var bottomBarSectionSettings = {
          leftButton: {
            onClick: this.deleteSelectedEntries,
            title: servicesInternationalization.localize("Delete entries (%ld)", +this.state.selectedAmount),
            isDisabled: this.state.selectedAmount < 1
          }, rightButton: { onClick: this.deleteAllEntries, icon: "controls menu-bar-delete" }
        };
        bottomBarSection = React.createElement(ComponentsMenuBottomBarMain, { settings: bottomBarSectionSettings })
      } else settings.canPlayerModerateForum && titleSettings.rightButton.push({
        onClick: this.determineEditingMode,
        icon: "controls menu-bar-edit",
        isDisabled: settings.threads.length < 1
      });
      titleSettings.rightButton.push({
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuMessagesNew.name,
          options: { mode: settingsGameConstant.NEW_MESSAGE_MODE.POST_IN_FORUM }
        }), icon: "controls menu-bar-forum-thread-add"
      }), servicesWorldSettings.settings.featureAllianceNewsfeed && (sectionComponentSettings = {
        classes: "first last",
        title: servicesInternationalization.localize("Alliance feed"),
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceFeed.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-feed-reports"
      }))), settings.threads.length ? settings.threads.forEach(buildTitlesList, this) : (sectionComponentSettings = { text: servicesInternationalization.localize("There are no forum threads in your alliance") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-no-messages"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: bottomBarSection,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuForum.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuForumController(options) {
    MenuForumController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.forum,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuForum.dataIsAvailable]
    }, {
      entity: xy.eNames.dataListeners.dataEntity.forum,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuForum.dataIsAvailable]
    }], this.localizedName = servicesInternationalization.localize("Forum")
  }

  return utilsOop.extend(MenuForumController, CoreControllerElementMenu), MenuForumController.prototype[xy.eNames.menuForum.dataIsAvailable] = function() {
    this.presenter.draw(this.dataSource.prepareThreadsTitles())
  }, MenuForumController.prototype[xy.eNames.menuForum.deleteThreads] = function(selectedThreadsSet) {
    this.dataSource.deleteThreads(selectedThreadsSet)
  }, MenuForumController.prototype[xy.eNames.menuForum.deleteAllThreads] = function(threadsSet) {
    this.showDialogDialog({
      title: "",
      text: servicesInternationalization.localize("Delete all entries"),
      callbackSuccess: this.dataSource.deleteThreads.bind(this.dataSource, threadsSet)
    })
  }, MenuForumController.prototype[xy.eNames.menuForum.onThreadCreated] = function() {
    this[xy.eNames.menu.closeViewUpToRoot]()
  }, MenuForumController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getThreads()
  }, MenuForumController
}]),xy.dStaticInjector.set(xy.dNames.game.menuForum.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuForumDataSource(options) {
    MenuForumDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuForumDataSource, CoreDataSource), MenuForumDataSource.prototype.getThreads = function() {
    servicesGameDataManager.forumsCollection.updated ? this.notify(xy.eNames.menuForum.dataIsAvailable) : this.request({}, "ForumAction/forumThreadArray", { callBack: this.receiveThreads })
  }, MenuForumDataSource.prototype.receiveThreads = function(data) {
    servicesGameDataManager.forumsCollection.updateForumData(data), this.notify(xy.eNames.menuForum.dataIsAvailable)
  }, MenuForumDataSource.prototype.prepareThreadsTitles = function() {
    return servicesGameDataManager.forumsCollection.getThreadsList()
  }, MenuForumDataSource.prototype.deleteThreads = function(selectedThreadsSet) {
    var key, threadsIdsArray = [];
    for (key in selectedThreadsSet)selectedThreadsSet.hasOwnProperty(key) && selectedThreadsSet[key] !== !1 && threadsIdsArray.push(key);
    this.request({ forumThreadIdArray: threadsIdsArray }, "ForumAction/deleteForumThreads", { callBack: this.handleSessionUpdateResponse }), servicesGameDataManager.forumsCollection.onDeleteForumThreads(threadsIdsArray);
  }, MenuForumDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuForum.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuForum.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuForumComponent) {
  "use strict";
  function MenuForumPresenter(options) {
    MenuForumPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuForumPresenter, CorePresenterElementMenu), MenuForumPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuForumComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuForumPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuForumThread.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuBottomBarMain, xy.dNames.components.messageForumEntry, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListButtonBasic, ComponentsMenuBottomBarMain, ComponentsMessageForumEntry) {
  "use strict";
  return componentsEngine.createClass({
    selectedForumMessagesSet: {},
    shouldComponentScroll: !1,
    mixins: [mixinsMenuComponentHandlers],
    getNewState: function() {
      return this.selectedForumMessagesSet = {}, { editMode: !1, selectedAmount: 0 }
    },
    setScrollPosition: function() {
      this.scrollToMenuElement({
        container: settingsGameConstant.COMPONENTS_REFS.FORUM.CONTAINER,
        target: settingsGameConstant.COMPONENTS_REFS.FORUM.TARGET
      })
    },
    getInitialState: function() {
      return this.getNewState()
    },
    componentDidMount: function() {
      this.setScrollPosition()
    },
    componentWillReceiveProps: function(newProps) {
      var isAnotherThreadSelected = this.props.settings.forumThread.id !== newProps.settings.forumThread.id;
      this.shouldComponentScroll = isAnotherThreadSelected || newProps.settings.messageList.length !== this.props.settings.messageList.length, isAnotherThreadSelected && this.setState(this.getNewState(), null)
    },
    componentDidUpdate: function() {
      this.shouldComponentScroll && (this.shouldComponentScroll = !1, this.setScrollPosition())
    },
    determineEditingMode: function(event) {
      event.preventDefault(), event.stopPropagation(), this.state.editMode || (this.selectedForumMessagesSet = {}), this.setState({
        editMode: !this.state.editMode,
        selectedAmount: 0
      }, null)
    },
    onCheckboxClick: function(message, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedAmount = +this.state.selectedAmount;
      this.selectedForumMessagesSet[message.id] ? (this.selectedForumMessagesSet[message.id] = !1, selectedAmount -= 1) : (this.selectedForumMessagesSet[message.id] = message, selectedAmount += 1), this.setState({ selectedAmount: selectedAmount }, null)
    },
    onCloseButtonClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuForumThread.changeThreadStatus, this.props.settings.forumThread), this.setScrollPosition(), this.selectedForumMessagesSet = {}, this.setState({ selectedAmount: 0 }, null)
    },
    deleteSelectedEntries: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuForumThread.deleteForumMessages, this.selectedForumMessagesSet), this.selectedForumMessagesSet = {}, this.setState({ selectedAmount: 0 }, null), this.setScrollPosition()
    },
    deleteAllEntries: function(event) {
      event.preventDefault(), event.stopPropagation();
      var selectedThreadsSet = {};
      selectedThreadsSet[this.props.settings.forumThread.id] = !0, this.props.presenter.notify(xy.eNames.menuForumThread.deleteThreads, selectedThreadsSet)
    },
    render: function() {
      var settings = { forumThread: {}, messageList: [], canPlayerModerateForum: !1 }, titleSettings = {};
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, bottomBarSection, componentsSections = [];
      if (titleSettings.title = settings.forumThread.topic, this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], this.state.editMode) {
        titleSettings.rightButton.push({
          title: servicesInternationalization.localize("cancel"),
          onClick: this.determineEditingMode
        });
        var bottomBarSectionSettings = {
          leftButton: {
            onClick: utilsObject.effectiveLength(this.selectedForumMessagesSet) === settings.messageList.length ? this.deleteAllEntries : this.deleteSelectedEntries,
            title: servicesInternationalization.localize("Delete entries (%ld)", +this.state.selectedAmount),
            isDisabled: this.state.selectedAmount < 1
          }
        };
        bottomBarSectionSettings.rightButton = [], bottomBarSectionSettings.rightButton.push({
          onClick: this.onCloseButtonClick,
          icon: settings.forumThread.closed ? "controls menu-bar-forum-thread-opened" : "controls menu-bar-forum-thread-closed"
        }), bottomBarSectionSettings.rightButton.push({
          onClick: this.deleteAllEntries,
          icon: "controls menu-bar-delete"
        }), bottomBarSection = React.createElement(ComponentsMenuBottomBarMain, { settings: bottomBarSectionSettings })
      } else settings.canPlayerModerateForum && titleSettings.rightButton.push({
        icon: "controls menu-bar-edit",
        onClick: this.determineEditingMode,
        isDisabled: settings.messageList.length < 1
      });
      settings.messageList.forEach(function(forumMessage, index) {
        var forumMessageSettings = {
          forumMessage: forumMessage,
          selectedForumMessagesSet: this.selectedForumMessagesSet,
          initialComponent: this,
          editMode: this.state.editMode,
          threadStatus: settings.forumThread.closed
        }, isLast = settings.messageList.length - 1 === index;
        isLast ? componentsSections.push(React.createElement(ComponentsMessageForumEntry, {
          ref: settingsGameConstant.COMPONENTS_REFS.FORUM.TARGET,
          settings: forumMessageSettings,
          key: "forum-entry-" + forumMessage.id
        })) : componentsSections.push(React.createElement(ComponentsMessageForumEntry, {
          settings: forumMessageSettings,
          key: "forum-entry-" + forumMessage.id
        }))
      }, this), settings.forumThread.closed || (sectionComponentSettings = {
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuMessagesNew.name,
          options: { message: settings.forumThread, mode: settingsGameConstant.NEW_MESSAGE_MODE.REPLY_FORUM }
        }), title: servicesInternationalization.localize("Reply")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-reply"
      })));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: bottomBarSection,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.FORUM.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuForumThread.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesGameDataManager, servicesInternationalization) {
  "use strict";
  function MenuForumThreadController(options) {
    MenuForumThreadController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.forum,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuForumThread.dataIsAvailable]
    }], this.localizedName = servicesInternationalization.localize("Messages")
  }

  return utilsOop.extend(MenuForumThreadController, CoreControllerElementMenu), MenuForumThreadController.prototype[xy.eNames.menuForumThread.dataIsAvailable] = function(thread) {
    if (thread && thread.id === this.initialOptions.forumThread.id && (this.initialOptions.forumThread = thread), this.isActive) {
      var data = this.dataSource.prepareThreadMessages(this.initialOptions.forumThread);
      data && this.presenter.draw(data)
    }
  }, MenuForumThreadController.prototype[xy.eNames.menuMessagesThread.deleteThreads] = function(selectedThreadsSet) {
    this.showDialogDialog({
      callbackSuccess: function() {
        this.dataSource.deleteThreads(selectedThreadsSet)
      }.bind(this), text: servicesInternationalization.localize("Delete thread?")
    })
  }, MenuForumThreadController.prototype[xy.eNames.menuForumThread.changeThreadStatus] = function(forumThread) {
    this.dataSource.changeThreadStatus(forumThread)
  }, MenuForumThreadController.prototype[xy.eNames.menuForumThread.deleteForumMessages] = function(selectedForumMessagesSet) {
    this.dataSource.deleteForumMessages(selectedForumMessagesSet)
  }, MenuForumThreadController.prototype.prepareDataForDraw = function() {
    this.isActive && (servicesGameDataManager.forumsCollection.isForumThreadDeleted(this.initialOptions.forumThread.id) ? this[xy.eNames.menu.openPrevView]() : this.dataSource.getForumThread(this.initialOptions.forumThread))
  }, MenuForumThreadController
}]),xy.dStaticInjector.set(xy.dNames.game.menuForumThread.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.gameInstance, function(CoreDataSource, utilsOop, servicesGameDataManager, gameInstance) {
  "use strict";
  function MenuForumThreadDataSource(options) {
    var menuForumDataSource = gameInstance.injector.get(xy.dNames.game.menuForum.dataSource);
    this.forLinking = [{
      resourceClass: menuForumDataSource,
      methodName: "deleteThreads"
    }], MenuForumThreadDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuForumThreadDataSource, CoreDataSource), MenuForumThreadDataSource.prototype.getForumThread = function(forumThread) {
    servicesGameDataManager.forumsCollection.isThreadCached(forumThread.id) ? this.notify(xy.eNames.menuForumThread.dataIsAvailable) : this.request({ id: forumThread.id }, "ForumAction/forumMessageArray", { callBack: this.receiveThreadMessages })
  }, MenuForumThreadDataSource.prototype.receiveThreadMessages = function(data) {
    servicesGameDataManager.forumsCollection.updateForumData(data, { softUpdate: !0 }), this.notify(xy.eNames.menuForumThread.dataIsAvailable)
  }, MenuForumThreadDataSource.prototype.prepareThreadMessages = function(forumThread) {
    var messageList = servicesGameDataManager.forumsCollection.getThreadsMessages(forumThread.id), canPlayerModerateForum = servicesGameDataManager.playersCollection.getPlayer().canModerateForum();
    return messageList && messageList.length ? {
      forumThread: forumThread,
      messageList: messageList,
      canPlayerModerateForum: canPlayerModerateForum
    } : (this.notify(xy.eNames.menu.onDataExpired), null)
  }, MenuForumThreadDataSource.prototype.changeThreadStatus = function(forumThread) {
    var newStatus = forumThread.closed ? 0 : 1;
    servicesGameDataManager.forumsCollection.changeThreadStatus(forumThread.id, newStatus), this.request({
      id: forumThread.id,
      closed: newStatus
    }, "ForumAction/setForumThreadClosed", { callBack: this.handleSessionUpdateResponse })
  }, MenuForumThreadDataSource.prototype.deleteForumMessages = function(selectedEntitySet) {
    var key, idsArray = [];
    for (key in selectedEntitySet)selectedEntitySet.hasOwnProperty(key) && selectedEntitySet[key] !== !1 && idsArray.push(key);
    this.request({ forumMessageIdArray: idsArray }, "ForumAction/deleteForumMessages", { callBack: this.handleSessionUpdateResponse }), servicesGameDataManager.forumsCollection.onDeleteThreadsMessages(idsArray)
  }, MenuForumThreadDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuForumThread.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuForumThread.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuForumThreadComponent) {
  "use strict";
  function MenuMessagesThreadPresenter(options) {
    MenuMessagesThreadPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMessagesThreadPresenter, CorePresenterElementMenu), MenuMessagesThreadPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuForumThreadComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMessagesThreadPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfile.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.overviewWidgetTreasureChest, xy.dNames.components.widgetRename, xy.dNames.components.protectionWidgetAttackProtectionButton, xy.dNames.components.protectionWidgetVacationButton, xy.dNames.components.widgetHabitatAmount, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTextBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsOverviewWidgetTreasureChest, ComponentsWidgetRename, ComponentsProtectionWidgetAttackProtectionButton, ComponentsProtectionWidgetVacationButton, ComponentsWidgetHabitatAmount) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    handlerLogOutButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneGame.onLogoutEvent)
    },
    handlerSwitchWorldButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneGame.onSwitchWorldEvent)
    },
    onAttackProtectionButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfile.onProtectionShieldClick)
    },
    onVacationButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfile.onStartVacationClick)
    },
    onPLayerRenameSubmitClick: function(newName) {
      this.props.presenter.notify(xy.eNames.menuPlayerProfile.updateNickName, { newName: newName })
    },
    render: function() {
      var settings = {
        player: null,
        nick: "",
        gold: "",
        points: "",
        habitatCountByTypeDictionary: {},
        events: "",
        possibleNickname: null,
        forceNextRedrawUpdate: !1,
        featureStatisticUrl: !1,
        featureAttackProtectionImprovement: !1
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, linkFAQ, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], themeIcons = servicesTheme.themeSettings.imagesClassNames;
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var renameSectionSettings = {
        name: settings.nick,
        onSubmitAction: this.onPLayerRenameSubmitClick,
        initialComponent: this,
        errorOnLoading: settings.possibleNickname,
        alertPosition: "bottom",
        minLength: servicesWorldSettings.settings.playerNameLengthMin,
        maxLength: servicesWorldSettings.settings.playerNameLengthMax,
        forceNextRedrawUpdate: settings.forceNextRedrawUpdate,
        habitat: settings.currentHabitat
      };
      sectionComponentSettings = {
        title: servicesInternationalization.localize("Nickname"),
        rightColumnDataValue: React.createElement(ComponentsWidgetRename, { settings: renameSectionSettings })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "profile-rename"
      })), sectionComponentSettings = { habitatCountByTypeDictionary: settings.habitatCountByTypeDictionary }, componentsSections.push(React.createElement(ComponentsWidgetHabitatAmount, {
        settings: sectionComponentSettings,
        key: "habitat-amount-widget"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Points"),
        rightColumnDataValue: settings.points
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "points"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Player rankings"),
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuRankModeChooser.name,
          options: { rankingId: settings.player.id, rankingMode: settingsGameConstant.RANKING_MODE.PLAYER }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "rank"
      })), sectionComponentSettings = { initialComponent: this }, componentsSections.push(React.createElement(ComponentsOverviewWidgetTreasureChest, {
        settings: sectionComponentSettings,
        key: "gold"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Event List"),
        rightColumnDataValue: settings.events,
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuEvent.name }),
        iconRight: "controls menu-next"
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "events"
      })), settings.featureStatisticUrl && (sectionComponentSettings = {
        iconLeft: themeIcons.featureStatisticView.featureIcon,
        title: servicesInternationalization.localize("PlayerStatisticsButton"),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuExternalIFrameInjection.name,
          options: { targetURL: settings.featureStatisticUrl }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-player-statistic"
      }))), linkFAQ = servicesTheme.getFAQLink("main"), linkFAQ && (sectionComponentSettings = {
        title: servicesInternationalization.localize("FAQ + Support"),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuExternalIFrameInjection.name,
          options: { targetURL: linkFAQ }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-faq"
      }))), sectionComponentSettings = {
        title: servicesInternationalization.localize("Choose a World"),
        onClick: this.handlerSwitchWorldButtonClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-switch-world"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Logout"),
        onClick: this.handlerLogOutButtonClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-logout"
      })), settings.featureAttackProtectionImprovement && (sectionComponentSettings = {
        initialComponent: this,
        onClick: this.onAttackProtectionButtonClick
      }, componentsSections.push(React.createElement(ComponentsProtectionWidgetAttackProtectionButton, {
        settings: sectionComponentSettings,
        key: "attack-protection"
      }))), sectionComponentSettings = {
        initialComponent: this,
        onClick: this.onVacationButtonClick
      }, componentsSections.push(React.createElement(ComponentsProtectionWidgetVacationButton, {
        settings: sectionComponentSettings,
        key: "vacation-mode"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Preferences"),
        iconLeft: themeIcons.settings.settingsIcon,
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuGameSettings.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-settings"
      })), sectionComponentSettings = {
        text: xy._version,
        classes: "game-version"
      }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "current-version"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfile.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, servicesTheme, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuPlayerProfileController(options) {
    MenuPlayerProfileController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw.bind(this, !0)
    }, {
      entity: xy.eNames.dataListeners.dataEntity.player,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw.bind(this, !0)
    }], this.localizedName = servicesInternationalization.localize("Profile")
  }

  return utilsOop.extend(MenuPlayerProfileController, CoreControllerElementMenu), MenuPlayerProfileController.prototype[xy.eNames.menuPlayerProfile.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuPlayerProfileController.prototype[xy.eNames.menuPlayerProfile.updateNickName] = function(options) {
    this.dataSource.changePlayersNick(options)
  }, MenuPlayerProfileController.prototype[xy.eNames.menuPlayerProfile.onProtectionShieldClick] = function() {
    var text, player = servicesGameDataManager.playersCollection.getPlayer(), gold = player.gold, goldName = servicesTheme.themeSettings.resources.premium, cost = 0, worldSettings = servicesWorldSettings.settings, attackProtectionNumberOfFreeTimes = worldSettings.attackProtectionNumberOfFreeTimes || 0, protectionShieldInHours = worldSettings.attackProtectionRuntimeMinutes / 60;
    return protectionShieldInHours !== (0 | protectionShieldInHours) && (protectionShieldInHours = (100 * protectionShieldInHours | 0) / 100), !isNaN(player.numberOfFreeAttackProtectionsUsed) && player.numberOfFreeAttackProtectionsUsed < attackProtectionNumberOfFreeTimes ? text = servicesInternationalization.localize("Do you want to start the protective shield? You can activate it for free %1$d more times. The duration for the shield is %2$d hours.", attackProtectionNumberOfFreeTimes, protectionShieldInHours) : (cost = worldSettings.attackProtectionCost, text = servicesInternationalization.localize("Do you want to start the protective shield for %1$d %2$@? You have %3$dÂ %4$@. The duration for the shield is %5$d hours.", cost, goldName, gold, goldName, protectionShieldInHours)), cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : void this.showDialogDialog({
      title: servicesInternationalization.localize("Protective shield"),
      text: text,
      callbackSuccess: this.dataSource.activateProtectiveShield.bind(this.dataSource, { cost: cost })
    })
  }, MenuPlayerProfileController.prototype[xy.eNames.menuPlayerProfile.onStartVacationClick] = function() {
    var localizedString, text, successCallBack, player = servicesGameDataManager.playersCollection.getPlayer(), worldSettings = servicesWorldSettings.settings;
    if (player.remainingVacationHours > 0) {
      localizedString = "You have %1$dÂ days and %2$dÂ hours left for vacations. Vacation mode starts %3$dÂ hours after you confirm. You can not log in for %4$dÂ hours after vacation mode started.";
      var daysLeft = player.remainingVacationHours / 24 | 0, hoursLeft = player.remainingVacationHours - 24 * daysLeft;
      text = servicesInternationalization.localize(localizedString, daysLeft, hoursLeft, worldSettings.vacationDelayHours, worldSettings.minimumVacationHours), successCallBack = this.dataSource.activateVacationProtectiveShield.bind(this.dataSource), this.showDialogDialog({
        classes: "higher",
        title: servicesInternationalization.localize("Start vacation"),
        text: text,
        callbackSuccess: successCallBack
      })
    } else this.showDialogAlert({
      title: servicesInternationalization.localize("Error"),
      text: servicesInternationalization.localize("There are no more vacation hours remaining")
    })
  }, MenuPlayerProfileController.prototype[xy.eNames.menuPlayerProfile.errorOnRenaming] = function(options) {
    var text, localizedString = 'The name "%@" is already taken. A possible name is "%@".';
    text = servicesInternationalization.localize(localizedString, options.attemptName, options.possibleNickname), this.showDialogAlert({
      title: "",
      text: text
    })
  }, MenuPlayerProfileController.prototype.prepareDataForDraw = function(isSessionUpdate) {
    this.isActive && this.dataSource.prepareProfileData(isSessionUpdate)
  }, MenuPlayerProfileController
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfile.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.worldSettings, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, servicesWorldSettings) {
  "use strict";
  function MenuPlayerProfileDataSource(options) {
    MenuPlayerProfileDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuPlayerProfileDataSource, CoreDataSource), MenuPlayerProfileDataSource.prototype.getWorldsListData = function() {
    this.request(null, "action", { callBack: this.testCallback, isLogin: !0 })
  }, MenuPlayerProfileDataSource.prototype.testCallback = function(data) {
    console.log(data)
  }, MenuPlayerProfileDataSource.prototype.prepareProfileData = function(isSessionUpdate) {
    var data = {}, player = servicesGameDataManager.playersCollection.getPlayer();
    data.player = player, data.nick = player.nick, data.gold = player.gold, data.points = player.points, data.habitatCountByTypeDictionary = servicesGameDataManager.habitatsCollection.getOwnHabitatsAmountByHabitatTypes();
    var events = servicesGameDataManager.getEventsStatistics();
    data.events = events.amountOfSuccess + "/" + events.amountTotal, data.forceNextRedrawUpdate = !isSessionUpdate;
    var statisticLink = servicesTheme.getStatisticLink({
      entity: "player",
      worldId: servicesGameDataManager.settings.worldId,
      playerId: data.player.id
    });
    statisticLink && (data.featureStatisticUrl = statisticLink), servicesWorldSettings.settings.featureAttackProtectionImprovement && (data.featureAttackProtectionImprovement = !0), this.notify(xy.eNames.menuPlayerProfile.dataIsReady, data)
  }, MenuPlayerProfileDataSource.prototype.changePlayersNick = function(options) {
    this.request({ nick: options.newName }, "ProfileAction/changeNickname", { callBack: this.handlePlayersRenaming }), this.attemptName = options.newName
  }, MenuPlayerProfileDataSource.prototype.handlePlayersRenaming = function(data) {
    data.Data && data.Data.Player instanceof Array && data.Data.Player.forEach(function(rawPlayer) {
      servicesGameDataManager.playersCollection.updatePlayersProperty({
        id: rawPlayer.id,
        property: "nick",
        value: rawPlayer.nick
      })
    }, this), data && data.possibleNickname && this.notify(xy.eNames.menuPlayerProfile.errorOnRenaming, {
      attemptName: this.attemptName,
      possibleNickname: data.possibleNickname
    }), this.prepareProfileData(!1)
  }, MenuPlayerProfileDataSource.prototype.activateProtectiveShield = function(options) {
    this.request({ paymentAmount: options.cost }, "ProfileAction/activateImprovedAttackProtection", { callBack: this.handleSessionUpdateResponse })
  }, MenuPlayerProfileDataSource.prototype.activateVacationProtectiveShield = function() {
    this.request({}, "ProfileAction/startVacationMode", { callBack: this.activationVacationResponseHandler })
  }, MenuPlayerProfileDataSource.prototype.activationVacationResponseHandler = function(data) {
    data = data || {};
    var modeledPlayer;
    data.vacationStartDate instanceof Date && (modeledPlayer = servicesGameDataManager.playersCollection.getPlayer(), modeledPlayer.activationOfVactionIsInProgress(data.vacationStartDate), servicesGameDataManager.fireDataUpdateListener(null, {
      entity: xy.eNames.dataListeners.dataEntity.player,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated
    }))
  }, MenuPlayerProfileDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfile.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuPlayerProfile.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuPlayerProfileComponent) {
  "use strict";
  function MenuPlayerProfilePresenter(options) {
    MenuPlayerProfilePresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuPlayerProfilePresenter, CorePresenterElementMenu), MenuPlayerProfilePresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuPlayerProfileComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuPlayerProfilePresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfileExternal.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListButtonDisplayLink, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.widgetAlliancePermissionBadges, xy.dNames.components.widgetHabitatAmount, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsMenuListButtonDisplayLink, ComponentsWidgetAllianceRelationBadge, ComponentsWidgetAlliancePermissionBadges, ComponentsWidgetHabitatAmount) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { activeModelLinkClicker: 0 }
    }, onChangeSortingDirectionButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfileExternal.changeSortingDirection)
    }, onSendInvitationClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfileExternal.sendInvitationToPlayer, { player: this.props.settings.player })
    }, onCancelInvitationClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfileExternal.cancelInvitationToPlayer, { player: this.props.settings.player })
    }, onDismissPlayerClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfileExternal.dismissPlayer, { player: this.props.settings.player })
    }, onAcceptApplicantClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfileExternal.acceptApplicant, { player: this.props.settings.player })
    }, onRejectApplicantClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayerProfileExternal.rejectApplicant, { player: this.props.settings.player })
    }, render: function() {
      var settings = {
        player: {},
        alliance: {},
        habitatsSet: {},
        habitatCountByTypeDictionary: {},
        canBeMessaged: !1,
        canPlayerBeManagedAsApplicant: !1,
        canBeInvited: !1,
        canRevokeInvitation: !1,
        canBeManageRightsInAlliance: !1,
        canBeDismissed: !1,
        canBeSorted: !1,
        sortingDirection: settingsGameConstant.SORTING_HABITAT_DIRECTION[0],
        sortingFunctionName: settingsGameConstant.SORTING_HABITAT_FUNCTION.ALPHABET,
        featureStatisticUrl: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeSettings = servicesTheme.themeSettings, themeIcons = themeSettings.imagesClassNames;
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = themeIcons.controls.close : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle,
              titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, sectionComponentSettings = {
        title: settings.player.nick,
        description: settings.player.points,
        iconLeft: "icon-game icon-ButtonPlayer",
        iconRight: React.createElement(ComponentsWidgetAllianceRelationBadge, {
          settings: {
            playerId: settings.player.id,
            classes: "icon-right"
          }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-player-details"
      })), sectionComponentSettings = {
        title: settings.alliance.name,
        description: settings.alliance.points,
        iconLeft: "icon-game icon-ButtonAlliance"
      }, settings.alliance.isEmpty || (sectionComponentSettings.onClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuAllianceProfile.name,
        options: { allianceId: settings.alliance.id }
      }), sectionComponentSettings.iconRight = themeIcons.controls.next), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-ally-details"
      })), sectionComponentSettings = { permission: settings.player.alliancePermission }, componentsSections.push(React.createElement(ComponentsWidgetAlliancePermissionBadges, {
        settings: sectionComponentSettings,
        key: "menu-widget-permission-icons"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Rank"),
        rightColumnDataValue: settings.player.rank,
        iconRight: themeIcons.controls.next,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuRankModeChooser.name,
          options: { rankingId: settings.player.id, rankingMode: settingsGameConstant.RANKING_MODE.PLAYER }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "rank"
      })), sectionComponentSettings = { habitatCountByTypeDictionary: settings.habitatCountByTypeDictionary }, componentsSections.push(React.createElement(ComponentsWidgetHabitatAmount, {
        settings: sectionComponentSettings,
        key: "habitat-amount-widget"
      })), settings.featureStatisticUrl && (sectionComponentSettings = {
        iconLeft: themeIcons.featureStatisticView.featureIcon,
        title: servicesInternationalization.localize("PlayerStatisticsButton"),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuExternalIFrameInjection.name,
          options: { targetURL: settings.featureStatisticUrl }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-player-statistic"
      }))), sectionComponentSettings = {
        iconLeft: "icon-game icon-PasteboardPlayerIcon",
        onClick: this.onGetModelLinkClick.bind(this, settings.player),
        targetModel: settings.player,
        defaultTitle: servicesInternationalization.localize("Display player link")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonDisplayLink, {
        settings: sectionComponentSettings,
        key: "menu-button-copy-player-link"
      })), settings.canBeMessaged && (sectionComponentSettings = {
        iconLeft: "icon-game icon-ButtonMessages",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuMessagesNew.name,
          options: { recipient: settings.player, mode: settingsGameConstant.NEW_MESSAGE_MODE.CREATE }
        }),
        title: servicesInternationalization.localize("Send Message")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-send-message"
      }))), settings.canPlayerBeManagedAsApplicant && (sectionComponentSettings = {
        iconLeft: themeIcons.alliance.acceptApplicant,
        onClick: this.onAcceptApplicantClick,
        title: servicesInternationalization.localize("Accept application")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-accept-player-application"
      })), sectionComponentSettings = {
        iconLeft: themeIcons.alliance.rejectApplicant,
        onClick: this.onRejectApplicantClick,
        title: servicesInternationalization.localize("Reject application")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-reject-player-application"
      }))), settings.canRevokeInvitation ? (sectionComponentSettings = {
        iconLeft: "icon-permission icon-permission-0",
        onClick: this.onCancelInvitationClick,
        title: servicesInternationalization.localize("Revoke Invitation")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-revoke-invitation"
      }))) : settings.canBeInvited && (sectionComponentSettings = {
        iconLeft: "icon-permission icon-permission-0",
        onClick: this.onSendInvitationClick,
        title: servicesInternationalization.localize("Send Invitation")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-invite-to-alliance"
      }))), settings.canBeManageRightsInAlliance && (sectionComponentSettings = {
        iconLeft: "icon-permission permission-32",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuAllianceRightsSettings.name,
          options: { player: settings.player }
        }),
        title: servicesInternationalization.localize("Change Permission")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-manage-rights"
      }))), settings.canBeDismissed && (sectionComponentSettings = {
        iconLeft: "icon-permission permission-2",
        onClick: this.onDismissPlayerClick,
        title: servicesInternationalization.localize("Dismiss member")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-dismiss-player"
      }))), settings.player.habitatArray.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Castles") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-castles"
      })), settings.canBeSorted && (sectionComponentSettings = {
        title: servicesInternationalization.localize(themeSettings.habitatSortingNames[settings.sortingFunctionName]),
        iconLeft: "icon-game icon-Sorting" + settings.sortingFunctionName,
        iconRight: themeIcons.controls.next,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuHabitatSortingChooser.name,
          options: { mode: settingsGameConstant.SORTING_HABITAT_CHOOSER_MODE.EXTERNAL_PLAYER }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitats-sorting-function-btn"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize(settingsGameConstant.SORTING_HABITAT_DIRECTION[settings.sortingDirection]),
        onClick: this.onChangeSortingDirectionButtonClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "habitats-sorting-direction-btn"
      }))), settings.player.habitatArray.forEach(function(habitatId) {
        var habitat = settings.habitatsSet[habitatId], habitatSettings = {
          title: habitat.name,
          description: habitat.points,
          iconLeft: "icon-game icon-CenterHabitat-" + habitat.publicHabitatType,
          iconRight: themeIcons.controls.next,
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuHabitatOverview.name,
            options: { habitatId: habitat.id }
          })
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: habitatSettings,
          key: "menu-element-habitats-list-" + habitat.id
        }))
      }, this));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfileExternal.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuPlayerProfileExternalController(options) {
    MenuPlayerProfileExternalController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Profile")
  }

  return utilsOop.extend(MenuPlayerProfileExternalController, CoreControllerElementMenu), MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.sendInvitationToPlayer] = function(data) {
    this.dataSource.sendInvitationToPlayer(data)
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.cancelInvitationToPlayer] = function(data) {
    this.dataSource.cancelInvitationToPlayer(data)
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.acceptApplicant] = function(data) {
    this.dataSource.acceptApplicationFromPlayer(data)
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.rejectApplicant] = function(data) {
    this.dataSource.rejectApplicationFromPlayer(data)
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.onApplicationStatusChanged] = function() {
    this.initialOptions.closeMenuOnApplicationStatusChanged && this[xy.eNames.menu.openPrevView]()
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.dismissPlayer] = function(data) {
    this.showDialogDialog({
      title: servicesInternationalization.localize("Alliance"),
      text: servicesInternationalization.localize('Do you really want to dismiss "%@" from the alliance?', data.player.nick),
      callbackSuccess: this.dataSource.dismissPlayer.bind(this.dataSource, data)
    })
  }, MenuPlayerProfileExternalController.prototype[xy.eNames.menuPlayerProfileExternal.changeSortingDirection] = function() {
    this.dataSource.changeHabitatsSortingDirectionForExternalPlayer()
  }, MenuPlayerProfileExternalController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getExternalPlayerData(this.initialOptions.playerId)
  }, MenuPlayerProfileExternalController
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfileExternal.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuPlayerProfileExternalDataSource(options) {
    MenuPlayerProfileExternalDataSource.__super__.constructor.call(this, options), this.playerId = 0
  }

  return utilsOop.extend(MenuPlayerProfileExternalDataSource, CoreDataSource), MenuPlayerProfileExternalDataSource.prototype.getExternalPlayerData = function(playerId) {
    this.playerId = playerId;
    var player = servicesGameDataManager.playersCollection.getPlayer(playerId);
    player && player.updated ? this.onPlayerInformationUpdated(player) : this.requestPlayerInformation({ playerId: playerId })
  }, MenuPlayerProfileExternalDataSource.prototype.requestPlayerInformation = function(options) {
    options = options || {};
    var playerId = options.playerId || this.playerId;
    this.request({ id: playerId }, "ProfileAction/playerInformation", { callBack: this.receivePlayerInformation })
  }, MenuPlayerProfileExternalDataSource.prototype.receivePlayerInformation = function(data) {
    servicesGameDataManager.updateHabitatsData(data.Data.Habitat, { isPeripheral: !0 }), servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), servicesGameDataManager.updateAlliancesData(data.Data.Alliance, { isPeripheral: !0 }), this.onPlayerInformationUpdated()
  }, MenuPlayerProfileExternalDataSource.prototype.onPlayerInformationUpdated = function(player) {
    var data = {
      alliance: null,
      habitatsSet: {},
      canBeInvited: !1
    }, thisPlayer = servicesGameDataManager.playersCollection.getPlayer();
    player = player || servicesGameDataManager.playersCollection.getPlayer(this.playerId);
    var habitatsCollection = servicesGameDataManager.habitatsCollection, habitatCountByTypeDictionary = {
      0: 0,
      2: 0,
      4: 0
    };
    data.player = player;
    var allHabitatsKnown = player.habitatArray.every(function(habitatId) {
      var habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      return !(!habitat || habitat.player !== player.id) && (data.habitatsSet[habitatId] = habitat, habitatCountByTypeDictionary[habitat.publicHabitatType] += 1, !0)
    }, this);
    if (!allHabitatsKnown)return void this.requestPlayerInformation();
    if (data.habitatCountByTypeDictionary = habitatCountByTypeDictionary, player.habitatArray instanceof Array && player.habitatArray.length > 1 && habitatsCollection.sortPLayerHabitats({ player: player }) && (data.canBeSorted = !0, data.sortingDirection = habitatsCollection.isReverseSortingForeign ? 1 : 0, data.sortingFunctionName = habitatsCollection.sortingForeignFunction), player.alliance) {
      if (data.alliance = servicesGameDataManager.alliancesCollection.getAlliance(player.alliance), !data.alliance && data.alliance.habitatArray instanceof Array)return void this.requestPlayerInformation()
    } else {
      if (servicesGameDataManager.alliancesCollection.isExternalPlayerAcceptedInvitation(player.id))return void this.requestPlayerInformation();
      data.alliance = servicesGameDataManager.alliancesCollection.getEmptyAlliance()
    }
    data.canBeMessaged = player.id !== thisPlayer.id, data.canBeInvited = servicesGameDataManager.alliancesCollection.canExternalPlayerBeInvited(player), data.canRevokeInvitation = servicesGameDataManager.alliancesCollection.isExternalPlayerInvited(player.id), data.canBeManageRightsInAlliance = player.alliance && thisPlayer.canManageRightsInAlliance() && player.id !== thisPlayer.id && player.alliance === thisPlayer.alliance, data.canBeDismissed = player.alliance && thisPlayer.canDismissFromAlliance() && player.id !== thisPlayer.id && player.alliance === thisPlayer.alliance, data.canPlayerBeManagedAsApplicant = servicesGameDataManager.alliancesCollection.isExternalPlayerApplicant(player.id);
    var statisticLink = servicesTheme.getStatisticLink({
      entity: "player",
      worldId: servicesGameDataManager.settings.worldId,
      playerId: player.id
    });
    statisticLink && (data.featureStatisticUrl = statisticLink), this.notify(xy.eNames.menuPlayerProfileExternal.dataIsReady, data)
  }, MenuPlayerProfileExternalDataSource.prototype.changeHabitatsSortingDirectionForExternalPlayer = function() {
    var habitatsCollection = servicesGameDataManager.habitatsCollection;
    habitatsCollection.isReverseSortingForeign = !habitatsCollection.isReverseSortingForeign, this.onPlayerInformationUpdated()
  }, MenuPlayerProfileExternalDataSource.prototype.sendInvitationToPlayer = function(data) {
    this.request({ id: data.player.id }, "AllianceAction/sendInvitation", { callBack: this.handleSessionUpdateResponse })
  }, MenuPlayerProfileExternalDataSource.prototype.cancelInvitationToPlayer = function(data) {
    this.request({ id: data.player.id }, "AllianceAction/cancelInvitation", { callBack: this.handleSessionUpdateResponse })
  }, MenuPlayerProfileExternalDataSource.prototype.dismissPlayer = function(data) {
    servicesGameDataManager.playersCollection.flushPlayersDataOnDisbandFromAlliance(data.player.id), this.request({ id: data.player.id }, "AllianceAction/dismissPlayer", { callBack: this.handleSessionUpdateResponse })
  }, MenuPlayerProfileExternalDataSource.prototype.acceptApplicationFromPlayer = function(data) {
    servicesGameDataManager.playersCollection.flushPlayersData(data.player.id), this.request({ id: data.player.id }, "AllianceAction/acceptApplication", { callBack: this.applicationStatusChanged })
  }, MenuPlayerProfileExternalDataSource.prototype.rejectApplicationFromPlayer = function(data) {
    servicesGameDataManager.playersCollection.flushPlayersData(data.player.id), this.request({ id: data.player.id }, "AllianceAction/declineApplication", { callBack: this.applicationStatusChanged })
  }, MenuPlayerProfileExternalDataSource.prototype.applicationStatusChanged = function(data) {
    this.handleSessionUpdateResponse(data), this.notify(xy.eNames.menuPlayerProfileExternal.onApplicationStatusChanged)
  }, MenuPlayerProfileExternalDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuPlayerProfileExternal.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuPlayerProfileExternal.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuPlayerProfileExternalComponent) {
  "use strict";
  function MenuPlayerProfileExternalPresenter(options) {
    MenuPlayerProfileExternalPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuPlayerProfileExternalPresenter, CorePresenterElementMenu), MenuPlayerProfileExternalPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuPlayerProfileExternalComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuPlayerProfileExternalPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceProfile.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuAllianceInvitation, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListButtonDisplayLink, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.widgetContentText, xy.dNames.components.widgetRename, xy.dNames.components.allianceInvitationMenuElement, xy.dNames.components.widgetHabitatAmount, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuAllianceInvitation, utilsObject, settingsGameConstant, servicesTheme, servicesWorldSettings, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsMenuListButtonDisplayLink, ComponentsWidgetAllianceRelationBadge, ComponentsWidgetContentText, ComponentsWidgetRename, ComponentsAllianceInvitationMenuElement, ComponentsWidgetHabitatAmount) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuAllianceInvitation],
    getInitialState: function() {
      return { activeModelLinkClicker: 0 }
    },
    onAllianceRenameSubmitClick: function(newName) {
      this.props.presenter.notify(xy.eNames.menuAllianceProfile.updateNickName, { newName: newName })
    },
    onAcceptSharingClick: function(sharingModel, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceProfile.acceptAllianceSharing, { sharingId: sharingModel.id })
    },
    onDeleteSharingClick: function(sharingModel, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceProfile.deleteAllianceSharing, { sharingId: sharingModel.id })
    },
    onApplyToAllianceClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceProfile.applyToAlliance, { allianceId: this.props.settings.alliance.id })
    },
    onRevokeApplicationToAllianceClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceProfile.revokeApplicationToAlliance, { allianceId: this.props.settings.alliance.id })
    },
    render: function() {
      var settings = {
        alliance: {},
        ownAllianceId: 0,
        sharingReservation: null,
        canChangeAllianceDescription: !1,
        canChangeDiplomaticRelation: !1,
        isApplyToAllianceAvailable: !1,
        isRevokeApplicationAvailable: !1,
        invitations: [],
        player: null,
        revokeApplicationToAlliance: !1,
        applyToAlliance: !1,
        canChangeName: !1,
        forceNextRedrawUpdate: !1,
        featureStatisticUrl: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var sectionComponentSettings, componentsSections = [], themeIcons = servicesTheme.themeSettings.imagesClassNames;
      if (settings.canChangeName) {
        var renameSectionSettings = {
          name: settings.alliance.name,
          onSubmitAction: this.onAllianceRenameSubmitClick,
          initialComponent: this,
          alertPosition: "bottom",
          minLength: servicesWorldSettings.settings.allianceNameLengthMin,
          maxLength: servicesWorldSettings.settings.allianceNameLengthMax,
          forceNextRedrawUpdate: settings.forceNextRedrawUpdate,
          habitat: settings.currentHabitat
        };
        sectionComponentSettings = {
          title: servicesInternationalization.localize("Nickname"),
          rightColumnDataValue: React.createElement(ComponentsWidgetRename, { settings: renameSectionSettings })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "profile-rename"
        }))
      } else sectionComponentSettings = {
        classes: "first",
        iconLeft: "icon-game icon-ButtonAlliance",
        title: settings.alliance.name,
        iconRight: React.createElement(ComponentsWidgetAllianceRelationBadge, {
          settings: {
            allianceId: settings.alliance.id,
            classes: "icon-right"
          }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-name"
      }));
      sectionComponentSettings = {
        title: servicesInternationalization.localize("Points"),
        rightColumnDataValue: settings.alliance.points,
        iconLeft: "icon icon-game icon-PointsTime"
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-points"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Average points"),
        rightColumnDataValue: settings.alliance.pointsAverage,
        iconLeft: "icon icon-game icon-PointsAverage"
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-points-average"
      })), utilsObject.isEmpty(settings.alliance.habitatCountByTypeDictionary) || (sectionComponentSettings = { habitatCountByTypeDictionary: settings.alliance.habitatCountByTypeDictionary }, componentsSections.push(React.createElement(ComponentsWidgetHabitatAmount, {
        settings: sectionComponentSettings,
        key: "habitat-amount-widget"
      }))), sectionComponentSettings = {
        title: servicesInternationalization.localize("Alliance rankings"),
        rightColumnDataValue: settings.alliance.rank,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuRankModeChooser.name,
          options: { rankingId: settings.alliance.id, rankingMode: settingsGameConstant.RANKING_MODE.ALLIANCE }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-rank"
      }));
      var amountOfMembers = settings.alliance.playerArray ? settings.alliance.playerArray.length : 1;
      sectionComponentSettings = {
        title: servicesInternationalization.localize("Members"),
        rightColumnDataValue: amountOfMembers,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuPlayersList.name,
          options: {
            playersList: settings.alliance.playerArray,
            mode: settingsGameConstant.PLAYERS_LIST_MODE.ALLIANCE_MEMBERS_LIST,
            allianceId: settings.alliance.id
          }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-members"
      })), sectionComponentSettings = { title: servicesInternationalization.localize("Description") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-title-description"
      })), sectionComponentSettings = {
        content: settings.alliance.descriptionText || servicesInternationalization.localize("No Description"),
        executingComponent: this,
        classes: "menu-list-element menu-list-element-basic"
      }, componentsSections.push(React.createElement(ComponentsWidgetContentText, {
        settings: sectionComponentSettings,
        key: "component-alliance-description"
      })), settings.canChangeAllianceDescription && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Edit Description"),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuAllianceDescription.name,
          options: { description: settings.alliance.descriptionText }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-description-edit"
      }))), settings.featureStatisticUrl && (sectionComponentSettings = {
        iconLeft: themeIcons.featureStatisticView.featureIcon,
        title: servicesInternationalization.localize("AllianceStatisticsButton"),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuExternalIFrameInjection.name,
          options: { targetURL: settings.featureStatisticUrl }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-alliance-statistic"
      }))), sectionComponentSettings = {
        iconLeft: "icon-game icon-PasteboardAllianceIcon",
        onClick: this.onGetModelLinkClick.bind(this, settings.alliance),
        targetModel: settings.alliance,
        defaultTitle: servicesInternationalization.localize("Display alliance link")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonDisplayLink, {
        settings: sectionComponentSettings,
        key: "menu-button-copy-alliance-link"
      })), settings.sharingReservation && (settings.sharingReservation.accepted === !0 || settings.sharingReservation.sourceAlliance === settings.ownAllianceId ? (sectionComponentSettings = {
        iconLeft: "icon-game icon-Cancel",
        onClick: this.onDeleteSharingClick.bind(this, settings.sharingReservation),
        title: servicesInternationalization.localize("Reject sharing reservations")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-stop-alliance-sharing"
      }))) : settings.sharingReservation.destinationAlliance === settings.ownAllianceId && (sectionComponentSettings = {
        iconLeft: "icon-game icon-BuffActivate",
        onClick: this.onAcceptSharingClick.bind(this, settings.sharingReservation),
        title: servicesInternationalization.localize("Approve")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-accept-alliance-sharing"
      })), sectionComponentSettings = {
        iconLeft: "icon-game icon-Cancel",
        onClick: this.onDeleteSharingClick.bind(this, settings.sharingReservation),
        title: servicesInternationalization.localize("Reject")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-reject-alliance-sharing"
      })))), settings.canChangeDiplomaticRelation && (sectionComponentSettings = {
        iconLeft: React.createElement(ComponentsWidgetAllianceRelationBadge, {
          settings: {
            allianceId: settings.alliance.id,
            classes: "icon-left"
          }
        }),
        title: servicesInternationalization.localize("Diplomacy Relationship"),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuAllianceDiplomacySettings.name,
          options: { allianceId: settings.alliance.id }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-relations-management"
      }))), settings.invitations.length && (sectionComponentSettings = {
        invitations: settings.invitations,
        initialComponent: this,
        onAcceptClick: this.onAcceptAllianceInvitationClick,
        onRejectClick: this.onRejectAllianceInvitationClick
      }, componentsSections.push(React.createElement(ComponentsAllianceInvitationMenuElement, {
        settings: sectionComponentSettings,
        key: "component-alliance-innovations-to-alliance"
      }))), settings.canApplyToAlliance && (sectionComponentSettings = {
        iconLeft: themeIcons.alliance.applyToAlliance,
        title: servicesInternationalization.localize("Apply for an alliance"),
        onClick: this.onApplyToAllianceClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-application-apply"
      }))), settings.canRevokeApplicationToAlliance && (sectionComponentSettings = {
        iconLeft: themeIcons.alliance.revokeApplicationToAlliance,
        title: servicesInternationalization.localize("Revoke application"),
        onClick: this.onRevokeApplicationToAllianceClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-application-revoke"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceProfile.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  function MenuAllianceProfileExternalController(options) {
    MenuAllianceProfileExternalController.__super__.constructor.call(this, options);
    var MenuAllianceManagementController = gameInstance.injector.get(xy.dNames.game.menuAllianceManagement.controller);
    this.forLinking = [{
      resourceClass: MenuAllianceManagementController,
      methodName: xy.eNames.menuAllianceManagement.acceptAllianceInvitation
    }, {
      resourceClass: MenuAllianceManagementController,
      methodName: xy.eNames.menuAllianceManagement.rejectAllianceInvitation
    }], this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuAllianceProfile.dataIsAvailable]
    }, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuAllianceProfile.dataIsAvailable]
    }], this.forceNextRedrawUpdate = !1, this.localizedName = servicesInternationalization.localize("Profile")
  }

  return utilsOop.extend(MenuAllianceProfileExternalController, CoreControllerElementMenu), MenuAllianceProfileExternalController.prototype[xy.eNames.menuAllianceProfile.dataIsAvailable] = function() {
    var data;
    this.isActive && (data = this.dataSource.getAllianceData(this.initialOptions.allianceId), this.forceNextRedrawUpdate && (data.forceNextRedrawUpdate = !0, this.forceNextRedrawUpdate = !1), this.presenter.draw(data))
  }, MenuAllianceProfileExternalController.prototype[xy.eNames.menuAllianceProfile.acceptAllianceSharing] = function(options) {
    this.dataSource.acceptSharing(options)
  }, MenuAllianceProfileExternalController.prototype[xy.eNames.menuAllianceProfile.deleteAllianceSharing] = function(options) {
    this.dataSource.deleteSharing(options)
  }, MenuAllianceProfileExternalController.prototype[xy.eNames.menuAllianceProfile.updateNickName] = function(options) {
    this.dataSource.changeAllianceNick(options)
  }, MenuAllianceProfileExternalController.prototype[xy.eNames.menuAllianceProfile.applyToAlliance] = function(options) {
    var appliedAlliancesId, isAppliedAlready = !1, player = servicesGameDataManager.playersCollection.getPlayer(), allianceApplications = player.allianceAplications;
    for (appliedAlliancesId in allianceApplications)if (allianceApplications.hasOwnProperty(appliedAlliancesId) && +appliedAlliancesId !== +options.allianceId) {
      isAppliedAlready = !0;
      break
    }
    if (isAppliedAlready) {
      var text = servicesInternationalization.localize("You already applied for an other alliance. Do you want to revoke the old application and apply for this alliance?");
      this.showDialogDialog({
        title: "",
        text: text,
        callbackSuccess: this.dataSource.applyForApplication.bind(this.dataSource, options)
      })
    } else this.dataSource.applyForApplication(options)
  }, MenuAllianceProfileExternalController.prototype[xy.eNames.menuAllianceProfile.revokeApplicationToAlliance] = function(options) {
    this.dataSource.revokeAllianceApplication(options)
  }, MenuAllianceProfileExternalController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.requestAllianceData(this.initialOptions.allianceId);
  }, MenuAllianceProfileExternalController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceProfile.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(gameInstance, CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuAllianceProfileExternalDataSource(options) {
    var MenuAllianceHabitatReservationSettingsDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceHabitatReservationSettings.dataSource), MenuAllianceManagementDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceManagement.dataSource);
    this.forLinking = [{
      resourceClass: MenuAllianceHabitatReservationSettingsDataSource,
      methodName: "acceptSharing"
    }, {
      resourceClass: MenuAllianceHabitatReservationSettingsDataSource,
      methodName: "deleteSharing"
    }, {
      resourceClass: MenuAllianceManagementDataSource,
      methodName: "acceptInvitation"
    }, {
      resourceClass: MenuAllianceManagementDataSource,
      methodName: "rejectInvitation"
    }], MenuAllianceProfileExternalDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceProfileExternalDataSource, CoreDataSource), MenuAllianceProfileExternalDataSource.prototype.getAllianceData = function(allianceId) {
    var data, player = servicesGameDataManager.playersCollection.getPlayer(), myAllianceId = servicesGameDataManager.getAllianceId(), canChangeAllianceDescription = player.canDiplomacy() && +allianceId === +myAllianceId, canChangeDiplomaticRelation = player.canDiplomacy() && allianceId !== myAllianceId, canChangeName = player.canDisband() && +allianceId === +myAllianceId;
    data = {
      canChangeName: canChangeName,
      canChangeAllianceDescription: canChangeAllianceDescription,
      canChangeDiplomaticRelation: canChangeDiplomaticRelation,
      ownAllianceId: servicesGameDataManager.getAllianceId(),
      sharingReservation: servicesGameDataManager.alliancesCollection.getSharingByAlliance(allianceId),
      alliance: servicesGameDataManager.alliancesCollection.getAlliance(allianceId)
    };
    var statisticLink = servicesTheme.getStatisticLink({
      entity: "alliance",
      worldId: servicesGameDataManager.settings.worldId,
      playerId: player.id,
      allianceId: allianceId
    });
    return statisticLink && (data.featureStatisticUrl = statisticLink), data.invitations = servicesGameDataManager.playersCollection.geInvitationsFromAlliance(allianceId), myAllianceId !== allianceId && 0 === data.invitations.length && (player.allianceAplications[allianceId] ? data.canRevokeApplicationToAlliance = !0 : data.canApplyToAlliance = !0), data
  }, MenuAllianceProfileExternalDataSource.prototype.requestAllianceData = function(allianceId) {
    var alliance = servicesGameDataManager.alliancesCollection.getAlliance(allianceId);
    alliance && alliance.updated ? this.notify(xy.eNames.menuAllianceProfile.dataIsAvailable) : this.request({ id: allianceId }, "AllianceAction/allianceInformation", { callBack: this.receiveAlliance })
  }, MenuAllianceProfileExternalDataSource.prototype.receiveAlliance = function(data) {
    servicesGameDataManager.alliancesCollection.updateAllianceWithFullData(data)
  }, MenuAllianceProfileExternalDataSource.prototype.changeAllianceNick = function(options) {
    this.request({ name: options.newName }, "AllianceAction/changeAllianceData", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuAllianceProfileExternalDataSource.prototype.applyForApplication = function(options) {
    this.request({ id: options.allianceId }, "AllianceAction/apply", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuAllianceProfileExternalDataSource.prototype.revokeAllianceApplication = function(options) {
    this.request({ id: options.allianceId }, "AllianceAction/revokeApplication", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuAllianceProfileExternalDataSource.prototype.handleAllianceRenaming = function(data) {
    console.log("Ally rename response"), console.log(data)
  }, MenuAllianceProfileExternalDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceProfile.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceProfile.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceProfileExternalComponent) {
  "use strict";
  function MenuAllianceProfileExternalPresenter(options) {
    MenuAllianceProfileExternalPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceProfileExternalPresenter, CorePresenterElementMenu), MenuAllianceProfileExternalPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceProfileExternalComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceProfileExternalPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDescription.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.inputContent, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsInputContent) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return this.descriptionLimit = servicesWorldSettings.settings["Alliance.descriptionText.length"], {
        content: !1,
        isContentValid: !1
      }
    }, onContentChange: function(event, newContent) {
      var isContentValid, value = newContent || event.target.value, valueLength = value.length;
      valueLength > +this.descriptionLimit && (value = value.substr(0, +this.descriptionLimit), valueLength = this.descriptionLimit), isContentValid = valueLength >= settingsGameConstant.MIN_LENGTH_CONTENT && valueLength <= this.descriptionLimit, this.setState({
        content: value,
        isContentValid: isContentValid
      }, null)
    }, onAllianceDescriptionChangeClick: function() {
      this.props.presenter.notify(xy.eNames.menuAllianceDescription.updateDescription, { newDescription: this.state.content })
    }, render: function() {
      var titleSettings, settings = { description: "" };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, descriptionLength, componentsSections = [];
      titleSettings = { title: this.props.settingsTitle.localizedTitle }, titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, descriptionLength = this.state.content !== !1 ? this.state.content.length : settings.description ? settings.description.length : 0, sectionComponentSettings = {
        value: this.state.content !== !1 ? this.state.content : settings.description,
        counter: servicesInternationalization.localize("Description (%d/%d)", descriptionLength, this.descriptionLimit),
        onChange: this.onContentChange
      }, componentsSections.push(React.createElement(ComponentsInputContent, {
        settings: sectionComponentSettings,
        key: "component-content"
      })), sectionComponentSettings = {
        onClick: this.onAllianceDescriptionChangeClick,
        title: servicesInternationalization.localize("Finish"),
        disabled: !this.state.isContentValid
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-send"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDescription.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuAllianceDescriptionController(options) {
    MenuAllianceDescriptionController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Edit Description")
  }

  return utilsOop.extend(MenuAllianceDescriptionController, CoreControllerElementMenu), MenuAllianceDescriptionController.prototype[xy.eNames.menuAllianceDescription.updateDescription] = function(options) {
    this.dataSource.changeAllianceDescription(options)
  }, MenuAllianceDescriptionController.prototype[xy.eNames.menuAllianceDescription.onUpdatedDescription] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuAllianceDescriptionController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.initialOptions)
  }, MenuAllianceDescriptionController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDescription.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, function(CoreDataSource, utilsOop) {
  "use strict";
  function MenuAllianceDescriptionDataSource(options) {
    MenuAllianceDescriptionDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDescriptionDataSource, CoreDataSource), MenuAllianceDescriptionDataSource.prototype.changeAllianceDescription = function(options) {
    this.request({ descriptionText: options.newDescription }, "AllianceAction/changeAllianceData", { callBack: this.responseFromChangeAllianceDescription })
  }, MenuAllianceDescriptionDataSource.prototype.responseFromChangeAllianceDescription = function(data) {
    this.handleSessionUpdateResponse(data), this.notify(xy.eNames.menuAllianceDescription.onUpdatedDescription)
  }, MenuAllianceDescriptionDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDescription.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceDescription.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceDescriptionComponent) {
  "use strict";
  function MenuAllianceDescriptionPresenter(options) {
    MenuAllianceDescriptionPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDescriptionPresenter, CorePresenterElementMenu), MenuAllianceDescriptionPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceDescriptionComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceDescriptionPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceManagement.componentNoAlliance, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuAllianceInvitation, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.inputTextFieldWithValidation, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.allianceInvitationMenuElement, xy.dNames.components.allianceMenuElement, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuAllianceInvitation, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsInputTextFieldWithValidation, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsAllianceInvitationMenuElement, ComponentsAllianceMenuElement) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuAllianceInvitation],
    onSubmitNameForNewAllianceClick: function(value, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceManagement.createNewAlliance, { name: value })
    },
    render: function() {
      var settings = {
        invitations: [],
        applications: [],
        attemptName: "",
        errors: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = {
        classes: "first",
        title: servicesInternationalization.localize("Apply for an alliance")
      }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-title-go-to-rank-alliance"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Ranking"),
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuRankModeChooser.name,
          options: { rankingId: null, rankingMode: settingsGameConstant.RANKING_MODE.ALLIANCE }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-rank"
      })), sectionComponentSettings = {
        classes: "first",
        title: servicesInternationalization.localize("Form a new alliance")
      }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-title-new-alliance"
      }));
      var subSectionSettings = {
        submitButton: { context: this, onClick: this.onSubmitNameForNewAllianceClick },
        value: settings.attemptName,
        forcedErrorText: settings.errors,
        validationErrorText: servicesInternationalization.localize("The name is too short"),
        removeSpaces: !0,
        validationRegExp: /.{3,}/g
      };
      sectionComponentSettings = {
        iconLeft: "icon-game icon-ButtonAlliance",
        title: servicesInternationalization.localize("Nickname"),
        rightColumnDataValue: React.createElement(ComponentsInputTextFieldWithValidation, { settings: subSectionSettings })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-name"
      })), settings.invitations.length && (sectionComponentSettings = {
        invitations: settings.invitations,
        initialComponent: this,
        onAcceptClick: this.onAcceptAllianceInvitationClick,
        onRejectClick: this.onRejectAllianceInvitationClick
      }, componentsSections.push(React.createElement(ComponentsAllianceInvitationMenuElement, {
        settings: sectionComponentSettings,
        key: "component-alliance-innovations-to-alliance"
      }))), settings.applications.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Sent application") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-applications-title"
      })), settings.applications.forEach(function(alliance) {
        sectionComponentSettings = {
          alliance: alliance,
          initialComponent: this
        }, componentsSections.push(React.createElement(ComponentsAllianceMenuElement, {
          settings: sectionComponentSettings,
          key: "menu-element-ally-details" + alliance.id
        }))
      }, this));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceManagement.componentInAlliance, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuAllianceInvitation, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.allianceInvitationMenuElement, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuAllianceInvitation, settingsGameConstant, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsAllianceInvitationMenuElement) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuAllianceInvitation],
    onLeaveAllianceClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceManagement.leaveAlliance)
    },
    onDisbandAllianceClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceManagement.disbandAlliance)
    },
    render: function() {
      var settings = {
        alliance: {},
        diplomacyAmount: 0,
        invitations: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = {
        classes: "first",
        title: servicesInternationalization.localize("Profile"),
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuAllianceProfile.name,
          options: { allianceId: settings.alliance.id }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-profile"
      }));
      var amountOfMembers = settings.alliance.playerArray ? settings.alliance.playerArray.length : 1;
      sectionComponentSettings = {
        title: servicesInternationalization.localize("Members"),
        rightColumnDataValue: amountOfMembers,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuPlayersList.name,
          options: {
            playersList: settings.alliance.playerArray,
            mode: settingsGameConstant.PLAYERS_LIST_MODE.ALLIANCE_MEMBERS_LIST,
            allianceId: settings.alliance.id
          }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-members"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Points"),
        rightColumnDataValue: settings.alliance.points,
        iconLeft: "icon icon-game icon-PointsTime"
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-points"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Alliance rankings"),
        rightColumnDataValue: settings.alliance.rank,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuRankModeChooser.name,
          options: { rankingId: settings.alliance.id, rankingMode: settingsGameConstant.RANKING_MODE.ALLIANCE }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-rank"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Castle Reservations"),
        rightColumnDataValue: servicesGameDataManager.habitatsCollection.ownHabitatReservationAmounts.accepted + "/" + servicesGameDataManager.habitatsCollection.ownHabitatReservationAmounts.requested,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceHabitatReservation.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-castle-reservation"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Clashes"),
        rightColumnDataValue: servicesGameDataManager.alliancesCollection.warClashedAmount,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceClashes.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-war-effort"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Diplomacy"),
        rightColumnDataValue: settings.diplomacyAmount,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceDiplomacy.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-diplomacy"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Invitations / Applications"),
        rightColumnDataValue: 0
      };
      var invitationsCount = settings.alliance.invitedPlayerArray instanceof Array ? settings.alliance.invitedPlayerArray.length : 0, applicantCount = settings.alliance.applicantArray instanceof Array ? settings.alliance.applicantArray.length : 0;
      (invitationsCount || applicantCount) && (sectionComponentSettings.rightColumnDataValue = invitationsCount + "/" + applicantCount, sectionComponentSettings.iconRight = "controls menu-next", sectionComponentSettings.onClick = this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceInvitations.name })), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-alliance-invitations"
      })), sectionComponentSettings = {
        onClick: this.onLeaveAllianceClick,
        title: servicesInternationalization.localize("Leave alliance")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-leave-alliance"
      })), servicesGameDataManager.playersCollection.getPlayer().canDisband() && (sectionComponentSettings = {
        onClick: this.onDisbandAllianceClick,
        title: servicesInternationalization.localize("Disband alliance")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-disband-alliance"
      }))), settings.invitations.length && (sectionComponentSettings = {
        invitations: settings.invitations,
        initialComponent: this,
        onAcceptClick: this.onAcceptAllianceInvitationClick,
        onRejectClick: this.onRejectAllianceInvitationClick
      }, componentsSections.push(React.createElement(ComponentsAllianceInvitationMenuElement, {
        settings: sectionComponentSettings,
        key: "component-alliance-innovations-to-alliance"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceManagement.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  function MenuAllianceManagementController(options) {
    MenuAllianceManagementController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitatReservation,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Alliance")
  }

  return utilsOop.extend(MenuAllianceManagementController, CoreControllerElementMenu), MenuAllianceManagementController.prototype[xy.eNames.menuAllianceManagement.createNewAlliance] = function(data) {
    this.dataSource.createNewAlliance(data)
  }, MenuAllianceManagementController.prototype[xy.eNames.menuAllianceManagement.acceptAllianceInvitation] = function(data) {
    var text, ownAllianceId = servicesGameDataManager.getAllianceId();
    text = ownAllianceId ? "Change alliance" : "Accept invitation", this.showDialogDialog({
      title: servicesInternationalization.localize("Invitations"),
      text: servicesInternationalization.localize(text),
      callbackSuccess: this.dataSource.acceptInvitation.bind(this.dataSource, data)
    })
  }, MenuAllianceManagementController.prototype[xy.eNames.menuAllianceManagement.rejectAllianceInvitation] = function(data) {
    this.showDialogDialog({
      title: servicesInternationalization.localize("Invitations"),
      text: servicesInternationalization.localize("Decline invitation"),
      callbackSuccess: this.dataSource.rejectInvitation.bind(this.dataSource, data)
    })
  }, MenuAllianceManagementController.prototype[xy.eNames.menuAllianceManagement.leaveAlliance] = function() {
    this.showDialogDialog({
      title: servicesInternationalization.localize("Alliance"),
      text: servicesInternationalization.localize("Leave alliance"),
      callbackSuccess: this.dataSource.leaveAlliance.bind(this.dataSource)
    })
  }, MenuAllianceManagementController.prototype[xy.eNames.menuAllianceManagement.disbandAlliance] = function() {
    this.showDialogDialog({
      title: servicesInternationalization.localize("Alliance"),
      text: servicesInternationalization.localize("Disband alliance"),
      callbackSuccess: this.dataSource.disbandAlliance.bind(this.dataSource)
    })
  }, MenuAllianceManagementController.prototype.prepareDataForDraw = function() {
    if (this.isActive) {
      var data = this.dataSource.getAllianceData(this.initialOptions.allianceId);
      switch (data.mode) {
        case settingsGameConstant.ALLIANCE_MANAGEMENT_MODE.NO_ALLIANCE:
          this.presenter.drawNoAllianceComponent(data);
          break;
        case settingsGameConstant.ALLIANCE_MANAGEMENT_MODE.IN_ALLIANCE:
          this.presenter.drawInAllianceComponent(data)
      }
    }
  }, MenuAllianceManagementController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceManagement.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, settingsGameConstant) {
  "use strict";
  function MenuAllianceManagementDataSource(options) {
    MenuAllianceManagementDataSource.__super__.constructor.call(this, options), this.page = null
  }

  return utilsOop.extend(MenuAllianceManagementDataSource, CoreDataSource), MenuAllianceManagementDataSource.prototype.getAllianceData = function() {
    var alliance = servicesGameDataManager.alliancesCollection.getAlliance(), invitations = servicesGameDataManager.playersCollection.getAllInviterAlliances(), applications = servicesGameDataManager.playersCollection.getAppliedAlliences(), diplomacyAmount = servicesGameDataManager.alliancesCollection.getDiplomacyList().length, mode = alliance ? settingsGameConstant.ALLIANCE_MANAGEMENT_MODE.IN_ALLIANCE : settingsGameConstant.ALLIANCE_MANAGEMENT_MODE.NO_ALLIANCE;
    return {
      alliance: alliance,
      invitations: invitations,
      applications: applications,
      diplomacyAmount: diplomacyAmount,
      mode: mode
    }
  }, MenuAllianceManagementDataSource.prototype.createNewAlliance = function(data) {
    this.request({ name: data.name }, "AllianceAction/createAlliance", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceManagementDataSource.prototype.acceptInvitation = function(data) {
    this.request({ id: data.allianceId }, "AllianceAction/acceptInvitation", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceManagementDataSource.prototype.rejectInvitation = function(data) {
    this.request({ id: data.allianceId }, "AllianceAction/declineInvitation", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceManagementDataSource.prototype.leaveAlliance = function() {
    servicesGameDataManager.alliancesCollection.resetDiplomacyRelations = !0, this.request({}, "AllianceAction/leaveAlliance", { callBack: this.quitAllianceHandler })
  }, MenuAllianceManagementDataSource.prototype.disbandAlliance = function() {
    servicesGameDataManager.alliancesCollection.resetDiplomacyRelations = !0, this.request({ id: servicesGameDataManager.getAllianceId() }, "AllianceAction/disbandAlliance", { callBack: this.quitAllianceHandler })
  }, MenuAllianceManagementDataSource.prototype.quitAllianceHandler = function(data) {
    data.error || this.notify(xy.eNames.menu.closeViewUpToRoot), this.handleSessionUpdateResponse(data)
  }, MenuAllianceManagementDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceManagement.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceManagement.componentNoAlliance, xy.dNames.game.menuAllianceManagement.componentInAlliance, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceManagementComponentNoAlliance, MenuAllianceManagementComponentInAlliance) {
  "use strict";
  function MenuAllianceManagementPresenter(options) {
    MenuAllianceManagementPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceManagementPresenter, CorePresenterElementMenu), MenuAllianceManagementPresenter.prototype.drawNoAllianceComponent = function(data) {
    this.draw(data, MenuAllianceManagementComponentNoAlliance)
  }, MenuAllianceManagementPresenter.prototype.drawInAllianceComponent = function(data) {
    this.draw(data, MenuAllianceManagementComponentInAlliance)
  }, MenuAllianceManagementPresenter.prototype.draw = function(data, Component) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(Component, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceManagementPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceRightsSettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesDameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { selectedPermissionIdsSet: {} }
    }, onCheckboxClick: function(permission, event) {
      event.preventDefault();
      var selectedPermissionIdsSet = this.state.selectedPermissionIdsSet, status = selectedPermissionIdsSet.hasOwnProperty(permission.id) ? selectedPermissionIdsSet[permission.id] : permission.grant;
      selectedPermissionIdsSet[permission.id] = !status, this.setState({ selectedPermissionIdsSet: selectedPermissionIdsSet }, null)
    }, onDoneClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceRightsSettings.saveRightsSettings, {
        initialSettings: this.props.settings.permissionSettingList,
        changesInSettings: this.state.selectedPermissionIdsSet
      })
    }, render: function() {
      var settings = { permissionSettingList: [] }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var componentsSections = [];
      titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.onDoneClick,
        title: servicesInternationalization.localize("Finish")
      }), settings.permissionSettingList.forEach(function(permissionSettings) {
        var reportSettings = {
          title: servicesInternationalization.localize(servicesTheme.themeSettings.alliancePermissionsName[permissionSettings.id]),
          iconLeft: "icon-permission permission-" + permissionSettings.id,
          isSelectable: !0,
          isSelected: this.state.selectedPermissionIdsSet.hasOwnProperty(permissionSettings.id) ? this.state.selectedPermissionIdsSet[permissionSettings.id] : permissionSettings.grant,
          onSelect: this.onCheckboxClick.bind(this, permissionSettings)
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: reportSettings,
          key: "permission-in-list-" + permissionSettings.id
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceRightsSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceRightsSettingsController(options) {
    MenuAllianceRightsSettingsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw.bind(this, !0)
    }], this.localizedName = servicesInternationalization.localize("Permission"), this.currentPlayer = null
  }

  return utilsOop.extend(MenuAllianceRightsSettingsController, CoreControllerElementMenu), MenuAllianceRightsSettingsController.prototype[xy.eNames.menuAllianceRightsSettings.saveRightsSettings] = function(data) {
    this.dataSource.savePermissionSettings(data, this.currentPlayer)
  }, MenuAllianceRightsSettingsController.prototype[xy.eNames.menuAllianceRightsSettings.onPermissionSet] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuAllianceRightsSettingsController.prototype.prepareDataForDraw = function() {
    this.initialOptions.player && (this.currentPlayer = this.initialOptions.player), this.isActive && this.presenter.draw(this.dataSource.getPermissionSettingsList(this.currentPlayer))
  }, MenuAllianceRightsSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceRightsSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, settingsGameConstant) {
  "use strict";
  function MenuAllianceRightsSettingsDataSource(options) {
    MenuAllianceRightsSettingsDataSource.__super__.constructor.call(this, options)
  }

  var rights = [settingsGameConstant.ALLIANCE_PERMISSION.INVITE_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.MASS_MAIL, settingsGameConstant.ALLIANCE_PERMISSION.MODERATE_FORUM, settingsGameConstant.ALLIANCE_PERMISSION.DIPLOMATIC_RELATIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISMISS_PLAYER, settingsGameConstant.ALLIANCE_PERMISSION.PLAYER_PERMISSIONS, settingsGameConstant.ALLIANCE_PERMISSION.DISBAND_ALLIANCE];
  return utilsOop.extend(MenuAllianceRightsSettingsDataSource, CoreDataSource), MenuAllianceRightsSettingsDataSource.prototype.getPermissionSettingsList = function(player) {
    var alliancePermission = player.alliancePermission || 0, isLeader = alliancePermission === settingsGameConstant.ALLIANCE_PERMISSION.MAX || alliancePermission === settingsGameConstant.ALLIANCE_PERMISSION.ALL, permissionSettingList = [];
    return rights.forEach(function(mask) {
      var settings = { id: mask, grant: !1 };
      (isLeader || alliancePermission & mask) && (settings.grant = !0), permissionSettingList.push(settings)
    }), { permissionSettingList: permissionSettingList }
  }, MenuAllianceRightsSettingsDataSource.prototype.onPermissionSet = function(data) {
    data.Data && data.Data.Player instanceof Array && data.Data.Player.forEach(function(rawPlayer) {
      servicesGameDataManager.playersCollection.updatePlayersProperty({
        id: rawPlayer.id,
        property: "alliancePermission",
        value: rawPlayer.alliancePermission
      })
    }, this), this.notify(xy.eNames.menuAllianceRightsSettings.onPermissionSet)
  }, MenuAllianceRightsSettingsDataSource.prototype.savePermissionSettings = function(data, player) {
    var newSetupValue = 0;
    data.initialSettings.forEach(function(permission) {
      var isChecked = data.changesInSettings.hasOwnProperty(permission.id) ? data.changesInSettings[permission.id] : permission.grant;
      isChecked && (newSetupValue |= permission.id)
    }), this.permission = newSetupValue, this.request({
      id: player.id,
      permission: newSetupValue
    }, "AllianceAction/setPermission", { callBack: this.onPermissionSet })
  }, MenuAllianceRightsSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceRightsSettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceRightsSettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceRightsSettingsComponent) {
  "use strict";
  function MenuAllianceRightsSettingsPresenter(options) {
    MenuAllianceRightsSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceRightsSettingsPresenter, CorePresenterElementMenu), MenuAllianceRightsSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceRightsSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceRightsSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeed.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuBottomBarMain, xy.dNames.components.menuListTextBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuBottomBarMain, ComponentsMenuListTextBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onReportOfHabitatTypeClick: function(capturedHabitat, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneGame.centerMapByCoordinates, {
        mapX: capturedHabitat.mapX,
        mapY: capturedHabitat.mapY
      })
    },
    render: function() {
      var settings = {
        reportsList: [],
        canPlayerModerateForum: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.canPlayerModerateForum && (titleSettings.rightButton = [], titleSettings.rightButton.push({
        icon: "controls menu-bar-settings",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceFeedSettings.name })
      }));
      var sectionComponentSettings, componentsSections = [];
      settings.reportsList.length ? settings.reportsList.forEach(function(report) {
        var reportSettings = {
          title: report.title,
          description: report.description,
          iconLeft: report.icon,
          iconRight: "controls menu-next"
        };
        switch (report.type) {
          case settingsGameConstant.ALLIANCE_REPORT_TYPE.CASTLE_CONQUERED:
          case settingsGameConstant.ALLIANCE_REPORT_TYPE.CASTLE_LOST:
            reportSettings.onClick = this.onReportOfHabitatTypeClick.bind(this, report.variables.capturedHabitat);
            break;
          default:
            reportSettings.onClick = this.handlerNextClick.bind(this, {
              next: xy.dNames.game.menuAllianceFeedOverview.name,
              options: { reportId: report.id }
            })
        }
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: reportSettings,
          key: "menu-element-report-in-list-" + report.id
        }))
      }, this) : (sectionComponentSettings = { text: servicesInternationalization.localize("There are no alliance reports") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-no-messages"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeed.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceFeedController(options) {
    MenuAllianceFeedController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.allianceReport,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this[xy.eNames.menuAllianceFeed.dataIsAvailable]
    }, {
      entity: xy.eNames.dataListeners.dataEntity.allianceReport,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Alliance feed"), this.currentReportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE
  }

  return utilsOop.extend(MenuAllianceFeedController, CoreControllerElementMenu), MenuAllianceFeedController.prototype[xy.eNames.menuAllianceFeed.dataIsAvailable] = function() {
    this.isActive && this.presenter.draw(this.dataSource.prepareAllianceReportsList())
  }, MenuAllianceFeedController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getAllianceReports()
  }, MenuAllianceFeedController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeed.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuAllianceFeedDataSource(options) {
    MenuAllianceFeedDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceFeedDataSource, CoreDataSource), MenuAllianceFeedDataSource.prototype.getAllianceReports = function() {
    servicesGameDataManager.allianceReportsCollection.updated ? this.notify(xy.eNames.menuAllianceFeed.dataIsAvailable) : this.request({}, "AllianceReportAction/allianceReportArray", { callBack: this.receiveAllianceReports })
  }, MenuAllianceFeedDataSource.prototype.receiveAllianceReports = function(data) {
    servicesGameDataManager.allianceReportsCollection.updateAlliancesReports(data)
  }, MenuAllianceFeedDataSource.prototype.prepareAllianceReportsList = function() {
    var reportList = servicesGameDataManager.allianceReportsCollection.getAllianceReportsList(), canPlayerModerateForum = servicesGameDataManager.playersCollection.getPlayer().canModerateForum();
    return { canPlayerModerateForum: canPlayerModerateForum, reportsList: reportList }
  }, MenuAllianceFeedDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeed.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceFeed.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceReportsComponent) {
  "use strict";
  function MenuAllianceFeedPresenter(options) {
    MenuAllianceFeedPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceFeedPresenter, CorePresenterElementMenu), MenuAllianceFeedPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceReportsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceFeedPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTapBarReportSwitcher, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.widgetAlliancePermissionList, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, utilsObject, settingsGameConstant, servicesTheme, servicesGameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsWidgetReportSwitcher, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsWidgetAllianceRelationBadge, ComponentsWidgetAlliancePermissionList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = { report: {} }, titleSettings = {};
      Object.assign(settings, this.props.settings);
      var sectionSettings, player, componentsSections = [], report = settings.report;
      if (this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, sectionSettings = {
                classes: "first",
                title: report.title,
                description: report.description,
                iconLeft: report.icon
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionSettings,
                key: "menu-element-report-title"
              })), report.sendingPlayer && (sectionSettings = { title: servicesInternationalization.localize("From Player") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionSettings,
                key: "component-title-from-player"
              })), player = servicesGameDataManager.playersCollection.getPlayer(report.sendingPlayer), sectionSettings = {
                title: player.nick,
                description: player.points,
                iconLeft: "icon-game icon-ButtonPlayer",
                iconRight: "controls menu-next",
                onClick: this.handlerNextClick.bind(this, {
                  next: xy.dNames.game.menuPlayerProfileExternal.name,
                  options: { playerId: player.id }
                })
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionSettings,
                key: "menu-element-player-from"
              }))), report.receivingPlayer && (sectionSettings = { title: servicesInternationalization.localize("To Player") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionSettings,
                key: "component-title-to-player"
              })), player = servicesGameDataManager.playersCollection.getPlayer(report.receivingPlayer), sectionSettings = {
                title: player.nick,
                description: player.points,
                iconLeft: "icon-game icon-ButtonPlayer",
                iconRight: "controls menu-next",
                onClick: this.handlerNextClick.bind(this, {
                  next: xy.dNames.game.menuPlayerProfileExternal.name,
                  options: { playerId: player.id }
                })
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionSettings,
                key: "menu-element-player-to"
              }))), report.variables) {
        report.variables.alliance && (sectionSettings = { title: servicesInternationalization.localize("For alliance") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-alliance-to"
        })), sectionSettings = {
          title: report.variables.alliance.name,
          description: report.variables.alliance.points,
          iconLeft: "icon-game icon-ButtonAlliance",
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuAllianceProfile.name,
            options: { allianceId: report.variables.alliance.id }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionSettings,
          key: "menu-element-alliance-to"
        }))), (report.variables.oldDiplomaticRelation || 0 === +report.variables.oldDiplomaticRelation) && (sectionSettings = { title: servicesInternationalization.localize("Old diplomacy relationship") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-old-alliance-diplomacy"
        })), sectionSettings = {
          title: servicesInternationalization.localize(servicesTheme.themeSettings.allianceDiplomacyName[report.variables.oldDiplomaticRelation]),
          iconLeft: React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              relation: report.variables.oldDiplomaticRelation,
              classes: "icon-left"
            }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionSettings,
          key: "menu-element-old-alliance-diplomacy"
        }))), (report.variables.newDiplomaticRelation || 0 === +report.variables.newDiplomaticRelation) && (sectionSettings = { title: servicesInternationalization.localize("New diplomacy relationship") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-new-alliance-diplomacy"
        })), sectionSettings = {
          title: servicesInternationalization.localize(servicesTheme.themeSettings.allianceDiplomacyName[report.variables.newDiplomaticRelation]),
          iconLeft: React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              relation: report.variables.newDiplomaticRelation,
              classes: "icon-left"
            }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionSettings,
          key: "menu-element-new-alliance-diplomacy"
        }))), (report.variables.newAlliancePermission || 0 === +report.variables.newAlliancePermission) && (sectionSettings = { title: servicesInternationalization.localize("New Permissions") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-new-permissions"
        })), componentsSections.push(React.createElement(ComponentsWidgetAlliancePermissionList, {
          settings: { permission: report.variables.newAlliancePermission },
          key: "widget-new-permission-list"
        }))), (report.variables.oldAlliancePermission || 0 === +report.variables.oldAlliancePermission) && (sectionSettings = { title: servicesInternationalization.localize("Old Permissions") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-old-permissions"
        })), componentsSections.push(React.createElement(ComponentsWidgetAlliancePermissionList, {
          settings: { permission: report.variables.oldAlliancePermission },
          key: "widget-old-permission-list"
        })));
        var isOldRank = report.variables.oldRankingPosition || 0 === +report.variables.oldRankingPosition, isNewRank = report.variables.newRankingPosition || 0 === +report.variables.newRankingPosition;
        (isNewRank || isOldRank) && (sectionSettings = { title: servicesInternationalization.localize("Alliance rankings") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionSettings,
          key: "component-title-ranking"
        })), isOldRank && (sectionSettings = { title: servicesInternationalization.localize("Old rank (%@)", report.variables.oldRankingPosition) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionSettings,
          key: "component-title-old-rank"
        }))), isNewRank && (sectionSettings = { title: servicesInternationalization.localize("New rank (%@)", report.variables.newRankingPosition) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionSettings,
          key: "component-title-new-rank"
        }))))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuAllianceFeedOverviewController(options) {
    MenuAllianceFeedOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Alliance Report")
  }

  return utilsOop.extend(MenuAllianceFeedOverviewController, CoreControllerElementMenu), MenuAllianceFeedOverviewController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.prepareOverviewReportData(this.initialOptions.reportId))
  }, MenuAllianceFeedOverviewController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedOverview.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuAllianceFeedOverviewDataSource(options) {
    MenuAllianceFeedOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceFeedOverviewDataSource, CoreDataSource), MenuAllianceFeedOverviewDataSource.prototype.prepareOverviewReportData = function(reportId) {
    servicesGameDataManager.allianceReportsCollection.setReportRead(reportId);
    var report = servicesGameDataManager.allianceReportsCollection.getAllianceReport(reportId);
    return { report: report }
  }, MenuAllianceFeedOverviewDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceFeedOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceReportsOverviewComponent) {
  "use strict";
  function MenuAllianceFeedOverviewPresenter(options) {
    MenuAllianceFeedOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceFeedOverviewPresenter, CorePresenterElementMenu), MenuAllianceFeedOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceReportsOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceFeedOverviewPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedSettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { selectedReportsTypesIdsSet: {} }
    }, onCheckboxClick: function(reportType, event) {
      event.preventDefault();
      var selectedReportsTypesIdsSet = this.state.selectedReportsTypesIdsSet, status = selectedReportsTypesIdsSet.hasOwnProperty(reportType.type) ? selectedReportsTypesIdsSet[reportType.type] : reportType.isActive;
      selectedReportsTypesIdsSet[reportType.type] = !status, this.setState({ selectedReportsTypesIdsSet: selectedReportsTypesIdsSet }, null)
    }, onDoneClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceFeedSettings.saveReportsSettings, {
        initialSettings: this.props.settings.settingsList,
        changesInSettings: this.state.selectedReportsTypesIdsSet
      })
    }, render: function() {
      var settings = { settingsList: [] }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var componentsSections = [];
      titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.onDoneClick,
        title: servicesInternationalization.localize("Finish")
      }), settings.settingsList.forEach(function(reportType) {
        var reportSettings = {
          title: servicesInternationalization.localize(reportType.name),
          isSelectable: !0,
          isSelected: this.state.selectedReportsTypesIdsSet.hasOwnProperty(reportType.type) ? this.state.selectedReportsTypesIdsSet[reportType.type] : reportType.isActive,
          onSelect: this.onCheckboxClick.bind(this, reportType)
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: reportSettings,
          key: "menu-element-alliance-report-type-in-list-" + reportType.name
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuAllianceFeedSettingsController(options) {
    MenuAllianceFeedSettingsController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Preferences")
  }

  return utilsOop.extend(MenuAllianceFeedSettingsController, CoreControllerElementMenu), MenuAllianceFeedSettingsController.prototype[xy.eNames.menuAllianceFeedSettings.saveReportsSettings] = function(data) {
    this.dataSource.saveReportsSettings(data)
  }, MenuAllianceFeedSettingsController.prototype[xy.eNames.menuAllianceFeedSettings.onSavedSettings] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuAllianceFeedSettingsController.prototype[xy.eNames.menuAllianceFeedSettings.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuAllianceFeedSettingsController.prototype.prepareDataForDraw = function() {
    this.dataSource.getSettingsList({ mode: this.initialOptions.mode })
  }, MenuAllianceFeedSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, settingsGameConstant) {
  "use strict";
  function menuAllianceFeedSettingsDataSource(options) {
    menuAllianceFeedSettingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(menuAllianceFeedSettingsDataSource, CoreDataSource), menuAllianceFeedSettingsDataSource.prototype.getSettingsList = function() {
    var allianceId = servicesGameDataManager.getAllianceId();
    this.request({ allianceId: allianceId }, "AllianceReportAction/reportSettings", { callBack: this.receiveAllianceReportSettings })
  }, menuAllianceFeedSettingsDataSource.prototype.receiveAllianceReportSettings = function(data) {
    var reportType, allianceReportsTypes = settingsGameConstant.ALLIANCE_REPORT_TYPE, allianceNewsfeedThemeTitles = servicesTheme.themeSettings.featureAllianceNewsFeed.types, settingsList = [];
    for (reportType in allianceReportsTypes)allianceReportsTypes.hasOwnProperty(reportType) && settingsList.push({
      type: allianceReportsTypes[reportType],
      name: allianceNewsfeedThemeTitles[allianceReportsTypes[reportType]],
      isActive: data.reportSettings.indexOf(allianceReportsTypes[reportType]) !== -1
    });
    this.notify(xy.eNames.menuAllianceFeedSettings.dataIsReady, { settingsList: settingsList })
  }, menuAllianceFeedSettingsDataSource.prototype.saveReportsSettings = function(data) {
    var reportSettings = [];
    data.initialSettings.forEach(function(allianceReport) {
      data.changesInSettings.hasOwnProperty(allianceReport.type) ? data.changesInSettings[allianceReport.type] && reportSettings.push(allianceReport.type) : allianceReport.isActive && reportSettings.push(allianceReport.type)
    }, this), this.request({ reportSettings: reportSettings }, "AllianceReportAction/setReportSettings", { callBack: this.onAllianceReportsSettingsSaved })
  }, menuAllianceFeedSettingsDataSource.prototype.onAllianceReportsSettingsSaved = function() {
    servicesGameDataManager.allianceReportsCollection.flushAllianceReportsOnSettingsChanged(), this.notify(xy.eNames.menuAllianceFeedSettings.onSavedSettings)
  }, menuAllianceFeedSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceFeedSettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceFeedSettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceFeedSettingsComponent) {
  "use strict";
  function MenuAllianceFeedSettingsPresenter(options) {
    MenuAllianceFeedSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceFeedSettingsPresenter, CorePresenterElementMenu), MenuAllianceFeedSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceFeedSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceFeedSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceClashes.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuTapBar, xy.dNames.components.widgetAllianceRelationBadge, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuTapBar, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { mode: this.props.settings.mode }
    }, updateCurrentMode: function(newMode, event) {
      event.preventDefault(), event.stopPropagation(), this.setState({ mode: newMode }, null), this.props.presenter.notify(xy.eNames.menuAllianceClashes.changeCurrentMode, { newMode: newMode })
    }, render: function() {
      var settings = {
        clashData: {
          attack: [],
          defense: []
        }
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var tapBarSettings = {
        buttons: [{
          isActive: settingsGameConstant.ALLIANCE_CLASHES_TYPE.ATTACK === this.state.mode,
          title: servicesInternationalization.localize("Attack"),
          onClick: this.updateCurrentMode.bind(this, settingsGameConstant.ALLIANCE_CLASHES_TYPE.ATTACK)
        }, {
          isActive: settingsGameConstant.ALLIANCE_CLASHES_TYPE.DEFENSE === this.state.mode,
          title: servicesInternationalization.localize("Defense"),
          onClick: this.updateCurrentMode.bind(this, settingsGameConstant.ALLIANCE_CLASHES_TYPE.DEFENSE)
        }]
      }, isAttack = settingsGameConstant.ALLIANCE_CLASHES_TYPE.ATTACK === this.state.mode, list = isAttack ? settings.clashData.attack : settings.clashData.defense;
      if (list.length)sectionComponentSettings = {
        title: isAttack ? servicesInternationalization.localize("Transits") : servicesInternationalization.localize("Support bridges")
      }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-alliance-clashes-title"
      })), list.forEach(function(clashModel) {
        var affectedHabitat = servicesGameDataManager.habitatsCollection.getHabitat(clashModel.affectedHabitat), descriptionText = clashModel.isBattle ? servicesInternationalization.localize("Next battle") + ": " : "", onClick = isAttack ? this.handlerCenterMap.bind(this, affectedHabitat) : this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuSupportBridge.name,
          options: { habitatId: clashModel.affectedHabitat }
        });
        sectionComponentSettings = {
          iconLeft: "icon-game icon-habitat-" + affectedHabitat.publicHabitatType,
          title: affectedHabitat.name,
          description: descriptionText + utilsDateTime.remainTime(clashModel.eventDate) + " - " + utilsDateTime.getLocaleDateTimeString(clashModel.eventDate),
          iconRight: React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              playerId: affectedHabitat.player,
              classes: "icon-right"
            }
          }),
          onClick: onClick
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "menu-clash-in-list-" + clashModel.id
        }))
      }, this); else {
        var noEntriesText;
        switch (this.state.mode) {
          case settingsGameConstant.ALLIANCE_CLASHES_TYPE.ATTACK:
            noEntriesText = "Your alliance does not have any attack war efforts.";
            break;
          case settingsGameConstant.ALLIANCE_CLASHES_TYPE.DEFENSE:
            noEntriesText = "Your alliance does not have any defense war efforts."
        }
        sectionComponentSettings = { text: servicesInternationalization.localize(noEntriesText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-text-empty"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceClashes.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuAllianceClashesController(options) {
    MenuAllianceClashesController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.allianceClashes,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.currentMode = settingsGameConstant.ALLIANCE_CLASHES_TYPE.ATTACK, this.localizedName = servicesInternationalization.localize("Clashes")
  }

  return utilsOop.extend(MenuAllianceClashesController, CoreControllerElementMenu), MenuAllianceClashesController.prototype[xy.eNames.menuAllianceClashes.dataIsAvailable] = function() {
    if (this.isActive) {
      var data = this.dataSource.prepareClashesLists({ mode: this.currentMode });
      this.presenter.draw(data), data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuAllianceClashes.dataIsAvailable].bind(this, data))
    }
  }, MenuAllianceClashesController.prototype[xy.eNames.menuAllianceClashes.changeCurrentMode] = function(data) {
    this.currentMode = data.newMode
  }, MenuAllianceClashesController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getClashes()
  }, MenuAllianceClashesController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceClashes.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuAllianceClashesDataSource(options) {
    MenuAllianceClashesDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceClashesDataSource, CoreDataSource), MenuAllianceClashesDataSource.prototype.getClashes = function() {
    servicesGameDataManager.alliancesCollection.warClashedUpdated ? this.notify(xy.eNames.menuAllianceClashes.dataIsAvailable) : this.request({}, "AllianceAction/clashes", { callBack: this.onClashesDataReceived })
  }, MenuAllianceClashesDataSource.prototype.onClashesDataReceived = function(data) {
    data.Data && (servicesGameDataManager.updateHabitatsData(data.Data.Habitat, { isPeripheral: !0 }), servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), servicesGameDataManager.updateAlliancesData(data.Data.Alliance, { isPeripheral: !0 }), servicesGameDataManager.alliancesCollection.updateWarClashesData({
      AllianceClashTransit: data.Data.AllianceClashTransit,
      AllianceClashBattle: data.Data.AllianceClashBattle,
      AllianceClashSupportBridge: data.Data.AllianceClashSupportBridge
    })), this.notify(xy.eNames.menuAllianceClashes.dataIsAvailable)
  }, MenuAllianceClashesDataSource.prototype.prepareClashesLists = function(options) {
    var isTimerable = !1, clashData = servicesGameDataManager.alliancesCollection.getAttackAndDefenseClashes();
    return (clashData.attack.length || clashData.defense.length) && (isTimerable = !0), {
      clashData: clashData,
      mode: options.mode,
      isTimerable: isTimerable
    }
  }, MenuAllianceClashesDataSource.prototype.publishTransitClashInAlliance = function(options) {
    this.request({ transitID: options.transitId }, "AllianceAction/postTransitClash", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceClashesDataSource.prototype.publishBattleClashInAlliance = function(options) {
    this.request({ habitatID: options.habitatId }, "AllianceAction/postBattleClash", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceClashesDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceClashes.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceClashes.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceClashesComponent) {
  "use strict";
  function MenuAllianceClashesPresenter(options) {
    MenuAllianceClashesPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceClashesPresenter, CorePresenterElementMenu), MenuAllianceClashesPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceClashesComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceClashesPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceInvitations.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuTapBar, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuTapBar) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    updateCurrentMode: function(newMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceInvitations.changeCurrentMode, { newMode: newMode })
    },
    render: function() {
      var settings = {
        mode: settingsGameConstant.ALLIANCE_INVITATIONS_MODE.INVITATIONS,
        list: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var text, tapBarSettings = {
        buttons: [{
          isActive: settingsGameConstant.ALLIANCE_INVITATIONS_MODE.INVITATIONS === settings.mode,
          title: servicesInternationalization.localize("Invitations"),
          onClick: this.updateCurrentMode.bind(this, settingsGameConstant.ALLIANCE_INVITATIONS_MODE.INVITATIONS)
        }, {
          isActive: settingsGameConstant.ALLIANCE_INVITATIONS_MODE.APPLICATIONS === settings.mode,
          title: servicesInternationalization.localize("Requests"),
          onClick: this.updateCurrentMode.bind(this, settingsGameConstant.ALLIANCE_INVITATIONS_MODE.APPLICATIONS)
        }]
      };
      if (settings.list.length) {
        settings.list.forEach(function(player) {
          sectionComponentSettings = {
            title: player.nick,
            description: servicesInternationalization.localize("%d Points", player.points),
            onClick: this.handlerNextClick.bind(this, {
              next: xy.dNames.game.menuPlayerProfileExternal.name,
              options: { playerId: player.id, closeMenuOnApplicationStatusChanged: !0 }
            }),
            iconRight: "controls menu-next"
          }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
            settings: sectionComponentSettings,
            key: "menu-player-in-list-" + player.id
          }))
        }, this);
        var numberOfAllianceMembers = servicesGameDataManager.alliancesCollection.getAllianceMembersNumber(), maxNumberOfAllianceMembers = servicesWorldSettings.settings["alliance.playerLimit"];
        text = servicesInternationalization.localize("HeaderTitleAllianceLimitProgress", maxNumberOfAllianceMembers - numberOfAllianceMembers, maxNumberOfAllianceMembers)
      } else switch (settings.mode) {
        case settingsGameConstant.ALLIANCE_INVITATIONS_MODE.INVITATIONS:
          text = servicesInternationalization.localize("Your alliance has not invited anybody to join the alliance");
          break;
        case settingsGameConstant.ALLIANCE_INVITATIONS_MODE.APPLICATIONS:
          text = servicesInternationalization.localize("Your alliance does not have any user applications")
      }
      sectionComponentSettings = { text: text }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-alliance-members-info"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceInvitations.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuAllianceInvitationsController(options) {
    MenuAllianceInvitationsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.currentMode = settingsGameConstant.ALLIANCE_INVITATIONS_MODE.INVITATIONS, this.localizedName = servicesInternationalization.localize("Invitations / Applications")
  }

  return utilsOop.extend(MenuAllianceInvitationsController, CoreControllerElementMenu), MenuAllianceInvitationsController.prototype[xy.eNames.menuAllianceInvitations.changeCurrentMode] = function(data) {
    this.currentMode = data.newMode, this.prepareDataForDraw()
  }, MenuAllianceInvitationsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw({
      list: this.dataSource.getInvitationsList({ mode: this.currentMode }),
      mode: this.currentMode
    })
  }, MenuAllianceInvitationsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceInvitations.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuAllianceInvitationsDataSource(options) {
    MenuAllianceInvitationsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceInvitationsDataSource, CoreDataSource), MenuAllianceInvitationsDataSource.prototype.getInvitationsList = function(options) {
    var listIds;
    switch (options.mode) {
      case settingsGameConstant.ALLIANCE_INVITATIONS_MODE.INVITATIONS:
        listIds = servicesGameDataManager.alliancesCollection.getInvitation();
        break;
      case settingsGameConstant.ALLIANCE_INVITATIONS_MODE.APPLICATIONS:
        listIds = servicesGameDataManager.alliancesCollection.getApplications();
        break;
      default:
        listIds = []
    }
    return servicesGameDataManager.playersCollection.getPlayersListData(listIds)
  }, MenuAllianceInvitationsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceInvitations.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceInvitations.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceInvitationsComponent) {
  "use strict";
  function MenuAlliacneReportsPresenter(options) {
    MenuAlliacneReportsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAlliacneReportsPresenter, CorePresenterElementMenu), MenuAlliacneReportsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceInvitationsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAlliacneReportsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacy.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetAllianceRelationBadge, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentsEngine.createClass({
    selectedReportsIdsSet: {},
    mixins: [mixinsMenuComponentHandlers],
    render: function() {
      var settings = { groupedRelations: {} }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], buildAllianceList = function(diplomacyModel) {
        var alliance = servicesDameDataManager.alliancesCollection.getAlliance(diplomacyModel.targetAlliance), localSettings = {
          iconLeft: React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              allianceId: alliance.id,
              classes: "icon-left"
            }
          }),
          title: alliance.name,
          description: alliance.points,
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuAllianceProfile.name,
            options: { allianceId: alliance.id }
          })
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localSettings,
          key: "menu-element-ally-in-list-" + alliance.id
        }))
      };
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.groupedRelations.groupsKeys && settings.groupedRelations.groupsKeys.length ? settings.groupedRelations.groupsKeys.forEach(function(groupKey, index) {
        var titleSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.allianceDiplomacyName[groupKey]) };
        componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: titleSettings,
          key: "menu-title-diplomacy-group-" + groupKey
        })), settings.groupedRelations.groups[index].forEach(buildAllianceList, this)
      }, this) : (sectionComponentSettings = { text: servicesInternationalization.localize("Your alliance does not have any diplomacy.") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-no-messages"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacy.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceDiplomacyController(options) {
    MenuAllianceDiplomacyController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Diplomacy Relatioship"), this.currentReportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE
  }

  return utilsOop.extend(MenuAllianceDiplomacyController, CoreControllerElementMenu), MenuAllianceDiplomacyController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.getAllianceRelationshipData())
  }, MenuAllianceDiplomacyController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacy.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesGroupable, settingsGameConstant) {
  "use strict";
  function MenuAllianceDiplomacyDataSource(options) {
    MenuAllianceDiplomacyDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDiplomacyDataSource, CoreDataSource), MenuAllianceDiplomacyDataSource.prototype.getAllianceRelationshipData = function() {
    var relationList = servicesGameDataManager.alliancesCollection.getDiplomacyList(), groupedRelations = servicesGroupable.byField(relationList, {
      field: "relationship",
      sortGroups: !0,
      sortGroupsIsReverse: !0
    });
    return { groupedRelations: groupedRelations }
  }, MenuAllianceDiplomacyDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacy.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceDiplomacy.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceDiplomacyComponent) {
  "use strict";
  function MenuAllianceDiplomacyPresenter(options) {
    MenuAllianceDiplomacyPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDiplomacyPresenter, CorePresenterElementMenu), MenuAllianceDiplomacyPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceDiplomacyComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceDiplomacyPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacySettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    selectedReportsIdsSet: {},
    mixins: [mixinsMenuComponentHandlers],
    getInitialState: function() {
      return { currentDiplomacyStatus: this.props.settings.currentDiplomacyStatus }
    },
    onDiplomaticRelationCheckBoxClick: function(diplomaticRelationStatus) {
      this.setState({ currentDiplomacyStatus: diplomaticRelationStatus }, null)
    },
    onSaveButtonClick: function() {
      this.props.presenter.notify(xy.eNames.menuAllianceDiplomacySettings.saveNewDiplomacy, { currentDiplomacyStatus: this.state.currentDiplomacyStatus })
    },
    render: function() {
      var settings = { diplomacyList: [] }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.onSaveButtonClick,
        title: servicesInternationalization.localize("Finish")
      });
      var componentsSections = [];
      settings.diplomacyList.forEach(function(relationId) {
        var localSettings = {
          iconLeft: "icon-alliance-relationship relationship-" + relationId,
          title: servicesTheme.themeSettings.allianceDiplomacyName[relationId],
          isSelectable: !0,
          isSelected: relationId === this.state.currentDiplomacyStatus,
          onSelect: this.onDiplomaticRelationCheckBoxClick.bind(this, relationId)
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localSettings,
          key: "menu-element-ally-relation-" + relationId
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacySettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceDiplomacySettingsController(options) {
    MenuAllianceDiplomacySettingsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Diplomacy Relatioship"), this.currentReportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE
  }

  return utilsOop.extend(MenuAllianceDiplomacySettingsController, CoreControllerElementMenu), MenuAllianceDiplomacySettingsController.prototype[xy.eNames.menuAllianceDiplomacySettings.saveNewDiplomacy] = function(options) {
    options.allianceId = this.initialOptions.allianceId, this.dataSource.saveDiplomacy(options)
  }, MenuAllianceDiplomacySettingsController.prototype[xy.eNames.menuAllianceDiplomacySettings.onSavedDiplomacy] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuAllianceDiplomacySettingsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.getCurrentDiplomacy({ allianceId: this.initialOptions.allianceId }))
  }, MenuAllianceDiplomacySettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacySettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, settingsGameConstant) {
  "use strict";
  function MenuAllianceDiplomacySettingsDataSource(options) {
    MenuAllianceDiplomacySettingsDataSource.__super__.constructor.call(this, options)
  }

  var diplomacyList = [settingsGameConstant.ALLIANCE_RELATIONSHIPS.VASSAL, settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALLY, settingsGameConstant.ALLIANCE_RELATIONSHIPS.NAP, settingsGameConstant.ALLIANCE_RELATIONSHIPS.NEUTRAL, settingsGameConstant.ALLIANCE_RELATIONSHIPS.ENEMY];
  return utilsOop.extend(MenuAllianceDiplomacySettingsDataSource, CoreDataSource), MenuAllianceDiplomacySettingsDataSource.prototype.getCurrentDiplomacy = function(options) {
    options = options || {};
    var currentDiplomacyStatus = servicesGameDataManager.alliancesCollection.getAllianceRelationship(options.allianceId);
    return { currentDiplomacyStatus: currentDiplomacyStatus, diplomacyList: diplomacyList }
  }, MenuAllianceDiplomacySettingsDataSource.prototype.saveDiplomacy = function(options) {
    this.request({
      id: options.allianceId,
      diplomaticValue: options.currentDiplomacyStatus
    }, "AllianceAction/setDiplomaticRelation", { callBack: this.responseFromSaveDiplomacy })
  }, MenuAllianceDiplomacySettingsDataSource.prototype.responseFromSaveDiplomacy = function(data) {
    this.handleSessionUpdateResponse(data), this.notify(xy.eNames.menuAllianceDiplomacySettings.onSavedDiplomacy)
  }, MenuAllianceDiplomacySettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceDiplomacySettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceDiplomacySettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceDiplomacySettingsComponent) {
  "use strict";
  function MenuAllianceDiplomacySettingsPresenter(options) {
    MenuAllianceDiplomacySettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDiplomacySettingsPresenter, CorePresenterElementMenu), MenuAllianceDiplomacySettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceDiplomacySettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceDiplomacySettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservation.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuBottomBarMain, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuTapBar, xy.dNames.components.allianceHabitatReservationsMenuElement, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuBottomBarMain, ComponentsMenuListTextBasic, ComponentsMenuTapBar, ComponentsAllianceHabitatReservationsMenuElement) {
  "use strict";
  return componentsEngine.createClass({
    selectedReservationsSet: {}, mixins: [mixinsMenuComponentHandlers], getNewState: function() {
      return this.selectedReservationsSet = {}, { editMode: !1, selectedAmount: 0 }
    }, getInitialState: function() {
      return this.getNewState()
    }, componentWillReceiveProps: function(newProps) {
      var isHabitatReservationsMissing = newProps.settings.currentGroupingMode === settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN ? newProps.settings.ownList.length < 1 : newProps.settings.groupedReservation.groupsKeys && newProps.settings.groupedReservation.groupsKeys.length < 1;
      newProps.settings.currentGroupingMode !== this.props.settings.currentGroupingMode || isHabitatReservationsMissing ? this.setState(this.getNewState(), null) : (this.selectedReservationsSet = {}, this.setState({ selectedAmount: 0 }, null))
    }, onAcceptButtonClick: function(reservation, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservation.acceptReservation, reservation)
    }, determineEditingMode: function(event) {
      event.preventDefault(), event.stopPropagation(), this.state.editMode || (this.selectedReservationsSet = {}), this.setState({
        editMode: !this.state.editMode,
        selectedAmount: 0
      }, null)
    }, onCheckboxClick: function(reservation, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedAmount = +this.state.selectedAmount;
      this.selectedReservationsSet[reservation.id] ? (this.selectedReservationsSet[reservation.id] = !1, selectedAmount -= 1) : (this.selectedReservationsSet[reservation.id] = reservation, selectedAmount += 1), this.setState({ selectedAmount: selectedAmount }, null)
    }, deleteSelectedEntries: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservation.deleteReservation, this.selectedReservationsSet)
    }, deleteAllEntries: function(event) {
      event.preventDefault(), event.stopPropagation();
      var habitatReservationsIdSet;
      habitatReservationsIdSet = servicesGameDataManager.habitatsCollection.getHabitatReservationsSetOfGroup(this.props.settings.currentGroupingMode), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservation.deleteAllReservations, habitatReservationsIdSet)
    }, updateGroupingMode: function(newGroupingMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservation.setGroupingMode, { newGroupingMode: newGroupingMode })
    }, render: function() {
      var settings = {
        currentGroupingMode: 0,
        groupedReservation: {},
        ownList: [],
        ownAllianceId: 0,
        canEdit: !1,
        settingNumberOfPlayerHabitatReservation: 0
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], bottomBarSection = null, buildReservationList = function(reservationModel) {
        sectionComponentSettings = {
          reservationModel: reservationModel,
          selectedReservationsSet: this.selectedReservationsSet,
          ownAllianceId: settings.ownAllianceId,
          currentGroupingMode: settings.currentGroupingMode,
          canEdit: settings.canEdit,
          editMode: this.state.editMode,
          initialComponent: this
        }, componentsSections.push(React.createElement(ComponentsAllianceHabitatReservationsMenuElement, { settings: sectionComponentSettings }))
      }.bind(this);
      if (this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], settings.canEdit && titleSettings.rightButton.push({
                icon: "controls menu-bar-settings",
                onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceHabitatReservationSettings.name })
              }), this.state.editMode) {
        titleSettings.rightButton.push({
          title: servicesInternationalization.localize("cancel"),
          onClick: this.determineEditingMode
        });
        var bottomBarSectionSettings = {
          leftButton: {
            onClick: this.deleteSelectedEntries,
            title: servicesInternationalization.localize("Delete entries (%ld)", +this.state.selectedAmount),
            isDisabled: this.state.selectedAmount < 1
          }, rightButton: { onClick: this.deleteAllEntries, icon: "controls menu-bar-delete" }
        };
        bottomBarSection = React.createElement(ComponentsMenuBottomBarMain, { settings: bottomBarSectionSettings })
      } else(settings.canEdit || settings.currentGroupingMode === settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN) && titleSettings.rightButton.push({
        icon: "controls menu-bar-edit",
        onClick: this.determineEditingMode,
        isDisabled: settings.currentGroupingMode === settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN ? settings.ownList.length < 1 : settings.groupedReservation.groupsKeys && settings.groupedReservation.groupsKeys.length < 1
      });
      var key, val, tapBarSettings = { buttons: [] };
      for (key in settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE)settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.hasOwnProperty(key) && (val = settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE[key], tapBarSettings.buttons.push({
        isActive: settings.currentGroupingMode === val,
        title: servicesInternationalization.localize(settingsGameConstant.HABITAT_RESERVATION_GROUPING_NAME[val]),
        onClick: this.updateGroupingMode.bind(this, val)
      }));
      if (settings.groupedReservation.groupsKeys && settings.groupedReservation.groupsKeys.length || settings.ownList.length)switch (settings.currentGroupingMode) {
        case settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.DATE:
          settings.groupedReservation.groupsKeys.forEach(function(groupKey, index) {
            var date = settings.groupedReservation.humanKeysSet[groupKey], sectionComponentSettings = { title: utilsDateTime.getLocaleDateString(date) };
            componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
              settings: sectionComponentSettings,
              key: "menu-title-for-group-" + index
            })), settings.groupedReservation.groups[index].forEach(buildReservationList)
          }, this);
          break;
        case settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.PLAYER:
          settings.groupedReservation.groupsKeys.forEach(function(groupKey, index) {
            var nick = servicesGameDataManager.playersCollection.getPlayerProperty("nick", groupKey);
            sectionComponentSettings = { title: nick }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
              settings: sectionComponentSettings,
              key: "menu-title-for-group-" + index
            })), settings.groupedReservation.groups[index].forEach(buildReservationList)
          }, this);
          break;
        case settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN:
          settings.ownList.forEach(buildReservationList)
      } else {
        var text;
        text = settings.currentGroupingMode === settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN ? servicesInternationalization.localize("There are %1$d of %2$d active reservations", 0, settings.settingNumberOfPlayerHabitatReservation) + " " + servicesInternationalization.localize("You do not have an approved castle reservation yet") : servicesInternationalization.localize("No alliance member has reserved a castle"), sectionComponentSettings = { text: text }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-text-no-reservation"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: null,
        bottomBar: bottomBarSection,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservation.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceHabitatReservationController(options) {
    MenuAllianceHabitatReservationController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitatReservation,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Castle Reservations"), this.currentGroupingMode = settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN
  }

  return utilsOop.extend(MenuAllianceHabitatReservationController, CoreControllerElementMenu), MenuAllianceHabitatReservationController.prototype[xy.eNames.menuAllianceHabitatReservation.deleteReservation] = function(selectedEntitySet) {
    this.showDialogDialog({
      title: "Delete",
      text: servicesInternationalization.localize("Do you really want to delete this request?"),
      callbackSuccess: this.dataSource.deleteReservations.bind(this.dataSource, selectedEntitySet)
    })
  }, MenuAllianceHabitatReservationController.prototype[xy.eNames.menuAllianceHabitatReservation.deleteAllReservations] = function(entitySet) {
    this.showDialogDialog({
      title: "Delete",
      text: servicesInternationalization.localize("Do you really want to delete all requests and reservations?"),
      callbackSuccess: this.dataSource.deleteReservations.bind(this.dataSource, entitySet)
    })
  }, MenuAllianceHabitatReservationController.prototype[xy.eNames.menuAllianceHabitatReservation.setGroupingMode] = function(options) {
    this.currentGroupingMode = options.newGroupingMode, this.prepareDataForDraw()
  }, MenuAllianceHabitatReservationController.prototype[xy.eNames.menuAllianceHabitatReservation.acceptReservation] = function(reservation) {
    this.dataSource.changeStatusOfReservations({
      reservationId: reservation.id,
      status: settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED
    })
  }, MenuAllianceHabitatReservationController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.prepareReservationData({ groupingMode: this.currentGroupingMode }))
  }, MenuAllianceHabitatReservationController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservation.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesGroupable, settingsGameConstant) {
  "use strict";
  function MenuAllianceHabitatReservationDataSource(options) {
    MenuAllianceHabitatReservationDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceHabitatReservationDataSource, CoreDataSource), MenuAllianceHabitatReservationDataSource.prototype.prepareReservationData = function(options) {
    options = options || {};
    var list = servicesGameDataManager.habitatsCollection.getHabitatReservationsList(), ownList = [], groupedReservation = {}, player = servicesGameDataManager.getPlayerId();
    switch (options.groupingMode) {
      case settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.DATE:
        groupedReservation = servicesGroupable.arrayByField(list, {
          field: "reservationDate",
          areGroupsDate: !0,
          sortGroups: !0,
          sortGroupsIsReverse: !1,
          sortWithinGroups: !0,
          sortWithinGroupsField: "reservationDate"
        });
        break;
      case settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.PLAYER:
        groupedReservation = servicesGroupable.arrayByField(list, {
          field: "player",
          areGroupsDate: !1,
          sortGroups: !0,
          sortGroupsIsReverse: !1,
          sortWithinGroups: !0,
          sortWithinGroupsField: "reservationDate"
        });
        break;
      case settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.OWN:
        list.forEach(function(reservationModel) {
          reservationModel.player === player && ownList.push(reservationModel)
        }, this)
    }
    return {
      currentGroupingMode: options.groupingMode,
      groupedReservation: groupedReservation,
      ownList: ownList,
      ownAllianceId: servicesGameDataManager.getAllianceId(),
      canEdit: servicesGameDataManager.playersCollection.getPlayer().canDiplomacy(),
      settingNumberOfPlayerHabitatReservation: servicesGameDataManager.alliancesCollection.getAllianceProperty("settingNumberOfPlayerHabitatReservation")
    }
  }, MenuAllianceHabitatReservationDataSource.prototype.deleteReservations = function(selectedEntitySet) {
    var key, idsArray = [];
    for (key in selectedEntitySet)selectedEntitySet.hasOwnProperty(key) && selectedEntitySet[key] !== !1 && idsArray.push(key);
    this.request({ habitatReservationIDArray: idsArray }, "HabitatReservationAction/deleteEntries", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceHabitatReservationDataSource.prototype.changeStatusOfReservations = function(options) {
    this.request({
      habitatReservationID: options.reservationId,
      status: options.status
    }, "HabitatReservationAction/changeStatusOfEntry", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceHabitatReservationDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservation.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceHabitatReservation.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceHabitatReservationComponent) {
  "use strict";
  function MenuAllianceHabitatReservationPresenter(options) {
    MenuAllianceHabitatReservationPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceHabitatReservationPresenter, CorePresenterElementMenu), MenuAllianceHabitatReservationPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceHabitatReservationComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceHabitatReservationPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.widgetAllianceRelationBadge, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesGameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentsEngine.createClass({
    selectedReservationsSet: {},
    mixins: [mixinsMenuComponentHandlers],
    onWithdrawReservationButtonClick: function(reservation, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservationOverview.withdrawReservation, {
        habitatReservationId: reservation.id,
        reservationMode: reservation.status
      })
    },
    onAcceptButtonClick: function(reservation, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservationOverview.acceptReservation, reservation)
    },
    onRejectButtonClick: function(reservation, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservationOverview.rejectReservation, reservation)
    },
    onDeleteButtonClick: function(reservation, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservationOverview.deleteReservation, reservation)
    },
    render: function() {
      var settings = {
        playerId: 0,
        reservation: {},
        player: {},
        habitat: {},
        habitatOwner: {},
        habitatOwnerAlliance: {},
        clashes: { requests: [], accepted: [] },
        canEdit: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, permissionIconId, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, permissionIconId = settings.player.alliancePermission ? servicesGameDataManager.playersCollection.getHighestPriorityAlliancePermission(settings.player.alliancePermission) : 0, sectionComponentSettings = {
        iconLeft: "icon-permission permission-" + permissionIconId,
        title: settings.player.nick,
        description: servicesInternationalization.localize("%d Points", settings.player.points),
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuPlayerProfileExternal.name,
          options: { playerId: settings.player.id }
        }),
        iconRight: "controls menu-next"
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "player-reservation-owner-" + settings.player.id
      })), sectionComponentSettings = { text: settings.reservation.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED ? servicesInternationalization.localize("Reservation valid until %1$@", utilsDateTime.getLocaleDateString(settings.reservation.expirationDate)) : servicesInternationalization.localize("Added on %1$@", utilsDateTime.getLocaleDateString(settings.reservation.reservationDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "validity-section"
      }));
      var habitatType = settings.habitat.publicHabitatType;
      sectionComponentSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.habitat.publicHabitatTypeNames[habitatType]) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-details"
      })), sectionComponentSettings = {
        onClick: this.handlerCenterMap.bind(this, settings.habitat),
        title: settings.habitat.name,
        description: settings.habitat.points,
        iconLeft: "icon-game icon-habitat-" + habitatType,
        iconRight: React.createElement(ComponentsWidgetAllianceRelationBadge, {
          settings: {
            playerId: settings.habitatOwner.id,
            classes: "icon-right"
          }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-habitat-details"
      })), sectionComponentSettings = {
        title: settings.habitatOwner.nick,
        description: settings.habitatOwner.points,
        iconLeft: "icon-game icon-ButtonPlayer"
      }, settings.habitatOwner.isEmpty || (sectionComponentSettings.onClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuPlayerProfileExternal.name,
        options: { playerId: settings.habitatOwner.id }
      }), sectionComponentSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-player-details"
      })), sectionComponentSettings = {
        title: settings.habitatOwnerAlliance.name,
        description: settings.habitatOwnerAlliance.points,
        iconLeft: "icon-game icon-ButtonAlliance"
      }, settings.habitatOwnerAlliance.isEmpty || (sectionComponentSettings.onClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuAllianceProfile.name,
        options: { allianceId: settings.habitatOwnerAlliance.id }
      }), sectionComponentSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-ally-details"
      }));
      var listingClashes = function(reservationModel) {
        var player = servicesGameDataManager.playersCollection.getPlayer(reservationModel.player), reservationSettings = {
          title: player.nick,
          description: player.points,
          iconLeft: "icon-game icon-ButtonPlayer",
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuPlayerProfileExternal.name,
            options: { playerId: player.id }
          })
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: reservationSettings,
          key: "reservation-clash-player-element-" + player.id
        }))
      }.bind(this);
      settings.clashes.accepted.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Already reserved by") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-element-reservation-accepted"
      })), settings.clashes.accepted.forEach(listingClashes)), settings.clashes.requests.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Already requested by") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-element-reservation-requested"
      })), settings.clashes.requests.forEach(listingClashes)), settings.reservation.player === settings.playerId && (sectionComponentSettings = {
        iconLeft: "icon-game icon-ReservationTakeBackHabitat-" + habitatType,
        onClick: this.onWithdrawReservationButtonClick.bind(this, settings.reservation),
        title: settings.reservation.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED ? servicesInternationalization.localize("Withdraw Reservation") : servicesInternationalization.localize("Withdraw Request")
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-withdraw-reservation"
      }))), settings.canEdit && (settings.reservation.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.REQUESTED ? (sectionComponentSettings = {
        title: servicesInternationalization.localize("Approve"),
        iconRight: "game-icon icon-BuffActivate",
        onClick: this.onAcceptButtonClick.bind(this, settings.reservation)
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-btn-accept"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Reject"),
        iconRight: "game-icon icon-Cancel",
        onClick: this.onRejectButtonClick.bind(this, settings.reservation)
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-btn-reject"
      }))) : (sectionComponentSettings = {
        title: servicesInternationalization.localize("Delete"),
        iconLeft: "game-icon icon-DeleteAll",
        onClick: this.onDeleteButtonClick.bind(this, settings.reservation)
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-btn-delete"
      }))));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceHabitatReservationOverviewController(options) {
    MenuAllianceHabitatReservationOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitatReservation,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Request"), this.currentGroupingMode = settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.DATE
  }

  return utilsOop.extend(MenuAllianceHabitatReservationOverviewController, CoreControllerElementMenu), MenuAllianceHabitatReservationOverviewController.prototype[xy.eNames.menuAllianceHabitatReservationOverview.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuAllianceHabitatReservationOverviewController.prototype[xy.eNames.menuAllianceHabitatReservationOverview.acceptReservation] = function(reservation) {
    this.dataSource.changeStatusOfReservations({
      reservationId: reservation.id,
      status: settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED
    })
  }, MenuAllianceHabitatReservationOverviewController.prototype[xy.eNames.menuAllianceHabitatReservationOverview.rejectReservation] = function(reservation) {
    this.dataSource.changeStatusOfReservations({
      reservationId: reservation.id,
      status: settingsGameConstant.HABITAT_RESERVATION_STATUS.REJECTED
    })
  }, MenuAllianceHabitatReservationOverviewController.prototype[xy.eNames.menuAllianceHabitatReservationOverview.deleteReservation] = function(reservation) {
    this.dataSource.deleteReservation(reservation), this[xy.eNames.menu.openPrevView]()
  }, MenuAllianceHabitatReservationOverviewController.prototype[xy.eNames.menuAllianceHabitatReservationOverview.withdrawReservation] = function(options) {
    var text = options.mode === settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED ? "Do you really want to reject this request?" : "Do you really want to withdraw your reservation?";
    this.showDialogDialog({
      title: "",
      text: servicesInternationalization.localize(text),
      callbackSuccess: this.dataSource.withdrawHabitatReservation.bind(this.dataSource, options)
    })
  }, MenuAllianceHabitatReservationOverviewController.prototype.prepareDataForDraw = function() {
    if (this.isActive)try {
      this.dataSource.prepareReservationOverviewData(this.initialOptions.reservationId)
    } catch (Exception) {
      this[xy.eNames.menu.onDataError](Exception)
    }
  }, MenuAllianceHabitatReservationOverviewController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.coreError, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.settings.gameConstant, function(gameInstance, CoreCoreError, CoreDataSource, utilsOop, servicesGameDataManager, settingsGameConstant) {
  "use strict";
  function MenuAllianceHabitatReservationOverviewDataSource(options) {
    var menuAllianceHabitatReservationDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceHabitatReservation.dataSource), MenuPlayerProfileExternalDataSource = gameInstance.injector.get(xy.dNames.game.menuPlayerProfileExternal.dataSource);
    this.forLinking = [{
      resourceClass: menuAllianceHabitatReservationDataSource,
      methodName: "changeStatusOfReservations"
    }, {
      resourceClass: menuAllianceHabitatReservationDataSource,
      methodName: "deleteReservations"
    }, {
      resourceClass: MenuPlayerProfileExternalDataSource,
      methodName: "requestPlayerInformation"
    }, {
      resourceClass: MenuPlayerProfileExternalDataSource,
      methodName: "receivePlayerInformation"
    }], MenuAllianceHabitatReservationOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceHabitatReservationOverviewDataSource, CoreDataSource), MenuAllianceHabitatReservationOverviewDataSource.prototype.onPlayerInformationUpdated = function() {
    this.prepareReservationOverviewData(this.reservationId)
  }, MenuAllianceHabitatReservationOverviewDataSource.prototype.prepareReservationOverviewData = function(reservationId) {
    this.reservationId = reservationId;
    var result = {}, reservation = servicesGameDataManager.habitatsCollection.getReservation(reservationId);
    if (!reservation)throw new CoreCoreError({
      message: "Reservation with " + reservationId + " is no longer available",
      context: this
    });
    if (result.reservation = reservation, result.player = servicesGameDataManager.playersCollection.getPlayer(reservation.player), result.habitat = servicesGameDataManager.habitatsCollection.getHabitat(reservation.habitat), result.habitat.player) {
      var habitatOwner = servicesGameDataManager.playersCollection.getPlayer(result.habitat.player);
      if (!habitatOwner)return void this.requestPlayerInformation({ playerId: result.habitat.player });
      result.habitatOwner = habitatOwner
    } else result.habitatOwner = servicesGameDataManager.playersCollection.getEmptyPlayer(result.habitat);
    if (result.habitatOwner.alliance ? result.habitatOwnerAlliance = servicesGameDataManager.alliancesCollection.getAlliance(result.habitatOwner.alliance) : result.habitatOwnerAlliance = servicesGameDataManager.alliancesCollection.getEmptyAlliance(), reservation.hasClash) {
      result.clashes = { requests: [], accepted: [] };
      var clashesList = servicesGameDataManager.habitatsCollection.getReservationsListForHabitat(reservation.habitat);
      clashesList.forEach(function(clashedReservation) {
        if (clashedReservation.id !== reservation.id) {
          var clashedPlayer = servicesGameDataManager.playersCollection.getPlayer(clashedReservation.player);
          clashedReservation.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED ? result.clashes.accepted.push(clashedPlayer) : clashedReservation.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.REQUESTED && result.clashes.requests.push(clashedPlayer)
        }
      }, this)
    }
    var allianceID = servicesGameDataManager.getAllianceId(), canEdit = servicesGameDataManager.playersCollection.getPlayer().canDiplomacy(), canBeEdited = result.player.alliance && result.player.alliance === allianceID;
    result.canEdit = canEdit && canBeEdited, result.playerId = servicesGameDataManager.getPlayerId(), this.notify(xy.eNames.menuAllianceHabitatReservationOverview.dataIsReady, result)
  }, MenuAllianceHabitatReservationOverviewDataSource.prototype.withdrawHabitatReservation = function(options) {
    var habitats = [];
    options.habitatReservationIdList instanceof Array && (habitats = options.habitatReservationIdList), options.habitatReservationId && (habitats.push(options.habitatReservationId), servicesGameDataManager.habitatsCollection.deleteReservation(options.habitatReservationId)), this.request({ habitatReservationIDArray: habitats }, "HabitatReservationAction/deleteEntries", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceHabitatReservationOverviewDataSource.prototype.deleteReservation = function(reservation) {
    var selectedEntitySet = {};
    selectedEntitySet[reservation.id] = reservation, this.deleteReservations(selectedEntitySet)
  }, MenuAllianceHabitatReservationOverviewDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceHabitatReservationOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceHabitatReservationOverviewComponent) {
  "use strict";
  function MenuAllianceHabitatReservationOverviewPresenter(options) {
    MenuAllianceHabitatReservationOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceHabitatReservationOverviewPresenter, CorePresenterElementMenu), MenuAllianceHabitatReservationOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceHabitatReservationOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceHabitatReservationOverviewPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationSettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.widgetRangeSlider, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsWidgetAllianceRelationBadge, ComponentsWidgetRangeSlider) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return {
        currentSettings: {
          perPLayerAmount: this.props.settings.currentSettings.perPLayerAmount,
          period: this.props.settings.currentSettings.period
        }, isSaveButtonDisabled: !0
      }
    }, onSetValueByRangeSlider: function(key, value) {
      var newCurrentSettings = this.state.currentSettings;
      newCurrentSettings[key] = value, this.setState({
        currentSettings: newCurrentSettings,
        isSaveButtonDisabled: newCurrentSettings.perPLayerAmount === this.props.settings.currentSettings.perPLayerAmount && newCurrentSettings.period === this.props.settings.currentSettings.period
      }, null)
    }, onSaveButtonClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceHabitatReservationSettings.saveSettings, { newSettings: this.state.currentSettings })
    }, render: function() {
      var settings = {
        currentSettings: { perPLayerAmount: 1, period: 1 },
        ownApplication: [],
        application: [],
        activeSharing: [],
        canEdit: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], buildReservationSharingList = function(allianceSharingModel) {
        var allianceModel = servicesGameDataManager.alliancesCollection.getAlliance(allianceSharingModel.targetAlliance), sharingSettings = {
          title: allianceModel.name,
          iconLeft: React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              allianceId: allianceSharingModel.targetAlliance,
              classes: "icon-left"
            }
          }),
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuAllianceProfile.name,
            options: { allianceId: allianceModel.id }
          })
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sharingSettings,
          key: "menu-element-sharing-in-list-" + allianceModel.id
        }))
      }.bind(this);
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.canEdit && (titleSettings.rightButton = [], titleSettings.rightButton.push({
        title: servicesInternationalization.localize("Finish"),
        isDisabled: this.state.isSaveButtonDisabled,
        onClick: this.onSaveButtonClick
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Reservations per Player"),
        minValue: settingsGameConstant.HABITAT_RESERVATION_SETTINGS.MIN_RESERVATION_AMOUNT,
        maxValue: servicesWorldSettings.settings.maxNumberOfPlayerHabitatReservation,
        currentValue: this.state.currentSettings.perPLayerAmount || settings.currentSettings.perPLayerAmount,
        onChange: this.onSetValueByRangeSlider.bind(this, "perPLayerAmount")
      }, componentsSections.push(React.createElement(ComponentsWidgetRangeSlider, {
        settings: sectionComponentSettings,
        key: "range-slider-reservation-per-player-amount"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Reservation Period"),
        minValue: servicesWorldSettings.settings.minDayDurationOfPlayerHabitatReservation,
        maxValue: servicesWorldSettings.settings.maxDayDurationOfPlayerHabitatReservation,
        currentValue: this.state.currentSettings.period || settings.currentSettings.period,
        onChange: this.onSetValueByRangeSlider.bind(this, "period")
      }, componentsSections.push(React.createElement(ComponentsWidgetRangeSlider, {
        settings: sectionComponentSettings,
        key: "range-slider-reservation-period"
      })), settings.activeSharing.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Active Alliances") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-active-sharing"
      })), settings.activeSharing.forEach(buildReservationSharingList)), settings.ownApplication.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Own Requests") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-own-application"
      })), settings.ownApplication.forEach(buildReservationSharingList)), settings.application.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Requests") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-application"
      })), settings.application.forEach(buildReservationSharingList)), sectionComponentSettings = {
        title: servicesInternationalization.localize("Share Reservations"),
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuAllianceSharing.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-btn-delete"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceHabitatReservationSettingsController(options) {
    MenuAllianceHabitatReservationSettingsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Preferences"), this.currentGroupingMode = settingsGameConstant.HABITAT_RESERVATION_GROUPING_MODE.DATE
  }

  return utilsOop.extend(MenuAllianceHabitatReservationSettingsController, CoreControllerElementMenu), MenuAllianceHabitatReservationSettingsController.prototype[xy.eNames.menuAllianceHabitatReservationSettings.saveSettings] = function(options) {
    this.dataSource.setNewReservationsSettings(options)
  }, MenuAllianceHabitatReservationSettingsController.prototype[xy.eNames.menuAllianceHabitatReservationSettings.onSavedSettings] = function(options) {
    this[xy.eNames.menu.openPrevView]()
  }, MenuAllianceHabitatReservationSettingsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.prepareReservationSettingData())
  }, MenuAllianceHabitatReservationSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuAllianceHabitatReservationSettingsDataSource(options) {
    MenuAllianceHabitatReservationSettingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceHabitatReservationSettingsDataSource, CoreDataSource), MenuAllianceHabitatReservationSettingsDataSource.prototype.prepareReservationSettingData = function() {
    var result = {}, myAlliance = servicesGameDataManager.alliancesCollection.getAlliance(), myAllianceId = myAlliance.id, sharingList = servicesGameDataManager.alliancesCollection.getSharingList();
    return result.currentSettings = {
      perPLayerAmount: myAlliance.settingNumberOfPlayerHabitatReservation || servicesWorldSettings.settings.defaultNumberOfPlayerHabitatReservation,
      period: myAlliance.settingDurationOfPlayerHabitatReservation || servicesWorldSettings.settings.defaultDayDurationOfPlayerHabitatReservation
    }, result.ownApplication = [], result.application = [], result.activeSharing = [], sharingList.forEach(function(allianceSharingModel) {
      allianceSharingModel.accepted ? result.activeSharing.push(allianceSharingModel) : allianceSharingModel.sourceAlliance === myAllianceId ? result.ownApplication.push(allianceSharingModel) : result.application.push(allianceSharingModel)
    }), result.canEdit = servicesGameDataManager.playersCollection.getPlayer().canDiplomacy(), result
  }, MenuAllianceHabitatReservationSettingsDataSource.prototype.setNewReservationsSettings = function(options) {
    options.newSettings && options.newSettings.perPLayerAmount && options.newSettings.period && (this.habitatReservationSettingDuration = options.newSettings.period, this.habitatReservationSettingNumber = options.newSettings.perPLayerAmount, this.request({
      habitatReservationSettingDuration: options.newSettings.period,
      habitatReservationSettingNumber: options.newSettings.perPLayerAmount
    }, "AllianceAction/applyHabitatReservationSettings", { callBack: this.responseOnSetReservationSettings }))
  }, MenuAllianceHabitatReservationSettingsDataSource.prototype.responseOnSetReservationSettings = function() {
    var id = servicesGameDataManager.getAllianceId();
    servicesGameDataManager.alliancesCollection.updateAlliance({
      id: id,
      key: "settingDurationOfPlayerHabitatReservation",
      value: this.habitatReservationSettingDuration
    }), servicesGameDataManager.alliancesCollection.updateAlliance({
      id: id,
      key: "settingNumberOfPlayerHabitatReservation",
      value: this.habitatReservationSettingNumber
    }), this.notify(xy.eNames.menuAllianceHabitatReservationSettings.onSavedSettings)
  }, MenuAllianceHabitatReservationSettingsDataSource.prototype.acceptSharing = function(options) {
    var idArray = [];
    options.sharingId && idArray.push(options.sharingId), this.request({ sharingIdArray: idArray }, "AllianceSharingAction/acceptSharing", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceHabitatReservationSettingsDataSource.prototype.requestSharing = function(options) {
    var idArray = [];
    options.allianceId && idArray.push(options.sharingId), options.allianceIdArray && (idArray = options.allianceIdArray), this.request({
      allianceIdArray: idArray,
      sharingType: 1
    }, "AllianceSharingAction/requestSharing", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceHabitatReservationSettingsDataSource.prototype.deleteSharing = function(options) {
    var idArray = [];
    options.sharingId && idArray.push(options.sharingId), this.request({ sharingIdArray: idArray }, "AllianceSharingAction/deleteSharing", { callBack: this.handleSessionUpdateResponse })
  }, MenuAllianceHabitatReservationSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceHabitatReservationSettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceHabitatReservationSettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceHabitatReservationSettingsComponent) {
  "use strict";
  function MenuAllianceHabitatReservationSettingsPresenter(options) {
    MenuAllianceHabitatReservationSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceHabitatReservationSettingsPresenter, CorePresenterElementMenu), MenuAllianceHabitatReservationSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceHabitatReservationSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceHabitatReservationSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceSharing.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetAllianceRelationBadge, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsWidgetAllianceRelationBadge) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { selectedAllianceIdsSet: {} }
    }, onShareButtonClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceSharing.shareWithAlliance, this.state.selectedAllianceIdsSet)
    }, onCheckboxClick: function(alliance, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedAllianceIdsSet = this.state.selectedAllianceIdsSet;
      selectedAllianceIdsSet[alliance.id] ? selectedAllianceIdsSet[alliance.id] = !1 : selectedAllianceIdsSet[alliance.id] = alliance, this.setState({ selectedAllianceIdsSet: selectedAllianceIdsSet }, null)
    }, render: function() {
      var settings = { groupedRelations: {} }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], buildAllianceList = function(diplomacyModel) {
        var alliance = servicesDameDataManager.alliancesCollection.getAlliance(diplomacyModel.targetAlliance), localSettings = {
          iconLeft: React.createElement(ComponentsWidgetAllianceRelationBadge, {
            settings: {
              allianceId: alliance.id,
              classes: "icon-left"
            }
          }),
          title: alliance.name,
          description: alliance.points,
          iconRight: "controls menu-next",
          isSelectable: !0,
          onSelect: this.onCheckboxClick.bind(this, alliance)
        };
        this.state.selectedAllianceIdsSet[alliance.id] && (localSettings.isSelected = !0), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localSettings,
          key: "menu-element-ally-in-list-" + alliance.id
        }))
      };
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.onShareButtonClick,
        title: servicesInternationalization.localize("Share")
      }), settings.groupedRelations.groupsKeys && settings.groupedRelations.groupsKeys.length ? settings.groupedRelations.groupsKeys.forEach(function(groupKey, index) {
        var titleSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.allianceDiplomacyName[groupKey]) };
        componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: titleSettings,
          key: "menu-title-diplomacy-group-" + groupKey
        })), settings.groupedRelations.groups[index].forEach(buildAllianceList, this)
      }, this) : (sectionComponentSettings = { text: servicesInternationalization.localize("Your alliance does not have any diplomacy") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "menu-text-no-messages"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceSharing.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuAllianceDiplomacyController(options) {
    MenuAllianceDiplomacyController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.received,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.alliance,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Selection"), this.currentReportGroup = settingsGameConstant.REPORT_GROUP.DEFENSE
  }

  return utilsOop.extend(MenuAllianceDiplomacyController, CoreControllerElementMenu), MenuAllianceDiplomacyController.prototype[xy.eNames.menuAllianceSharing.shareWithAlliance] = function(selectedAllianceIdsSet) {
    var id, idArrays = [];
    for (id in selectedAllianceIdsSet)selectedAllianceIdsSet.hasOwnProperty(id) && selectedAllianceIdsSet[id] && idArrays.push(id);
    idArrays.length && (this.dataSource.requestSharing({ allianceIdArray: idArrays }), this[xy.eNames.menu.openPrevView]())
  }, MenuAllianceDiplomacyController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.getAllianceListForSharingData())
  }, MenuAllianceDiplomacyController
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceSharing.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, function(gameInstance, CoreDataSource, utilsOop, servicesGameDataManager, servicesGroupable) {
  "use strict";
  function MenuAllianceDiplomacyDataSource(options) {
    var MenuAllianceHabitatReservationSettingsDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceHabitatReservationSettings.dataSource);
    this.forLinking = [{
      resourceClass: MenuAllianceHabitatReservationSettingsDataSource,
      methodName: "requestSharing"
    }], MenuAllianceDiplomacyDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDiplomacyDataSource, CoreDataSource), MenuAllianceDiplomacyDataSource.prototype.getAllianceListForSharingData = function() {
    var groupedRelations, relationList = servicesGameDataManager.alliancesCollection.getDiplomacyList(), filteredList = relationList.filter(function(element) {
      return !servicesGameDataManager.alliancesCollection.getSharingByAlliance(element.targetAlliance)
    });
    return groupedRelations = servicesGroupable.byField(filteredList, {
      field: "relationship",
      sortGroups: !0,
      sortGroupsIsReverse: !0
    }), { dataIsAvailable: filteredList.length, groupedRelations: groupedRelations }
  }, MenuAllianceDiplomacyDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuAllianceSharing.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuAllianceSharing.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuAllianceSharingComponent) {
  "use strict";
  function MenuAllianceDiplomacyPresenter(options) {
    MenuAllianceDiplomacyPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuAllianceDiplomacyPresenter, CorePresenterElementMenu), MenuAllianceDiplomacyPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuAllianceSharingComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuAllianceDiplomacyPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingChooser.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.tapBarHabitatType, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsTapBarHabitatType) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    updateCurrentMode: function(newTabMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuBuildingsChooser.onTabSwitch, { newTabMode: newTabMode })
    },
    onBuildingChoose: function(buildingClassIdentifier, habitatTypeMode) {
      switch (this.props.settings.mode) {
        case settingsGameConstant.BUILDING_CHOOSER_LIST_MODE.MASS_BUILDING:
          this.handlerNextClick({
            next: xy.dNames.game.menuMassFunctionBuildings.name,
            options: { chosenBuildingClassIdentifier: buildingClassIdentifier, habitatTypeMode: habitatTypeMode }
          })
      }
    },
    render: function() {
      var settings = {
        availableHabitatTypes: {},
        mode: settingsGameConstant.BUILDING_CHOOSER_LIST_MODE.MASS_BUILDING,
        tabMode: settingsGameConstant.BUILDING_CHOOSER_LIST_TAB_MODE.HABITAT_TYPE_O,
        buildings: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var tapBar = null, tapBarSettings = null;
      utilsObject.effectiveLength(settings.availableHabitatTypes) > 1 && (tapBarSettings = {
        tabMode: settings.tabMode,
        availableHabitatTypes: settings.availableHabitatTypes,
        onBarButtonClick: this.updateCurrentMode
      }, tapBar = React.createElement(ComponentsTapBarHabitatType, { settings: tapBarSettings })), settings.buildings.forEach(function(buildingTitleAvailableObject, index) {
        var buildingClassIdentifier = buildingTitleAvailableObject.buildingTitle.replace(/\s/g, "").toLowerCase(), localComponentSettings = {
          title: servicesInternationalization.localize(buildingTitleAvailableObject.buildingTitle),
          iconLeft: "icon-building icon-building-" + buildingClassIdentifier,
          iconRight: "controls menu-next",
          onClick: this.onBuildingChoose.bind(this, buildingClassIdentifier, settings.tabMode)
        };
        settings.mode === settingsGameConstant.BUILDING_CHOOSER_LIST_MODE.MASS_BUILDING && (localComponentSettings.disabled = !0, localComponentSettings.rightColumnDataValue = buildingTitleAvailableObject.availableForRunUpgrades.toString(), buildingTitleAvailableObject.availableForRunUpgrades > 0 && (localComponentSettings.disabled = !1)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "building-in-list-" + index
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: tapBar,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingChooser.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuBuildingsChooserController(options) {
    MenuBuildingsChooserController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.allianceClashes,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.currentTabMode = settingsGameConstant.BUILDING_CHOOSER_LIST_TAB_MODE.HABITAT_TYPE_O, this.localizedName = servicesInternationalization.localize("Building Selection"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuBuildingsChooserController, CoreControllerElementMenu), MenuBuildingsChooserController.prototype[xy.eNames.menuBuildingsChooser.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuBuildingsChooserController.prototype[xy.eNames.menuBuildingsChooser.onTabSwitch] = function(options) {
    this.currentTabMode = options.newTabMode, this.prepareDataForDraw()
  }, MenuBuildingsChooserController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.prepareBuildingsLists({
      tabMode: this.currentTabMode,
      mode: this.initialOptions.mode
    })
  }, MenuBuildingsChooserController
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingChooser.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.worldSettings, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.sortable, function(CoreDataSource, utilsOop, settingsGameConstant, servicesWorldSettings, servicesGameDataManager, servicesTheme, servicesSortable) {
  "use strict";
  function MenuBuildingsChooserDataSource(options) {
    MenuBuildingsChooserDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingsChooserDataSource, CoreDataSource), MenuBuildingsChooserDataSource.prototype.prepareBuildingsLists = function(options) {
    var availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), buildingsTitlesList = servicesTheme.themeSettings.buildings.titlesListsByHabitatType[options.tabMode], ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [], buildingList = [], buildingClassIdentifiersList = [];
    buildingsTitlesList.forEach(function(buildingTitle) {
      buildingClassIdentifiersList.push(buildingTitle.replace(/\s/g, "").toLowerCase())
    }), ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), habitatBuildingsObject = {};
      if (modeledHabitat.publicHabitatType === options.tabMode) {
        var i, currentBuildingModel, possibleUpgradePk, possibleBuildingForUpgrade, upgradesArray = servicesGameDataManager.buildingsCollection.getHabitatBuildingUpgrades({ habitat: modeledHabitat }), last = upgradesArray.length - 1;
        for (i = last; i < -1; i -= 1)currentBuildingModel = upgradesArray[i].resultBuilding, habitatBuildingsObject.hasOwnProperty(currentBuildingModel.classIdentifier) || (possibleUpgradePk = currentBuildingModel.getResultBuildingPK(), possibleBuildingForUpgrade = servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: possibleUpgradePk }), habitatBuildingsObject[currentBuildingModel.classIdentifier] = possibleBuildingForUpgrade);
        last = buildingClassIdentifiersList.length;
        var buildingClassIdentifierLocal;
        for (i = 0; i < last; i += 1)buildingClassIdentifierLocal = buildingClassIdentifiersList[i], habitatBuildingsObject.hasOwnProperty(buildingClassIdentifierLocal) || (currentBuildingModel = servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
          habitat: modeledHabitat,
          buildingClass: buildingClassIdentifierLocal
        }), currentBuildingModel && (possibleUpgradePk = currentBuildingModel.getResultBuildingPK(), possibleBuildingForUpgrade = servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: possibleUpgradePk }), habitatBuildingsObject[buildingClassIdentifierLocal] = possibleBuildingForUpgrade));
        habitatsList.push({ habitat: modeledHabitat, habitatBuildingsObject: habitatBuildingsObject })
      }
    }), buildingsTitlesList.forEach(function(buildingTitle) {
      var i, habitatModel, buildingModel, buildingClassIdentifierLocal = buildingTitle.replace(/\s/g, "").toLowerCase(), availableForRunUpgrades = 0, len = habitatsList.length;
      for (i = 0; i < len; i += 1)habitatModel = habitatsList[i].habitat, buildingModel = habitatsList[i].habitatBuildingsObject[buildingClassIdentifierLocal], buildingModel && habitatModel.canHabitatAffordUpgrade(buildingModel) && (availableForRunUpgrades += 1);
      buildingList.push({ buildingTitle: buildingTitle, availableForRunUpgrades: availableForRunUpgrades })
    });
    var data = {};
    data.availableHabitatTypes = availableHabitatTypes, data.mode = options.mode, data.tabMode = options.tabMode, data.buildings = buildingList, this.notify(xy.eNames.menuBuildingsChooser.dataIsReady, data)
  }, MenuBuildingsChooserDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingChooser.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuBuildingChooser.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuBuildingChooserComponent) {
  "use strict";
  function MenuBuildingsChooserPresenter(options) {
    MenuBuildingsChooserPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingsChooserPresenter, CorePresenterElementMenu), MenuBuildingsChooserPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuBuildingChooserComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuBuildingsChooserPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingsList.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.utils.object, xy.dNames.utils.dateTime, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.buildingUpgradesList, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesGameDataManager, servicesInternationalization, utilsObject, utilsDateTime, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementButtonAction, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsWidgetUpgradesInProgressList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onUpgradeButtonClick: function(options, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuBuildingsList.upgradeBuilding, options)
    },
    onSpeedUpButtonClick: function(options, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuBuildingsList.speedUpUpgrade, options)
    },
    render: function() {
      var settings = {
        currentHabitat: null,
        currentConstructionsList: [],
        lastUpgradeCompleteDate: null,
        habitatBuildingsList: [],
        lastUpgradeForBuilding: {},
        firstUpgradeInQueueForBuilding: {}
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], checkAvailabilityOfUpgrade = function(possibleUpgradeBuildingPK) {
        var upgradeBuilding = servicesGameDataManager.buildingsCollection.getBuilding({ pk: possibleUpgradeBuildingPK });
        return settings.currentHabitat.canHabitatAffordUpgrade(upgradeBuilding)
      }, addBuildingToList = function(building) {
        var settingsEntry = {
          iconLeft: building.icon,
          title: servicesInternationalization.localize(building.title),
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuBuildingOverview.name,
            options: { classIdentifier: building.classIdentifier, title: building.title }
          }),
          iconRight: "controls menu-next"
        }, key = "building-in-list" + building.primaryKey;
        if (settings.lastUpgradeForBuilding[building.classIdentifier]) {
          var resultBuilding = settings.lastUpgradeForBuilding[building.classIdentifier].resultBuilding;
          settingsEntry.description = servicesInternationalization.localize("Upgrading to level %d done %@", resultBuilding.level, utilsDateTime.getLocaleDateTimeString(settings.lastUpgradeForBuilding[building.classIdentifier].completeDate)), building = resultBuilding
        } else building.isFurtherUpgradePossible && (settingsEntry.description = servicesInternationalization.localize("Level %d", building.level));
        if (building.isFurtherUpgradePossible) {
          var rightIconButtonSettings = {
            classes: "button--in-building-list--construct-" + building.classIdentifier,
            icon: "icon-game white icon-Build",
            onClick: this.onUpgradeButtonClick.bind(this, {
              resultBuildingPK: building.getResultBuildingPK(),
              habitat: settings.currentHabitat,
              paymentGranted: !1
            }),
            isDisabled: !building.upgradeToArray.every(checkAvailabilityOfUpgrade)
          };
          settingsEntry.iconRight = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings })
        }
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: settingsEntry,
          key: key
        }))
      }.bind(this);
      if (settings.currentConstructionsList.length && (sectionComponentSettings = {
                currentHabitat: settings.currentHabitat,
                firstUpgradeInQueueForBuilding: settings.firstUpgradeInQueueForBuilding,
                upgrades: settings.currentConstructionsList,
                onSpeedUpClick: this.onSpeedUpButtonClick,
                onClick: this.handlerNextClick,
                showCompleteAllSection: !0,
                initialComponent: this
              }, componentsSections.push(React.createElement(ComponentsWidgetUpgradesInProgressList, {
                settings: sectionComponentSettings,
                key: "menu-currently-is-is-progress"
              })), sectionComponentSettings = { text: servicesInternationalization.localize("Last upgrade done %@", utilsDateTime.getLocaleDateTimeString(settings.lastUpgradeCompleteDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
                settings: sectionComponentSettings,
                key: "menu-last-will-finished-text"
              }))), settings.habitatBuildingsList.length) {
        var groupTitle = "Habitat Buildings";
        sectionComponentSettings = { title: servicesInternationalization.localize(groupTitle) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "menu-title-habitat-constructions"
        })), settings.habitatBuildingsList.forEach(addBuildingToList)
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingsList.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.eventManager, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings, servicesEventManager) {
  "use strict";
  function MenuBuildingsListController(options) {
    MenuBuildingsListController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Construction list")
  }

  return utilsOop.extend(MenuBuildingsListController, CoreControllerElementMenu), MenuBuildingsListController.prototype[xy.eNames.menuBuildingsList.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuBuildingsListController.prototype[xy.eNames.menuBuildingsList.speedUpUpgrade] = function(options) {
    var localizationString, localizationTitle, text, successCallBack, resultBuilding = options.resultBuilding, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = resultBuilding.buildSpeedupCost;
    return cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (options.buildingUpgrade.isLessThanHalfConstructionTimeRemain() ? (localizationString = "Finishing building %@ level %d instantly costs %d %@. You have %d %@.", localizationTitle = "Finish build", successCallBack = function() {
      servicesEventManager.handleClientEvent(resultBuilding.classIdentifier + "-finish-button-click"), this.dataSource.finishConstruction(options)
    }.bind(this)) : (localizationString = "Build time reduction for %@ level %d costs %d %@. You have %d %@.", localizationTitle = "Speedup build", successCallBack = function() {
      servicesEventManager.handleClientEvent(resultBuilding.classIdentifier + "-speedup-button-click"), this.dataSource.speedUpConstruction(options)
    }.bind(this)), text = servicesInternationalization.localize(localizationString, resultBuilding.title, resultBuilding.level, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize(localizationTitle),
      text: text,
      callbackSuccess: successCallBack
    }))
  }, MenuBuildingsListController.prototype[xy.eNames.menuBuildingsList.upgradeBuilding] = function(options) {
    var habitat = options.habitat, constructionQueueLimit = servicesWorldSettings.settings.buildingUpgradeListBoundaryByHabitatType[habitat.habitatType], resultBuilding = servicesGameDataManager.buildingsCollection.getBuilding({ pk: options.resultBuildingPK });
    if (habitat.habitatBuildingUpgradeArray.length >= constructionQueueLimit) {
      options.paymentGranted = !0;
      var text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = resultBuilding.buildSpeedupCost;
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      text = servicesInternationalization.localize("Your building upgrade queue is full. An additional slot costs %d %@\\nYou have %d %@", cost, "Gold", gold, "Gold"), this.showDialogDialog({
        title: "", text: text, callbackSuccess: function() {
          servicesEventManager.handleClientEvent(resultBuilding.classIdentifier + "-construct-button-click"),
                  this.dataSource.upgradeBuilding(options)
        }.bind(this)
      })
    } else servicesEventManager.handleClientEvent(resultBuilding.classIdentifier + "-construct-button-click"), this.dataSource.upgradeBuilding(options)
  }, MenuBuildingsListController.prototype[xy.eNames.menuBuildingsList.completeAllUpgrades] = function(options) {
    var costMultiplierBase, habitatId, finishArray, habitatsObject = options.habitatsObject, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0, dataSourceOptions = { actions: {} };
    for (habitatId in habitatsObject)habitatsObject.hasOwnProperty(habitatId) && (finishArray = [], habitatsObject[habitatId].upgrades.forEach(function(upgrade) {
      costMultiplierBase = upgrade.buildingUpgrade.isLessThanHalfConstructionTimeRemain() ? 1 : 2, cost += costMultiplierBase * upgrade.resultBuilding.buildSpeedupCost, finishArray.push(upgrade.buildingUpgrade.id)
    }), dataSourceOptions.actions[habitatId] = [{ finish: finishArray }]);
    if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
    dataSourceOptions.cost = cost;
    var text, localizationString = "Do you want to finish all active building upgrades for %1$d %2$@? You have %3$d %4$@.";
    text = servicesInternationalization.localize(localizationString, cost, "Gold", gold, "Gold"), this.showDialogDialog({
      title: servicesInternationalization.localize("Finish build"),
      text: text,
      callbackSuccess: this.dataSource.batchBuildingUpgrade.bind(this.dataSource, dataSourceOptions)
    })
  }, MenuBuildingsListController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate(), this.isActive && this.dataSource.prepareBuildingsListData()
  }, MenuBuildingsListController
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingsList.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, xy.dNames.services.eventManager, function(CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager, servicesEventManager) {
  "use strict";
  function MenuBuildingsListDataSource(options) {
    MenuBuildingsListDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingsListDataSource, CoreDataSource), MenuBuildingsListDataSource.prototype.prepareBuildingsListData = function() {
    var data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    data.habitatBuildingsList = [], data.currentHabitat = currentHabitat, data.currentConstructionsList = servicesGameDataManager.buildingsCollection.getHabitatBuildingUpgrades({ habitat: currentHabitat });
    var currentConstructionsListLength = data.currentConstructionsList.length;
    currentConstructionsListLength && (data.lastUpgradeCompleteDate = data.currentConstructionsList[currentConstructionsListLength - 1].buildingUpgrade.complete, data.lastUpgradeForBuilding = {}, data.firstUpgradeInQueueForBuilding = {}, data.currentConstructionsList.forEach(function(upgrade) {
      data.lastUpgradeForBuilding[upgrade.resultBuilding.classIdentifier] = {
        resultBuilding: upgrade.resultBuilding,
        completeDate: upgrade.buildingUpgrade.complete
      }, data.firstUpgradeInQueueForBuilding[upgrade.resultBuilding.classIdentifier] || (data.firstUpgradeInQueueForBuilding[upgrade.resultBuilding.classIdentifier] = upgrade.buildingUpgrade.id)
    })), currentHabitat.habitatBuildingKeyArray.forEach(function(buildingPK) {
      var building = servicesGameDataManager.buildingsCollection.getBuilding({ pk: buildingPK });
      data.habitatBuildingsList.push(building)
    }), this.notify(xy.eNames.menuBuildingsList.dataIsReady, data)
  }, MenuBuildingsListDataSource.prototype.speedUpConstruction = function(options) {
    this.request({ id: options.buildingUpgrade.id }, "HabitatAction/speedupBuildingUpgrade", { callBack: this.onSpeedUpConstructionResponse })
  }, MenuBuildingsListDataSource.prototype.onSpeedUpConstructionResponse = function(data) {
    servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.buildingSpeedUpCallCompleted), this.handleSessionUpdateResponse(data)
  }, MenuBuildingsListDataSource.prototype.finishConstruction = function(options) {
    this.request({ id: options.buildingUpgrade.id }, "HabitatAction/finishBuildingUpgrade", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingsListDataSource.prototype.upgradeBuilding = function(options) {
    this.request({
      habitatID: options.habitat.id,
      primaryKey: options.resultBuildingPK,
      paymentGranted: options.paymentGranted
    }, "HabitatAction/upgradeBuilding", { callBack: this.onUpgradeConstructionResponse })
  }, MenuBuildingsListDataSource.prototype.onUpgradeConstructionResponse = function(data) {
    servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.buildingUpgradeCallCompleted), this.handleSessionUpdateResponse(data)
  }, MenuBuildingsListDataSource.prototype.batchBuildingUpgrade = function(options) {
    var params = {};
    options.cost && (params.paymentAmount = options.cost), params.actions = utilsNetwork.dictionaryToQueryString(options.actions, {
      trailingCommaFlag: !1,
      noStringFlag: !0
    }), this.request(params, "HabitatAction/batchBuildingUpgrade", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingsListDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuBuildingsList.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuBuildingsList.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuBuildingsListComponent) {
  "use strict";
  function MenuBuildingsListPresenter(options) {
    MenuBuildingsListPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingsListPresenter, CorePresenterElementMenu), MenuBuildingsListPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuBuildingsListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuBuildingsListPresenter
}]);
xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.utils.object, xy.dNames.utils.dateTime, xy.dNames.game.menuBuildingOverview.componentBuffEntry, xy.dNames.game.menuBuildingOverview.componentMissions, xy.dNames.game.menuBuildingOverview.componentKnowledges, xy.dNames.game.menuBuildingOverview.componentHabitatUpgradeConstruction, xy.dNames.game.menuBuildingOverview.componentRecruitmentInProgressList, xy.dNames.game.menuBuildingOverview.componentResourcesExchange, xy.dNames.game.menuBuildingOverview.componentResourcesStorage, xy.dNames.game.menuBuildingOverview.componentNobleExchange, xy.dNames.game.menuBuildingOverview.componentRefill, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.widgetRename, xy.dNames.components.overviewWidgetConstructCost, xy.dNames.components.buildingUpgradesList, xy.dNames.components.buildingWidgetTradeRates, xy.dNames.components.overviewWidgetBattleAbilityList, xy.dNames.components.overviewWidgetTreasureChest, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesTheme, servicesWorldSettings, utilsObject, utilsDateTime, MenuBuildingOverviewComponentBuffEntry, MenuBuildingOverviewComponentMissions, MenuBuildingOverviewComponentKnowledges, MenuBuildingOverviewComponentHabitatUpgradeConstruction, MenuBuildingOverviewComponentRecruitmentInProgressList, MenuBuildingOverviewComponentResourcesExchange, MenuBuildingOverviewComponentResourcesStorage, MenuBuildingOverviewComponentNobleExchange, MenuBuildingOverviewComponentRefill, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementButtonAction, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsWidgetRename, ComponentsWidgetConstructBuildingCost, ComponentsBuildingUpgradesList, ComponentsBuildingWidgetTradeRates, ComponentsOverviewWidgetBattleAbilityList, ComponentsOverviewWidgetTreasureChest) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onUpgradeButtonClick: function(options, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuBuildingsList.upgradeBuilding, options)
    },
    onSpeedUpButtonClick: function(options, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuBuildingsList.speedUpUpgrade, options)
    },
    onUnitRecruitmentClick: function(options, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuBuildingOverview.unitRecruitmentStart, options)
    },
    onHabitatRenameSubmitClick: function(newName) {
      this.props.presenter.notify(xy.eNames.menuBuildingOverview.changeNameForHabitat, {
        habitat: this.props.settings.currentHabitat,
        newName: newName
      })
    },
    render: function() {
      var settings = {
        building: {},
        relativeBuilding: {},
        currentHabitat: null,
        currentConstructionsList: [],
        relativeConstructionsList: [],
        firstUpgradeInQueueForBuilding: null,
        firstUpgradeInQueueForRelativeBuilding: null,
        forceNextRedrawUpdate: !1,
        renameHabitat: null,
        habitatUpgradeConstructionObject: null,
        battleAbilityWithModifiers: null,
        showStockRefillButton: !1,
        buffsList: null,
        activeBuffs: {},
        researches: null,
        activeResearches: null,
        missions: null,
        activeMissions: null,
        unitsInProgress: null,
        units: null,
        nobleMarket: null,
        treasureChest: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], building = settings.building, currentConstructionsList = settings.currentConstructionsList;
      gameInstance.getGameLanguage();
      sectionComponentSettings = {
        iconLeft: building.icon,
        title: servicesInternationalization.localize(building.title) + " " + building.level
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-current-level"
      }));
      var descriptionKey = servicesTheme.themeSettings.buildings.descriptionKeys[building.classIdentifier];
      if (sectionComponentSettings = { title: servicesInternationalization.localize(descriptionKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "building-overview-building-type-description"
              })), !utilsObject.isEmpty(settings.generateResourceWithModifiers)) {
        var resourceId, generateResourceWithModifiers = settings.generateResourceWithModifiers;
        for (resourceId in generateResourceWithModifiers)generateResourceWithModifiers.hasOwnProperty(resourceId) && (sectionComponentSettings = {
          iconLeft: "icon icon-resource icon-resource-" + resourceId,
          title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[resourceId]),
          rightColumnDataValue: "+" + settings.generateResourceWithModifiers[resourceId] + "/h"
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "building-overview-production-" + resourceId
        })))
      }
      building.storeAmount && building.storeResourceArray instanceof Array && building.storeResourceArray.length && building.storeResourceArray.forEach(function(resourceId) {
        var localComponentSettings = {
          iconLeft: "icon icon-resource icon-resource-" + resourceId,
          title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[resourceId]),
          rightColumnDataValue: settings.currentHabitat.habitatResourceDictionary[resourceId].amount + "/" + building.storeAmount
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "building-overview-store-" + resourceId
        }))
      }, this), building.marketDistance && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Distance to market"),
        rightColumnDataValue: servicesInternationalization.localize("%d fields", building.marketDistance)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-market-distance"
      }))), building.modifierArray instanceof Array && building.modifierArray.length && building.modifierArray.forEach(function(modifierPK) {
        var modifierModel = servicesGameDataManager.modifiersCollection.getModifier({ primaryKey: modifierPK }), localComponentSettings = {
          iconLeft: modifierModel.icon,
          title: servicesInternationalization.localize("Modifier"),
          rightColumnDataValue: modifierModel.title
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "building-overview-modifier-" + modifierPK
        }))
      }, this), settings.battleAbilityWithModifiers && (sectionComponentSettings = { battleAbility: settings.battleAbilityWithModifiers }, componentsSections.push(React.createElement(ComponentsOverviewWidgetBattleAbilityList, {
        settings: sectionComponentSettings,
        key: "building-overview-battle-ability"
      })));
      var isFurtherUpgradePossible, nextBuildingPK, nextBuilding, currentUpgradesLength = currentConstructionsList.length;
      currentUpgradesLength ? (isFurtherUpgradePossible = currentConstructionsList[currentUpgradesLength - 1].resultBuilding.isFurtherUpgradePossible, nextBuildingPK = currentConstructionsList[currentUpgradesLength - 1].resultBuilding.getResultBuildingPK()) : (isFurtherUpgradePossible = building.isFurtherUpgradePossible, nextBuildingPK = building.getResultBuildingPK()), isFurtherUpgradePossible && (nextBuilding = servicesGameDataManager.buildingsCollection.getBuilding({ pk: nextBuildingPK }), sectionComponentSettings = {
        initialComponent: this,
        constructingEntity: nextBuilding,
        title: servicesInternationalization.localize("Level %d", nextBuilding.level),
        currentHabitat: settings.currentHabitat,
        showMissingResources: !0,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuBuildingUpgrades.name,
          options: { classIdentifier: building.classIdentifier }
        }),
        onConstructButtonClick: this.onUpgradeButtonClick.bind(this, {
          resultBuildingPK: nextBuilding.primaryKey,
          habitat: settings.currentHabitat,
          paymentGranted: !1
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetConstructBuildingCost, {
        settings: sectionComponentSettings,
        key: "building-overview-widget-net-level-upgrade"
      }))), currentUpgradesLength && (sectionComponentSettings = {
        currentHabitat: settings.currentHabitat,
        firstUpgradeInQueueForBuilding: settings.firstUpgradeInQueueForBuilding,
        upgrades: currentConstructionsList,
        onSpeedUpClick: this.onSpeedUpButtonClick,
        onClick: this.handlerNextClick,
        initialComponent: this
      }, componentsSections.push(React.createElement(ComponentsBuildingUpgradesList, {
        settings: sectionComponentSettings,
        key: "menu-currently-is-is-progress"
      }))), settings.habitatUpgradeConstructionObject && (sectionComponentSettings = {
        habitatUpgradeConstructionObject: settings.habitatUpgradeConstructionObject,
        initialComponent: this
      }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentHabitatUpgradeConstruction, {
        settings: sectionComponentSettings,
        key: "building-overview-habitat-upgrade-construction"
      }))), utilsObject.isEmpty(building.marketRateDictionary) || (sectionComponentSettings = {
        marketRateDictionary: building.marketRateDictionary,
        initialComponent: this,
        building: building
      }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentResourcesExchange, {
        settings: sectionComponentSettings,
        key: "component-resources-exchange"
      }))), settings.nobleMarket && (sectionComponentSettings = {
        marketRateDictionary: settings.nobleMarket,
        initialComponent: this
      }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentNobleExchange, {
        settings: sectionComponentSettings,
        key: "component-resources-exchange-noble-market"
      }))), settings.buffsList && (sectionComponentSettings = { title: servicesInternationalization.localize("Banners") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-buffs-title"
      })), settings.buffsList.forEach(function(modeledBuff, index) {
        var settingsEntry = {
          currentHabitat: settings.currentHabitat,
          buff: modeledBuff,
          activeBuff: settings.activeBuffs[modeledBuff.primaryKey] || null,
          initialComponent: this
        };
        componentsSections.push(React.createElement(MenuBuildingOverviewComponentBuffEntry, {
          settings: settingsEntry,
          key: "buff-button" + index
        }))
      }, this)), settings.missions && (sectionComponentSettings = {
        currentHabitat: settings.currentHabitat,
        missions: settings.missions,
        activeMissions: settings.activeMissions,
        initialComponent: this
      }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentMissions, {
        settings: sectionComponentSettings,
        key: "mission-module"
      }))), settings.researches && (sectionComponentSettings = {
        currentHabitat: settings.currentHabitat,
        researches: settings.researches,
        activeResearches: settings.activeResearches,
        initialComponent: this
      }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentKnowledges, {
        settings: sectionComponentSettings,
        key: "mission-module"
      })));
      var unitRecruitmentIcons = servicesTheme.themeSettings.imagesClassNames.units;
      if (settings.unitsInProgress && (sectionComponentSettings = {
                currentHabitat: settings.currentHabitat,
                upgrades: settings.unitsInProgress,
                initialComponent: this
              }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentRecruitmentInProgressList, {
                settings: sectionComponentSettings,
                key: "external-component-units-in-progress-list"
              }))), settings.units && (sectionComponentSettings = { title: servicesInternationalization.localize("Unit Recruiting") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "building-overview-units-title"
              })), settings.units.forEach(function(unitRecruitingObject) {
                var settingsEntry, rightIconButtonSettings, rightIconButton, unitRecruitmentInHabitat = unitRecruitingObject.unitRecruitmentInHabitat;
                rightIconButtonSettings = {
                  icon: "white " + unitRecruitmentIcons.recruit,
                  classes: unitRecruitingObject.unitModel.niceIdentifier + "--open-recruitment-menu--button",
                  onClick: this.handlerNextClick.bind(this, {
                    next: xy.dNames.game.menuUnitConstruction.name,
                    options: { unit: unitRecruitingObject.unitModel, building: building }
                  }),
                  isDisabled: 0 === unitRecruitmentInHabitat.amountPossible
                }, rightIconButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings }), settingsEntry = {
                  iconLeft: unitRecruitingObject.unitModel.icon,
                  title: unitRecruitmentInHabitat.currentAmount + " X " + unitRecruitingObject.unitModel.title,
                  iconRight: rightIconButton,
                  onClick: this.handlerNextClick.bind(this, {
                    next: xy.dNames.game.menuUnitOverview.name,
                    options: { unit: unitRecruitingObject.unitModel, building: building }
                  })
                }, unitRecruitmentInHabitat.missingKnowledge ? (settingsEntry.classes = "bad-description", settingsEntry.description = servicesInternationalization.localize("Required: %@", unitRecruitmentInHabitat.missingKnowledge.identifier)) : settingsEntry.description = servicesInternationalization.localize("%d affordable", unitRecruitmentInHabitat.amountPossible), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: settingsEntry,
                  key: "units-in-list-" + unitRecruitingObject.unitModel.primaryKey
                }))
              }, this)), settings.relativeBuilding && settings.relativeBuilding.storeAmount && (sectionComponentSettings = {
                building: settings.relativeBuilding,
                currentHabitat: settings.currentHabitat,
                firstUpgradeInQueueForBuilding: settings.firstUpgradeInQueueForRelativeBuilding,
                currentConstructionsList: settings.relativeConstructionsList,
                classes: "first",
                initialComponent: this
              }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentResourcesStorage, {
                settings: sectionComponentSettings,
                key: "component-resource-production"
              }))), settings.showDisbandUnitsButton) {
        sectionComponentSettings = {
          iconLeft: "icon-game icon-DisbandUnitsIcon",
          title: servicesInternationalization.localize("Disband units"),
          onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuUnitsDisband.name })
        };
        var faqLink = servicesTheme.themeSettings.faqLinks.disbandUnits;
        faqLink && (sectionComponentSettings = this.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "building-overview-disband-units-button"
        }))
      }
      if (settings.showStockRefillButton && (sectionComponentSettings = {
                currentHabitat: settings.currentHabitat,
                customOnTimerFinishedCallBack: this.refreshMenu,
                initialComponent: this
              }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentRefill, {
                settings: sectionComponentSettings,
                key: "component-refill"
              }))), settings.treasureChest && (sectionComponentSettings = {
                classes: "first",
                initialComponent: this
              }, componentsSections.push(React.createElement(ComponentsOverviewWidgetTreasureChest, {
                settings: sectionComponentSettings,
                key: "treasure-chest"
              }))), settings.renameHabitat) {
        var renameSectionSettings = {
          name: settings.renameHabitat.currentName,
          onSubmitAction: this.onHabitatRenameSubmitClick,
          initialComponent: this,
          minLength: servicesWorldSettings.settings.habitatNameLengthMin,
          maxLength: servicesWorldSettings.settings.habitatNameLengthMax,
          forceNextRedrawUpdate: settings.forceNextRedrawUpdate,
          habitat: settings.currentHabitat
        };
        sectionComponentSettings = {
          title: servicesInternationalization.localize("Rename Habitat"),
          rightColumnDataValue: React.createElement(ComponentsWidgetRename, { settings: renameSectionSettings })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "building-overview-rename-habitat"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]);
xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentBuffEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, utilsObject, settingsGameConstant, servicesLog, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], onBuffRiseClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.riseBuff, options)
    }, constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        if (!props.settings.activeBuff)return {};
        timer = props.settings.activeBuff.expirationDate, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Buff timer error"), servicesLog("debug", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { currentHabitat: {}, buff: null, activeBuff: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var settingsEntry, rightIconButtonSettings, activeBuff = settings.activeBuff, buff = settings.buff;
      return rightIconButtonSettings = {
        icon: "icon-game white icon-BuffActivate",
        onClick: this.onBuffRiseClick.bind(this, { buff: buff, habitat: settings.currentHabitat })
      }, settingsEntry = {
        iconLeft: buff.icon,
        title: buff.title,
        description: buff.humanTimeDuration,
        iconRight: React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings })
      }, activeBuff && (settingsEntry.description = this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(activeBuff.expirationDate)), React.createElement(ComponentsMenuListElementBasic, { settings: settingsEntry })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentMissions, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.game.menuBuildingOverview.componentMissionsEntry, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListElementButtonAction, function(componentEngine, utilsDateTime, utilsObject, settingsGameConstant, servicesTheme, servicesInternationalization, MenuBuildingOverviewComponentMissionsEntry, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    getInitialState: function() {
      return { multipleMissionChooserMode: !1, selectedMissions: {} }
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id && this.setState({ selectedMissions: {} }, null)
    }, onMissionSelectionModeClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.setState({
        multipleMissionChooserMode: !this.state.multipleMissionChooserMode,
        selectedMissions: {}
      }, null)
    }, onSelectMissionCheckboxClick: function(mission, event) {
      event.preventDefault(), event.stopPropagation();
      var selectedMissions = this.state.selectedMissions;
      selectedMissions[mission.primaryKey] ? selectedMissions[mission.primaryKey] = !1 : selectedMissions[mission.primaryKey] = mission, this.setState({ selectedMissions: selectedMissions }, null)
    }, onMissionStartClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.missionStart, options)
    }, onMultiMissionStartClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.multiMissionStart, {
        selectedMissions: this.state.selectedMissions,
        currentHabitat: this.props.settings.currentHabitat
      }), this.setState({ selectedMissions: {} }, null)
    }, onMissionSpeedUpClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.missionSpeedUp, options)
    }, onMissionCancelClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.missionCancel, options)
    }, onSpeedUpAllMissionClick: function(activeMissions, event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings, presenter = settings.initialComponent.props.presenter;
      presenter.notify(xy.eNames.menuMassFunctionMissions.speedUpAllMissions, { activeMissions: activeMissions })
    }, onCancelAllMissionClick: function(missionsForCancel, event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings, presenter = settings.initialComponent.props.presenter;
      presenter.notify(xy.eNames.menuMassFunctionMissions.cancelAllMissions, { activeMissions: missionsForCancel })
    }, render: function() {
      var settings = {
        classes: "",
        currentHabitat: {},
        missions: null,
        initialComponent: null,
        hideMassModeSwitcher: !1,
        activeMissions: {}
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, componentsSections = [], missionIcons = servicesTheme.themeSettings.imagesClassNames.missions;
      sectionComponentSettings = { title: servicesInternationalization.localize("Available missions") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-missions-title"
      }));
      var multiMissionButtonsIconSettings, missionSwitcherTitle = "Switch to Group Selection", multiMissionButtonsIcon = null;
      return settings.hideMassModeSwitcher || (this.state.multipleMissionChooserMode && (missionSwitcherTitle = "Switch to Single Selection", multiMissionButtonsIconSettings = {
        icon: "white " + missionIcons.startMultiple,
        onClick: this.onMultiMissionStartClick,
        isDisabled: utilsObject.effectiveLength(this.state.selectedMissions) < 1
      }, multiMissionButtonsIcon = React.createElement(ComponentsMenuListElementButtonAction, { settings: multiMissionButtonsIconSettings })), sectionComponentSettings = {
        title: servicesInternationalization.localize(missionSwitcherTitle),
        onClick: this.onMissionSelectionModeClick,
        iconRight: multiMissionButtonsIcon
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-missions-switcher"
      })), settings.activeMissions && settings.activeMissions.missionsForSpeedUp instanceof Array && settings.activeMissions.missionsForSpeedUp.length > 1 && (multiMissionButtonsIconSettings = {
        icon: "white " + servicesTheme.themeSettings.imagesClassNames.massFunction.massMissionSpeedUp,
        onClick: this.onSpeedUpAllMissionClick.bind(this, settings.activeMissions.missionsForSpeedUp)
      }, multiMissionButtonsIcon = React.createElement(ComponentsMenuListElementButtonAction, { settings: multiMissionButtonsIconSettings }), sectionComponentSettings = {
        iconRight: multiMissionButtonsIcon,
        title: servicesInternationalization.localize("Speedup all running missions")
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-speed-up-all-missions"
      }))), settings.activeMissions && settings.activeMissions.missionsForCancel instanceof Array && settings.activeMissions.missionsForCancel.length > 1 && (multiMissionButtonsIconSettings = {
        icon: "white " + servicesTheme.themeSettings.imagesClassNames.massFunction.massMissionCancel,
        onClick: this.onCancelAllMissionClick.bind(this, settings.activeMissions.missionsForCancel)
      }, multiMissionButtonsIcon = React.createElement(ComponentsMenuListElementButtonAction, { settings: multiMissionButtonsIconSettings }), sectionComponentSettings = {
        iconRight: multiMissionButtonsIcon,
        title: servicesInternationalization.localize("Cancel all missions")
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-cancel-all-missions"
      })))), settings.missions.forEach(function(missionObject, index) {
        var settingsEntry = {
          currentHabitat: settings.currentHabitat,
          mission: missionObject,
          initialComponent: originalThis,
          listComponent: this
        };
        componentsSections.push(React.createElement(MenuBuildingOverviewComponentMissionsEntry, {
          settings: settingsEntry,
          key: "mission-in-list-" + index
        }))
      }, this), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentMissionsEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, utilsObject, settingsGameConstant, servicesLog, servicesTheme, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, secondsLeft, timer = !1;
      try {
        if (!props.settings.mission.missionInProgress)return {};
        timer = props.settings.mission.missionInProgress.complete, secondsLeft = utilsDateTime.remainTimeInSeconds(timer),
                remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Mission timer error"), servicesLog("debug", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        expired: secondsLeft < 1,
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { currentHabitat: {}, mission: null, initialComponent: null, listComponent: null };
      Object.assign(settings, this.props.settings);
      var settingsEntry, isInstantFinishingAvailable, isCancelAvailable, rightIconButtonSettings, rightIconButtonIcon, rightIconButtonOnClick, rightIconButton, originalThis = settings.initialComponent, listThis = settings.listComponent, missionObject = settings.mission, missionIcons = servicesTheme.themeSettings.imagesClassNames.missions, isSomethingMissingInHabitatToAffordMission = settings.currentHabitat.whatMissingInHabitatToAffordMission(missionObject.mission, {
        previouslySelected: listThis.state.selectedMissions,
        multiSelectionMode: listThis.state.multipleMissionChooserMode
      });
      missionObject.missionInProgress ? this.state.expired || (isInstantFinishingAvailable = missionObject.missionInProgress.doesHalfTimeOfConstructionPassNormally(), isCancelAvailable = missionObject.missionInProgress.wasSpeedUp(), rightIconButtonOnClick = listThis.onMissionSpeedUpClick, isCancelAvailable ? (rightIconButtonIcon = missionIcons.cancel, rightIconButtonOnClick = listThis.onMissionCancelClick) : rightIconButtonIcon = isInstantFinishingAvailable ? missionIcons.finish : missionIcons.speedUp, rightIconButtonSettings = {
        icon: "white " + rightIconButtonIcon,
        onClick: rightIconButtonOnClick.bind(listThis, {
          missionInProgress: missionObject.missionInProgress,
          mission: missionObject.mission,
          habitat: settings.currentHabitat
        })
      }) : rightIconButtonSettings = {
        classes: missionObject.mission.niceIdentifier + "--mission-start--button",
        icon: "white " + missionIcons.start,
        onClick: listThis.onMissionStartClick.bind(listThis, {
          mission: missionObject.mission,
          habitat: settings.currentHabitat
        }),
        isDisabled: settingsGameConstant.ENTITY.NONE !== isSomethingMissingInHabitatToAffordMission
      }, rightIconButtonSettings && (rightIconButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings })), settingsEntry = {
        iconLeft: missionObject.mission.icon,
        title: missionObject.mission.title,
        iconRight: rightIconButton,
        onClick: originalThis.handlerNextClick.bind(originalThis, {
          next: xy.dNames.game.menuMissionOverview.name,
          options: { mission: missionObject.mission }
        })
      };
      var missionSelected = !1, description = null;
      if (!missionObject.missionInProgress && listThis.state.multipleMissionChooserMode && (missionSelected = listThis.state.selectedMissions[missionObject.mission.primaryKey] || !1, settingsEntry.iconRight = null, settingsEntry.isSelectable = missionSelected || isSomethingMissingInHabitatToAffordMission === settingsGameConstant.ENTITY.NONE, settingsEntry.isSelected = missionSelected, settingsEntry.onSelect = listThis.onSelectMissionCheckboxClick.bind(listThis, missionObject.mission)), missionObject.missionInProgress)description = this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(missionObject.missionInProgress.complete); else if (!missionSelected && isSomethingMissingInHabitatToAffordMission) {
        switch (isSomethingMissingInHabitatToAffordMission) {
          case settingsGameConstant.ENTITY.UNIT:
            description = servicesInternationalization.localize("Needed: Units");
            break;
          case settingsGameConstant.ENTITY.RESOURCE:
            description = servicesInternationalization.localize("Needed: Resources")
        }
        settingsEntry.classes = "bad-description"
      }
      return settingsEntry.description = description, React.createElement(ComponentsMenuListElementBasic, { settings: settingsEntry })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentKnowledges, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.game.menuBuildingOverview.componentKnowledgeEntry, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListTextBasic, function(componentEngine, utilsDateTime, utilsObject, settingsGameConstant, servicesTheme, servicesInternationalization, MenuBuildingOverviewComponentKnowledgeEntry, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsMenuListTextBasic) {
  "use strict";
  return componentEngine.createClass({
    onResearchStartClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.researchStart, options)
    }, onResearchSpeedUpClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.researchSpeedUp, options)
    }, render: function() {
      var settings = { classes: "", currentHabitat: {}, initialComponent: null, researches: [], activeResearches: [] };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, originalThis = settings.initialComponent, availableResearchSections = [], activeResearches = settings.activeResearches, activeResearchesSection = null;
      if (sectionComponentSettings = {
                classes: "first",
                title: servicesInternationalization.localize("Available research")
              }, availableResearchSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "building-overview-buffs-title"
              })), settings.researches.forEach(function(researchObject, index) {
                var settingsEntry = {
                  currentHabitat: settings.currentHabitat,
                  listComponent: this,
                  initialComponent: originalThis,
                  research: researchObject
                };
                availableResearchSections.push(React.createElement(MenuBuildingOverviewComponentKnowledgeEntry, {
                  settings: settingsEntry,
                  key: "research-" + index
                }))
              }, this), activeResearches.length) {
        activeResearchesSection = [], sectionComponentSettings = {
          classes: "first",
          title: servicesInternationalization.localize("Knowledge Orders")
        }, activeResearchesSection.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "research-overview-in-progress-queue"
        })), activeResearches.forEach(function(researchObject, index) {
          var settingsEntry = {
            currentHabitat: settings.currentHabitat,
            listComponent: this,
            initialComponent: originalThis,
            research: researchObject
          };
          activeResearchesSection.push(React.createElement(MenuBuildingOverviewComponentKnowledgeEntry, {
            settings: settingsEntry,
            key: "research-in-progress-list-" + index
          }))
        }, this);
        var lastResearchObject = activeResearches[activeResearches.length - 1];
        sectionComponentSettings = { text: servicesInternationalization.localize("Last knowledge done %1$@", utilsDateTime.getLocaleDateTimeString(lastResearchObject.knowledgeInProgress.complete)) }, activeResearchesSection.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "last-research-in-progress-queue"
        }))
      }
      return React.createElement("div", { className: settings.classes }, activeResearchesSection, availableResearchSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentKnowledgeEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesLog, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        if (!props.settings.research.knowledgeInProgress)return {};
        timer = props.settings.research.knowledgeInProgress.complete, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Knowledge timer error"), servicesLog("debug", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { currentHabitat: {}, listComponent: null, initialComponent: null, research: {} };
      Object.assign(settings, this.props.settings);
      var rightIconButtonSettings, settingsEntry, isInstantFinishingAvailable, listThis = settings.listComponent, originalThis = settings.initialComponent, research = settings.research, rightIconButton = null;
      return research.isResearched || (research.knowledgeInProgress ? (isInstantFinishingAvailable = research.knowledgeInProgress.isLessThanHalfConstructionTimeRemain(), rightIconButtonSettings = {
        icon: "icon-game white icon-" + (isInstantFinishingAvailable ? "ResearchFinish" : "ResearchSpeedup"),
        onClick: listThis.onResearchSpeedUpClick.bind(listThis, {
          knowledgeInProgress: research.knowledgeInProgress,
          knowledge: research.knowledge,
          habitat: settings.currentHabitat
        })
      }) : rightIconButtonSettings = {
        icon: "icon-game white icon-Research",
        onClick: listThis.onResearchStartClick.bind(listThis, {
          knowledge: research.knowledge,
          habitat: settings.currentHabitat
        }),
        isDisabled: !settings.currentHabitat.canHabitatAffordUpgrade(research.knowledge)
      }, rightIconButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings })), settingsEntry = {
        iconLeft: research.knowledge.icon,
        title: research.knowledge.title,
        iconRight: rightIconButton,
        onClick: originalThis.handlerNextClick.bind(originalThis, {
          next: xy.dNames.game.menuKnowledgeOverview.name,
          options: { knowledge: research.knowledge }
        })
      }, research.knowledgeInProgress && (settingsEntry.description = this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(research.knowledgeInProgress.complete)), React.createElement(ComponentsMenuListElementBasic, { settings: settingsEntry })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentHabitatUpgradeConstruction, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.settings.gameConstant, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, function(componentEngine, utilsDateTime, servicesTheme, servicesInternationalization, servicesLog, settingsGameConstant, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = { classes: "", habitatUpgradeConstructionObject: {}, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], upgradeObject = settings.habitatUpgradeConstructionObject, habitatType = upgradeObject.original.affectedHabitatType, habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades[habitatType], habitatUpgradesIconSettings = servicesTheme.themeSettings.imagesClassNames.habitatUpgrades[habitatType];
      return sectionComponentSettings = { title: servicesInternationalization.localize(habitatUpgradesThemeSettings.title) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-city-title"
      })), sectionComponentSettings = {
        iconLeft: habitatUpgradesIconSettings.build,
        title: servicesInternationalization.localize(upgradeObject.title),
        description: upgradeObject.subTitle,
        iconRight: "controls menu-next",
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, { next: xy.dNames.game.menuHabitatUpgradeConstruction.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-city-construction-element"
      })), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentRecruitmentInProgressList, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.game.menuBuildingOverview.componentRecruitmentInProgressEntry, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, function(componentEngine, utilsDateTime, servicesInternationalization, servicesTheme, MenuBuildingOverviewComponentRecruitmentInProgressEntry, ComponentsMenuListElementButtonAction, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic) {
  "use strict";
  return componentEngine.createClass({
    onSpeedUpClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var presenter = this.props.settings.initialComponent.props.presenter;
      presenter.notify(xy.eNames.menuUnitConstruction.speedUpRecruitment, options)
    }, onCompleteAllRecruitments: function(event) {
      event.preventDefault(), event.stopPropagation();
      var options, settings = this.props.settings, habitatsObject = {}, presenter = settings.initialComponent.props.presenter;
      habitatsObject[settings.currentHabitat.id] = {
        upgrades: settings.upgrades,
        habitat: settings.currentHabitat
      }, options = { habitatsObject: habitatsObject }, presenter.notify(xy.eNames.menuUnitConstruction.completeAllRecruitment, options)
    }, render: function() {
      var settings = { classes: "", currentHabitat: null, upgrades: [], initialComponent: null };
      if (Object.assign(settings, this.props.settings), !settings.upgrades.length)return null;
      var sectionComponentSettings, classes = "widget--upgrades-in-progress--list", componentsSections = [], originalThis = settings.initialComponent, themeIcon = servicesTheme.themeSettings.imagesClassNames, unitRecruitmentIcons = themeIcon.units;
      sectionComponentSettings = { title: servicesInternationalization.localize("Unit Orders") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-units-in-progress-current"
      })), settings.upgrades.length > 1 && (sectionComponentSettings = {
        iconLeft: unitRecruitmentIcons.recruit,
        title: servicesInternationalization.localize("Complete all recruitments"),
        rightColumnDataValue: settings.upgrades.length,
        onClick: this.onCompleteAllRecruitments
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "complete-all-section"
      }))), settings.upgrades.forEach(function(upgrade) {
        var settingsEntry = {
          initialComponent: originalThis,
          listComponent: this,
          currentHabitat: settings.currentHabitat,
          upgrade: upgrade
        };
        componentsSections.push(React.createElement(MenuBuildingOverviewComponentRecruitmentInProgressEntry, {
          settings: settingsEntry,
          key: "unit-is-in-progress-entry-" + upgrade.inProgressModel.id
        }))
      }, this);
      var lastInUpgradeIndex = settings.upgrades.length - 1, lastInProgressCompleteDate = settings.upgrades[lastInUpgradeIndex].inProgressModel.complete;
      return sectionComponentSettings = { text: servicesInternationalization.localize("Last recruitment done %@", utilsDateTime.getLocaleDateTimeString(lastInProgressCompleteDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "last-units-will-be-done-at"
      })), React.createElement("div", { className: classes + settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentRecruitmentInProgressEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuListElementButtonAction, ComponentsMenuListElementBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var timer = props.settings.upgrade.inProgressModel.nextUnitFinishedDate;
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: utilsDateTime.remainTime(timer, !0)
      }
    }, render: function() {
      var settings = { upgrade: null, currentHabitat: null, listComponent: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var rightIconButtonSettings, settingsEntry, themeIcon = servicesTheme.themeSettings.imagesClassNames, unitRecruitmentIcons = themeIcon.units, originalThis = settings.initialComponent, listThis = settings.listComponent, inProgressModel = settings.upgrade.inProgressModel, isInstantFinishingAvailable = inProgressModel.isLessThanHalfConstructionTimeRemain();
      return rightIconButtonSettings = {
        icon: "white " + (isInstantFinishingAvailable ? unitRecruitmentIcons.recruitFinish : unitRecruitmentIcons.recruitSpeedUp),
        onClick: listThis.onSpeedUpClick.bind(listThis, {
          unitInProgress: inProgressModel,
          habitat: settings.currentHabitat,
          unit: settings.upgrade.unitModel
        })
      }, settingsEntry = {
        iconLeft: settings.upgrade.unitModel.icon,
        title: settings.upgrade.unitModel.title,
        description: servicesInternationalization.localize("%@ - %d in %@", this.state.remainTimeString, inProgressModel.unitsLeft, utilsDateTime.remainTime(inProgressModel.complete, !0)),
        onClick: originalThis.handlerNextClick.bind(originalThis, {
          next: xy.dNames.game.menuUnitOverview.name,
          options: { unit: settings.upgrade.unitModel }
        }),
        iconRight: React.createElement(ComponentsMenuListElementButtonAction, { settings: rightIconButtonSettings })
      }, React.createElement(ComponentsMenuListElementBasic, { settings: settingsEntry })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentResourcesExchange, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.components.menuListTitleBasic, xy.dNames.components.buildingWidgetTradeRates, function(componentEngine, utilsDateTime, servicesInternationalization, ComponentsMenuListTitleBasic, ComponentsBuildingWidgetTradeRates) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        building: null,
        title: "Available market resources",
        marketRateDictionary: {},
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = { title: servicesInternationalization.localize(settings.title) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-trading-goods-title"
      }));
      var tradingResourceId, marketRateDictionary = settings.marketRateDictionary;
      for (tradingResourceId in marketRateDictionary)marketRateDictionary.hasOwnProperty(tradingResourceId) && (sectionComponentSettings = {
        tradeResourceId: tradingResourceId,
        ratesToOtherResources: marketRateDictionary[tradingResourceId],
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuResourcesMarket.name,
          options: { tradingResourceId: tradingResourceId, building: settings.building }
        })
      }, componentsSections.push(React.createElement(ComponentsBuildingWidgetTradeRates, {
        settings: sectionComponentSettings,
        key: "building-overview-trading-goods-widget-" + tradingResourceId
      })));
      return React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentResourcesStorage, [xy.dNames.componentsEngine, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListElementBasic, xy.dNames.components.overviewWidgetConstructCost, xy.dNames.components.buildingUpgradesList, function(componentsEngine, servicesGameDataManager, servicesInternationalization, servicesTheme, ComponentsMenuListElementBasic, ComponentsWidgetConstructBuildingCost, ComponentsBuildingUpgradesList) {
  "use strict";
  return componentsEngine.createClass({
    render: function() {
      var settings = {
        building: {},
        currentHabitat: {},
        firstUpgradeInQueueForBuilding: {},
        currentConstructionsList: [],
        classes: "",
        initialComponent: {}
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], building = settings.building, initialComponent = settings.initialComponent, currentConstructionsList = settings.currentConstructionsList;
      sectionComponentSettings = {
        iconLeft: building.icon,
        title: servicesInternationalization.localize(building.title) + " " + building.level
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-current-level"
      }));
      var descriptionKey = servicesTheme.themeSettings.buildings.descriptionKeys[building.classIdentifier];
      sectionComponentSettings = { title: servicesInternationalization.localize(descriptionKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-building-type-description"
      })), building.storeAmount && building.storeResourceArray instanceof Array && building.storeResourceArray.length && building.storeResourceArray.forEach(function(resourceId) {
        var localComponentSettings = {
          iconLeft: "icon icon-resource icon-resource-" + resourceId,
          title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[resourceId]),
          rightColumnDataValue: settings.currentHabitat.habitatResourceDictionary[resourceId].amount + "/" + building.storeAmount
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "building-overview-store-" + resourceId
        }))
      }, this);
      var isFurtherUpgradePossible, nextBuildingPK, nextBuilding, currentUpgradesLength = currentConstructionsList ? currentConstructionsList.length : 0;
      return currentUpgradesLength ? (isFurtherUpgradePossible = currentConstructionsList[currentUpgradesLength - 1].resultBuilding.isFurtherUpgradePossible, nextBuildingPK = currentConstructionsList[currentUpgradesLength - 1].resultBuilding.getResultBuildingPK()) : (isFurtherUpgradePossible = building.isFurtherUpgradePossible, nextBuildingPK = building.getResultBuildingPK()), isFurtherUpgradePossible && (nextBuilding = servicesGameDataManager.buildingsCollection.getBuilding({ pk: nextBuildingPK }), sectionComponentSettings = {
        initialComponent: initialComponent,
        constructingEntity: nextBuilding,
        title: servicesInternationalization.localize("Level %d", nextBuilding.level),
        currentHabitat: settings.currentHabitat,
        showMissingResources: !0,
        onClick: initialComponent.handlerNextClick.bind(initialComponent, {
          next: xy.dNames.game.menuBuildingUpgrades.name,
          options: { classIdentifier: building.classIdentifier }
        }),
        onConstructButtonClick: initialComponent.onUpgradeButtonClick.bind(initialComponent, {
          resultBuildingPK: nextBuilding.primaryKey,
          habitat: settings.currentHabitat,
          paymentGranted: !1
        })
      }, componentsSections.push(React.createElement(ComponentsWidgetConstructBuildingCost, {
        settings: sectionComponentSettings,
        key: "building-overview-widget-net-level-upgrade"
      }))), currentUpgradesLength && (sectionComponentSettings = {
        currentHabitat: settings.currentHabitat,
        firstUpgradeInQueueForBuilding: settings.firstUpgradeInQueueForBuilding,
        upgrades: currentConstructionsList,
        onSpeedUpClick: initialComponent.onSpeedUpButtonClick,
        onClick: initialComponent.handlerNextClick,
        initialComponent: initialComponent
      }, componentsSections.push(React.createElement(ComponentsBuildingUpgradesList, {
        settings: sectionComponentSettings,
        key: "menu-currently-is-is-progress"
      }))), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentRefill, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuListButtonBasic, function(componentEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesLog, servicesInternationalization, servicesTheme, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinsMenuComponentTimer], onRefillStockClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var originalThis = this.props.settings.initialComponent;
      originalThis.props.presenter.notify(xy.eNames.menuBuildingOverview.refillStock, { habitat: this.props.settings.currentHabitat })
    }, constructState: function(props) {
      var remainTimeString, timer = !1;
      try {
        if (!props.settings.currentHabitat.nextLegalRestockDate || utilsDateTime.remainTimeInSeconds(props.settings.currentHabitat.nextLegalRestockDate) < 0)return {};
        timer = props.settings.currentHabitat.nextLegalRestockDate, remainTimeString = utilsDateTime.remainTime(timer, !0)
      } catch (eX) {
        servicesLog("warn", "Refill timer error"), servicesLog("debug", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { classes: "", currentHabitat: {}, customOnTimerFinishedCallBack: null, initialComponent: null };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], isRestockDisabled = !settings.currentHabitat.canRefill(), restockDescription = "", originalThis = settings.initialComponent;
      isRestockDisabled && settings.currentHabitat.nextLegalRestockDate && utilsDateTime.remainTimeInSeconds(settings.currentHabitat.nextLegalRestockDate) > 0 && (restockDescription = this.state.remainTimeString + " - " + utilsDateTime.getLocaleDateTimeString(settings.currentHabitat.nextLegalRestockDate)), sectionComponentSettings = {
        iconLeft: "icon-game icon-RestockResourceStorage",
        title: servicesInternationalization.localize("Fill up the stock"),
        description: restockDescription,
        onClick: this.onRefillStockClick,
        disabled: isRestockDisabled
      };
      var faqLink = servicesTheme.themeSettings.faqLinks.fillUpStock;
      return faqLink && (sectionComponentSettings = originalThis.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-refill-stock-button"
      })), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.componentNobleExchange, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.components.menuListTitleBasic, xy.dNames.components.buildingWidgetTradeRates, xy.dNames.services.worldSettings, xy.dNames.services.internationalization, xy.dNames.services.theme, function(componentEngine, utilsDateTime, ComponentsMenuListTitleBasic, ComponentsBuildingWidgetTradeRates, servicesWorldSettings, servicesInternationalization, servicesTheme) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        classes: "",
        building: null,
        title: "Exchange Gold for goods",
        marketRateDictionary: {},
        initialComponent: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = { title: servicesInternationalization.localize(settings.title) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "building-overview-trading-goods-title"
      }));
      var tradingResourceId, rateObject, settingsName, resourcesThemeSettings = servicesTheme.themeSettings.resources, marketRateDictionary = settings.marketRateDictionary;
      for (tradingResourceId in marketRateDictionary)marketRateDictionary.hasOwnProperty(tradingResourceId) && (settingsName = resourcesThemeSettings.nobleMarketsNames.byId[tradingResourceId], rateObject = { premium: servicesWorldSettings.settings[settingsName] || resourcesThemeSettings.nobleMarkets[settingsName].rate.premium }, sectionComponentSettings = {
        tradeResourceId: tradingResourceId,
        reverseRate: !0,
        ratesToOtherResources: rateObject,
        onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
          next: xy.dNames.game.menuResourcesNobleMarket.name,
          options: { tradingResourceId: tradingResourceId }
        })
      }, componentsSections.push(React.createElement(ComponentsBuildingWidgetTradeRates, {
        settings: sectionComponentSettings,
        key: "building-overview-trading-goods-widget-" + tradingResourceId
      })));
      return React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.eventManager, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager, servicesWorldSettings, servicesEventManager) {
  "use strict";
  function MenuBuildingOverviewController(options) {
    var menuBuildingListsDataController = gameInstance.injector.get(xy.dNames.game.menuBuildingsList.controller), menuUnitConstructionController = gameInstance.injector.get(xy.dNames.game.menuUnitConstruction.controller), menuMassFunctionMissionsController = gameInstance.injector.get(xy.dNames.game.menuMassFunctionMissions.controller);
    this.forLinking = [{
      resourceClass: menuBuildingListsDataController,
      methodName: xy.eNames.menuBuildingsList.upgradeBuilding
    }, {
      resourceClass: menuBuildingListsDataController,
      methodName: xy.eNames.menuBuildingsList.speedUpUpgrade
    }, {
      resourceClass: menuUnitConstructionController,
      methodName: xy.eNames.menuUnitConstruction.speedUpRecruitment
    }, {
      resourceClass: menuUnitConstructionController,
      methodName: xy.eNames.menuUnitConstruction.completeAllRecruitment
    }, {
      resourceClass: menuMassFunctionMissionsController,
      methodName: xy.eNames.menuMassFunctionMissions.cancelAllMissions
    }, {
      resourceClass: menuMassFunctionMissionsController,
      methodName: xy.eNames.menuMassFunctionMissions.speedUpAllMissions
    }], MenuBuildingOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuBuildingOverviewController, CoreControllerElementMenu), MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.dataIsReady] = function(data) {
    this.isActive && (servicesEventManager.handleClientEvent("habitat-scene--click-on-" + data.building.classIdentifier), this.presenter.draw(data))
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.refillStock] = function(options) {
    var text, cost, amount, affectedHabitat = options.habitat, gold = servicesGameDataManager.playersCollection.getPlayer().gold, rUnit = servicesWorldSettings.settings.restockingResourcesUnit, rCost = servicesWorldSettings.settings.restockingResourcesCostPerUnit;
    if (amount = affectedHabitat.getRestockResourceAmount(), 0 !== amount) {
      if (cost = Math.ceil(amount / rUnit) * rCost, cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      options.acceptedPayment = cost, text = servicesInternationalization.localize("Filling up the stock of resources costs %1$d gold coins. You own %2$d gold coins.", cost, gold), this.showDialogDialog({
        title: servicesInternationalization.localize("Fill up the stock"),
        text: text,
        callbackSuccess: this.dataSource.refillHabitatStock.bind(this.dataSource, options)
      })
    }
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.riseBuff] = function(options) {
    var text, cost, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
    return cost = options.buff.goldAmount, cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (text = servicesInternationalization.localize("Raising the banner costs %1$d gold coins. You currently own %2$d gold coins.", cost, gold), void this.showDialogDialog({
      title: servicesInternationalization.localize("Raise the banner"),
      text: text,
      callbackSuccess: this.dataSource.riseBuff.bind(this.dataSource, options)
    }))
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.researchStart] = function(options) {
    var researchLimit = +servicesWorldSettings.settings.knowledgeResearchListBoundaryByHabitatType[options.habitat.habitatType];
    if (researchLimit <= options.habitat.habitatKnowledgeOrderArray.length) {
      var text, cost = options.knowledge.buildSpeedupCost, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      options.paymentAmount = cost, text = servicesInternationalization.localize("Your knowledge order queue is full. An additional slot costs %1$d %2$@\\nYou have %3$d %4$@", cost, "Gold", gold, "Gold"), this.showDialogDialog({
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.researchConduct.bind(this.dataSource, options)
      })
    } else this.dataSource.researchConduct(options)
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.researchSpeedUp] = function(options) {
    var localizationString, text, successCallBack, resultKnowledge = options.knowledge, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = resultKnowledge.buildSpeedupCost;
    return cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (options.knowledgeInProgress.isLessThanHalfConstructionTimeRemain() ? (localizationString = "Finishing the research (%@) instantly costs %d %@. You have %d %@.", successCallBack = this.dataSource.researchFinish.bind(this.dataSource, options)) : (localizationString = "Research time reduction for %@ costs %d %@. You have %d %@.", successCallBack = this.dataSource.researchSpeedUp.bind(this.dataSource, options)), text = servicesInternationalization.localize(localizationString, resultKnowledge.identifier, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Gold"),
      text: text,
      callbackSuccess: successCallBack
    }))
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.missionStart] = function(options) {
    this.dataSource.missionStart(options)
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.missionSpeedUp] = function(options) {
    var localizationString, text, mission = options.mission, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = mission.buildSpeedupCost;
    return cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (localizationString = options.missionInProgress.doesHalfTimeOfConstructionPassNormally() ? "Finishing mission %@ instantly costs %d %@. You have %d %@." : "Mission time reduction for %@ costs %d %@. You have %d %@.", text = servicesInternationalization.localize(localizationString, mission.identifier, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Gold"),
      text: text,
      callbackSuccess: this.dataSource.missionSpeedUp.bind(this.dataSource, options)
    }))
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.missionCancel] = function(options) {
    var localizationString, text, mission = options.mission, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = mission.buildSpeedupCost;
    return cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (options.paymentAmount = cost, localizationString = "Do you like to cancel all missions for %1$ld %2$@. You have %3$ld %4$@. Caution! Canceled missions don't produce resources.", text = servicesInternationalization.localize(localizationString, mission.identifier, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Gold"),
      text: text,
      callbackSuccess: this.dataSource.missionCancel.bind(this.dataSource, options)
    }))
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.multiMissionStart] = function(options) {
    this.dataSource.multipleMissionsStart(options)
  }, MenuBuildingOverviewController.prototype[xy.eNames.menuBuildingOverview.changeNameForHabitat] = function(options) {
    this.dataSource.tryChangeNameForHabitat(options)
  }, MenuBuildingOverviewController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = !1;
    this.isActive && (this.forceNextRedrawUpdate && (forceNextRedrawUpdate = !0, this.forceNextRedrawUpdate = !1), this.dataSource.prepareBuildingData({
      classIdentifier: this.initialOptions.classIdentifier,
      forceNextRedrawUpdate: forceNextRedrawUpdate
    }))
  }, MenuBuildingOverviewController.prototype.setLocalizationName = function(buildingClassIdentifier) {
    this.localizedName = servicesInternationalization.localize(buildingClassIdentifier)
  }, MenuBuildingOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.utils.network, xy.dNames.utils.dateTime, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.sortable, xy.dNames.services.worldSettings, xy.dNames.services.eventManager, function(gameInstance, CoreDataSource, utilsOop, utilsObject, utilsNetwork, utilsDateTime, servicesGameDataManager, servicesTheme, servicesSortable, servicesWorldSettings, servicesEventManager) {
  "use strict";
  function MenuBuildingOverviewDataSource(options) {
    var menuBuildingListsDataSource = gameInstance.injector.get(xy.dNames.game.menuBuildingsList.dataSource), menuUnitConstructionDataSource = gameInstance.injector.get(xy.dNames.game.menuUnitConstruction.dataSource), menuMassFunctionMissionsDataSource = gameInstance.injector.get(xy.dNames.game.menuMassFunctionMissions.dataSource);
    this.forLinking = [{
      resourceClass: menuBuildingListsDataSource,
      methodName: "speedUpConstruction"
    }, {
      resourceClass: menuBuildingListsDataSource,
      methodName: "finishConstruction"
    }, {
      resourceClass: menuBuildingListsDataSource,
      methodName: "upgradeBuilding"
    }, {
      resourceClass: menuBuildingListsDataSource,
      methodName: "onSpeedUpConstructionResponse"
    }, {
      resourceClass: menuBuildingListsDataSource,
      methodName: "onUpgradeConstructionResponse"
    }, {
      resourceClass: menuUnitConstructionDataSource,
      methodName: "speedUpUnit"
    }, {
      resourceClass: menuUnitConstructionDataSource,
      methodName: "finishUnit"
    }, {
      resourceClass: menuUnitConstructionDataSource,
      methodName: "batchRecruitmentActions"
    }, {
      resourceClass: menuMassFunctionMissionsDataSource,
      methodName: "massMissionsSpeedUp"
    }, {
      resourceClass: menuMassFunctionMissionsDataSource,
      methodName: "massMissionsCancel"
    }], MenuBuildingOverviewDataSource.__super__.constructor.call(this, options), this.optionsCache = null
  }

  return utilsOop.extend(MenuBuildingOverviewDataSource, CoreDataSource), MenuBuildingOverviewDataSource.prototype.prepareBuildingData = function(options, extraData) {
    if (options = options || {}, extraData = extraData || {}, !options.classIdentifier)return void this.notify(xy.eNames.menu.onDataError, "Empty building classifier");
    this.optionsCache = options;
    var building, relatedBuilding, currentConstructionsList, relativeConstructionsList, buildingClassIdentifierFixed, relativeBuildingClassIdentifierFixed, abilitiesWithModifiers, buildingsThemeSettings = servicesTheme.themeSettings.buildings, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    if (buildingClassIdentifierFixed = buildingsThemeSettings.crossHabitatTypesBuildingRelations[options.classIdentifier][currentHabitat.publicHabitatType], building = servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
              habitat: currentHabitat,
              buildingClass: buildingClassIdentifierFixed
            }), this.controller.setLocalizationName(building.title), data.building = building, data.currentHabitat = currentHabitat, currentConstructionsList = servicesGameDataManager.buildingsCollection.getHabitatBuildingUpgrades({
              habitat: currentHabitat,
              buildingClass: buildingClassIdentifierFixed
            }), currentConstructionsList.length && (data.currentConstructionsList = currentConstructionsList, data.firstUpgradeInQueueForBuilding = {}, data.firstUpgradeInQueueForBuilding[buildingClassIdentifierFixed] = currentConstructionsList[0].buildingUpgrade.id), buildingsThemeSettings.relativeBuildings[options.classIdentifier] && (relativeBuildingClassIdentifierFixed = buildingsThemeSettings.relativeBuildings[options.classIdentifier][currentHabitat.publicHabitatType], relatedBuilding = servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
              habitat: currentHabitat,
              buildingClass: relativeBuildingClassIdentifierFixed
            }), relativeConstructionsList = servicesGameDataManager.buildingsCollection.getHabitatBuildingUpgrades({
              habitat: currentHabitat,
              buildingClass: relativeBuildingClassIdentifierFixed
            }), data.relativeBuilding = relatedBuilding, relativeConstructionsList.length && (data.relativeConstructionsList = relativeConstructionsList, data.firstUpgradeInQueueForRelativeBuilding = {}, data.firstUpgradeInQueueForRelativeBuilding[relativeBuildingClassIdentifierFixed] = relativeConstructionsList[0].buildingUpgrade.id)), utilsObject.isEmpty(building.battleValueDictionary) || (abilitiesWithModifiers = currentHabitat.applyModifiers({
              targetObject: "Building",
              rawData: building.battleValueDictionary
            }), data.battleAbilityWithModifiers = abilitiesWithModifiers.battleAbility), utilsObject.isEmpty(building.generateResourceDictionary) || (abilitiesWithModifiers = currentHabitat.applyModifiers({
              targetObject: "Building",
              generateResource: building.generateResourceDictionary
            }), currentHabitat.habitatBuffArray instanceof Array && currentHabitat.habitatBuffArray.length && (abilitiesWithModifiers = currentHabitat.applyBuffs({
              targetObject: "Building",
              generateResource: abilitiesWithModifiers.generateResource
            })), data.generateResourceWithModifiers = abilitiesWithModifiers.generateResource), servicesTheme.themeSettings.buildings.stockBuildings[buildingClassIdentifierFixed] && (data.showStockRefillButton = !0), servicesTheme.themeSettings.buildings.disbandUnitsBuildings[buildingClassIdentifierFixed] && (data.showDisbandUnitsButton = !0), building.buffFactoryArray instanceof Array && building.buffFactoryArray.length) {
      data.activeBuffs = currentHabitat.getActiveBuffs();
      var buffsList = [];
      building.buffFactoryArray.forEach(function(buffPK) {
        var modeledBuff = servicesGameDataManager.buffsCollection.getBuff({ primaryKey: buffPK });
        buffsList.push(modeledBuff)
      }, this), data.buffsList = buffsList
    }
    if (building.knowledgeFactoryArray instanceof Array) {
      var researches = [], activeResearches = [], researchedKnowledge = {}, researchingKnowledge = {};
      currentHabitat.habitatKnowledgeIdArray.forEach(function(knowledgePK) {
        researchedKnowledge[knowledgePK] = !0
      }), currentHabitat.habitatKnowledgeOrderArray.length && currentHabitat.habitatKnowledgeOrderArray.forEach(function(knowledgeInProgressId) {
        var modeledKnowledgeInProgress = servicesGameDataManager.knowledgesCollection.getKnowledgeInProgress(knowledgeInProgressId);
        researchingKnowledge[modeledKnowledgeInProgress.knowledgeId] = modeledKnowledgeInProgress
      }), building.knowledgeFactoryArray.forEach(function(knowledgePK) {
        var modeledKnowledge = servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: knowledgePK });
        researchingKnowledge[modeledKnowledge.primaryKey] && activeResearches.push({
          knowledge: modeledKnowledge,
          isResearched: researchedKnowledge.hasOwnProperty(modeledKnowledge.primaryKey),
          knowledgeInProgress: researchingKnowledge[modeledKnowledge.primaryKey]
        }), researches.push({
          knowledge: modeledKnowledge,
          isResearched: researchedKnowledge.hasOwnProperty(modeledKnowledge.primaryKey),
          knowledgeInProgress: researchingKnowledge[modeledKnowledge.primaryKey]
        })
      }), researches.sort(servicesSortable.byField("knowledge", "order")), activeResearches.sort(servicesSortable.byField("knowledgeInProgress", "complete")), data.researches = researches, data.activeResearches = activeResearches
    }
    if (building.missionFactoryArray instanceof Array) {
      var missions = [], missionInProgress = {}, missionsForCancel = [], missionsForSpeedUp = [];
      currentHabitat.habitatMissionArray.length && currentHabitat.habitatMissionArray.forEach(function(missionInProgressId) {
        var modeledMissionInProgress = servicesGameDataManager.missionsCollection.getMissionInProgress(missionInProgressId);
        missionInProgress[modeledMissionInProgress.missionId] = modeledMissionInProgress, modeledMissionInProgress.wasSpeedUp() ? missionsForCancel.push({
          habitat: currentHabitat,
          missionInProgress: modeledMissionInProgress
        }) : missionsForSpeedUp.push(modeledMissionInProgress)
      }), building.missionFactoryArray.forEach(function(missionPK) {
        var modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: missionPK });
        missions.push({ mission: modeledMission, missionInProgress: missionInProgress[modeledMission.primaryKey] })
      }, this), missions.sort(servicesSortable.byField("mission", "order")), data.activeMissions = {
        missionsForCancel: missionsForCancel,
        missionsForSpeedUp: missionsForSpeedUp
      }, data.missions = missions
    }
    if (building.unitFactoryArray instanceof Array) {
      var unitFactory = [];
      if (building.unitFactoryArray.forEach(function(unitPK) {
                var modeledUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPK });
                unitFactory.push({
                  unitModel: modeledUnit,
                  unitRecruitmentInHabitat: currentHabitat.unitRecruitmentInHabitat(modeledUnit)
                })
              }), unitFactory.sort(servicesSortable.byField("unitModel", "order")), data.units = unitFactory, currentHabitat.habitatUnitOrderArray instanceof Array) {
        var unitsInProgress = [];
        currentHabitat.habitatUnitOrderArray.forEach(function(unitInProgressId) {
          var modeledUnitInProgress = servicesGameDataManager.unitsCollection.getUnitInProgress(unitInProgressId), modeledUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: modeledUnitInProgress.unitId });
          unitsInProgress.push({ unitModel: modeledUnit, inProgressModel: modeledUnitInProgress })
        }), unitsInProgress.sort(servicesSortable.byField("inProgressModel", "complete")), data.unitsInProgress = unitsInProgress
      }
    }
    var isFortressEnabled = servicesTheme.themeSettings.buildings.fortressConstructionBuilding === buildingClassIdentifierFixed && servicesWorldSettings.settings.featureFortress, isCityEnabled = servicesTheme.themeSettings.buildings.cityConstructionBuilding === buildingClassIdentifierFixed && servicesWorldSettings.settings.featureCity;
    if ((isFortressEnabled || isCityEnabled) && (data.habitatUpgradeConstructionObject = currentHabitat.getHabitatUpgrade()), servicesTheme.themeSettings.buildings.nobleMarkets[buildingClassIdentifierFixed] && servicesWorldSettings.settings.featureSpecialExchange && building.specialExchangeArray instanceof Array && building.specialExchangeArray.length) {
      var nobleMarketsDictionaryRates = {}, resourcesThemeSettings = servicesTheme.themeSettings.resources;
      building.specialExchangeArray.forEach(function(exchangeItem) {
        var settingsName = resourcesThemeSettings.nobleMarketsNames.byBuildingSpecialExchange[exchangeItem], nobleMarketSettings = resourcesThemeSettings.nobleMarkets[settingsName];
        nobleMarketsDictionaryRates[nobleMarketSettings.resource] = nobleMarketSettings.rate
      }), data.nobleMarket = nobleMarketsDictionaryRates
    }
    building.functionArray instanceof Array && building.functionArray.forEach(function(functionName) {
      switch (functionName) {
        case"Rename Habitat":
          var renameResponse = extraData.renameResponse || {};
          data.renameHabitat = {
            currentName: currentHabitat.name,
            errorMessage: renameResponse.errorMessage || null,
            listOfAvailableOptions: renameResponse.listOfAvailableOptions || null
          };
          break;
        case"Treasure Chest":
          data.treasureChest = !0
      }
    }), data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuBuildingOverview.dataIsReady, data)
  }, MenuBuildingOverviewDataSource.prototype.refillHabitatStock = function(options) {
    this.request({
      habitatID: options.habitat.id,
      paymentAmount: options.acceptedPayment
    }, "HabitatAction/restockResourceStorage", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.riseBuff = function(options) {
    this.request({
      habitatID: options.habitat.id,
      primaryKey: options.buff.primaryKey
    }, "HabitatAction/activateBuff", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.researchConduct = function(options) {
    var param = { habitatID: options.habitat.id, primaryKey: options.knowledge.primaryKey };
    options.paymentAmount && (param.paymentAmount = options.paymentAmount), this.request(param, "HabitatAction/researchKnowledge", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.researchSpeedUp = function(options) {
    this.request({
      habitatID: options.habitat.id,
      primaryKey: options.knowledge.primaryKey
    }, "HabitatAction/speedupKnowledgeResearch", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.researchFinish = function(options) {
    this.request({
      habitatID: options.habitat.id,
      primaryKey: options.knowledge.primaryKey
    }, "HabitatAction/finishKnowledgeResearch", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.missionStart = function(options) {
    servicesEventManager.handleClientEvent(options.mission.niceIdentifier + "--start-mission"), this.request({
      habitatID: options.habitat.id,
      primaryKey: options.mission.primaryKey
    }, "HabitatAction/executeMission", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.multipleMissionsStart = function(options) {
    var habitatIDMissionIDArrayDictionary = {};
    if (options.currentHabitat && options.selectedMissions) {
      var selectedMissionsArray = [];
      Object.keys(options.selectedMissions).forEach(function(missionId) {
        options.selectedMissions[missionId] && (servicesEventManager.handleClientEvent(options.selectedMissions[missionId].niceIdentifier + "--start-mission"), selectedMissionsArray.push(missionId))
      }), habitatIDMissionIDArrayDictionary[options.currentHabitat.id] = selectedMissionsArray
    }
    habitatIDMissionIDArrayDictionary = utilsNetwork.dictionaryToQueryString(habitatIDMissionIDArrayDictionary), this.request({ habitatIDMissionIDArrayDictionary: habitatIDMissionIDArrayDictionary }, "HabitatAction/executeMissionsInHabitatDictionary", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.missionSpeedUp = function(options) {
    this.request({
      habitatID: options.habitat.id,
      primaryKey: options.mission.primaryKey
    }, "HabitatAction/speedupMission", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.missionCancel = function(options) {
    var param = { habitatID: options.habitat.id, paymentAmount: options.paymentAmount };
    options.mission && (param.primaryKey = options.mission.primaryKey), this.request(param, "HabitatAction/cancelMission", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource.prototype.tryChangeNameForHabitat = function(options) {
    this.request({
      habitatID: options.habitat.id,
      name: options.newName
    }, "HabitatAction/changeHabitatName", { callBack: this.handleSessionUpdateResponse })
  }, MenuBuildingOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuBuildingOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuBuildingOverviewComponent) {
  "use strict";
  function MenuBuildingOverviewPresenter(options) {
    MenuBuildingOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingOverviewPresenter, CorePresenterElementMenu), MenuBuildingOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuBuildingOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuBuildingOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingUpgrades.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.game.menuBuildingUpgrades.componentLevelEntry, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentBuildingUpgradesLevelEntry) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = {
        upgrades: {},
        currentLevelOfBuilding: "",
        currentHabitat: {}
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      if (this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.upgrades) {
        var upgradePK;
        for (upgradePK in settings.upgrades)settings.upgrades.hasOwnProperty(upgradePK) && settings.upgrades[upgradePK].building && settings.upgrades[upgradePK].building.level && (sectionComponentSettings = {
          upgrade: settings.upgrades[upgradePK],
          currentHabitat: settings.currentHabitat,
          currentLevelOfBuilding: settings.currentLevelOfBuilding,
          initialComponent: this
        }, componentsSections.push(React.createElement(ComponentBuildingUpgradesLevelEntry, {
          settings: sectionComponentSettings,
          key: "buildings-upgrades-level-entry-" + upgradePK
        })))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingUpgrades.componentLevelEntry, [xy.dNames.componentsEngine, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.utils.object, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.overviewWidgetConstructCost, xy.dNames.components.overviewWidgetBattleAbilityList, xy.dNames.components.buildingWidgetTradeRates, function(componentEngine, servicesInternationalization, servicesTheme, servicesGameDataManager, utilsObject, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsWidgetConstructBuildingCost, ComponentsOverviewWidgetBattleAbilityList, ComponentsBuildingWidgetTradeRates) {
  "use strict";
  return componentEngine.createClass({
    render: function() {
      var settings = {
        upgrade: {},
        currentHabitat: {},
        currentLevelOfBuilding: "",
        initialComponent: null,
        classes: ""
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], upgradeBuilding = settings.upgrade.building, isLevelReached = upgradeBuilding.level <= settings.currentLevelOfBuilding;
      if (sectionComponentSettings = { title: servicesInternationalization.localize("Level %d", upgradeBuilding.level) }, isLevelReached && (sectionComponentSettings.iconRight = "controls menu-accept"), componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, { settings: sectionComponentSettings })), upgradeBuilding.marketDistance && (sectionComponentSettings = {
                title: servicesInternationalization.localize("Distance to market"),
                rightColumnDataValue: servicesInternationalization.localize("%d fields", upgradeBuilding.marketDistance)
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "building-overview-market-distance"
              }))), !utilsObject.isEmpty(settings.upgrade.generateResourceWithModifiers)) {
        var resourceId, generateResourceWithModifiers = settings.upgrade.generateResourceWithModifiers;
        for (resourceId in generateResourceWithModifiers)generateResourceWithModifiers.hasOwnProperty(resourceId) && (sectionComponentSettings = {
          iconLeft: "icon icon-resource icon-resource-" + resourceId,
          title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[resourceId]),
          rightColumnDataValue: "+" + generateResourceWithModifiers[resourceId] + "/h"
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "building-overview-production-" + resourceId
        })))
      }
      if (settings.upgrade.researches && settings.upgrade.researches.forEach(function(research) {
                sectionComponentSettings = {
                  iconLeft: research.knowledge.icon,
                  title: research.knowledge.title,
                  onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
                    next: xy.dNames.game.menuKnowledgeOverview.name,
                    options: { knowledge: research.knowledge }
                  })
                }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings }))
              }), settings.upgrade.missions && settings.upgrade.missions.forEach(function(missionObject) {
                sectionComponentSettings = {
                  iconLeft: missionObject.mission.icon,
                  title: missionObject.mission.title,
                  onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
                    next: xy.dNames.game.menuMissionOverview.name,
                    options: { mission: missionObject.mission }
                  })
                }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, { settings: sectionComponentSettings }))
              }, this), upgradeBuilding.storeAmount && upgradeBuilding.storeResourceArray instanceof Array && upgradeBuilding.storeResourceArray.length && upgradeBuilding.storeResourceArray.forEach(function(resourceId) {
                sectionComponentSettings = {
                  iconLeft: "icon icon-resource icon-resource-" + resourceId,
                  title: servicesInternationalization.localize(servicesTheme.themeSettings.resources[resourceId]),
                  rightColumnDataValue: settings.currentHabitat.habitatResourceDictionary[resourceId].amount + "/" + upgradeBuilding.storeAmount
                }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: sectionComponentSettings,
                  key: "building-overview-store-" + resourceId
                }))
              }, this), upgradeBuilding.modifierArray instanceof Array && upgradeBuilding.modifierArray.length && upgradeBuilding.modifierArray.forEach(function(modifierPK) {
                var modifierModel = servicesGameDataManager.modifiersCollection.getModifier({ primaryKey: modifierPK }), localComponentSettings = {
                  iconLeft: modifierModel.icon,
                  title: servicesInternationalization.localize("Modifier"),
                  rightColumnDataValue: modifierModel.title
                };
                componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: localComponentSettings,
                  key: "building-overview-modifier-" + modifierPK
                }))
              }, this), settings.upgrade.battleAbilityWithModifiers && (sectionComponentSettings = { battleAbility: settings.upgrade.battleAbilityWithModifiers }, componentsSections.push(React.createElement(ComponentsOverviewWidgetBattleAbilityList, {
                settings: sectionComponentSettings,
                key: "building-overview-battle-ability"
              }))), upgradeBuilding.marketRateDictionary) {
        var tradingResourceId;
        for (tradingResourceId in upgradeBuilding.marketRateDictionary)upgradeBuilding.marketRateDictionary.hasOwnProperty(tradingResourceId) && (sectionComponentSettings = {
          tradeResourceId: tradingResourceId,
          ratesToOtherResources: upgradeBuilding.marketRateDictionary[tradingResourceId]
        }, componentsSections.push(React.createElement(ComponentsBuildingWidgetTradeRates, {
          settings: sectionComponentSettings,
          key: "building-overview-trading-goods-widget-" + tradingResourceId
        })))
      }
      return settings.upgrade.units && settings.upgrade.units.forEach(function(unitRecruitingObject) {
        var unitRecruitmentInHabitat = unitRecruitingObject.unitRecruitmentInHabitat;
        sectionComponentSettings = {
          iconLeft: unitRecruitingObject.unitModel.icon,
          title: unitRecruitmentInHabitat.currentAmount + " X " + unitRecruitingObject.unitModel.title,
          onClick: settings.initialComponent.handlerNextClick.bind(settings.initialComponent, {
            next: xy.dNames.game.menuUnitOverview.name,
            options: { unit: unitRecruitingObject.unitModel, building: upgradeBuilding }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "units-in-list-" + unitRecruitingObject.unitModel.primaryKey
        }))
      }, this), isLevelReached || (sectionComponentSettings = {
        constructingEntity: upgradeBuilding,
        title: servicesInternationalization.localize("Cost"),
        currentHabitat: settings.currentHabitat,
        initialComponent: settings.initialComponent,
        showMissingResources: !0
      }, componentsSections.push(React.createElement(ComponentsWidgetConstructBuildingCost, {
        settings: sectionComponentSettings,
        key: "building-overview-widget-net-level-upgrade-" + upgradeBuilding.level
      }))), React.createElement("div", { className: settings.classes }, componentsSections)
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingUpgrades.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuBuildingsUpgradesController(options) {
    MenuBuildingsUpgradesController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.allianceClashes,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuBuildingsUpgradesController, CoreControllerElementMenu), MenuBuildingsUpgradesController.prototype[xy.eNames.menuBuildingUpgrades.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuBuildingsUpgradesController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.prepareBuildingsUpgradesData({ classIdentifier: this.initialOptions.classIdentifier })
  }, MenuBuildingsUpgradesController.prototype.setLocalizationName = function(buildingClassIdentifier) {
    this.localizedName = servicesInternationalization.localize(buildingClassIdentifier + " level overview")
  }, MenuBuildingsUpgradesController
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingUpgrades.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.utils.object, xy.dNames.services.sortable, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(CoreDataSource, utilsOop, settingsGameConstant, utilsObject, servicesSortable, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuBuildingsUpgradesDataSource(options) {
    MenuBuildingsUpgradesDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingsUpgradesDataSource, CoreDataSource), MenuBuildingsUpgradesDataSource.prototype.prepareBuildingsUpgradesData = function(options) {
    var building, buildingsOfClass, buildingClassIdentifierFixed, data = { upgrades: {} }, buildingsThemeSettings = servicesTheme.themeSettings.buildings, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    buildingClassIdentifierFixed = buildingsThemeSettings.crossHabitatTypesBuildingRelations[options.classIdentifier][currentHabitat.publicHabitatType], building = servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
      habitat: currentHabitat,
      buildingClass: buildingClassIdentifierFixed
    }), this.controller.setLocalizationName(building.title), buildingsOfClass = servicesGameDataManager.buildingsCollection.getAllBuildingsOfClass({ buildingClass: building.classIdentifier });
    var buildingOfClassPK;
    for (buildingOfClassPK in buildingsOfClass)if (buildingsOfClass.hasOwnProperty(buildingOfClassPK)) {
      var abilitiesWithModifiers, buildingOfClass = buildingsOfClass[buildingOfClassPK], researches = [], missions = [], unitFactory = [];
      data.upgrades[buildingOfClassPK] = {}, buildingOfClass.knowledgeFactoryArray instanceof Array && (buildingOfClass.knowledgeFactoryArray.forEach(function(knowledgePK) {
        var modeledKnowledge = servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: knowledgePK });
        researches.push({ knowledge: modeledKnowledge })
      }), researches.sort(servicesSortable.byField("knowledge", "order")), data.upgrades[buildingOfClassPK].researches = researches), utilsObject.isEmpty(buildingOfClass.generateResourceDictionary) || (abilitiesWithModifiers = currentHabitat.applyModifiers({
        targetObject: "Building",
        generateResource: buildingOfClass.generateResourceDictionary
      }), currentHabitat.habitatBuffArray instanceof Array && currentHabitat.habitatBuffArray.length && (abilitiesWithModifiers = currentHabitat.applyBuffs({
        targetObject: "Building", generateResource: abilitiesWithModifiers.generateResource
      })), data.upgrades[buildingOfClassPK].generateResourceWithModifiers = abilitiesWithModifiers.generateResource), buildingOfClass.missionFactoryArray instanceof Array && (buildingOfClass.missionFactoryArray.forEach(function(missionPK) {
        var modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: missionPK });
        missions.push({ mission: modeledMission })
      }, this), missions.sort(servicesSortable.byField("mission", "order")), data.upgrades[buildingOfClassPK].missions = missions), utilsObject.isEmpty(buildingOfClass.battleValueDictionary) || (abilitiesWithModifiers = currentHabitat.applyModifiers({
        targetObject: "Building",
        rawData: buildingOfClass.battleValueDictionary
      }), data.upgrades[buildingOfClassPK].battleAbilityWithModifiers = abilitiesWithModifiers.battleAbility), buildingOfClass.marketDistance && buildingOfClass.unitFactoryArray instanceof Array && (buildingOfClass.unitFactoryArray.forEach(function(unitPK) {
        var modeledUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPK });
        unitFactory.push({
          unitModel: modeledUnit,
          unitRecruitmentInHabitat: currentHabitat.unitRecruitmentInHabitat(modeledUnit)
        })
      }), unitFactory.sort(servicesSortable.byField("unitModel", "order")), data.upgrades[buildingOfClassPK].units = unitFactory), data.upgrades[buildingOfClassPK].building = buildingOfClass
    }
    data.currentLevelOfBuilding = building.level, data.currentHabitat = currentHabitat, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuBuildingUpgrades.dataIsReady, data)
  }, MenuBuildingsUpgradesDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuBuildingUpgrades.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuBuildingUpgrades.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuBuildingUpgradesComponent) {
  "use strict";
  function MenuBuildingsUpgradesPresenter(options) {
    MenuBuildingsUpgradesPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuBuildingsUpgradesPresenter, CorePresenterElementMenu), MenuBuildingsUpgradesPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuBuildingUpgradesComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuBuildingsUpgradesPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuRank.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.number, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuTapBar, xy.dNames.components.menuListElementBasic, xy.dNames.components.buttonPageListing, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.inputTextFieldWithValidation, function(componentsEngine, mixinsMenuComponentHandlers, utilsNumber, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuTapBar, ComponentsMenuListElementBasic, ComponentsButtonPageListing, ComponentsMenuListTextBasic, ComponentsWidgetAllianceRelationBadge, ComponentsInputTextFieldWithValidation) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], setScrollPosition: function() {
      this.scrollToMenuElement({
        container: settingsGameConstant.COMPONENTS_REFS.RANK.CONTAINER,
        target: settingsGameConstant.COMPONENTS_REFS.RANK.TARGET
      })
    }, componentDidMount: function() {
      this.setScrollPosition()
    }, componentWillReceiveProps: function(newProps) {
      this.shouldComponentScroll = newProps.settings.currentRankType !== this.props.settings.currentRankType
    }, componentDidUpdate: function() {
      this.shouldComponentScroll && (this.shouldComponentScroll = !1, this.setScrollPosition()), this.shouldComponentScrollToTop && (this.shouldComponentScrollToTop = !1, this.scrollToTop(settingsGameConstant.COMPONENTS_REFS.RANK.CONTAINER))
    }, updateRankTypeFunction: function(options, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuRank.setNewRankType, {
        newRankType: options.rankButtonName,
        isSearchMode: options.isSearchMode
      })
    }, onChangePageClick: function(direction, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuRank.changeRankingPage, { direction: direction })
    }, onScrollToFirstPageClick: function(direction, event) {
      this.onChangePageClick(direction, event), this.shouldComponentScrollToTop = !0
    }, onSearchButtonClick: function(value, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuRank.runSearch, { newSearchString: value })
    }, render: function() {
      var listRankElementSettings, settings = {
        rankingId: null,
        searchString: "",
        ranking: null,
        mode: 0,
        currentRankType: "",
        info: null,
        rankTypes: null,
        isFirst: !0,
        isLast: !0
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [];
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var searchMode, isSearchMode = !1;
      switch (settings.mode) {
        case settingsGameConstant.RANKING_MODE.PLAYER:
          searchMode = settingsGameConstant.RANKING_MODE.PLAYER_SEARCH;
          break;
        case settingsGameConstant.RANKING_MODE.ALLIANCE:
          searchMode = settingsGameConstant.RANKING_MODE.ALLIANCE_SEARCH;
          break;
        default:
          isSearchMode = !0
      }
      var searchBar = null, tapBarSettings = { buttons: [] }, rankingIconsTheme = servicesTheme.themeSettings.imagesClassNames.ranking;
      if (settings.rankTypes && settings.rankTypes.length && settings.rankTypes.forEach(function(rankButtonName, index) {
                var localSettings = {
                  name: rankButtonName + index,
                  icon: rankingIconsTheme[rankButtonName],
                  onClick: this.updateRankTypeFunction.bind(this, {
                    rankButtonName: rankButtonName,
                    isSearchMode: isSearchMode,
                    searchMode: searchMode
                  })
                };
                settings.currentRankType === rankButtonName && (localSettings.isActive = !0), tapBarSettings.buttons.push(localSettings)
              }, this), isSearchMode) {
        var subSectionSettings = {
          classes: "menu-search-bar menu-search-bar--with-button",
          submitButton: { icon: "controls menu-search", context: this, onClick: this.onSearchButtonClick },
          value: settings.searchString || "",
          placeHolder: servicesInternationalization.localize("search"),
          removeSpaces: !0,
          validationRegExp: /.{3,}/g
        };
        searchBar = React.createElement(ComponentsInputTextFieldWithValidation, {
          settings: subSectionSettings,
          key: "search-bar"
        })
      } else titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuRank.name,
          options: {
            mode: searchMode,
            rankingId: settings.rankingId,
            currentRankType: settings.currentRankType,
            rankTypes: settings.rankTypes
          }
        }), icon: "controls menu-search"
      }, {
        icon: "controls jump-to-top-button",
        onClick: this.onScrollToFirstPageClick.bind(this, settingsGameConstant.RANKS.SCROLL_DIRECTION.FIRST_PAGE)
      });
      (!isSearchMode || isSearchMode && settings.ranking.length) && (listRankElementSettings = {
        isUp: !0,
        onClick: this.onChangePageClick.bind(this, settingsGameConstant.RANKS.SCROLL_DIRECTION.PAGE_UP)
      }, settings.isFirst && (listRankElementSettings.isDisabled = !0), componentsSections.push(React.createElement(ComponentsButtonPageListing, {
        settings: listRankElementSettings,
        key: "button-prev"
      }))), settings.info && (listRankElementSettings = { text: servicesInternationalization.localize(settings.info) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: listRankElementSettings,
        key: "server-info"
      })));
      var nameKey, menuOverviewName, initialOptionKey, addDiplomaticRelationFlag = !1;
      switch (settings.mode) {
        case settingsGameConstant.RANKING_MODE.PLAYER:
        case settingsGameConstant.RANKING_MODE.PLAYER_SEARCH:
          nameKey = "nick", menuOverviewName = xy.dNames.game.menuPlayerProfileExternal.name, initialOptionKey = "playerId";
          break;
        case settingsGameConstant.RANKING_MODE.ALLIANCE:
        case settingsGameConstant.RANKING_MODE.ALLIANCE_SEARCH:
          nameKey = "name", menuOverviewName = xy.dNames.game.menuAllianceProfile.name, initialOptionKey = "allianceId", addDiplomaticRelationFlag = !0
      }
      if (settings.ranking.length > 0)settings.ranking.forEach(function(rankEntry, index) {
        var extraClasses = "";
        +rankEntry.id === settings.rankingId && (extraClasses = "player-own-rank-entry");
        var localSettings, initialOptions = {}, name = rankEntry[nameKey] || servicesInternationalization.localize("No Alliance"), score = rankEntry.quantifier || null;
        initialOptions[initialOptionKey] = rankEntry.id;
        var settingsRankEntry = {
          classes: extraClasses,
          title: rankEntry.rank + ". " + name,
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, { next: menuOverviewName, options: initialOptions })
        };
        score && (score = utilsNumber.roundGaussian(+score), settingsRankEntry.description = servicesInternationalization.localize(settingsGameConstant.RANKING_TYPES_DESCRIPTION_NAMES[rankEntry.type], score)), rankEntry.id || (settingsRankEntry.disabled = !0), addDiplomaticRelationFlag && (localSettings = {
          allianceId: rankEntry.id,
          classes: "icon-left"
        }, settingsRankEntry.iconLeft = React.createElement(ComponentsWidgetAllianceRelationBadge, { settings: localSettings })), +rankEntry.id === settings.rankingId ? componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          ref: settingsGameConstant.COMPONENTS_REFS.RANK.TARGET,
          settings: settingsRankEntry,
          key: "entity-" + rankEntry.id + index
        })) : componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: settingsRankEntry,
          key: "entity-" + rankEntry.id + index
        }))
      }, this); else {
        var infoText = null;
        settings.info ? infoText = settings.info : isSearchMode && settings.searchString && (infoText = "You have not been ranked yet."), infoText && (listRankElementSettings = { text: servicesInternationalization.localize(infoText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: listRankElementSettings,
          key: "no-ranking"
        })))
      }
      (!isSearchMode || isSearchMode && settings.ranking.length) && (listRankElementSettings = {
        isDown: !0,
        onClick: this.onChangePageClick.bind(this, settingsGameConstant.RANKS.SCROLL_DIRECTION.PAGE_DOWN)
      }, settings.isLast && (listRankElementSettings.isDisabled = !0), componentsSections.push(React.createElement(ComponentsButtonPageListing, {
        settings: listRankElementSettings,
        key: "button-next"
      })));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        showJumpTop: !0,
        searchBar: searchBar,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.RANK.CONTAINER
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuRank.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuRankController(options) {
    MenuRankController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.rank,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Rank"), this.currentRankType = null, this.initializationCompleteFlag = !1, this.searchString = null
  }

  return utilsOop.extend(MenuRankController, CoreControllerElementMenu), MenuRankController.prototype[xy.eNames.menuRank.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuRankController.prototype[xy.eNames.menuRank.setNewRankType] = function(options) {
    this.currentRankType = options.newRankType, this.prepareDataForDraw()
  }, MenuRankController.prototype[xy.eNames.menuRank.changeRankingPage] = function(options) {
    this.dataSource.moveRankingOffsetByDirection(options), this.prepareDataForDraw()
  }, MenuRankController.prototype[xy.eNames.menuRank.runSearch] = function(options) {
    this.searchString = options.newSearchString, this.prepareDataForDraw()
  }, MenuRankController.prototype.prepareDataForDraw = function() {
    if (this.isActive)switch (this.initialOptions.mode) {
      case settingsGameConstant.RANKING_MODE.PLAYER:
      case settingsGameConstant.RANKING_MODE.ALLIANCE:
        this.initializationCompleteFlag || (this.currentRankType = this.initialOptions.rankTypes ? this.initialOptions.rankTypes[0] : [], this.dataSource.setRankingInitialValues({
          rankingId: this.initialOptions.rankingId || null,
          row: this.initialOptions.row,
          rankTypes: this.initialOptions.rankTypes,
          rankingMode: this.initialOptions.mode
        }), this.initializationCompleteFlag = !0), this.dataSource.getRanksListData({ currentRankType: this.currentRankType });
        break;
      case settingsGameConstant.RANKING_MODE.PLAYER_SEARCH:
      case settingsGameConstant.RANKING_MODE.ALLIANCE_SEARCH:
        this.initializationCompleteFlag || (this.currentRankType = this.initialOptions.currentRankType, this.dataSource.setSearchingInitialValues({
          rankingId: this.initialOptions.rankingId || null,
          searchingMode: this.initialOptions.mode,
          rankTypes: this.initialOptions.rankTypes
        }), this.localizedName = servicesInternationalization.localize("search"), this.initializationCompleteFlag = !0), this.dataSource.getSearchListData({
          searchString: this.searchString,
          currentRankType: this.currentRankType
        })
    }
  }, MenuRankController
}]), xy.dStaticInjector.set(xy.dNames.game.menuRank.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.log, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesLog) {
  "use strict";
  function MenuRankDataSource(options) {
    MenuRankDataSource.__super__.constructor.call(this, options), this.searchMode = !1, this.searchString = "", this.mode = null, this.rankingId = null, this.rankTypes = []
  }

  return utilsOop.extend(MenuRankDataSource, CoreDataSource), MenuRankDataSource.prototype.setRankingInitialValues = function(options) {
    this.rankingId = options.rankingId, this.rankTypes = options.rankTypes, this.mode = options.rankingMode, this.offset = {}, options.rankTypes.forEach(function(rankTypeName) {
      this.offset[rankTypeName] = -1
    }, this)
  }, MenuRankDataSource.prototype.setSearchingInitialValues = function(options) {
    this.rankingId = options.rankingId, this.rankTypes = options.rankTypes, this.mode = options.searchingMode, this.searchMode = !0, this.offset = {}
  }, MenuRankDataSource.prototype.moveRankingOffsetByDirection = function(options) {
    var currentOffset = this.offset[this.currentRankType], pageSize = settingsGameConstant.RANKS.REQUEST_SIZE;
    options.direction === settingsGameConstant.RANKS.SCROLL_DIRECTION.FIRST_PAGE ? currentOffset = 0 : currentOffset > -1 && options.direction && (currentOffset += pageSize * options.direction), currentOffset > -1 && (this.offset[this.currentRankType] = currentOffset)
  }, MenuRankDataSource.prototype.getSearchListData = function(options) {
    var url, params = {}, pageSize = settingsGameConstant.RANKS.REQUEST_SIZE;
    switch (this.searchString = options.searchString || "", this.mode) {
      case settingsGameConstant.RANKING_MODE.PLAYER_SEARCH:
        url = "QueryAction/playerRanks", this.currentRankType = "playerSearch" + options.currentRankType, this.tabCurrentRankType = options.currentRankType, this.searchString && (params.nick = this.searchString);
        break;
      case settingsGameConstant.RANKING_MODE.ALLIANCE_SEARCH:
        url = "QueryAction/allianceRanks", this.currentRankType = "allianceSearch" + options.currentRankType, this.tabCurrentRankType = options.currentRankType, this.searchString && (params.name = this.searchString);
        break;
      default:
        return void servicesLog("warn", "you try to retrieve search table of unknown mode")
    }
    if (this.offset[this.currentRankType] || (this.offset[this.currentRankType] = 0), options.searchString) {
      var offset = this.offset[this.currentRankType], rankingList = servicesGameDataManager.rankingCollection.getCachedPage({
        currentsSubjectType: options.searchString,
        currentRankType: this.currentRankType,
        offset: offset
      });
      if (rankingList)return void this.prepareDataToShow(rankingList);
      params.type = "(" + options.currentRankType + ")", params.offset = offset, params.limit = pageSize, params.sortBy = "(row.asc)", this.request(params, url, { callBack: this.prepareRankData })
    } else this.prepareDataToShow([], {})
  }, MenuRankDataSource.prototype.getRanksListData = function(options) {
    var url, subjectType, params = {}, pageSize = settingsGameConstant.RANKS.REQUEST_SIZE;
    switch (this.mode) {
      case settingsGameConstant.RANKING_MODE.PLAYER:
        url = "QueryAction/playerRanks", subjectType = "player", this.offset[options.currentRankType] > -1 ? params.offset = this.offset[this.currentRankType] : this.rankingId && (params.centerOnPageContainingPlayerId = this.rankingId);
        break;
      case settingsGameConstant.RANKING_MODE.ALLIANCE:
        url = "QueryAction/allianceRanks", subjectType = "alliance", this.offset[options.currentRankType] > -1 ? params.offset = this.offset[this.currentRankType] : this.rankingId && (params.centerOnPageContainingAllianceId = this.rankingId);
        break;
      default:
        return void servicesLog("warn", "you try to retrieve rank table of unknown mode")
    }
    this.tabCurrentRankType = options.currentRankType, this.currentRankType = options.currentRankType, this.currentsubjectType = subjectType;
    var rankingList = servicesGameDataManager.rankingCollection.getCachedPage({
      currentsSubjectType: this.currentsubjectType,
      currentRankType: this.currentRankType,
      offset: this.offset[options.currentRankType]
    });
    return rankingList ? void this.prepareDataToShow(rankingList) : (params.limit = pageSize, params.type = "(" + options.currentRankType + ")", params.sortBy = "(row.asc)", void this.request(params, url, { callBack: this.prepareRankData }))
  }, MenuRankDataSource.prototype.prepareRankData = function(rankData) {
    var rankingList, data, syncUpdated = !1, realOffset = 0;
    if (rankData.allianceRanks instanceof Array ? data = rankData.allianceRanks : rankData.playerRanks instanceof Array && (data = rankData.playerRanks), data instanceof Array) {
      var dataParam;
      this.searchMode ? dataParam = {
        currentsSubjectType: this.searchString,
        currentRankType: this.currentRankType,
        offset: this.offset[this.currentRankType]
      } : (realOffset = data[0] ? data[0].row - 1 : this.offset[this.currentRankType], this.offset[this.currentRankType] = realOffset, dataParam = {
        currentsSubjectType: this.currentsubjectType,
        currentRankType: this.currentRankType,
        offset: realOffset
      }), syncUpdated = servicesGameDataManager.rankingCollection.updateCache(data, dataParam), syncUpdated && (rankingList = servicesGameDataManager.rankingCollection.getCachedPage(dataParam), this.prepareDataToShow(rankingList, { info: rankData.info }))
    }
  }, MenuRankDataSource.prototype.prepareDataToShow = function(rankingList, options) {
    options = options || {}, rankingList = rankingList || [], this.notify(xy.eNames.menuRank.dataIsReady, {
      mode: this.mode,
      rankingId: this.rankingId,
      currentRankType: this.tabCurrentRankType,
      rankTypes: this.rankTypes,
      ranking: rankingList,
      searchString: this.searchString,
      info: options.info || null,
      isFirst: 0 === this.offset[this.currentRankType],
      isLast: rankingList.length < settingsGameConstant.RANKS.REQUEST_SIZE
    })
  }, MenuRankDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuRank.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuRank.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuPlayerRankComponent) {
  "use strict";
  function MenuRankPresenter(options) {
    MenuRankPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuRankPresenter, CorePresenterElementMenu), MenuRankPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuPlayerRankComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuRankPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuRankModeChooser.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuTapBar, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = {
        rankingMode: settingsGameConstant.RANKING_MODE.PLAYER,
        rankingId: 0,
        categories: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var componentsSections = [], themeHabitatRankingIcons = servicesTheme.themeSettings.imagesClassNames.ranking;
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.categories.forEach(function(rankingCategoryObject) {
        var localComponentSettings = {
          title: servicesInternationalization.localize(settingsGameConstant.RANKING_CATEGORIES_NAMES[rankingCategoryObject.name]),
          rightColumnDataValue: rankingCategoryObject.quantifier,
          iconLeft: themeHabitatRankingIcons[rankingCategoryObject.name],
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuRank.name,
            options: {
              rankingId: settings.rankingId,
              mode: settings.rankingMode,
              row: rankingCategoryObject.row,
              rankTypes: rankingCategoryObject.rankTypes
            }
          })
        };
        rankingCategoryObject.rank && (localComponentSettings.description = servicesInternationalization.localize("Position: %ld", rankingCategoryObject.rank)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "rank-category-in-list-" + rankingCategoryObject.name
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuRankModeChooser.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuRankModeChooserController(options) {
    MenuRankModeChooserController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.rank,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Ranking selection")
  }

  return utilsOop.extend(MenuRankModeChooserController, CoreControllerElementMenu), MenuRankModeChooserController.prototype[xy.eNames.menuRankModeChooser.dataIsReady] = function(data) {
    this.isActive && (data.rankingId = this.initialOptions.rankingId, data.rankingMode = this.initialOptions.rankingMode, this.presenter.draw(data))
  }, MenuRankModeChooserController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.prepareRankCategories({
      rankingId: this.initialOptions.rankingId,
      rankingMode: this.initialOptions.rankingMode
    })
  }, MenuRankModeChooserController
}]), xy.dStaticInjector.set(xy.dNames.game.menuRankModeChooser.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuRankModeChooserDataSource(options) {
    MenuRankModeChooserDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuRankModeChooserDataSource, CoreDataSource), MenuRankModeChooserDataSource.prototype.prepareRankCategories = function(options) {
    switch (options.rankingMode) {
      case settingsGameConstant.RANKING_MODE.PLAYER:
        this.preparePlayersRankCategory(options);
        break;
      case settingsGameConstant.RANKING_MODE.ALLIANCE:
        this.prepareAllianceRankCategory(options)
    }
  }, MenuRankModeChooserDataSource.prototype.preparePlayersRankCategory = function(options) {
    var cachedCategories, param = { subjectType: "player", subjectId: options.rankingId };
    return this.currentsSubjectType = "player", this.currentsSubjectId = options.rankingId, (cachedCategories = servicesGameDataManager.rankingCollection.getCategoricalCache({
      currentsSubjectType: this.currentsSubjectType,
      subjectId: this.currentsSubjectId
    })) ? void this.notify(xy.eNames.menuRankModeChooser.dataIsReady, { categories: cachedCategories }) : void this.request(param, "QueryAction/rankCategories", { callBack: this.handleRankResponse })
  }, MenuRankModeChooserDataSource.prototype.prepareAllianceRankCategory = function(options) {
    var cachedCategories, param = { subjectType: "alliance" };
    return this.currentsSubjectId = null, this.currentsSubjectType = null, this.currentsSubjectType = "alliance", options.rankingId && (this.currentsSubjectId = options.rankingId, param.subjectId = options.rankingId), (cachedCategories = servicesGameDataManager.rankingCollection.getCategoricalCache({
      currentsSubjectType: this.currentsSubjectType,
      subjectId: this.currentsSubjectId
    })) ? void this.notify(xy.eNames.menuRankModeChooser.dataIsReady, { categories: cachedCategories }) : void this.request(param, "QueryAction/rankCategories", { callBack: this.handleRankResponse })
  }, MenuRankModeChooserDataSource.prototype.handleRankResponse = function(data) {
    var categories, sync;
    sync = servicesGameDataManager.rankingCollection.updateCategoricalCache(data.rankCategories, {
      currentsSubjectType: this.currentsSubjectType,
      subjectId: this.currentsSubjectId
    }), sync && (categories = servicesGameDataManager.rankingCollection.getCategoricalCache({
      currentsSubjectType: this.currentsSubjectType,
      subjectId: this.currentsSubjectId
    })), this.notify(xy.eNames.menuRankModeChooser.dataIsReady, { categories: categories })
  }, MenuRankModeChooserDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuRankModeChooser.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuRankModeChooser.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuRankModeChooserComponent) {
  "use strict";
  function MenuRankModeChooserPresenter(options) {
    MenuRankModeChooserPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuRankModeChooserPresenter, CorePresenterElementMenu), MenuRankModeChooserPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuRankModeChooserComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuRankModeChooserPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuPlayersList.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuSearchBarHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.utils.object, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuSearchBar, xy.dNames.components.menuTapBar, xy.dNames.components.menuBottomBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers, settingsGameConstant, servicesTheme, servicesGameDataManager, servicesInternationalization, utilsObject, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuSearchBar, ComponentsMenuTapBar, ComponentsMenuBottomBarMain, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    selectedRecipients: {},
    initializationFlag: !0,
    mixins: [mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers],
    getInitialState: function() {
      return this.selectedRecipients = {}, { selectedAll: !0, searchQueryString: "", showIcon: !0 }
    },
    componentWillUpdate: function(newProps, newState) {
      var filterString = newState.searchQueryString.toLowerCase(), playersList = newProps.settings.playersList;
      if (newState.searchQueryString && (newState.searchQueryString !== this.state.searchQueryString || newProps.settings.mode !== this.props.settings.mode)) {
        playersList = this.filterPlayersList(playersList, filterString);
        var id;
        for (id in this.selectedRecipients)this.selectedRecipients.hasOwnProperty(id) && (this.selectedRecipients[id] = !1);
        utilsObject.effectiveLength(playersList) && playersList.forEach(function(player) {
          this.selectedRecipients[player.id] = player
        }, this)
      }
    },
    setSortingFunction: function(newSortingFunction, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuPlayersList.setSortingFunction, { newSortingFunction: newSortingFunction })
    },
    onDisableAllClick: function(event) {
      event.preventDefault();
      var id;
      for (id in this.selectedRecipients)this.selectedRecipients.hasOwnProperty(id) && (this.selectedRecipients[id] = !1);
      this.setState({ selectedAll: !1 }, null)
    },
    onSelectAllClick: function(event) {
      event.preventDefault();
      var playersList = this.props.settings.playersList;
      this.state.searchQueryString.length && (playersList = this.filterPlayersList(playersList)), playersList.forEach(function(player) {
        this.selectedRecipients[player.id] = player
      }, this), this.setState({ selectedAll: !0 }, null)
    },
    onCheckboxClick: function(player, event) {
      event.preventDefault(), event.stopPropagation(), this.selectedRecipients[player.id] ? this.selectedRecipients[player.id] = !1 : this.selectedRecipients[player.id] = player;
      var selectedAll = utilsObject.effectiveLength(this.selectedRecipients) === this.props.settings.playersList.length;
      this.setState({ selectedAll: selectedAll }, null)
    },
    onAddRecipientsClick: function() {
      this.props.presenter.notify(xy.eNames.menuMessagesThread.addRecipients, {
        message: this.props.settings.message,
        recipients: this.selectedRecipients
      })
    },
    onWriteMessageClick: function(event) {
      this.handlerNextClick({
        next: xy.dNames.game.menuMessagesNew.name,
        options: { recipients: this.selectedRecipients, mode: settingsGameConstant.NEW_MESSAGE_MODE.CREATE }
      }, event)
    },
    filterPlayersList: function(playersList, filterString) {
      return filterString = filterString || this.state.searchQueryString.toLowerCase(), playersList.filter(function(h) {
        return !!~h.nick.toLowerCase().indexOf(filterString)
      })
    },
    onDeleteSelectedPlayersClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuMessagesThread.deleteRecipients, {
        message: this.props.settings.message,
        recipients: this.selectedRecipients
      })
    },
    onDeleteAllPlayersClick: function(selectedRecipients, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuMessagesThread.deleteAllRecipients, {
        message: this.props.settings.message,
        recipients: selectedRecipients
      })
    },
    render: function() {
      var themeIconsSettings = servicesTheme.themeSettings.imagesClassNames, settings = {
        playersList: [],
        listOfIds: [],
        currentSortingFunction: settingsGameConstant.SORTING_PLAYERS_FUNCTION.POINTS,
        mode: settingsGameConstant.PLAYERS_LIST_MODE.SIMPLE,
        isSendMassMailButtonAvailable: !1,
        canPLayerManageMassMails: !1,
        allianceId: 0,
        message: null,
        ownPlayerId: 0
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle }, bottomBarSection = null;
      if (Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot)titleSettings.leftButton = !0, titleSettings.leftButtonIcon = themeIconsSettings.controls.close, titleSettings.leftButtonOnClick = this.handlerCloseButtonClick; else {
        switch (titleSettings.leftButton = !0,
                settings.mode) {
          case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_COMPOSE:
          case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_ADD_RECIPIENTS:
          case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_DELETE_RECIPIENTS:
            titleSettings.leftButtonTitle = servicesInternationalization.localize("Back");
            break;
          case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_OVERVIEW_RECIPIENTS:
            titleSettings.leftButtonTitle = servicesInternationalization.localize("Back"), titleSettings.rightButton = [], settings.canPLayerManageMassMails && titleSettings.rightButton.push({
              icon: themeIconsSettings.controls.edit,
              onClick: this.handlerNextClick.bind(this, {
                next: xy.dNames.game.menuPlayersList.name,
                options: {
                  playersList: settings.listOfIds,
                  mode: settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_DELETE_RECIPIENTS,
                  message: settings.message
                }
              })
            });
            break;
          default:
            titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle
        }
        titleSettings.leftButtonOnClick = this.handlerPrevClick
      }
      var searchBarSettings = {
        value: this.state.searchQueryString,
        onChange: this.updateSearchQuery,
        onFocus: this.onSearchFieldFocus,
        onBlur: this.onSearchFieldBlur
      };
      this.state.showIcon && (searchBarSettings.iconLeft = "controls menu-search");
      var tapBarSettings = { buttons: [] };
      settingsGameConstant.SORTING_PLAYERS_FUNCTION_ORDER.forEach(function(functionKey) {
        if (settingsGameConstant.SORTING_PLAYERS_FUNCTION.hasOwnProperty(functionKey)) {
          var value = settingsGameConstant.SORTING_PLAYERS_FUNCTION[functionKey];
          tapBarSettings.buttons.push({
            isActive: value === settings.currentSortingFunction,
            onClick: this.setSortingFunction.bind(this, value),
            title: servicesInternationalization.localize(value)
          })
        }
      }, this);
      var sectionComponentSettings, componentsSections = [], playerSections = [], isSelectingMode = !1, selectedAmount = 0;
      switch (this.state.searchQueryString.length && (settings.playersList = this.filterPlayersList(settings.playersList)), settings.mode) {
        case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_COMPOSE:
        case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_ADD_RECIPIENTS:
        case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_DELETE_RECIPIENTS:
          isSelectingMode = !0
      }
      if (settings.isSendMassMailButtonAvailable && (sectionComponentSettings = {
                disabled: settings.listOfIds.length < 1 || !utilsObject.effectiveLength(settings.playersList),
                iconLeft: "icon-game icon-ButtonMessages",
                title: servicesInternationalization.localize("Send mass mail"),
                onClick: this.handlerNextClick.bind(this, {
                  next: xy.dNames.game.menuPlayersList.name,
                  options: {
                    playersList: settings.listOfIds,
                    mode: settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_COMPOSE,
                    allianceId: settings.allianceId
                  }
                })
              }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
                settings: sectionComponentSettings,
                key: "menu-button-go-to-mass-mail"
              }))), console.log(settings), settings.playersList.forEach(function(player) {
                var settingsEntry, permissionIconId = player.alliancePermission ? servicesGameDataManager.playersCollection.getHighestPriorityAlliancePermission(player.alliancePermission) : 0;
                settingsEntry = {
                  iconLeft: "icon-permission permission-" + permissionIconId,
                  title: player.nick,
                  description: servicesInternationalization.localize("%d Points", player.points),
                  onClick: this.handlerNextClick.bind(this, {
                    next: xy.dNames.game.menuPlayerProfileExternal.name,
                    options: { playerId: player.id }
                  }),
                  iconRight: themeIconsSettings.controls.next
                }, settings.ownPlayerId === player.id && (settingsEntry.classes = "good-title"), isSelectingMode && (settingsEntry.isSelectable = !0, settingsEntry.onSelect = this.onCheckboxClick.bind(this, player), this.initializationFlag ? (settingsEntry.isSelected = !0, this.selectedRecipients[player.id] = player) : this.selectedRecipients[player.id] && (selectedAmount += 1, settingsEntry.isSelected = !0)), playerSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: settingsEntry,
                  key: "external-player-" + player.id
                }))
              }, this), settings.canPLayerManageMassMails)switch (settings.mode) {
        case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_COMPOSE:
          sectionComponentSettings = {
            disabled: utilsObject.effectiveLength(this.selectedRecipients) < 1,
            iconLeft: "icon-game icon-ButtonMessages",
            title: servicesInternationalization.localize("Write Message"),
            onClick: this.onWriteMessageClick
          }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
            settings: sectionComponentSettings,
            key: "menu-button-go-to-new-mail"
          }));
          break;
        case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_ADD_RECIPIENTS:
          sectionComponentSettings = {
            disabled: utilsObject.effectiveLength(this.selectedRecipients) < 1,
            iconLeft: "icon-game icon-AddMemberDiscussion",
            title: servicesInternationalization.localize("Add recipient"),
            onClick: this.onAddRecipientsClick
          }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
            settings: sectionComponentSettings,
            key: "menu-button-add-new-recipients"
          }));
          break;
        case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_DELETE_RECIPIENTS:
          var playersList = settings.playersList, selectAllPlayerObject = {};
          this.state.searchQueryString.length && (playersList = this.filterPlayersList(playersList)), playersList.forEach(function(player) {
            selectAllPlayerObject[player.id] = player
          }, this);
          var bottomBarSectionSettings = {
            leftButton: {
              onClick: this.onDeleteSelectedPlayersClick,
              title: servicesInternationalization.localize("Remove participants (%1$ld)", selectedAmount),
              isDisabled: selectedAmount < 1
            },
            rightButton: {
              onClick: this.onDeleteAllPlayersClick.bind(this, selectAllPlayerObject),
              icon: themeIconsSettings.controls.delete
            }
          };
          bottomBarSection = React.createElement(ComponentsMenuBottomBarMain, { settings: bottomBarSectionSettings })
      }
      isSelectingMode && (this.initializationFlag = !1, sectionComponentSettings = utilsObject.effectiveLength(this.selectedRecipients) === settings.playersList.length ? {
        title: servicesInternationalization.localize("Remove All Markers"),
        disabled: utilsObject.effectiveLength(settings.playersList) < 1,
        onClick: this.onDisableAllClick
      } : {
        title: servicesInternationalization.localize("Select All"),
        disabled: utilsObject.effectiveLength(settings.playersList) < 1,
        onClick: this.onSelectAllClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-select-deselect"
      }))), componentsSections = componentsSections.concat(playerSections);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: React.createElement(ComponentsMenuSearchBar, { settings: searchBarSettings }),
        bottomBar: bottomBarSection,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        key: "player-list-mode-" + settings.mode
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuPlayersList.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuPLayersListController(options) {
    MenuPLayersListController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Members"), this.currentSortingFunction = settingsGameConstant.SORTING_PLAYERS_FUNCTION.POINTS, this.currentMode = settingsGameConstant.PLAYERS_LIST_MODE.SIMPLE
  }

  return utilsOop.extend(MenuPLayersListController, CoreControllerElementMenu), MenuPLayersListController.prototype[xy.eNames.menuPlayersList.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuPLayersListController.prototype[xy.eNames.menuPlayersList.setSortingFunction] = function(data) {
    this.currentSortingFunction = data.newSortingFunction, this.prepareDataForDraw()
  }, MenuPLayersListController.prototype.prepareDataForDraw = function() {
    this.initialOptions.mode && (this.currentMode = this.initialOptions.mode), this.isActive && (this.initialOptions.customLocalizedTitle && (this.localizedName = this.initialOptions.customLocalizedTitle), this.dataSource.prepareDataForPlayerList({
      allianceId: this.initialOptions.allianceId || null,
      message: this.initialOptions.message || null,
      list: this.initialOptions.playersList,
      sortingFunction: this.currentSortingFunction,
      mode: this.currentMode
    }))
  }, MenuPLayersListController
}]), xy.dStaticInjector.set(xy.dNames.game.menuPlayersList.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesSortable) {
  "use strict";
  function MenuPLayersListDataSource(options) {
    MenuPLayersListDataSource.__super__.constructor.call(this, options);
    var MenuPlayerProfileExternalDataSource = gameInstance.injector.get(xy.dNames.game.menuPlayerProfileExternal.dataSource);
    this.forLinking = [{
      resourceClass: MenuPlayerProfileExternalDataSource,
      methodName: "requestPlayerInformation"
    }, { resourceClass: MenuPlayerProfileExternalDataSource, methodName: "receivePlayerInformation" }]
  }

  return utilsOop.extend(MenuPLayersListDataSource, CoreDataSource), MenuPLayersListDataSource.prototype.prepareDataForPlayerList = function(options) {
    options && (this.options = options);
    var unknownPLayers = servicesGameDataManager.playersCollection.getUnknownPlayersInList(this.options.list);
    if (unknownPLayers.length)return void this.requestPlayerInformation({ playerId: unknownPLayers[0] });
    var playersList, result = {}, player = servicesGameDataManager.playersCollection.getPlayer(), playerCanMassMail = player.canMassMail(), localOptions = this.options, excludePlayerFromMassMailOperationFlag = !1, isSendMassMailButtonAvailable = !1;
    switch (localOptions.mode) {
      case settingsGameConstant.PLAYERS_LIST_MODE.ALLIANCE_MEMBERS_LIST:
        isSendMassMailButtonAvailable = playerCanMassMail && localOptions.allianceId === servicesGameDataManager.getAllianceId();
        break;
      case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_COMPOSE:
      case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_ADD_RECIPIENTS:
        excludePlayerFromMassMailOperationFlag = !0;
        break;
      case settingsGameConstant.PLAYERS_LIST_MODE.MASS_MAIL_DELETE_RECIPIENTS:
        excludePlayerFromMassMailOperationFlag = !1
    }
    switch (playersList = servicesGameDataManager.playersCollection.getPlayersListData(this.options.list, { excludePLayer: excludePlayerFromMassMailOperationFlag }), result.allianceId = localOptions.allianceId || null, result.listOfIds = localOptions.list, result.currentSortingFunction = localOptions.sortingFunction, result.mode = localOptions.mode, result.isSendMassMailButtonAvailable = isSendMassMailButtonAvailable, result.canPLayerManageMassMails = playerCanMassMail, result.message = options.message, result.ownPlayerId = servicesGameDataManager.getPlayerId(), localOptions.sortingFunction) {
      case settingsGameConstant.SORTING_PLAYERS_FUNCTION.POINTS:
        playersList.sort(servicesSortable.player({ field: "points", isDESC: !0 }));
        break;
      case settingsGameConstant.SORTING_PLAYERS_FUNCTION.ALPHABET:
        playersList.sort(servicesSortable.player({ field: "nick" }));
        break;
      case settingsGameConstant.SORTING_PLAYERS_FUNCTION.RIGHTS:
        playersList.sort(servicesSortable.player({ field: "alliancePermission", isDESC: !0 }))
    }
    result.playersList = playersList, this.notify(xy.eNames.menuPlayersList.dataIsReady, result)
  }, MenuPLayersListDataSource.prototype.onPlayerInformationUpdated = function() {
    this.prepareDataForPlayerList()
  }, MenuPLayersListDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuPlayersList.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuPlayersList.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuPlayersListComponent) {
  "use strict";
  function MenuPLayersListPresenter(options) {
    MenuPLayersListPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuPLayersListPresenter, CorePresenterElementMenu), MenuPLayersListPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuPlayersListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuPLayersListPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuEvent.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.widgetHabitatOverview, xy.dNames.components.menuListTextBasic, xy.dNames.game.menuEvent.componentListEntry, function(componentsEngine, mixinsMenuComponentHandlers, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsWidgetHabitatOverview, ComponentsMenuListTextBasic, ComponentsMenuEventListEntry) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    handlerShowEventClick: function(gameEvent, event) {
      event.preventDefault(), gameEvent.isDemo = !0, this.props.presenter.notify(xy.eNames.popUpEvent.popUp, gameEvent)
    },
    setHabitatAsRewarded: function(id) {
      this.props.presenter.notify(xy.eNames.menuEvent.onSetRewardedHabitat, id)
    },
    render: function() {
      var habitatOverviewSettings, habitatOverviewWarningSettings, listTitleSettings, settings = {
        currentRewardedHabitat: null,
        world: [],
        task: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [];
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var tasksLength = settings.task.length, worldLength = settings.world.length;
      tasksLength || worldLength ? (settings.currentRewardedHabitat && (habitatOverviewSettings = {
        habitat: settings.currentRewardedHabitat,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuHabitatsList.name,
          options: {
            currentHabitatId: settings.currentRewardedHabitat.id,
            onMenuClickEvent: "close",
            onHabitatMenuEvent: this.setHabitatAsRewarded
          }
        })
      }, habitatOverviewWarningSettings = { text: servicesInternationalization.localize("TaskEventInfoText") }, componentsSections.push(React.createElement(ComponentsWidgetHabitatOverview, {
        settings: habitatOverviewSettings,
        key: "reward-habitat"
      })), componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: habitatOverviewWarningSettings,
        key: "reward-habitat-warning"
      }))), worldLength && (listTitleSettings = { title: servicesInternationalization.localize("Events") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: listTitleSettings,
        key: "task-title"
      }))), settings.world.forEach(function(event) {
        var settingsEventEntry = {
          event: event,
          currentRewardedHabitat: settings.currentRewardedHabitat,
          initialComponent: this
        };
        componentsSections.push(React.createElement(ComponentsMenuEventListEntry, { settings: settingsEventEntry }))
      }, this), tasksLength && (listTitleSettings = { title: servicesInternationalization.localize("Quests") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: listTitleSettings,
        key: "quest-title"
      }))), settings.task.forEach(function(event) {
        var settingsEventEntry = {
          event: event,
          currentRewardedHabitat: settings.currentRewardedHabitat,
          initialComponent: this
        };
        componentsSections.push(React.createElement(ComponentsMenuEventListEntry, { settings: settingsEventEntry }))
      }, this)) : (listTitleSettings = { text: servicesInternationalization.localize("No events available currently") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: listTitleSettings,
        key: "menu-text-no-events"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuEvent.componentListEntry, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentTimer, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.components.menuListElementBasic, xy.dNames.components.icon, function(componentsEngine, mixinsMenuComponentTimer, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesLog, servicesTheme, servicesGameDataManager, ComponentsMenuListElementBasic, ComponentsIcon) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentTimer], constructState: function(props) {
      var remainTimeString, timer = !1;
      if (!props.settings.event.playerDeadline)return {};
      try {
        utilsDateTime.remainTimeInSeconds(props.settings.event.playerDeadline) > 0 && (timer = props.settings.event.playerDeadline, remainTimeString = utilsDateTime.remainTime(timer, !0))
      } catch (eX) {
        servicesLog("warn", "Event timer error"), servicesLog("log", eX)
      }
      return this.countDownTimer && clearTimeout(this.countDownTimer), timer && (this.countDownTimer = setTimeout(this.tick, settingsGameConstant.COUNTDOWN_TIMER)), {
        timer: timer,
        remainTimeString: remainTimeString
      }
    }, render: function() {
      var settings = { event: {}, currentRewardedHabitat: {}, initialComponent: {} };
      Object.assign(settings, this.props.settings);
      var unit, unitPk, freeSpaceForResource, reward, warningIcon, title, event = settings.event, originalThis = settings.initialComponent, themeSettings = servicesTheme.themeSettings, humanResourceId = themeSettings.resources.humanResourceId, eventRewardsThemeSettings = themeSettings.eventRewards, classes = "", notEnoughSpace = !1, multiplier = 1;
      if (event.success)for (reward in event.rewards)event.rewards.hasOwnProperty(reward) && eventRewardsThemeSettings.resourceId[reward] && (freeSpaceForResource = settings.currentRewardedHabitat.getFreeSpaceForResource({ resourceId: eventRewardsThemeSettings.resourceId[reward] }), eventRewardsThemeSettings.resourceId[reward] === humanResourceId && (unitPk = eventRewardsThemeSettings.unitId[reward], unit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPk }), multiplier = unit.volumeAmount), event.rewards[reward] * multiplier > freeSpaceForResource && (notEnoughSpace = !0));
      notEnoughSpace ? (classes = "color-red", warningIcon = React.createElement(ComponentsIcon, { settings: { icon: "controls warning-sign" } }), title = React.createElement("div", { className: "menu-title-with-warning-icon" }, warningIcon, event.clientInfo.title)) : title = event.clientInfo.title;
      var settingsEventEntry = {
        title: title,
        description: this.state.remainTimeString && event.playerDeadlineCountDown ? event.totalDone + " " + event.clientInfo.onProgressLocKey + " - " + this.state.remainTimeString : [event.totalDone, event.clientInfo.onProgressLocKey].join(" "),
        classes: classes,
        iconLeft: "event-list " + event.type,
        iconRight: event.success ? "event-list success" : null,
        onClick: originalThis.handlerShowEventClick.bind(originalThis, event)
      };
      return React.createElement(ComponentsMenuListElementBasic, {
        settings: settingsEventEntry,
        key: "event-" + event.id
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuEvent.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuEventController(options) {
    MenuEventController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Event List")
  }

  return utilsOop.extend(MenuEventController, CoreControllerElementMenu), MenuEventController.prototype[xy.eNames.menuEvent.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuEventController.prototype[xy.eNames.menuEvent.onSetRewardedHabitat] = function(id) {
    this.dataSource.setNewRewardedHabitat(id)
  }, MenuEventController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getEventsListData()
  }, MenuEventController
}]), xy.dStaticInjector.set(xy.dNames.game.menuEvent.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, utilsDateTime, servicesGameDataManager) {
  "use strict";
  function MenuEventDataSource(options) {
    MenuEventDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuEventDataSource, CoreDataSource), MenuEventDataSource.prototype.setNewRewardedHabitat = function(id) {
    servicesGameDataManager.eventsCollection.setRewardedHabitatId(id)
  }, MenuEventDataSource.prototype.getEventsListData = function() {
    var rewardedHabitatId, rewardedHabitat, rawEvents = servicesGameDataManager.getTrackingEvents(), events = {
      world: [],
      task: [],
      tutorial: [],
      info: []
    }, now = new Date;
    rawEvents.forEach(function(event) {
      if (!event.playerDeadline || (event.playerDeadlineCountDown = event.playerDeadline - now > 0 && utilsDateTime.secondsToTimeString(utilsDateTime.remainTimeInSeconds(event.playerDeadline)), event.playerDeadlineCountDown || event.success === !0)) {
        var completionCount, completionLimit, lastIndex, requiredValue, requiredIdentifier, currentValue;
        completionCount = event.completionCount ? +event.completionCount : 0, completionLimit = +event.completionLimit, event.conditions.length && (lastIndex = event.conditions.length - 1, requiredValue = +event.conditions[lastIndex].value, requiredIdentifier = event.conditions[lastIndex].identifier, currentValue = event.remainingConditions[requiredIdentifier]), "world" === event.type && void 0 !== currentValue ? event.totalDone = completionLimit - completionCount > 0 ? completionCount * requiredValue + currentValue : currentValue + "/" + requiredValue : "task" === event.type && void 0 !== currentValue ? event.totalDone = currentValue + "/" + requiredValue : "info" === event.type ? event.totalDone = !1 : event.success ? event.totalDone = requiredValue + "/" + requiredValue : event.totalDone = !1, events[event.type].push(event)
      }
    }), rewardedHabitatId = servicesGameDataManager.eventsCollection.getRewardedHabitatId(), rewardedHabitat = servicesGameDataManager.habitatsCollection.getHabitat(rewardedHabitatId), events.currentRewardedHabitat = rewardedHabitat, this.notify(xy.eNames.menuEvent.dataIsReady, events)
  }, MenuEventDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuEvent.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuEvent.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuEventComponent) {
  "use strict";
  function MenuEventPresenter(options) {
    MenuEventPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuEventPresenter, CorePresenterElementMenu), MenuEventPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuEventComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuEventPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatsList.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuSearchBarHandlers, xy.dNames.settings.gameConstant, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuTapBar, xy.dNames.components.menuSearchBar, xy.dNames.components.widgetHabitatOverview, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers, settingsGameConstant, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuTapBar, ComponentsMenuSearchBar, ComponentsWidgetHabitatOverview) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuSearchBarHandlers],
    onChildRender: function() {
    },
    checkCompleteLoading: function() {
    },
    getInitialState: function() {
      return this.childrenAmountTotal = 0, this.childrenAmountRendered = 0, this.renderIndex = 0, {
        searchQueryString: "",
        showIcon: !0
      }
    },
    updateSortingFunction: function(btnName, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatsList.onResortHabitat, btnName)
    },
    updateSortingDirection: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatsList.onChangeSortingDirection)
    },
    handlerOnHabitatClick: function(habitat, event) {
      switch (event.preventDefault(), this.props.settings.onMenuClickEvent) {
        case"close":
          this.handlerTitleLeftButtonClick();
          break;
        default:
          this.props.presenter.notify(xy.eNames.sceneGame.onPickHabitatFromHabitatList, { habitatId: habitat.id })
      }
      "function" == typeof this.props.settings.onHabitatMenuEvent && this.props.settings.onHabitatMenuEvent(habitat.id)
    },
    render: function() {
      this.renderIndex += 1;
      var habitatSettings, filterString = this.state.searchQueryString.toLowerCase(), settings = {
        currentHabitatId: null,
        summaryHabitat: null,
        habitatsList: [],
        sortingButtons: [],
        activeSortingButton: null,
        sortingDirection: null,
        showDistance: !0,
        showSummary: !0,
        sortingFunction: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle }, habitats = [];
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], settings.activeSortingButton === settingsGameConstant.SORTING_HABITAT_FUNCTION.UNITS && titleSettings.rightButton.push({
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuUnitChooser.name,
          options: { mode: settingsGameConstant.UNIT_CHOOSER_LIST_MODE.HABITAT_SORTING }
        }), icon: "controls sorting-units"
      }), titleSettings.rightButton.push({
        icon: "controls sorting-direction",
        onClick: this.updateSortingDirection
      }, {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.HABITATS_LIST.CONTAINER)
      });
      var searchBarSettings = {
        value: this.state.searchQueryString,
        onChange: this.updateSearchQuery,
        onFocus: this.onSearchFieldFocus,
        onBlur: this.onSearchFieldBlur
      };
      this.state.showIcon && (searchBarSettings.iconLeft = "controls menu-search");
      var tapBarSettings = { buttons: [] }, activeSortingButton = settings.activeSortingButton;
      settings.sortingButtons.forEach(function(btnName) {
        var lSettings = {
          name: btnName,
          icon: "icon-game white icon-Sorting" + btnName,
          onClick: this.updateSortingFunction.bind(this, btnName)
        };
        activeSortingButton === btnName && (lSettings.ref = "first-in-list", lSettings.index = this.renderIndex, lSettings.isActive = !0), tapBarSettings.buttons.push(lSettings)
      }, this), settings.showSummary && (habitatSettings = {
        habitat: settings.summaryHabitat,
        isSummary: !0
      }, habitats.push(React.createElement(ComponentsWidgetHabitatOverview, {
        settings: habitatSettings,
        key: "habitat-in-list-summary"
      }))), filterString && (settings.habitatsList = settings.habitatsList.filter(function(h) {
        return !!~h.name.toLowerCase().indexOf(filterString)
      })), this.childrenAmountTotal = 0, this.childrenAmountRendered = 0, settings.habitatsList.forEach(function(habitat) {
        this.childrenAmountTotal += 1, habitatSettings = {
          habitat: habitat,
          isCurrentHabitat: habitat.id === settings.currentHabitatId,
          onClick: this.handlerOnHabitatClick.bind(this, habitat),
          showDistance: settings.showDistance
        }, habitat.possibleNextBattleDate && (habitatSettings.habitatIcon = "icon icon-game icon-HabitatUnderAttack"), habitats.push(React.createElement(ComponentsWidgetHabitatOverview, {
          settings: habitatSettings,
          onRender: this.onChildRender,
          key: "habitat-in-list-" + habitat.id
        }))
      }, this), habitats.push(React.createElement("div", {
        ref: "lastInList",
        "data-render-index": this.renderIndex,
        key: "habitat-last-list"
      }));
      var menuSectionContentSettings = { content: habitats }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }),
        searchBar: React.createElement(ComponentsMenuSearchBar, { settings: searchBarSettings }),
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.HABITATS_LIST.CONTAINER
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatsList.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuHabitatsListController(options) {
    MenuHabitatsListController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.habitatsSorted,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Castle Selection")
  }

  return utilsOop.extend(MenuHabitatsListController, CoreControllerElementMenu), MenuHabitatsListController.prototype[xy.eNames.menuHabitatsList.dataIsReady] = function(data) {
    this.initialOptions && (this.initialOptions.currentHabitatId && (data.currentHabitatId = this.initialOptions.currentHabitatId), this.initialOptions.showSummary && (data.showSummary = !0), this.initialOptions.showDistance && (data.showDistance = !0), this.initialOptions.onMenuClickEvent && (data.onMenuClickEvent = this.initialOptions.onMenuClickEvent), this.initialOptions.onHabitatMenuEvent && (data.onHabitatMenuEvent = this.initialOptions.onHabitatMenuEvent)), this.presenter.draw(data)
  }, MenuHabitatsListController.prototype[xy.eNames.menuHabitatsList.onResortHabitat] = function(btnName) {
    this.dataSource.sortHabitatBy(btnName)
  }, MenuHabitatsListController.prototype[xy.eNames.menuHabitatsList.onChangeSortingDirection] = function() {
    this.dataSource.sortHabitatInOppositeDirection()
  }, MenuHabitatsListController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.getHabitatsListData()
  }, MenuHabitatsListController
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatsList.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, settingsGameConstant) {
  "use strict";
  function MenuHabitatsListSource(options) {
    MenuHabitatsListSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatsListSource, CoreDataSource), MenuHabitatsListSource.prototype.sortHabitatBy = function(btnName) {
    servicesGameDataManager.habitatsCollection.sortOwnHabitat({ by: btnName })
  }, MenuHabitatsListSource.prototype.sortHabitatInOppositeDirection = function() {
    servicesGameDataManager.habitatsCollection.sortOwnHabitat({ oppositeDirection: !0 })
  }, MenuHabitatsListSource.prototype.getHabitatsListData = function() {
    var data = {
      currentHabitatId: servicesGameDataManager.habitatsCollection.currentHabitatId,
      activeSortingButton: servicesGameDataManager.habitatsCollection.sortingFunction,
      sortingDirection: servicesGameDataManager.habitatsCollection.isReverseSorting,
      sortingButtons: [],
      summaryHabitat: servicesGameDataManager.habitatsCollection.getEmptySummaryHabitat(),
      habitatsList: []
    }, habitatIds = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), humanResourceId = servicesTheme.themeSettings.resources.humanResourceId;
    habitatIds.forEach(function(id) {
      var key, amount, currentHabitat = servicesGameDataManager.habitatsCollection.getHabitat(id);
      for (key in data.summaryHabitat.habitatResourceDictionary)data.summaryHabitat.habitatResourceDictionary.hasOwnProperty(key) && (amount = humanResourceId === +key ? currentHabitat.habitatResourceDictionary[key].storeAmount - currentHabitat.habitatResourceDictionary[key].amount : currentHabitat.habitatResourceDictionary[key].amount, data.summaryHabitat.habitatResourceDictionary[key].amount += amount);
      var i, len = data.summaryHabitat.ownLocalUnits.length;
      for (i = 0; i < len; i += 1)data.summaryHabitat.ownLocalUnits[i].amount += currentHabitat.ownLocalUnits[i].amount;
      data.habitatsList.push(currentHabitat)
    });
    var key, sortingButtonsObject = settingsGameConstant.SORTING_HABITAT_FUNCTION;
    for (key in sortingButtonsObject)sortingButtonsObject.hasOwnProperty(key) && data.sortingButtons.push(sortingButtonsObject[key]);
    this.notify(xy.eNames.menuHabitatsList.dataIsReady, data)
  }, MenuHabitatsListSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatsList.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatsList.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatsListComponent) {
  "use strict";
  function MenuHabitatsListPresenter(options) {
    MenuHabitatsListPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatsListPresenter, CorePresenterElementMenu), MenuHabitatsListPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatsListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuHabitatsListPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatOverview.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListButtonDisplayLink, xy.dNames.components.unitsListLocalDefenders, xy.dNames.components.allianceMenuElement, xy.dNames.components.widgetUnitsList, xy.dNames.components.transitExternalListButton, xy.dNames.components.transitsSummary, xy.dNames.components.transitList, xy.dNames.components.overviewWidgetMovementWithLastFormation, xy.dNames.components.unitsListLocalAttackers, xy.dNames.components.unitsListExternalAttackers, xy.dNames.components.unitsListAttackersInForeignerHabitat, xy.dNames.components.transitMenuSendSpyButton, xy.dNames.components.transitMenuSendResourcesButton, xy.dNames.components.transitMenuAttackButton, xy.dNames.components.transitMenuSupportButton, xy.dNames.components.protectionWidgetNoobProtectionTeleportButton, xy.dNames.components.habitatMenuElement, xy.dNames.components.habitatAnnexMenuElement, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, servicesStorage, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsMenuListButtonDisplayLink, ComponentsUnitsListLocalDefenders, ComponentsAllianceMenuElement, ComponentsWidgetUnitList, ComponentsTransitExternalListButton, ComponentsTransitsSummary, ComponentsTransitList, ComponentsOverviewWidgetMovementWithLastFormation, ComponentsUnitsListLocalAttackers, ComponentsUnitsListExternalAttackers, ComponentsUnitsListAttackersInForeignerHabitat, ComponentsTransitMenuSendSpyButton, ComponentsTransitMenuSendResourcesButton, ComponentsTransitMenuAttackButton, ComponentsTransitMenuSupportButton, ComponentsProtectionWidgetNoobProtectionTeleportButton, ComponentsHabitatMenuElement, ComponentsHabitatAnnexMenuElement) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { activeModelLinkClicker: 0 }
    }, setActive: function(habitatId, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatOverview.setHabitatActive, habitatId)
    }, onHighlightHabitatClick: function(habitatId, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatOverview.switchHighlightForHabitat, { habitatId: habitatId })
    }, onReservationButtonClick: function(habitatId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuHabitatOverview.reserveHabitat, { habitatId: habitatId })
    }, onMovementWithLastFormationButtonClick: function(event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuHabitatOverview.doMovementWithLastFormation, {
        destinationHabitat: this.props.settings.habitat,
        sourceHabitat: this.props.settings.currentHabitat,
        units: this.props.settings.lastFormationUnits,
        resources: this.props.settings.lastFormationResources,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, onWithdrawReservationButtonClick: function(habitatReservationId, reservationMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuHabitatOverview.withdrawReservation, {
        habitatReservationId: habitatReservationId,
        reservationMode: reservationMode
      })
    }, onAnnexHabitatClick: function() {
      this.props.presenter.notify(xy.eNames.menuHabitatOverview.annexHabitat, { habitat: this.props.settings.habitat })
    }, onRelocateHabitatClick: function() {
      this.props.presenter.notify(xy.eNames.menuHabitatOverview.relocateHabitat, {
        freeHabitat: this.props.settings.habitat,
        currentHabitat: this.props.settings.currentHabitat
      })
    }, render: function() {
      var faqLink, settings = {
        ownPlayerId: 0,
        habitat: {},
        currentHabitat: {},
        isHabitatActive: !1,
        nextLegalFreeHabitatPurchaseDate: !1,
        player: {},
        alliance: {},
        sunCycles: null,
        defenders: null,
        attackersAll: null,
        attackerExternal: null,
        isTransitsOmitted: !1,
        transits: null,
        isPlayerInAlliance: !1,
        reservations: [],
        reservationLimitReached: !1,
        canDoMovementWithLastBand: !1,
        lastFormationUnits: null,
        lastFormationResources: null,
        lastFormationUnitsArrivalTime: null,
        lastFormationMode: !1,
        isArrivalTimeFinderAvailable: !1,
        isHabitatToFarAway: !1,
        isHabitatCanBeTeleported: !1,
        isSupportBridgeAvailable: !1,
        isPlayerOwnProtectionActive: !1,
        isHabitatOwnerVacationActive: !1,
        isHabitatOwnerProtectionActive: !1,
        isHabitatOwnerUnderNoobProtectionActive: !1,
        isAttackProtectionActive: !1,
        isFullProtectionActive: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], habitatType = settings.habitat.publicHabitatType, iconsTheme = servicesTheme.themeSettings.imagesClassNames;
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, sectionComponentSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.habitat.publicHabitatTypeNames[habitatType]) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-details"
      })), sectionComponentSettings = {
        habitat: settings.habitat,
        initialComponent: this
      }, componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
        settings: sectionComponentSettings,
        key: "menu-element-habitat-details"
      })), sectionComponentSettings = {
        title: settings.player.nick,
        description: settings.player.points,
        iconLeft: "icon-game icon-ButtonPlayer"
      }, settings.player.isEmpty || (sectionComponentSettings.onClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuPlayerProfileExternal.name,
        options: { playerId: settings.player.id }
      }), sectionComponentSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-player-details"
      })), sectionComponentSettings = {
        alliance: settings.alliance,
        initialComponent: this
      }, componentsSections.push(React.createElement(ComponentsAllianceMenuElement, {
        settings: sectionComponentSettings,
        key: "menu-element-ally-details"
      })), settings.isSupportBridgeAvailable && settings.habitat.isOwnByPlayer && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Support Bridge"),
        iconLeft: iconsTheme.featureSupportBridge.supportBridge,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuSupportBridge.name,
          options: { habitatId: settings.habitat.id }
        })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-support-bridge"
      }))), !settings.isHabitatActive && settings.habitat.isOwnByPlayer && (sectionComponentSettings = {
        iconLeft: "icon-game icon-SelectAsActiveHabitat-" + habitatType,
        onClick: this.setActive.bind(this, settings.habitat.id),
        title: servicesTheme.themeSettings.setActiveButtonTitle[habitatType]
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-set-active"
      }))), sectionComponentSettings = {
        iconLeft: "icon-game icon-copyPasteHabitatLink-" + habitatType,
        onClick: this.onGetModelLinkClick.bind(this, settings.habitat),
        targetModel: settings.habitat,
        defaultTitle: servicesTheme.themeSettings.displayLinkTitle[habitatType]
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonDisplayLink, {
        settings: sectionComponentSettings,
        key: "menu-button-copy-habitat-link"
      })), sectionComponentSettings = {
        iconLeft: "icon-game icon-ButtonMap",
        onClick: this.onHighlightHabitatClick.bind(this, settings.habitat.id),
        title: servicesTheme.themeSettings.highlightHabitatButtonTitle[habitatType]
      }, servicesStorage.isHighlighted(settings.habitat.id) && (sectionComponentSettings.iconRight = "icon-game icon-BuffActivate"), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "menu-button-highlight-habitat"
      }));
      var isReserved = !1, habitatReservationId = 0, reservationMode = 0, reservationSectionRequested = [], reservationSectionAccepted = [];
      if (sectionComponentSettings = { title: servicesInternationalization.localize("Already requested by") }, reservationSectionRequested.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "title-element-reservation-requested"
              })), sectionComponentSettings = { title: servicesInternationalization.localize("Already reserved by") }, reservationSectionAccepted.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "title-element-reservation-accepted"
              })), settings.reservations.length && settings.reservations.forEach(function(reservationModel) {
                reservationModel.player === settings.ownPlayerId && (isReserved = !0, reservationMode = reservationModel.status, habitatReservationId = reservationModel.id);
                var player = servicesGameDataManager.playersCollection.getPlayer(reservationModel.player), reservationSettings = {
                  title: player.nick,
                  description: player.points,
                  iconLeft: "icon-game icon-ButtonPlayer",
                  iconRight: "controls menu-next",
                  onClick: this.handlerNextClick.bind(this, {
                    next: xy.dNames.game.menuPlayerProfileExternal.name,
                    options: { playerId: player.id }
                  })
                };
                reservationModel.status === settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED ? reservationSectionAccepted.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: reservationSettings,
                  key: "reservation-player-element-" + player.id
                })) : reservationSectionRequested.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: reservationSettings,
                  key: "reservation-player-element-" + player.id
                }))
              }, this), reservationSectionRequested.length > 1 && (componentsSections = componentsSections.concat(reservationSectionRequested)), reservationSectionAccepted.length > 1 && (componentsSections = componentsSections.concat(reservationSectionAccepted)), !settings.habitat.isOwnByPlayer && settings.isPlayerInAlliance && (isReserved ? (sectionComponentSettings = {
                iconLeft: "icon-game icon-ReservationTakeBackHabitat-" + habitatType,
                onClick: this.onWithdrawReservationButtonClick.bind(this, habitatReservationId, reservationMode),
                title: reservationMode === settingsGameConstant.HABITAT_RESERVATION_STATUS.ACCEPTED ? servicesInternationalization.localize("Withdraw Reservation") : servicesInternationalization.localize("Withdraw Request")
              }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
                settings: sectionComponentSettings,
                key: "menu-button-reserve-habitat"
              }))) : settings.reservationLimitReached ? (sectionComponentSettings = { text: servicesInternationalization.localize("Number of max HabitatReservations reached.") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
                settings: sectionComponentSettings,
                key: "menu-text-reservations-limit"
              }))) : (sectionComponentSettings = {
                iconLeft: "icon-game icon-ReservationHabitat-" + habitatType,
                onClick: this.onReservationButtonClick.bind(this, settings.habitat.id),
                title: servicesTheme.themeSettings.reserveHabitatButtonTitle[habitatType]
              }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
                settings: sectionComponentSettings,
                key: "menu-button-reserve-habitat"
              })))), settings.isHabitatCanBeTeleported && (sectionComponentSettings = {
                timer: settings.currentHabitat.noobProtectionEndDate,
                onClick: this.onRelocateHabitatClick
              }, componentsSections.push(React.createElement(ComponentsProtectionWidgetNoobProtectionTeleportButton, {
                settings: sectionComponentSettings,
                key: "menu-element-relocate-habitat"
              }))), settings.isAttackProtectionActive || settings.isFullProtectionActive) {
        var textProtectionModeWarning;
        settings.isPlayerOwnProtectionActive ? textProtectionModeWarning = servicesInternationalization.localize("Your protective shield is active. You cannot attack, support or spy on other castles.") : settings.isHabitatOwnerProtectionActive ? textProtectionModeWarning = servicesInternationalization.localize("Castle is under attack protection. You cannot attack, support or spy on this castle.") : settings.isHabitatOwnerUnderNoobProtectionActive ? textProtectionModeWarning = servicesInternationalization.localize("Castle is protected by newbie protection until %@.", utilsDateTime.getLocaleDateTimeString(settings.habitat.noobProtectionEndDate)) : settings.isHabitatOwnerVacationActive && (textProtectionModeWarning = servicesInternationalization.localize("Castle is protected by vacation protection.")), sectionComponentSettings = { text: textProtectionModeWarning }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-text-you-can-not-attack"
        }))
      }
      sectionComponentSettings = { title: servicesInternationalization.localize("Actions") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu-title-actions"
      })), settings.canDoMovementWithLastBand && (sectionComponentSettings = {
        units: settings.lastFormationUnits,
        resources: settings.lastFormationResources,
        arrivalDate: settings.lastFormationUnitsArrivalTime,
        onClick: this.onMovementWithLastFormationButtonClick,
        lastFormationMode: settings.lastFormationMode,
        initialComponent: this
      }, componentsSections.push(React.createElement(ComponentsOverviewWidgetMovementWithLastFormation, {
        settings: sectionComponentSettings,
        key: "menu-element-repeat-last-movement"
      }))), settings.isAttackProtectionActive || settings.isFullProtectionActive || settings.habitat.isOwnByPlayer || (sectionComponentSettings = {
        attackingHabitat: settings.habitat,
        isHabitatToFarAway: settings.isHabitatToFarAway,
        initialComponent: this,
        showAsMenuElement: !0
      }, componentsSections.push(React.createElement(ComponentsTransitMenuAttackButton, {
        settings: sectionComponentSettings,
        key: "menu-element-attack"
      }))), settings.isFullProtectionActive || settings.habitat.isRenegade || settings.isHabitatActive || (sectionComponentSettings = {
        habitat: settings.habitat,
        isHabitatToFarAway: settings.isHabitatToFarAway,
        initialComponent: this,
        showAsMenuElement: !0
      }, componentsSections.push(React.createElement(ComponentsTransitMenuSupportButton, {
        settings: sectionComponentSettings,
        key: "menu-element-support"
      }))), settings.habitat.isRenegade || settings.isHabitatActive || (sectionComponentSettings = {
        affectedHabitat: settings.habitat,
        isHabitatToFarAway: settings.isHabitatToFarAway,
        initialComponent: this,
        showAsMenuElement: !0
      }, componentsSections.push(React.createElement(ComponentsTransitMenuSendResourcesButton, {
        settings: sectionComponentSettings,
        key: "menu-element-send-transit"
      }))), settings.isAttackProtectionActive || settings.isFullProtectionActive || settings.habitat.isOwnByPlayer || (sectionComponentSettings = {
        affectedHabitat: settings.habitat,
        isHabitatToFarAway: settings.isHabitatToFarAway,
        initialComponent: this,
        showAsMenuElement: !0
      }, componentsSections.push(React.createElement(ComponentsTransitMenuSendSpyButton, {
        settings: sectionComponentSettings,
        key: "menu-element-send-spy"
      }))), settings.isArrivalTimeFinderAvailable && (sectionComponentSettings = {
        iconLeft: "icon-game icon-Duration",
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuArrivalTimeFinder.name,
          options: { affectedHabitat: settings.habitat, affectedPlayer: settings.player }
        }),
        title: servicesInternationalization.localize("Arrival time finder")
      }, faqLink = servicesTheme.themeSettings.faqLinks.arrivalTimeFinder, faqLink && (sectionComponentSettings = this.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "menu-element-arrival-calculator"
      }))), settings.habitat.isRenegade && (sectionComponentSettings = {
        habitat: settings.habitat,
        nextLegalFreeHabitatPurchaseDate: settings.nextLegalFreeHabitatPurchaseDate,
        initialComponent: this
      }, componentsSections.push(React.createElement(ComponentsHabitatAnnexMenuElement, {
        settings: sectionComponentSettings,
        key: "menu-element-annex-habitat"
      }))), settings.sunCycles && settings.sunCycles.forEach(function(cycle) {
        var cycleSettings = { iconLeft: "icon-game colored icon-" + cycle.mode + "Icon", text: cycle.dateTimeString };
        componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: cycleSettings,
          key: "menu-cycle-" + cycle.mode
        }))
      }), settings.defenders && settings.defenders.length && (sectionComponentSettings = {
        initialComponent: this,
        defenders: settings.defenders,
        habitat: settings.habitat,
        massSendBackActionType: settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_LOCAL_DEFENDERS
      }, componentsSections.push(React.createElement(ComponentsUnitsListLocalDefenders, {
        settings: sectionComponentSettings,
        key: "menu--local-defenders-list"
      }))), settings.habitat.isOwnByPlayer ? (settings.attackersAll && settings.attackersAll.length && (sectionComponentSettings = {
        initialComponent: this,
        attackers: settings.attackersAll,
        habitat: settings.habitat
      }, componentsSections.push(React.createElement(ComponentsUnitsListLocalAttackers, {
        settings: sectionComponentSettings,
        key: "menu--local-attackers-list"
      }))), settings.attackerExternal && settings.attackerExternal.length && (sectionComponentSettings = {
        initialComponent: this,
        attackers: settings.attackerExternal,
        habitat: settings.habitat
      }, componentsSections.push(React.createElement(ComponentsUnitsListExternalAttackers, {
        settings: sectionComponentSettings,
        key: "menu--external-attackers-list"
      })))) : settings.attackersAll && settings.attackersAll.length && (sectionComponentSettings = {
        initialComponent: this,
        attackers: settings.attackersAll,
        habitat: settings.habitat,
        massSendBackActionType: settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_LOCAL_ATTACKERS
      }, componentsSections.push(React.createElement(ComponentsUnitsListAttackersInForeignerHabitat, {
        settings: sectionComponentSettings,
        key: "menu--local-attackers-list-in-foreigner-habitat"
      }))), settings.isTransitsOmitted && (settings.habitat.isOwnByPlayer && settings.habitat.transitCount || !settings.habitat.isOwnByPlayer) ? (sectionComponentSettings = { title: servicesInternationalization.localize("Transits") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu--transit-title"
      })), sectionComponentSettings = {
        initialComponent: this,
        habitat: settings.habitat
      }, componentsSections.push(React.createElement(ComponentsTransitExternalListButton, {
        settings: sectionComponentSettings,
        key: "menu-element-external-transit"
      }))) : settings.transits && (sectionComponentSettings = { title: servicesInternationalization.localize("Transits") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu--transit-title"
      })), sectionComponentSettings = { transits: settings.transits }, componentsSections.push(React.createElement(ComponentsTransitsSummary, {
        settings: sectionComponentSettings,
        key: "menu--transit-summary"
      })), sectionComponentSettings = {
        initialComponent: this,
        transits: settings.transits
      }, componentsSections.push(React.createElement(ComponentsTransitList, {
        settings: sectionComponentSettings,
        key: "menu--transit-list"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatOverview.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.storage, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.services.eventManager, function(gameInstance, CoreControllerElementMenu, utilsOop, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings, servicesStorage, servicesTheme, servicesLog, servicesEventManager) {
  "use strict";
  function MenuHabitatOverviewController(options) {
    var menuTransitOverviewController = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.controller), menuAllianceHabitatReservationOverviewController = gameInstance.injector.get(xy.dNames.game.menuAllianceHabitatReservationOverview.controller), menuHabitatSendUnitsResourcesController = gameInstance.injector.get(xy.dNames.game.menuHabitatSendUnitsResources.controller), menuHabitatSendSpyController = gameInstance.injector.get(xy.dNames.game.menuHabitatSendSpy.controller);
    this.forLinking = [{
      resourceClass: menuTransitOverviewController,
      methodName: xy.eNames.menuTransitOverview.speedUpTransit
    }, {
      resourceClass: menuAllianceHabitatReservationOverviewController,
      methodName: xy.eNames.menuAllianceHabitatReservationOverview.withdrawReservation
    }, {
      resourceClass: menuHabitatSendUnitsResourcesController,
      methodName: xy.eNames.menuHabitatSendUnitsResources.startAttack
    }, {
      resourceClass: menuHabitatSendUnitsResourcesController,
      methodName: xy.eNames.menuHabitatSendUnitsResources.sendSupport
    }, {
      resourceClass: menuHabitatSendUnitsResourcesController,
      methodName: xy.eNames.menuHabitatSendUnitsResources.sendResources
    }, {
      resourceClass: menuHabitatSendSpyController,
      methodName: xy.eNames.menuHabitatSendSpy.sendSpy
    }], MenuHabitatOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Actions"), this.arrivalTimeSettings = {
      actionKey: null,
      unitPK: null
    }
  }

  return utilsOop.extend(MenuHabitatOverviewController, CoreControllerElementMenu), MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.dataIsReady] = function(data) {
    data.habitat.isRenegade && servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.menuHabitatOverviewFreeHabitatOpened), this.presenter.draw(data)
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.setHabitatActive] = function(habitatId) {
    this.dataSource.setHabitatActive(habitatId)
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.reserveHabitat] = function(options) {
    this.dataSource.reserveHabitat(options)
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.withdrawReservation] = function(options) {
    this[xy.eNames.menuAllianceHabitatReservationOverview.withdrawReservation](options)
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.switchHighlightForHabitat] = function(options) {
    servicesStorage.switchHighlighting(options.habitatId), this.prepareDataForDraw()
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.doMovementWithLastFormation] = function(options) {
    var text, callback, newOptions = {
      destinationHabitat: options.destinationHabitat,
      sourceHabitat: options.sourceHabitat,
      lastFormationMode: options.lastFormationMode,
      disableLastFormationCacheRewriting: !0
    }, title = servicesInternationalization.localize(servicesTheme.themeSettings.movementWithLastFormation[options.lastFormationMode]);
    switch (options.lastFormationMode) {
      case settingsGameConstant.LAST_FORMATION_MODE.ATTACK:
        text = servicesInternationalization.localize("Do you really want to attack castle %@ with last formation?", options.destinationHabitat.name), newOptions.units = options.units, newOptions.resources = options.resources, callback = this[xy.eNames.menuHabitatSendUnitsResources.startAttack].bind(this.dataSource, newOptions);
        break;
      case settingsGameConstant.LAST_FORMATION_MODE.SUPPORT:
        text = servicesInternationalization.localize("Do you really want to support the castle %1$@ with the last formation?", options.destinationHabitat.name), newOptions.units = options.units, newOptions.resources = {}, callback = this[xy.eNames.menuHabitatSendUnitsResources.sendSupport].bind(this.dataSource, newOptions);
        break;
      case settingsGameConstant.LAST_FORMATION_MODE.SEND_RESOURCE:
        text = servicesInternationalization.localize("Do you really want to send resources to the castle %1$@ with the last formation?", options.destinationHabitat.name), newOptions.units = options.units, newOptions.resources = options.resources, callback = this[xy.eNames.menuHabitatSendUnitsResources.sendResources].bind(this.dataSource, newOptions);
        break;
      case settingsGameConstant.LAST_FORMATION_MODE.SEND_SPY:
        text = servicesInternationalization.localize("Do you really want to send a spy with the last %1$@ amount to the castle %2$@?", options.resources[servicesTheme.themeSettings.resources.spyResourceId], options.destinationHabitat.name), newOptions.spyResourceAmount = options.resources[servicesTheme.themeSettings.resources.spyResourceId], callback = this[xy.eNames.menuHabitatSendSpy.sendSpy].bind(this.dataSource, newOptions);
        break;
      default:
        servicesLog("warn", "unknown last formation mode")
    }
    this.showDialogDialog({ title: title, text: text, callbackSuccess: callback })
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.annexHabitat] = function(options) {
    var text, warningText, habitatType = options.habitat.publicHabitatType, title = servicesInternationalization.localize(servicesTheme.themeSettings.buyHabitatTitle[habitatType]), player = servicesGameDataManager.playersCollection.getPlayer(), gold = player.gold, possiblePurchaseDate = player.nextLegalFreeHabitatPurchaseDateDictionary[habitatType], annexCost = servicesWorldSettings.settings.freeHabitatPurchasePriceDictionary[habitatType];
    switch (habitatType) {
      case settingsGameConstant.HABITAT_TYPE.CASTLE:
      case settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER:
        text = "The claiming of the castle costs %1$d gold coins. You currently own %2$d gold coins. Do you wish to claim the castle?", warningText = "The selected castle can only be annexed after the cooldown";
        break;
      case settingsGameConstant.HABITAT_TYPE.FORTRESS:
      case settingsGameConstant.HABITAT_TYPE.CITY_CENTER:
        text = "The claiming of the fortress costs %1$d gold coins. You currently own %2$d gold coins. Do you wish to claim the fortress?", warningText = "The selected fortress can only be annexed after the cooldown"
    }
    return annexCost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, annexCost - gold) : (options.cost = annexCost, possiblePurchaseDate && possiblePurchaseDate > new Date ? void this.showDialogAlert({
      title: title,
      text: servicesInternationalization.localize(warningText)
    }) : (text = servicesInternationalization.localize(text, annexCost, gold), void this.showDialogDialog({
      title: title,
      text: text,
      callbackSuccess: this.dataSource.annexHabitat.bind(this.dataSource, options)
    })))
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuHabitatOverview.relocateHabitat] = function(options) {
    var text, title = servicesInternationalization.localize("Relocate castle"), player = servicesGameDataManager.playersCollection.getPlayer(), gold = player.gold, goldName = servicesTheme.themeSettings.resources.premiumResourceNameForLocalization, relocateCost = servicesWorldSettings.settings.relocateHabitatCost || 0;
    if (relocateCost > 0) {
      if (relocateCost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, relocateCost - gold);
      text = 'Are you sure you want to change the position of your castle \\"%1$@\\" with the position of castle \\"%2$@\\" for %3$d %4$@? You have %5$d %6$@. The relocating functionality can only be used once and can\'t be undone.', text = servicesInternationalization.localize(text, options.currentHabitat.name, options.freeHabitat.name, relocateCost, goldName, gold, goldName), options.cost = relocateCost, this.showDialogDialog({
        classes: "higher",
        title: title,
        text: text,
        callbackSuccess: this.dataSource.relocationHabitat.bind(this.dataSource, options)
      })
    } else text = 'Are you sure you want to change the position of your castle "%1$s" with the position of castle "%2$s". The relocating functionality can only be used once and cannot be undone.', text = servicesInternationalization.localize(text, options.currentHabitat.name, options.freeHabitat.name), this.showDialogDialog({
      title: title,
      text: text,
      callbackSuccess: this.dataSource.relocationHabitat.bind(this.dataSource, options)
    })
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuArrivalTimeFinder.setActionKey] = function(actionKey) {
    this.arrivalTimeSettings.actionKey = actionKey
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuArrivalTimeFinder.setUnitPK] = function(unitPK) {
    this.arrivalTimeSettings.unitPK = unitPK
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuArrivalTimeFinder.getActionKey] = function() {
    return this.arrivalTimeSettings.actionKey
  }, MenuHabitatOverviewController.prototype[xy.eNames.menuArrivalTimeFinder.getUnitPK] = function() {
    return this.arrivalTimeSettings.unitPK
  }, MenuHabitatOverviewController.prototype.prepareDataForDraw = function() {
    var habitatId = this.initialOptions.habitatId || this.initialData.habitatId;
    (this.isActive || this.isRoot) && this.dataSource.prepareHabitatOverviewData({ habitatId: habitatId })
  }, MenuHabitatOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.utils.moving, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.storage, xy.dNames.services.log, function(gameInstance, CoreDataSource, utilsOop, utilsDateTime, utilsMoving, utilsObject, settingsGameConstant, servicesGameDataManager, servicesWorldSettings, servicesStorage, servicesLog) {
  "use strict";
  function MenuHabitatOverviewDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource), menuAllianceHabitatReservationOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceHabitatReservationOverview.dataSource), menuHabitatSendUnitsResourcesDataSource = gameInstance.injector.get(xy.dNames.game.menuHabitatSendUnitsResources.dataSource), menuHabitatSendSpyDataSource = gameInstance.injector.get(xy.dNames.game.menuHabitatSendSpy.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransitResponse"
    }, {
      resourceClass: menuAllianceHabitatReservationOverviewDataSource,
      methodName: "withdrawHabitatReservation"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }, {
      resourceClass: menuHabitatSendUnitsResourcesDataSource,
      methodName: "initiateAttackTransit"
    }, {
      resourceClass: menuHabitatSendUnitsResourcesDataSource,
      methodName: "initiateSupportTransit"
    }, {
      resourceClass: menuHabitatSendUnitsResourcesDataSource,
      methodName: "initiateResourcesTransit"
    }, {
      resourceClass: menuHabitatSendSpyDataSource,
      methodName: "initiateSpyAction"
    }, {
      resourceClass: menuHabitatSendSpyDataSource,
      methodName: "onInitiateSpyAction"
    }], MenuHabitatOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatOverviewDataSource, CoreDataSource), MenuHabitatOverviewDataSource.prototype.setHabitatActive = function(habitatId) {
    servicesGameDataManager.habitatsCollection.setCurrentHabitatId(habitatId)
  }, MenuHabitatOverviewDataSource.prototype.prepareHabitatOverviewData = function(options) {
    var lastFormationUnits, lastFormationResources, lastFormationUnitsArrivalTime, lastFormationData, now, data = {}, habitatId = options.habitatId, currentHabitat = servicesGameDataManager.habitatsCollection.getHabitat(), habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), distance = currentHabitat.computeDistanceBetweenHabitats(habitat), player = servicesGameDataManager.playersCollection.getPlayer();
    if (data.isHabitatToFarAway = currentHabitat.isAnotherHabitatToFarAway(distance), !player.usedRelocateHabitat && habitat.isRenegade && servicesWorldSettings.settings.featureRelocateHabitatPremium && currentHabitat.noobProtectionEndDate && (now = new Date, habitat.publicHabitatType === settingsGameConstant.HABITAT_TYPE.CASTLE && currentHabitat.noobProtectionEndDate > now && (data.isHabitatCanBeTeleported = !0)), player.attackProtectionEndDate && utilsDateTime.remainTimeInSeconds(player.attackProtectionEndDate) > 0 ? (data.isPlayerOwnProtectionActive = !0, data.isFullProtectionActive = !0) : data.player && data.player.isOnVacation ? (data.isHabitatOwnerVacationActive = !0, data.isAttackProtectionActive = !0) : data.player && data.player.attackProtectionEndDate && utilsDateTime.remainTimeInSeconds(data.player.attackProtectionEndDate) > 0 ? (data.isHabitatOwnerProtectionActive = !0, data.isFullProtectionActive = !0) : habitat.noobProtectionEndDate && utilsDateTime.remainTimeInSeconds(habitat.noobProtectionEndDate) > 0 && (data.isHabitatOwnerUnderNoobProtectionActive = !0, data.isAttackProtectionActive = !0), data.ownPlayerId = servicesGameDataManager.getPlayerId(), data.habitat = habitat, data.currentHabitat = currentHabitat, data.isHabitatActive = servicesGameDataManager.habitatsCollection.currentHabitatId === habitatId, data.nextLegalFreeHabitatPurchaseDate = servicesGameDataManager.playersCollection.getNextLegalFreeHabitatPurchaseDate(habitat.publicHabitatType), lastFormationData = servicesStorage.getLastFormationUnits(), utilsObject.effectiveLength(lastFormationData)) {
      var offensiveRequirements = !data.isHabitatToFarAway && !habitat.isOwnByPlayer && !data.isFullProtectionActive, defensiveRequirements = !data.isHabitatToFarAway && !habitat.isRenegade && !data.isHabitatActive;
      switch (lastFormationUnits = lastFormationData.unitsDictionary, lastFormationResources = lastFormationData.resourcesDictionary, lastFormationData.lastFormationMode) {
        case settingsGameConstant.LAST_FORMATION_MODE.ATTACK:
          data.canDoMovementWithLastBand = currentHabitat.hasEnoughUnits(lastFormationUnits) && currentHabitat.hasEnoughResources(lastFormationResources) && offensiveRequirements && !data.isPlayerOwnProtectionActive, lastFormationUnitsArrivalTime = utilsMoving.getArrivalTime(lastFormationUnits, { distance: data.habitat.distanceToActiveHabitat });
          break;
        case settingsGameConstant.LAST_FORMATION_MODE.SUPPORT:
          data.canDoMovementWithLastBand = currentHabitat.hasEnoughUnits(lastFormationUnits) && defensiveRequirements && !data.isFullProtectionActive, lastFormationUnitsArrivalTime = utilsMoving.getArrivalTime(lastFormationUnits, { distance: data.habitat.distanceToActiveHabitat });
          break;
        case settingsGameConstant.LAST_FORMATION_MODE.SEND_RESOURCE:
          data.canDoMovementWithLastBand = currentHabitat.hasEnoughUnits(lastFormationUnits) && currentHabitat.hasEnoughResources(lastFormationResources) && defensiveRequirements, lastFormationUnitsArrivalTime = utilsMoving.getArrivalTime(lastFormationUnits, { distance: data.habitat.distanceToActiveHabitat });
          break;
        case settingsGameConstant.LAST_FORMATION_MODE.SEND_SPY:
          data.canDoMovementWithLastBand = currentHabitat.hasEnoughResources(lastFormationResources) && offensiveRequirements && !data.isAttackProtectionActive, lastFormationUnitsArrivalTime = utilsMoving.getArrivalTime(null, {
            spySpeed: servicesWorldSettings.settings.spyAttackSecondsPerField,
            distance: data.habitat.distanceToActiveHabitat
          });
          break;
        default:
          servicesLog("warn", "unknown last formation mode")
      }
      data.canDoMovementWithLastBand && (data.lastFormationUnits = lastFormationUnits, data.lastFormationResources = lastFormationResources, data.lastFormationUnitsArrivalTime = lastFormationUnitsArrivalTime, data.lastFormationMode = lastFormationData.lastFormationMode)
    }
    data.habitat.player ? data.player = servicesGameDataManager.playersCollection.getPlayer(data.habitat.player) : data.player = servicesGameDataManager.playersCollection.getEmptyPlayer(data.habitat), data.player.alliance ? data.alliance = servicesGameDataManager.alliancesCollection.getAlliance(data.player.alliance) : data.alliance = servicesGameDataManager.alliancesCollection.getEmptyAlliance(), data.sunCycles = [], servicesWorldSettings.worldDawn < servicesWorldSettings.worldDusk ? (data.sunCycles.push({
      mode: "Day",
      dateTimeString: utilsDateTime.getLocaleDateTimeString(servicesWorldSettings.worldDawn)
    }), data.sunCycles.push({
      mode: "Night",
      dateTimeString: utilsDateTime.getLocaleDateTimeString(servicesWorldSettings.worldDusk)
    })) : (data.sunCycles.push({
      mode: "Night",
      dateTimeString: utilsDateTime.getLocaleDateTimeString(servicesWorldSettings.worldDusk)
    }), data.sunCycles.push({
      mode: "Day",
      dateTimeString: utilsDateTime.getLocaleDateTimeString(servicesWorldSettings.worldDawn)
    })), servicesGameDataManager.transitsCollection.isPartialTransitMode() ? (data.isTransitsOmitted = !0, data.transits = null) : (data.isTransitsOmitted = !1, data.transits = servicesGameDataManager.transitsCollection.getHabitatTransitsForHabitat(habitatId)), data.reservations = servicesGameDataManager.habitatsCollection.getReservationsListForHabitat(habitatId);
    var myAlliance = servicesGameDataManager.alliancesCollection.getAlliance();
    myAlliance ? (data.isPlayerInAlliance = !0, servicesGameDataManager.habitatsCollection.ownReservationsAmount >= myAlliance.settingNumberOfPlayerHabitatReservation && (data.reservationLimitReached = !0)) : data.isPlayerInAlliance = !1, servicesWorldSettings.settings.featureArrivalTimeFinder && (data.isArrivalTimeFinderAvailable = !0, (data.isAttackProtectionActive || data.isFullProtectionActive) && habitat.isRenegade && (data.isArrivalTimeFinderAvailable = !1)), servicesWorldSettings.settings.featureSupportBridge && (habitat.nextBattleDate || servicesGameDataManager.habitatsCollection.isHabitatUnderAttack(habitatId)) && (data.isSupportBridgeAvailable = !0);
    var localHabitatUnitsArray;
    habitat.isOwnByPlayer ? (localHabitatUnitsArray = habitat.localHabitatUnitArray, data.attackerExternal = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: habitat.remoteHabitatUnitArray })) : localHabitatUnitsArray = servicesGameDataManager.unitsCollection.getForeignerHabitatLocalUnits(habitatId), data.defenders = servicesGameDataManager.unitsCollection.getDefendersUnits({ habitatUnitArray: localHabitatUnitsArray }), data.attackersAll = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: localHabitatUnitsArray }), this.notify(xy.eNames.menuHabitatOverview.dataIsReady, data)
  }, MenuHabitatOverviewDataSource.prototype.requestHabitatInformation = function(options) {
    this.request({ habitatID: options.habitatId }, "HabitatAction/habitatInformation", { callBack: this.prepareHabitatOverviewData.bind(this, options) })
  }, MenuHabitatOverviewDataSource.prototype.reserveHabitat = function(options) {
    this.request({ habitatID: options.habitatId }, "HabitatReservationAction/makeInquiry", { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatOverviewDataSource.prototype.annexHabitat = function(options) {
    this.request({
      habitatID: options.habitat.id,
      paymentAmount: options.cost
    }, "HabitatAction/buyFreeHabitat", { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatOverviewDataSource.prototype.relocationHabitat = function(options) {
    var params = { srcHabitatId: options.currentHabitat.id, dstHabitatId: options.freeHabitat.id };
    options.cost && (params.paymentAmount = options.cost), this.request(params, "HabitatAction/relocateHabitat", { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatOverviewComponent) {
  "use strict";
  function MenuHabitatOverviewPresenter(options) {
    MenuHabitatOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatOverviewPresenter, CorePresenterElementMenu), MenuHabitatOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuHabitatOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatTransitsListOverview.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.transitsSummary, xy.dNames.components.transitList, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, servicesStorage, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsTransitsSummary, ComponentsTransitList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = { transits: null }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.transits && (sectionComponentSettings = { title: servicesInternationalization.localize("Transits") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu--transit-title"
      })), sectionComponentSettings = { transits: settings.transits }, componentsSections.push(React.createElement(ComponentsTransitsSummary, {
        settings: sectionComponentSettings,
        key: "menu--transit-summary"
      })), sectionComponentSettings = {
        initialComponent: this,
        transits: settings.transits,
        isCompletedExcluded: !0
      }, componentsSections.push(React.createElement(ComponentsTransitList, {
        settings: sectionComponentSettings,
        key: "menu--transit-list"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatTransitsListOverview.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuHabitatTransitsListOverviewController(options) {
    var menuTransitOverviewController = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.controller);
    this.forLinking = [{
      resourceClass: menuTransitOverviewController,
      methodName: xy.eNames.menuTransitOverview.speedUpTransit
    }], MenuHabitatTransitsListOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.transitsCache,
      identifier: xy.eNames.dataListeners.dataIdentifiers.updated,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Transits")
  }

  return utilsOop.extend(MenuHabitatTransitsListOverviewController, CoreControllerElementMenu), MenuHabitatTransitsListOverviewController.prototype[xy.eNames.eventHabitatTransitListOverview.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuHabitatTransitsListOverviewController.prototype.prepareDataForDraw = function() {
    this.isVisible() && this.dataSource.prepareTransitListOverviewData({
      relatedToCurrentHabitat: this.initialOptions.relatedToCurrentHabitat || !1,
      habitatId: this.initialOptions.habitatId
    })
  }, MenuHabitatTransitsListOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatTransitsListOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.utils.moving, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.storage, xy.dNames.services.log, function(gameInstance, CoreDataSource, utilsOop, utilsDateTime, utilsMoving, utilsObject, settingsGameConstant, servicesGameDataManager, servicesWorldSettings, servicesStorage, servicesLog) {
  "use strict";
  function MenuHabitatTransitsListOverviewDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransitResponse"
    }], MenuHabitatTransitsListOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatTransitsListOverviewDataSource, CoreDataSource), MenuHabitatTransitsListOverviewDataSource.prototype.prepareTransitListOverviewData = function(options) {
    var transits, data = { transits: [] }, habitatId = options.relatedToCurrentHabitat ? servicesGameDataManager.habitatsCollection.getCurrentHabitatId() : options.habitatId;
    servicesGameDataManager.transitsCollection.flagPartialCollectionMode ? servicesGameDataManager.transitsCollection.isHabitatsTransitCached(habitatId) ? (transits = servicesGameDataManager.transitsCollection.getHabitatTransitsForHabitat(habitatId) || [], transits.forEach(function(transitConstructedObject) {
      transitConstructedObject.transit.isTransitActive() && data.transits.push(transitConstructedObject)
    }, this), this.notify(xy.eNames.eventHabitatTransitListOverview.dataIsReady, data)) : this.requestOmittedTransitData({ habitatId: habitatId }) : this.notify(xy.eNames.menu.onDataExpired)
  }, MenuHabitatTransitsListOverviewDataSource.prototype.requestOmittedTransitData = function(options) {
    this.request({ habitatID: options.habitatId }, "HabitatAction/transits", { callBack: this.onTransitDataReceived.bind(this, options) })
  }, MenuHabitatTransitsListOverviewDataSource.prototype.onTransitDataReceived = function(options, data) {
    var playerData = data.Data || {};
    servicesGameDataManager.transitsCollection.partialUpdateTransit(options.habitatId, playerData.Transit || []), servicesGameDataManager.updateHabitatsData(playerData.Habitat, { isPeripheral: !0 }), servicesGameDataManager.updatePlayersData(playerData.Player, { isPeripheral: !0 }), servicesGameDataManager.updateAlliancesData(playerData.Alliance, { isPeripheral: !0 }), servicesGameDataManager.updateHabitatsUnits(playerData.HabitatUnit)
  }, MenuHabitatTransitsListOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatTransitsListOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatTransitsListOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatTransitsListOverviewComponent) {
  "use strict";
  function MenuHabitatTransitsListOverviewPresenter(options) {
    MenuHabitatTransitsListOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatTransitsListOverviewPresenter, CorePresenterElementMenu), MenuHabitatTransitsListOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatTransitsListOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuHabitatTransitsListOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendUnitsResources.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuComponentArrivalDate, xy.dNames.utils.moving, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListButtonBasic, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetRangeSliderDivider, xy.dNames.components.widgetDateTimePicker, xy.dNames.components.widgetTimeDelay, xy.dNames.components.widgetResourcesList, xy.dNames.components.overviewWidgetResourcesInHabitat, xy.dNames.components.transitMenuSendResourcesButton, xy.dNames.components.transitMenuAttackButton, xy.dNames.components.transitMenuSupportButton, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, mixinsMenuComponentArrivalDate, utilMoving, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesTheme, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsMenuListButtonBasic, ComponentsHabitatMenuElement, ComponentsWidgetRangeSliderDivider, ComponentsWidgetDateTimePicker, ComponentsWidgetTimeDelay, ComponentsWidgetResourcesList, ComponentsWidgetResourcesInHabitat, ComponentsTransitMenuSendResourcesButton, ComponentsTransitMenuAttackButton, ComponentsTransitMenuSupportButton) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuComponentArrivalDate], getNewState: function() {
      return this.slowestUnitSpeed = 0, {
        changedArrivalDate: null,
        totalCapacity: 0,
        totalForExchange: 0,
        tradeResourceAmount: 0,
        unitDictionary: {},
        resourceDictionary: {}
      }
    }, getInitialState: function() {
      return this.getNewState()
    }, componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceNextRedrawUpdate || newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id) && this.setState(this.getNewState(), null)
    }, onAutoFillClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var totalCapacity = utilMoving.computeUnitsCapacity(this.state.unitDictionary, this.props.settings.exchangeableResource), tempResourceDictionary = utilMoving.fillUnitsCapacity({
        availableResources: this.props.settings.availableResources,
        totalCapacity: totalCapacity
      }), totalLoaded = utilMoving.computeTotalResourcesLoaded(tempResourceDictionary);
      this.setState({ resourceDictionary: tempResourceDictionary, totalForExchange: totalLoaded }, null)
    }, onSetValueByRangeSlider: function(dictionaryKey, primaryKey, amount) {
      var totalLoaded, tempResourceDictionary, slowestUnitSpeed, dictionary = this.state[dictionaryKey], newStates = {};
      switch (dictionary[primaryKey] = amount, dictionaryKey) {
        case"unitDictionary":
          var totalCapacity = utilMoving.computeUnitsCapacity(dictionary, this.props.settings.exchangeableResource);
          totalCapacity < utilMoving.computeTotalResourcesLoaded(this.state.resourceDictionary) && (tempResourceDictionary = utilMoving.fillUnitsCapacity({
            availableResources: this.props.settings.availableResources,
            totalCapacity: totalCapacity
          }), newStates.totalForExchange = utilMoving.computeTotalResourcesLoaded(tempResourceDictionary), newStates.resourceDictionary = tempResourceDictionary), slowestUnitSpeed = utilMoving.getSlowestUnitSpeed(dictionary), slowestUnitSpeed !== this.slowestUnitSpeed && (this.slowestUnitSpeed = slowestUnitSpeed, newStates.changedArrivalDate = null), newStates.unitDictionary = dictionary, newStates.totalCapacity = totalCapacity, this.setState(newStates, null);
          break;
        case"resourceDictionary":
          totalLoaded = utilMoving.computeTotalResourcesLoaded(dictionary), newStates.resourceDictionary = dictionary, newStates.totalForExchange = totalLoaded, this.setState(newStates, null)
      }
    }, onAttackButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatSendUnitsResources.startAttack, {
        resources: this.state.resourceDictionary,
        units: this.state.unitDictionary,
        sourceHabitat: this.props.settings.currentHabitat,
        destinationHabitat: this.props.settings.affectedHabitat,
        earliestArrivalTime: this.state.changedArrivalDate,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, onSupportButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatSendUnitsResources.sendSupport, {
        resources: {},
        units: this.state.unitDictionary,
        sourceHabitat: this.props.settings.currentHabitat,
        destinationHabitat: this.props.settings.affectedHabitat,
        earliestArrivalTime: this.state.changedArrivalDate,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, onTransitButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatSendUnitsResources.sendResources, {
        resources: this.state.resourceDictionary,
        units: this.state.unitDictionary,
        sourceHabitat: this.props.settings.currentHabitat,
        destinationHabitat: this.props.settings.affectedHabitat,
        earliestArrivalTime: this.state.changedArrivalDate,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, onSynchronizeAttackButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatSendUnitsResources.synchronizeAttack, {
        resources: this.state.resourceDictionary,
        units: this.state.unitDictionary,
        transit: this.props.settings.transit,
        sourceHabitat: this.props.settings.currentHabitat,
        destinationHabitat: this.props.settings.affectedHabitat,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, onSynchronizeSupportButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuHabitatSendUnitsResources.synchronizeSupport, {
        resources: {},
        units: this.state.unitDictionary,
        transit: this.props.settings.transit,
        sourceHabitat: this.props.settings.currentHabitat,
        destinationHabitat: this.props.settings.affectedHabitat,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, render: function() {
      var settings = {
        isHabitatToFarAway: !1,
        currentHabitat: null,
        affectedHabitat: null,
        distance: 0,
        availableUnits: null,
        availableResources: [],
        mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK,
        showResources: !0,
        showUnits: !0,
        conquestCost: null,
        lastFormationMode: !1,
        transit: null,
        isManualDelayAvailable: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, rightActionButton, rightActionButtonSettings, componentsSections = [], resourcesThemeSettings = servicesTheme.themeSettings.resources, themesIcons = servicesTheme.themeSettings.imagesClassNames, startTransitIcons = themesIcons.startTransit;
      if (settings.isHabitatToFarAway)sectionComponentSettings = { text: servicesInternationalization.localize("Castle is too far away") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "too-far"
      })); else if (settings.availableUnits.length) {
        sectionComponentSettings = { title: servicesInternationalization.localize("Target habitat") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "title-attacking-habitat"
        })), sectionComponentSettings = {
          initialComponent: this,
          habitat: settings.affectedHabitat
        }, componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
          settings: sectionComponentSettings,
          key: "attacking-habitat"
        })), settings.transit && (sectionComponentSettings = { text: servicesInternationalization.localize("Destination ETA") + ": " + utilsDateTime.getLocaleDateTimeString(settings.transit.destinationETA) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "synchronized-arrival-time"
        }))), settings.affectedHabitat.isOwnByPlayer && settings.mode === settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SEND_RESOURCES && (sectionComponentSettings = { resourceDictionary: settings.affectedHabitat.habitatResourceDictionary }, componentsSections.push(React.createElement(ComponentsWidgetResourcesInHabitat, {
          settings: sectionComponentSettings,
          key: "widget-resources-in-habitat"
        }))), sectionComponentSettings = { title: servicesInternationalization.localize("Transport units") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "title-transport-unit"
        })), settings.availableUnits.forEach(function(UnitAmountObject) {
          var unitArrivalTime, unit = UnitAmountObject.unit, unitPrimaryKey = unit.primaryKey;
          sectionComponentSettings = {
            handleIcon: unit.icon,
            currentValue: this.state.unitDictionary[unitPrimaryKey] || 0,
            minValue: 0,
            maxValue: UnitAmountObject.amount,
            title: unit.title,
            onChange: this.onSetValueByRangeSlider.bind(this, "unitDictionary", unitPrimaryKey)
          }, settings.transit && (unitArrivalTime = utilMoving.getArrivalTimeOfUnit(unit, { distance: settings.distance }), sectionComponentSettings.disabled = unitArrivalTime > settings.transit.destinationETA), componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
            settings: sectionComponentSettings,
            key: "transportation-unit-range-slider-" + unitPrimaryKey
          }))
        }, this);
        var cycle, destinationDate, transportTimeInSeconds = utilMoving.getTransportationTime(this.state.unitDictionary, { distance: settings.distance }), arrivalDate = utilMoving.getArrivalTime(this.state.unitDictionary, { distance: settings.distance }), worldSettings = servicesWorldSettings.settings, manualDelayInSeconds = 0;
        if (this.state.changedArrivalDate && arrivalDate && (manualDelayInSeconds = (this.state.changedArrivalDate.getTime() - arrivalDate.getTime()) / 1e3 | 0, manualDelayInSeconds < 0 ? manualDelayInSeconds = 0 : transportTimeInSeconds += manualDelayInSeconds), sectionComponentSettings = {
                  iconLeft: themesIcons.transportTime,
                  title: servicesInternationalization.localize("Transport duration"),
                  rightColumnDataValue: utilsDateTime.secondsToTimeString(transportTimeInSeconds, !0)
                }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: sectionComponentSettings,
                  key: "transport-time"
                })), settings.transit) {
          var delayInSeconds = 0;
          destinationDate = settings.transit.destinationETA, cycle = utilsDateTime.getDayCycle(destinationDate), utilsObject.effectiveLength(this.state.unitDictionary) && (delayInSeconds = (destinationDate.getTime() - arrivalDate.getTime()) / 1e3 | 0, delayInSeconds < 0 && (delayInSeconds = 0)), sectionComponentSettings = {
            delayInSeconds: delayInSeconds,
            iconLeft: themesIcons.featureSynchronizeTransit.timeDelay,
            title: servicesInternationalization.localize("Delay"),
            showFAQlink: !1,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsWidgetTimeDelay, {
            settings: sectionComponentSettings,
            key: "transit-delay-element"
          })), sectionComponentSettings = {
            iconLeft: startTransitIcons.transportTime,
            title: servicesInternationalization.localize("Destination ETA"),
            rightColumnLeftIcon: "icon-game colored icon-" + cycle + "Icon",
            rightColumnDataValue: utilsDateTime.getLocaleDateTimeString(destinationDate)
          }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
            settings: sectionComponentSettings,
            key: "arrival-time"
          }))
        } else if (cycle = utilsDateTime.getDayCycle(arrivalDate), utilsObject.effectiveLength(this.state.unitDictionary))if (settings.isManualDelayAvailable) {
          var delayPercentage = worldSettings.transitDelayMaximumPercentage, maxDelayTimeInSeconds = transportTimeInSeconds * delayPercentage / 100, minDate = new Date, maxDate = new Date;
          maxDelayTimeInSeconds < worldSettings.transitDelayLowerLimitBoundSeconds && (maxDelayTimeInSeconds = worldSettings.transitDelayLowerLimitBoundSeconds), maxDelayTimeInSeconds > worldSettings.transitDelayUpperLimitBoundSeconds && (maxDelayTimeInSeconds = worldSettings.transitDelayUpperLimitBoundSeconds), minDate.setTime(arrivalDate.getTime()), maxDate.setTime(minDate.getTime() + 1e3 * maxDelayTimeInSeconds), sectionComponentSettings = {
            forceNextRedrawUpdate: !0,
            currentDate: this.state.changedArrivalDate || arrivalDate,
            minDate: minDate,
            maxDate: maxDate,
            isResetAvailable: !0,
            onReset: this.onArrivalDateReset.bind(this, arrivalDate),
            onSubmit: this.onArrivalDateSubmit,
            isDisabled: 0 === transportTimeInSeconds
          }, componentsSections.push(React.createElement(ComponentsWidgetDateTimePicker, {
            settings: sectionComponentSettings,
            key: "time-picker"
          }))
        } else sectionComponentSettings = {
          iconLeft: startTransitIcons.transportTime,
          title: servicesInternationalization.localize("Destination ETA"),
          rightColumnLeftIcon: "icon-game colored icon-" + cycle + "Icon",
          rightColumnDataValue: utilsDateTime.getLocaleDateTimeString(arrivalDate)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "arrival-time"
        })); else sectionComponentSettings = {
          iconLeft: startTransitIcons.transportTime,
          title: servicesInternationalization.localize("Destination ETA"),
          rightColumnDataValue: settingsGameConstant.ARRIVAL_DEFAULT_TIME
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "arrival-time"
        }));
        if (settings.transit || (sectionComponentSettings = {
                  delayInSeconds: manualDelayInSeconds,
                  initialComponent: this
                }, componentsSections.push(React.createElement(ComponentsWidgetTimeDelay, {
                  settings: sectionComponentSettings,
                  key: "time-delay-element"
                }))), settings.showResources && (rightActionButtonSettings = {
                  icon: "white " + startTransitIcons.fillTransport,
                  onClick: this.onAutoFillClick
                }, rightActionButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightActionButtonSettings }), sectionComponentSettings = {
                  iconLeft: startTransitIcons.capacity,
                  title: servicesInternationalization.localize("Transport capacity"),
                  rightColumnDataValue: this.state.totalForExchange + "/" + this.state.totalCapacity,
                  iconRight: rightActionButton
                }, this.state.totalForExchange <= 0 ? sectionComponentSettings.classes = "bad-value" : sectionComponentSettings.classes = "good-value", componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: sectionComponentSettings, key: "capacity-total"
                })), sectionComponentSettings = { title: servicesInternationalization.localize("Offered resources") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                  settings: sectionComponentSettings,
                  key: "title-transport-resurces"
                })), settings.availableResources)) {
          var freeSpace = this.state.totalCapacity - this.state.totalForExchange, maxLimitOnValue = freeSpace >= 0 ? freeSpace : 0;
          settings.availableResources.forEach(function(resourceIdAmountObject) {
            var resourceId = resourceIdAmountObject.resourceId, currentValue = this.state.resourceDictionary[resourceId] || 0;
            sectionComponentSettings = {
              handleIcon: "icon icon-resource icon-resource-" + resourceId,
              currentValue: currentValue,
              minValue: 0,
              maxValue: resourceIdAmountObject.amount,
              maxLimitOnCurrentValue: maxLimitOnValue + currentValue,
              changeStepValue: resourceIdAmountObject.exchangeRate,
              title: servicesInternationalization.localize(resourcesThemeSettings[resourceId]),
              onChange: this.onSetValueByRangeSlider.bind(this, "resourceDictionary", resourceId)
            }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
              settings: sectionComponentSettings,
              key: "transportation-resource-range-slider-" + resourceId
            }))
          }, this)
        }
        switch (settings.conquestCost && (sectionComponentSettings = { text: servicesInternationalization.localize("Needed for conquest: %@", settings.conquestCost) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-conquest-cost"
        }))), settings.mode) {
          case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK:
            sectionComponentSettings = {
              onClick: this.onAttackButtonClick,
              mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK,
              initialComponent: this
            }, componentsSections.push(React.createElement(ComponentsTransitMenuAttackButton, {
              settings: sectionComponentSettings,
              key: "button-action"
            }));
            break;
          case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK_SYNC:
            sectionComponentSettings = {
              onClick: this.onSynchronizeAttackButtonClick,
              mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK_SYNC,
              initialComponent: this
            }, componentsSections.push(React.createElement(ComponentsTransitMenuAttackButton, {
              settings: sectionComponentSettings,
              key: "button-action"
            }));
            break;
          case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT:
            sectionComponentSettings = {
              onClick: this.onSupportButtonClick,
              initialComponent: this
            }, componentsSections.push(React.createElement(ComponentsTransitMenuSupportButton, {
              settings: sectionComponentSettings,
              key: "button-action"
            }));
            break;
          case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT_SYNC:
            sectionComponentSettings = {
              onClick: this.onSynchronizeSupportButtonClick,
              mode: settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT_SYNC,
              initialComponent: this
            }, componentsSections.push(React.createElement(ComponentsTransitMenuSupportButton, {
              settings: sectionComponentSettings,
              key: "button-action"
            }));
            break;
          case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SEND_RESOURCES:
            sectionComponentSettings = {
              onClick: this.onTransitButtonClick,
              initialComponent: this
            }, componentsSections.push(React.createElement(ComponentsTransitMenuSendResourcesButton, {
              settings: sectionComponentSettings,
              key: "button-action"
            }))
        }
      } else sectionComponentSettings = { text: servicesInternationalization.localize("Action not available") + "\n" + servicesInternationalization.localize("There are no units in the castle you have chosen. Recruit new troops, to perform this action.") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "too-far"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendUnitsResources.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.eventManager, function(CoreControllerElementMenu, utilsOop, utilsObject, settingsGameConstant, servicesInternationalization, servicesEventManager) {
  "use strict";
  function MenuHabitatSendUnitsResourcesController(options) {
    MenuHabitatSendUnitsResourcesController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuHabitatSendUnitsResourcesController, CoreControllerElementMenu), MenuHabitatSendUnitsResourcesController.prototype[xy.eNames.menuHabitatSendUnitsResources.dataIsReady] = function(data) {
    data.mode === settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK && servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.menuAttackHabitatOpened), this.presenter.draw(data)
  }, MenuHabitatSendUnitsResourcesController.prototype[xy.eNames.menuHabitatSendUnitsResources.startAttack] = function(options) {
    return utilsObject.effectiveLength(options.units) ? void this.dataSource.initiateAttackTransit(options) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("Please assign more transport units or reduce the amount of resources.")
    })
  }, MenuHabitatSendUnitsResourcesController.prototype[xy.eNames.menuHabitatSendUnitsResources.synchronizeAttack] = function(options) {
    return utilsObject.effectiveLength(options.units) ? void this.dataSource.synchronizeAttackTransit(options) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("Please assign more transport units or reduce the amount of resources.")
    })
  }, MenuHabitatSendUnitsResourcesController.prototype[xy.eNames.menuHabitatSendUnitsResources.sendSupport] = function(options) {
    return utilsObject.effectiveLength(options.units) ? void this.dataSource.initiateSupportTransit(options) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("Please assign more transport units or reduce the amount of resources.")
    })
  }, MenuHabitatSendUnitsResourcesController.prototype[xy.eNames.menuHabitatSendUnitsResources.synchronizeSupport] = function(options) {
    return utilsObject.effectiveLength(options.units) ? void this.dataSource.synchronizeSupportTransit(options) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("Please assign more transport units or reduce the amount of resources.")
    })
  }, MenuHabitatSendUnitsResourcesController.prototype[xy.eNames.menuHabitatSendUnitsResources.sendResources] = function(options) {
    return utilsObject.effectiveLength(options.units) ? utilsObject.effectiveLength(options.resources) ? void this.dataSource.initiateResourcesTransit(options) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("AlertMessageNoResourcesSelected")
    }) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("Please assign more transport units or reduce the amount of resources.")
    })
  }, MenuHabitatSendUnitsResourcesController.prototype.setLocalizedName = function() {
    var name;
    switch (this.initialOptions.mode) {
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK:
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK_SYNC:
        name = "Attack";
        break;
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT:
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT_SYNC:
        name = "Defend Habitat";
        break;
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SEND_RESOURCES:
        name = "Send Resources"
    }
    this.localizedName = servicesInternationalization.localize(name)
  }, MenuHabitatSendUnitsResourcesController.prototype.prepareDataForDraw = function() {
    var data, forceNextRedrawUpdate = !1;
    this.isActive && (this.forceNextRedrawUpdate && (forceNextRedrawUpdate = !0, this.forceNextRedrawUpdate = !1), data = {
      mode: this.initialOptions.mode,
      attackingHabitat: this.initialOptions.attackingHabitat,
      forceNextRedrawUpdate: forceNextRedrawUpdate
    }, this.initialOptions.transit && (data.transit = this.initialOptions.transit), this.dataSource.prepareDataForHabitatAttack(data))
  }, MenuHabitatSendUnitsResourcesController
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendUnitsResources.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.storage, xy.dNames.services.worldSettings, xy.dNames.services.eventManager, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesTheme, serviceStorage, servicesWorldSettings, servicesEventManager) {
  "use strict";
  function MenuHabitatSendUnitsResourcesDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "synchronizeTransit"
    }], MenuHabitatSendUnitsResourcesDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatSendUnitsResourcesDataSource, CoreDataSource), MenuHabitatSendUnitsResourcesDataSource.prototype.prepareDataForHabitatAttack = function(options) {
    var isHabitatToFarAway, affectedHabitatId, affectedHabitat, distance, unitsAmountObject, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    if (options.transit ? affectedHabitatId = options.transit.destinationHabitat : options.attackingHabitat && (affectedHabitatId = options.attackingHabitat.id), affectedHabitat = servicesGameDataManager.habitatsCollection.getHabitat(affectedHabitatId), distance = currentHabitat.computeDistanceBetweenHabitats(affectedHabitat), isHabitatToFarAway = currentHabitat.isAnotherHabitatToFarAway(distance), data.isTimerable = !1, data.currentHabitat = currentHabitat, data.affectedHabitat = affectedHabitat, data.distance = distance, isHabitatToFarAway)return data.isHabitatToFarAway = !0, void this.notify(xy.eNames.menuHabitatSendUnitsResources.dataIsReady, data);
    unitsAmountObject = servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
      habitatId: currentHabitat.id,
      habitat: currentHabitat
    });
    var unitsPK, availableUnits = [];
    for (unitsPK in unitsAmountObject)unitsAmountObject.hasOwnProperty(unitsPK) && availableUnits.push({
      unit: servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitsPK }),
      amount: unitsAmountObject[unitsPK]
    });
    data.availableUnits = availableUnits;
    var player, exchangeableResource, themeResourcesSettings = servicesTheme.themeSettings.resources, themeConquestResourceId = themeResourcesSettings.conquestResourceId, availableResources = [], manDelayIsAvailableForMode = !0;
    switch (options.mode) {
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK:
        player = servicesGameDataManager.playersCollection.getPlayer(), data.conquestCost = player.conquerResourceAmountForTypeDictionary[affectedHabitat.publicHabitatType][themeConquestResourceId], exchangeableResource = [themeConquestResourceId], data.lastFormationMode = settingsGameConstant.LAST_FORMATION_MODE.ATTACK, availableResources.push({
          resourceId: themeConquestResourceId,
          amount: currentHabitat.habitatResourceDictionary[themeConquestResourceId].amount || 0,
          exchangeRate: 1
        });
        break;
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK_SYNC:
        player = servicesGameDataManager.playersCollection.getPlayer(), data.conquestCost = player.conquerResourceAmountForTypeDictionary[affectedHabitat.publicHabitatType][themeConquestResourceId], exchangeableResource = [themeConquestResourceId], availableResources.push({
          resourceId: themeConquestResourceId,
          amount: currentHabitat.habitatResourceDictionary[themeConquestResourceId].amount || 0,
          exchangeRate: 1
        }), data.transit = options.transit, manDelayIsAvailableForMode = !1, data.lastFormationMode = settingsGameConstant.LAST_FORMATION_MODE.ATTACK;
        break;
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT:
        data.showResources = !1, exchangeableResource = themeResourcesSettings.supportResources, data.lastFormationMode = settingsGameConstant.LAST_FORMATION_MODE.SUPPORT;
        break;
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT_SYNC:
        data.showResources = !1, exchangeableResource = themeResourcesSettings.supportResources, manDelayIsAvailableForMode = !1, data.transit = options.transit, data.lastFormationMode = settingsGameConstant.LAST_FORMATION_MODE.SUPPORT;
        break;
      case settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SEND_RESOURCES:
        exchangeableResource = affectedHabitat.isOwnByPlayer ? themeResourcesSettings.transitResourcesWithOwnHabitat : themeResourcesSettings.transitResources, data.lastFormationMode = settingsGameConstant.LAST_FORMATION_MODE.SEND_RESOURCE, exchangeableResource.forEach(function(resourceId) {
          availableResources.push({
            resourceId: resourceId,
            amount: currentHabitat.habitatResourceDictionary[resourceId].amount || 0,
            exchangeRate: 1
          })
        })
    }
    data.exchangeableResource = exchangeableResource, data.availableResources = availableResources, data.mode = options.mode, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, servicesWorldSettings.settings.featureManuallyDelayedTransits && manDelayIsAvailableForMode && (data.isManualDelayAvailable = !0), this.notify(xy.eNames.menuHabitatSendUnitsResources.dataIsReady, data)
  }, MenuHabitatSendUnitsResourcesDataSource.prototype.initiateAttackTransit = function(options) {
    servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.transitAttackTransitStarted), options.transitType = settingsGameConstant.TRANSIT_TYPE.ATTACK, this.startTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuHabitatSendUnitsResourcesDataSource.prototype.synchronizeAttackTransit = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.ATTACK, this.synchronizeTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuHabitatSendUnitsResourcesDataSource.prototype.initiateSupportTransit = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.DEFENSE, this.startTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuHabitatSendUnitsResourcesDataSource.prototype.synchronizeSupportTransit = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.DEFENSE, this.synchronizeTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuHabitatSendUnitsResourcesDataSource.prototype.initiateResourcesTransit = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.TRANSPORT, this.startTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuHabitatSendUnitsResourcesDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendUnitsResources.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatSendUnitsResources.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatSendUnitsResourcesComponent) {
  "use strict";
  function MenuHabitatSendUnitsResourcesPresenter(options) {
    MenuHabitatSendUnitsResourcesPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatSendUnitsResourcesPresenter, CorePresenterElementMenu), MenuHabitatSendUnitsResourcesPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatSendUnitsResourcesComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data,
      key: this.instanceId
    }), document.getElementById(this.domElement))
  }, MenuHabitatSendUnitsResourcesPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSortingChooser.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onSortingButtonClick: function(newSortingFunction, mode, event) {
      switch (event.preventDefault(), mode) {
        case settingsGameConstant.SORTING_HABITAT_CHOOSER_MODE.EXTERNAL_PLAYER:
          this.props.presenter.notify(xy.eNames.menuHabitatSortingChooser.setNewSorting, { newSortingFunction: newSortingFunction })
      }
    },
    render: function() {
      var settings = {
        sortingList: [],
        activeSortingFunction: settingsGameConstant.SORTING_HABITAT_FUNCTION.ALPHABET,
        mode: settingsGameConstant.SORTING_HABITAT_CHOOSER_MODE.EXTERNAL_PLAYER
      };
      Object.assign(settings, this.props.settings);
      var themeSettings = servicesTheme.themeSettings, themeIcons = themeSettings.imagesClassNames, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = themeIcons.controls.close : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var componentsSections = [];
      settings.sortingList.forEach(function(sortingFunctionName, index) {
        var localComponentSettings = {
          title: servicesInternationalization.localize(themeSettings.habitatSortingNames[sortingFunctionName]),
          iconLeft: "icon-game icon-Sorting" + sortingFunctionName,
          onClick: this.onSortingButtonClick.bind(this, sortingFunctionName, settings.mode)
        };
        sortingFunctionName === settings.activeSortingFunction ? (localComponentSettings.iconRight = themeIcons.controls.checked, localComponentSettings.classes = " active") : localComponentSettings.iconRight = themeIcons.controls.next, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "sorting-function" + index
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSortingChooser.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuHabitatSortingChooserController(options) {
    MenuHabitatSortingChooserController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Sorting options")
  }

  return utilsOop.extend(MenuHabitatSortingChooserController, CoreControllerElementMenu), MenuHabitatSortingChooserController.prototype[xy.eNames.menuHabitatSortingChooser.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuHabitatSortingChooserController.prototype[xy.eNames.menuHabitatSortingChooser.setNewSorting] = function(options) {
    this.dataSource.setNewSortingFunction(options)
  }, MenuHabitatSortingChooserController.prototype[xy.eNames.menuHabitatSortingChooser.sortingSetHandler] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuHabitatSortingChooserController.prototype.prepareDataForDraw = function() {
    var mode = this.initialOptions.mode, data = { mode: mode };
    this.isActive && this.dataSource.buildUnitsList(data)
  }, MenuHabitatSortingChooserController
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSortingChooser.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuHabitatSortingChooserDataSource(options) {
    MenuHabitatSortingChooserDataSource.__super__.constructor.call(this, options), this.mode = settingsGameConstant.SORTING_HABITAT_CHOOSER_MODE.EXTERNAL_PLAYER
  }

  return utilsOop.extend(MenuHabitatSortingChooserDataSource, CoreDataSource), MenuHabitatSortingChooserDataSource.prototype.buildUnitsList = function(options) {
    var data = {}, mode = options.mode;
    this.mode = mode, data.sortingList = settingsGameConstant.SORTING_HABITAT_CHOOSER_LIST[mode], data.activeSortingFunction = servicesGameDataManager.habitatsCollection.sortingForeignFunction, data.mode = mode, this.notify(xy.eNames.menuHabitatSortingChooser.dataIsReady, data)
  }, MenuHabitatSortingChooserDataSource.prototype.setNewSortingFunction = function(options) {
    options = options || {};
    var habitatsCollection = servicesGameDataManager.habitatsCollection;
    switch (this.mode) {
      case settingsGameConstant.SORTING_HABITAT_CHOOSER_MODE.EXTERNAL_PLAYER:
        habitatsCollection.sortingForeignFunction = options.newSortingFunction
    }
    this.notify(xy.eNames.menuHabitatSortingChooser.sortingSetHandler)
  }, MenuHabitatSortingChooserDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSortingChooser.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatSortingChooser.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatSortingChooserComponent) {
  "use strict";
  function MenuHabitatSortingChooserPresenter(options) {
    MenuHabitatSortingChooserPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatSortingChooserPresenter, CorePresenterElementMenu), MenuHabitatSortingChooserPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatSortingChooserComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuHabitatSortingChooserPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendSpy.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.mixins.menuComponentArrivalDate, xy.dNames.utils.moving, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListButtonBasic, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetRangeSliderDivider, xy.dNames.components.widgetDateTimePicker, xy.dNames.components.widgetTimeDelay, xy.dNames.components.transitMenuSendSpyButton, function(componentsEngine, mixinsMenuComponentHandlers, mixinsMenuComponentArrivalDate, utilMoving, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesTheme, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsMenuListButtonBasic, ComponentsHabitatMenuElement, ComponentsWidgetRangeSliderDivider, ComponentsWidgetDateTimePicker, ComponentsWidgetTimeDelay, ComponentsTransitMenuSendSpyButton) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers, mixinsMenuComponentArrivalDate], getNewState: function(settings) {
      return {
        totalCapacity: settings.totalCapacity,
        changedArrivalDate: null,
        totalForExchange: 0,
        tradeResourceAmount: 0,
        resourceDictionary: {}
      }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceNextRedrawUpdate || newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id) && this.setState(this.getNewState(newProps.settings), null)
    }, onAutoFillClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var totalCapacity = this.state.totalCapacity, tempResourceDictionary = utilMoving.fillUnitsCapacity({
        availableResources: this.props.settings.availableResources,
        totalCapacity: totalCapacity
      }), totalLoaded = utilMoving.computeTotalResourcesLoaded(tempResourceDictionary);
      this.setState({ resourceDictionary: tempResourceDictionary, totalForExchange: totalLoaded }, null)
    }, onSetValueByRangeSlider: function(dictionaryKey, primaryKey, amount) {
      var totalLoaded, dictionary = this.state[dictionaryKey], newStates = {};
      switch (dictionary[primaryKey] = amount, dictionaryKey) {
        case"resourceDictionary":
          totalLoaded = utilMoving.computeTotalResourcesLoaded(dictionary), newStates.resourceDictionary = dictionary, newStates.totalForExchange = totalLoaded, totalLoaded || (newStates.changedArrivalDate = null), this.setState(newStates, null)
      }
    }, onSendSpyButtonClick: function(event) {
      event.preventDefault();
      var spyResourceId = servicesTheme.themeSettings.resources.spyResourceId;
      this.props.presenter.notify(xy.eNames.menuHabitatSendSpy.sendSpy, {
        spyResourceAmount: this.state.resourceDictionary[spyResourceId],
        sourceHabitat: this.props.settings.currentHabitat,
        destinationHabitat: this.props.settings.affectedHabitat,
        earliestArrivalTime: this.state.changedArrivalDate,
        lastFormationMode: this.props.settings.lastFormationMode
      })
    }, render: function() {
      var settings = {
        currentHabitat: null,
        affectedHabitat: null,
        isHabitatToFarAway: !1,
        exchangeableResource: null,
        distance: 0,
        spySpeed: 10,
        availableResources: [],
        lastFormationMode: !1,
        isManualDelayAvailable: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, rightActionButton, rightActionButtonSettings, componentsSections = [], resourcesThemeSettings = servicesTheme.themeSettings.resources, themesIcons = servicesTheme.themeSettings.imagesClassNames.startTransit;
      if (settings.isHabitatToFarAway)sectionComponentSettings = { text: servicesInternationalization.localize("Castle is too far away") }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "too-far"
      })); else {
        if (sectionComponentSettings = { title: servicesInternationalization.localize("Target habitat") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                  settings: sectionComponentSettings,
                  key: "title-affected-habitat"
                })), sectionComponentSettings = {
                  initialComponent: this,
                  habitat: settings.affectedHabitat
                }, componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
                  settings: sectionComponentSettings,
                  key: "affected-habitat"
                })), sectionComponentSettings = { title: servicesInternationalization.localize("Offered resources") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                  settings: sectionComponentSettings,
                  key: "title-transport-resurces"
                })), settings.availableResources) {
          var freeSpace = this.state.totalCapacity - this.state.totalForExchange, maxLimitOnValue = freeSpace >= 0 ? freeSpace : 0;
          settings.availableResources.forEach(function(resourceIdAmountObject) {
            var resourceId = resourceIdAmountObject.resourceId, currentValue = this.state.resourceDictionary[resourceId] || 0;
            sectionComponentSettings = {
              handleIcon: "icon icon-resource icon-resource-" + resourceId,
              currentValue: currentValue,
              minValue: 0,
              maxValue: resourceIdAmountObject.amount,
              maxLimitOnCurrentValue: maxLimitOnValue + currentValue,
              changeStepValue: resourceIdAmountObject.exchangeRate,
              title: servicesInternationalization.localize(resourcesThemeSettings[resourceId]),
              onChange: this.onSetValueByRangeSlider.bind(this, "resourceDictionary", resourceId)
            }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
              settings: sectionComponentSettings,
              key: "transportation-resource-range-slider-" + resourceId
            }))
          }, this)
        }
        var transportTimeInSeconds = utilMoving.getTransportationTime(null, {
          spySpeed: settings.spySpeed,
          distance: settings.distance
        }), arrivalDate = utilMoving.getArrivalTime(null, {
          spySpeed: settings.spySpeed,
          distance: settings.distance
        }), cycle = utilsDateTime.getDayCycle(arrivalDate), worldSettings = servicesWorldSettings.settings, manualDelayInSeconds = 0;
        if (this.state.changedArrivalDate && arrivalDate && (manualDelayInSeconds = (this.state.changedArrivalDate.getTime() - arrivalDate.getTime()) / 1e3 | 0, manualDelayInSeconds < 0 ? manualDelayInSeconds = 0 : transportTimeInSeconds += manualDelayInSeconds), sectionComponentSettings = {
                  iconLeft: themesIcons.transportTime,
                  title: servicesInternationalization.localize("Transport duration"),
                  rightColumnDataValue: utilsDateTime.secondsToTimeString(transportTimeInSeconds, !0)
                }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: sectionComponentSettings,
                  key: "transport-time"
                })), settings.isManualDelayAvailable) {
          var delayPercentage = worldSettings.transitDelayMaximumPercentage, maxDelayTimeInSeconds = transportTimeInSeconds * delayPercentage / 100, minDate = new Date, maxDate = new Date;
          maxDelayTimeInSeconds < worldSettings.transitDelayLowerLimitBoundSeconds && (maxDelayTimeInSeconds = worldSettings.transitDelayLowerLimitBoundSeconds), maxDelayTimeInSeconds > worldSettings.transitDelayUpperLimitBoundSeconds && (maxDelayTimeInSeconds = worldSettings.transitDelayUpperLimitBoundSeconds), minDate.setTime(arrivalDate.getTime()), maxDate.setTime(minDate.getTime() + 1e3 * maxDelayTimeInSeconds), sectionComponentSettings = {
            forceNextRedrawUpdate: !0,
            currentDate: this.state.changedArrivalDate || arrivalDate,
            minDate: minDate,
            maxDate: maxDate,
            isResetAvailable: !0,
            onReset: this.onArrivalDateReset.bind(this, arrivalDate),
            onSubmit: this.onArrivalDateSubmit,
            isDisabled: 0 === utilsObject.effectiveLength(this.state.resourceDictionary)
          }, componentsSections.push(React.createElement(ComponentsWidgetDateTimePicker, {
            settings: sectionComponentSettings,
            key: "time-picker"
          })), sectionComponentSettings = {
            delayInSeconds: manualDelayInSeconds,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsWidgetTimeDelay, {
            settings: sectionComponentSettings,
            key: "time-delay-element"
          }))
        } else sectionComponentSettings = {
          iconLeft: themesIcons.transportTime,
          title: servicesInternationalization.localize("Destination ETA"),
          rightColumnLeftIcon: "icon-game colored icon-" + cycle + "Icon",
          rightColumnDataValue: utilsDateTime.getLocaleDateTimeString(arrivalDate)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "arrival-time"
        }));
        rightActionButtonSettings = {
          icon: "white " + themesIcons.fillTransport,
          onClick: this.onAutoFillClick
        }, rightActionButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightActionButtonSettings }), sectionComponentSettings = {
          iconLeft: themesIcons.capacity,
          title: servicesInternationalization.localize("Transport capacity"),
          rightColumnDataValue: this.state.totalForExchange + "/" + this.state.totalCapacity,
          iconRight: rightActionButton
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "capacity-total"
        })), sectionComponentSettings = {
          onClick: this.onSendSpyButtonClick,
          initialComponent: this
        }, componentsSections.push(React.createElement(ComponentsTransitMenuSendSpyButton, {
          settings: sectionComponentSettings,
          key: "button-start-attack"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting
      })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendSpy.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.theme, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesTheme) {
  "use strict";
  function MenuHabitatSendSpyController(options) {
    MenuHabitatSendSpyController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Send Spy"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuHabitatSendSpyController, CoreControllerElementMenu), MenuHabitatSendSpyController.prototype[xy.eNames.menuHabitatSendSpy.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuHabitatSendSpyController.prototype[xy.eNames.menuHabitatSendSpy.sendSpy] = function(options) {
    if (!options.spyResourceAmount) {
      var spyResourceId = servicesTheme.themeSettings.resources.spyResourceId, spyResourceTitleLocalized = servicesInternationalization.localize(servicesTheme.themeSettings.resources[spyResourceId]), text = servicesInternationalization.localize("Resources needed") + ": " + spyResourceTitleLocalized;
      return void this.showDialogAlert({ title: servicesInternationalization.localize("Resources needed"), text: text })
    }
    this.dataSource.initiateSpyAction(options)
  }, MenuHabitatSendSpyController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = !1;
    this.isActive && (this.forceNextRedrawUpdate && (forceNextRedrawUpdate = !0, this.forceNextRedrawUpdate = !1), this.dataSource.prepareDataForHabitatAttack({
      affectedHabitat: this.initialOptions.affectedHabitat,
      forceNextRedrawUpdate: forceNextRedrawUpdate
    }))
  }, MenuHabitatSendSpyController
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendSpy.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.services.storage, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesTheme, servicesWorldSettings, serviceStorage) {
  "use strict";
  function MenuHabitatSendSpyDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }], MenuHabitatSendSpyDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatSendSpyDataSource, CoreDataSource), MenuHabitatSendSpyDataSource.prototype.prepareDataForHabitatAttack = function(options) {
    var distance, isHabitatToFarAway, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), affectedHabitat = servicesGameDataManager.habitatsCollection.getHabitat(options.affectedHabitat.id);
    if (distance = currentHabitat.computeDistanceBetweenHabitats(affectedHabitat), isHabitatToFarAway = currentHabitat.isAnotherHabitatToFarAway(distance), data.currentHabitat = currentHabitat, data.affectedHabitat = affectedHabitat, data.distance = distance, data.spySpeed = servicesWorldSettings.settings.spyAttackSecondsPerField, isHabitatToFarAway)return data.isHabitatToFarAway = !0, void this.notify(xy.eNames.menuHabitatSendSpy.dataIsReady, data);
    var themeSpyResourceId = servicesTheme.themeSettings.resources.spyResourceId, availableSpyResources = currentHabitat.habitatResourceDictionary[themeSpyResourceId].amount || 0, availableResources = [];
    availableResources.push({
      resourceId: themeSpyResourceId,
      amount: availableSpyResources,
      exchangeRate: 1
    }), data.lastFormationMode = settingsGameConstant.LAST_FORMATION_MODE.SEND_SPY, data.totalCapacity = availableSpyResources, data.availableResources = availableResources, data.exchangeableResource = [themeSpyResourceId], data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, servicesWorldSettings.settings.featureManuallyDelayedTransits && (data.isManualDelayAvailable = !0), this.notify(xy.eNames.menuHabitatSendSpy.dataIsReady, data)
  }, MenuHabitatSendSpyDataSource.prototype.initiateSpyAction = function(options) {
    var param = {
      sourceHabitatID: options.sourceHabitat.id,
      destinationHabitatID: options.destinationHabitat.id,
      copperAmount: options.spyResourceAmount
    };
    options.earliestArrivalTime && (param.earliestArrivalTime = options.earliestArrivalTime.valueOf()), this.request(param, "SpyAction/startSpyingTransit", { callBack: this.onInitiateSpyAction.bind(this, options) })
  }, MenuHabitatSendSpyDataSource.prototype.onInitiateSpyAction = function(options, data) {
    if (!data.error && options.lastFormationMode === settingsGameConstant.LAST_FORMATION_MODE.SEND_SPY && !options.disableLastFormationCacheRewriting) {
      var resourcesDictionary = {};
      resourcesDictionary[servicesTheme.themeSettings.resources.spyResourceId] = options.spyResourceAmount, serviceStorage.storeLastFormationUnits({
        lastFormationMode: settingsGameConstant.LAST_FORMATION_MODE.SEND_SPY,
        resourcesDictionary: resourcesDictionary
      })
    }
    this.handleSessionUpdateResponse(data), this.controller.forceNextRedrawUpdate = !0
  }, MenuHabitatSendSpyDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuHabitatSendSpy.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatSendSpy.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatSendSpyComponent) {
  "use strict";
  function MenuHabitatSendSpyPresenter(options) {
    MenuHabitatSendSpyPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatSendSpyPresenter, CorePresenterElementMenu), MenuHabitatSendSpyPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatSendSpyComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data,
      key: this.instanceId
    }), document.getElementById(this.domElement))
  }, MenuHabitatSendSpyPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitList.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.unitsListLocalAttackers, xy.dNames.components.unitsListLocalDefenders, xy.dNames.components.unitsListExternalAttackers, xy.dNames.components.unitsListExternalDefenders, xy.dNames.game.menuBuildingOverview.componentMissions, xy.dNames.components.transitExternalListButton, xy.dNames.components.transitsSummary, xy.dNames.components.transitList, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsUnitsListLocalAttackers, ComponentsUnitsListLocalDefenders, ComponentsUnitsListExternalAttackers, ComponentsUnitsListExternalDefenders, MenuBuildingOverviewComponentMissions, ComponentsTransitExternalListButton, ComponentsTransitsSummary, ComponentsTransitList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = {
        currentHabitat: null,
        attackersAll: null,
        defendersAll: null,
        attackerExternal: null,
        defendersExternal: null,
        isTransitsOmitted: !1,
        transits: null,
        activeMissions: null,
        isSupportBridgeAvailable: !1
      }, iconTheme = servicesTheme.themeSettings.imagesClassNames, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick), settings.isSupportBridgeAvailable && (titleSettings.rightButton = [], titleSettings.rightButton.push({
        icon: iconTheme.featureSupportBridge.supportBridgeControl,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuSupportBridge.name,
          options: { habitatId: settings.currentHabitat.id }
        })
      }));
      var sectionComponentSettings, componentsSections = [];
      settings.attackersAll && (sectionComponentSettings = {
        initialComponent: this,
        attackers: settings.attackersAll,
        habitat: settings.currentHabitat
      }, componentsSections.push(React.createElement(ComponentsUnitsListLocalAttackers, {
        settings: sectionComponentSettings,
        key: "menu--local-attackers-list"
      }))), settings.defendersAll && (sectionComponentSettings = {
        initialComponent: this,
        isCurrentHabitatUnitList: !0,
        defenders: settings.defendersAll,
        habitat: settings.currentHabitat,
        massSendBackActionType: settingsGameConstant.SEND_ALL_UNITS_BACK.RETURN_LOCAL_DEFENDERS
      }, componentsSections.push(React.createElement(ComponentsUnitsListLocalDefenders, {
        settings: sectionComponentSettings,
        key: "menu--local-defenders-list"
      }))), settings.attackerExternal && (sectionComponentSettings = {
        initialComponent: this,
        attackers: settings.attackerExternal,
        habitat: settings.currentHabitat,
        massSendBackActionType: settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_EXTERNAL_ATTACKERS
      }, componentsSections.push(React.createElement(ComponentsUnitsListExternalAttackers, {
        settings: sectionComponentSettings,
        key: "menu--external-attackers-list"
      }))), settings.defendersExternal && (sectionComponentSettings = {
        initialComponent: this,
        defenders: settings.defendersExternal,
        habitat: settings.currentHabitat,
        massSendBackActionType: settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_EXTERNAL_DEFENDERS
      }, componentsSections.push(React.createElement(ComponentsUnitsListExternalDefenders, {
        settings: sectionComponentSettings,
        key: "menu--external-defender-list"
      }))), settings.isTransitsOmitted && settings.currentHabitat.transitCount ? (sectionComponentSettings = { title: servicesInternationalization.localize("Transits") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu--transit-title"
      })), sectionComponentSettings = {
        initialComponent: this,
        habitat: settings.currentHabitat,
        relatedToCurrentHabitat: !0
      }, componentsSections.push(React.createElement(ComponentsTransitExternalListButton, {
        settings: sectionComponentSettings,
        key: "menu-element-external-transit"
      }))) : settings.transits && (sectionComponentSettings = { title: servicesInternationalization.localize("Transits") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "menu--transit-title"
      })), sectionComponentSettings = { transits: settings.transits }, componentsSections.push(React.createElement(ComponentsTransitsSummary, {
        settings: sectionComponentSettings,
        key: "menu--transit-summary"
      })), sectionComponentSettings = {
        initialComponent: this,
        transits: settings.transits
      }, componentsSections.push(React.createElement(ComponentsTransitList, {
        settings: sectionComponentSettings,
        key: "menu--transit-list"
      }))), settings.activeMissions && (sectionComponentSettings = {
        initialComponent: this,
        missions: settings.activeMissions,
        currentHabitat: settings.currentHabitat,
        hideMassModeSwitcher: !0
      }, componentsSections.push(React.createElement(MenuBuildingOverviewComponentMissions, {
        settings: sectionComponentSettings,
        key: "menu--missions-list"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitList.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuUnitListController(options) {
    var menuTransitOverviewController = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.controller), menuBuildingOverviewController = gameInstance.injector.get(xy.dNames.game.menuBuildingOverview.controller);
    this.forLinking = [{
      resourceClass: menuTransitOverviewController,
      methodName: xy.eNames.menuTransitOverview.speedUpTransit
    }, {
      resourceClass: menuBuildingOverviewController,
      methodName: xy.eNames.menuBuildingOverview.missionSpeedUp
    }, {
      resourceClass: menuBuildingOverviewController,
      methodName: xy.eNames.menuBuildingOverview.missionCancel
    }], MenuUnitListController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Units")
  }

  return utilsOop.extend(MenuUnitListController, CoreControllerElementMenu), MenuUnitListController.prototype[xy.eNames.menuUnitList.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuUnitList.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data))
  }, MenuUnitListController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate(), this.isActive && this.dataSource.prepareUnitListData()
  }, MenuUnitListController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitList.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, xy.dNames.services.worldSettings, function(gameInstance, CoreDataSource, utilsOop, servicesGameDataManager, servicesSortable, servicesWorldSettings) {
  "use strict";
  function MenuUnitListDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource), menuBuildingOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuBuildingOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "speedUpTransitResponse"
    }, {
      resourceClass: menuBuildingOverviewDataSource,
      methodName: "missionSpeedUp"
    }, {
      resourceClass: menuBuildingOverviewDataSource,
      methodName: "missionCancel"
    }], MenuUnitListDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitListDataSource, CoreDataSource), MenuUnitListDataSource.prototype.prepareUnitListData = function() {
    var attackersAll, defendersAll, attackerExternal, defendersExternal, transits, activeMissions, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    attackersAll = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: currentHabitat.localHabitatUnitArray }), attackersAll.length && (data.attackersAll = attackersAll), defendersAll = servicesGameDataManager.unitsCollection.getDefendersUnits({ habitatUnitArray: currentHabitat.localHabitatUnitArray }), defendersAll.length && (data.defendersAll = defendersAll), attackerExternal = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: currentHabitat.remoteHabitatUnitArray }), attackerExternal.length && (data.attackerExternal = attackerExternal), defendersExternal = servicesGameDataManager.unitsCollection.getDefendersUnits({ habitatUnitArray: currentHabitat.remoteHabitatUnitArray }), defendersExternal.length && (data.defendersExternal = defendersExternal), data.isTransitsOmitted = servicesGameDataManager.transitsCollection.flagPartialCollectionMode, transits = servicesGameDataManager.transitsCollection.getHabitatTransitsForHabitat(currentHabitat.id), transits && (data.transits = transits), currentHabitat.habitatMissionArray.length && (activeMissions = [], currentHabitat.habitatMissionArray.forEach(function(missionInProgressId) {
      var modeledMissionInProgress = servicesGameDataManager.missionsCollection.getMissionInProgress(missionInProgressId), modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: modeledMissionInProgress.missionId });
      activeMissions.push({ mission: modeledMission, missionInProgress: modeledMissionInProgress })
    }), activeMissions.sort(servicesSortable.byField("mission", "order")), data.activeMissions = activeMissions, data.isTimerable = !0), servicesWorldSettings.settings.featureSupportBridge && (currentHabitat.nextBattleDate || servicesGameDataManager.habitatsCollection.isHabitatUnderAttack(currentHabitat.id)) && (data.isSupportBridgeAvailable = !0), data.currentHabitat = currentHabitat, this.notify(xy.eNames.menuUnitList.dataIsReady, data)
  }, MenuUnitListDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitList.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitList.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitListComponent) {
  "use strict";
  function MenuUnitListPresenter(options) {
    MenuUnitListPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitListPresenter, CorePresenterElementMenu), MenuUnitListPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitListPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDisband.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.utils.object, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.widgetRangeSliderDivider, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, utilsObject, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsWidgetRangeSliderDivider) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { unitDictionary: {} }
    }, componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceNextRedrawUpdate || newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id) && this.setState({ unitDictionary: {} }, null)
    }, onDisbandUnits: function() {
      var selected = {};
      selected[this.props.settings.currentHabitat.id] = this.state.unitDictionary, this.props.presenter.notify(xy.eNames.menuUnitDisband.disbandUnits, { dismissUnitDictionary: selected })
    }, onSetValueByRangeSlider: function(primaryKey, amount) {
      var dictionary = this.state.unitDictionary, newStates = {};
      dictionary[primaryKey] = amount, newStates.unitDictionary = dictionary, this.setState(newStates, null)
    }, render: function() {
      var settings = {
        availableUnits: {},
        currentHabitat: {}
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [];
      if (settings.availableUnits.length) {
        settings.availableUnits.forEach(function(unitAmountObject) {
          var unit = unitAmountObject.unit, unitPK = unit.primaryKey;
          sectionComponentSettings = {
            handleIcon: unit.icon,
            currentValue: this.state.unitDictionary[unitPK] || 0,
            minValue: 0,
            maxValue: unitAmountObject.amount,
            title: unit.title,
            onChange: this.onSetValueByRangeSlider.bind(this, unitPK)
          }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
            settings: sectionComponentSettings,
            key: "disband-unit-range-slider-" + unitPK
          }))
        }, this), sectionComponentSettings = {
          iconLeft: "icon-game icon-DisbandUnitsIcon",
          title: servicesInternationalization.localize("Disband units"),
          onClick: this.onDisbandUnits,
          disabled: utilsObject.effectiveLength(this.state.unitDictionary) < 1
        };
        var faqLink = servicesTheme.themeSettings.faqLinks.disbandUnits;
        faqLink && (sectionComponentSettings = this.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "building-overview-disband-units-button"
        }))
      } else {
        var localizationString = "There are no units in the castle you have chosen. Recruit new troops, to perform this action.";
        sectionComponentSettings = { text: servicesInternationalization.localize(localizationString) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "title-no-unit"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDisband.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuUnitDisbandController(options) {
    MenuUnitDisbandController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Available Units"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuUnitDisbandController, CoreControllerElementMenu), MenuUnitDisbandController.prototype[xy.eNames.menuUnitDisband.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuUnitDisbandController.prototype[xy.eNames.menuUnitDisband.disbandUnits] = function(options) {
    var successCallBack;
    successCallBack = this.dataSource.disbandUnits.bind(this.dataSource, options), this.showDialogDialog({
      title: servicesInternationalization.localize("Disband units"),
      text: servicesInternationalization.localize("Do you really like to disband the selected units?"),
      callbackSuccess: successCallBack
    })
  }, MenuUnitDisbandController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = this.forceNextRedrawUpdate;
    this.isActive && (this.dataSource.prepareDisbandUnitData({ forceNextRedrawUpdate: forceNextRedrawUpdate }), this.forceNextRedrawUpdate = !1)
  }, MenuUnitDisbandController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDisband.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, function(CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager) {
  "use strict";
  function MenuUnitDisbandDataSource(options) {
    MenuUnitDisbandDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitDisbandDataSource, CoreDataSource), MenuUnitDisbandDataSource.prototype.prepareDisbandUnitData = function(options) {
    var unitsPK, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), unitsAmountObject = servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
      habitatId: currentHabitat.id,
      habitat: currentHabitat
    }), availableUnits = [];
    for (unitsPK in unitsAmountObject)unitsAmountObject.hasOwnProperty(unitsPK) && availableUnits.push({
      unit: servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitsPK }),
      amount: unitsAmountObject[unitsPK]
    });
    data.currentHabitat = currentHabitat, data.availableUnits = availableUnits, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuUnitDisband.dataIsReady, data)
  }, MenuUnitDisbandDataSource.prototype.disbandUnits = function(options) {
    var dictionaryToString = utilsNetwork.dictionaryToQueryString(options.dismissUnitDictionary);
    this.request({ dismissOrders: dictionaryToString }, "HabitatAction/dismissUnits", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuUnitDisbandDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDisband.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitsDisband.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitDisbandComponent) {
  "use strict";
  function MenuUnitDisbandPresenter(options) {
    MenuUnitDisbandPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitDisbandPresenter, CorePresenterElementMenu), MenuUnitDisbandPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitDisbandComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitDisbandPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersLocal.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.unitsListReturnFromHabitat, xy.dNames.components.widgetUnitsList, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsUnitsListReturnFromHabitat, ComponentsWidgetUnitsList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    sendBackAction: function(sourceHabitat, units, habitatUnitsToFlush) {
      this.props.presenter.notify(xy.eNames.menuUnitDefenderLocal.sendUnitsBack, {
        sourceHabitat: this.props.settings.initialHabitat,
        destinationHabitat: sourceHabitat,
        units: units,
        habitatUnitsToFlush: habitatUnitsToFlush
      })
    },
    render: function() {
      var settings = {
        initialHabitat: null,
        currentHabitat: null,
        forceRedraw: !1,
        ownLocalUnits: [],
        defendersGroupedObject: null,
        massSendBackActionType: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = {
        initialComponent: this,
        unitsList: settings.ownLocalUnits,
        showDescriptionOnClick: !0,
        habitatId: settings.initialHabitat.id
      }, componentsSections.push(React.createElement(ComponentsWidgetUnitsList, {
        settings: sectionComponentSettings,
        key: "own-habitat-units"
      })), settings.defendersGroupedObject && settings.defendersGroupedObject.groups && settings.defendersGroupedObject.groups.length && (titleSettings.rightButton = {
        icon: servicesTheme.themeSettings.imagesClassNames.units.massSendBackControl,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuUnitsMassSendBack.name,
          options: { habitatId: settings.initialHabitat.id, massSendBackActionType: settings.massSendBackActionType }
        })
      }, settings.defendersGroupedObject.groupsKeys.forEach(function(habitatId, index) {
        var localComponentSettings, habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
        localComponentSettings = {
          forceRedraw: settings.forceRedraw,
          initialComponent: this,
          isDefendersLocal: !0,
          currentHabitat: settings.currentHabitat,
          habitat: habitat,
          sourceHabitat: settings.initialHabitat,
          destinationHabitat: habitat,
          unitsList: settings.defendersGroupedObject.groups[index],
          onRecallAction: this.sendBackAction.bind(this, habitat)
        }, componentsSections.push(React.createElement(ComponentsUnitsListReturnFromHabitat, {
          settings: localComponentSettings,
          key: "menu-unit-block-origin-" + habitatId
        }))
      }, this));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersLocal.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, utilsObject, servicesInternationalization) {
  "use strict";
  function MenuUnitDefendersLocalController(options) {
    MenuUnitDefendersLocalController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Defending troops"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuUnitDefendersLocalController, CoreControllerElementMenu), MenuUnitDefendersLocalController.prototype[xy.eNames.menuUnitDefenderLocal.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuUnitDefenderLocal.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data))
  }, MenuUnitDefendersLocalController.prototype[xy.eNames.menuUnitDefenderLocal.sendUnitsBack] = function(options) {
    var text, successCallBack;
    return utilsObject.effectiveLength(options.units) ? (successCallBack = this.dataSource.sendUnitsBackToOriginHabitat.bind(this.dataSource, options), text = servicesInternationalization.localize("Verify"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Send troops home"),
      text: text,
      callbackSuccess: successCallBack
    })) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Send troops home"),
      text: servicesInternationalization.localize("You haven't chosen any units")
    })
  }, MenuUnitDefendersLocalController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = this.forceNextRedrawUpdate;
    this.isActive && (this.dataSource.prepareUnitDefendersLocalData({
      habitatId: this.initialOptions.habitatId, forceNextRedrawUpdate: forceNextRedrawUpdate,
      massSendBackActionType: this.initialOptions.massSendBackActionType
    }), this.forceNextRedrawUpdate = !1)
  }, MenuUnitDefendersLocalController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersLocal.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuUnitDefendersLocalDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }], MenuUnitDefendersLocalDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitDefendersLocalDataSource, CoreDataSource), MenuUnitDefendersLocalDataSource.prototype.prepareUnitDefendersLocalData = function(options) {
    var initialHabitat, defendersLocal, data = {}, battleType = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    if (initialHabitat = options.habitatId ? servicesGameDataManager.habitatsCollection.getHabitat(options.habitatId) : currentHabitat, initialHabitat.isOwnByPlayer)battleType[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0, defendersLocal = servicesGameDataManager.unitsCollection.getGroupedUnitsByHabitat({
      habitatUnitArray: initialHabitat.localHabitatUnitArray,
      battleTypes: battleType,
      groupingField: "sourceHabitat"
    }), data.defendersGroupedObject = defendersLocal, data.ownLocalUnits = servicesGameDataManager.unitsCollection.getOwnDefendersUnits({ habitatUnitArray: initialHabitat.localHabitatUnitArray }); else {
      var localHabitatUnitsArray = servicesGameDataManager.unitsCollection.getForeignerHabitatLocalUnits(initialHabitat.id);
      battleType[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0, defendersLocal = servicesGameDataManager.unitsCollection.getGroupedUnitsByHabitat({
        habitatUnitArray: localHabitatUnitsArray,
        battleTypes: battleType,
        groupingField: "sourceHabitat"
      }), data.defendersGroupedObject = defendersLocal, data.ownLocalUnits = servicesGameDataManager.unitsCollection.getOwnDefendersUnits({ habitatUnitArray: localHabitatUnitsArray })
    }
    data.massSendBackActionType = options.massSendBackActionType, data.forceRedraw = options.forceNextRedrawUpdate, data.initialHabitat = initialHabitat, data.currentHabitat = currentHabitat, this.notify(xy.eNames.menuUnitDefenderLocal.dataIsReady, data)
  }, MenuUnitDefendersLocalDataSource.prototype.sendUnitsBackToOriginHabitat = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.DEFENSE_RETURN, options.habitatUnitsToFlush && servicesGameDataManager.unitsCollection.flushHabittasUnits(options.habitatUnitsToFlush), this.startTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuUnitDefendersLocalDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersLocal.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitsDefendersLocal.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitDefendersLocalComponent) {
  "use strict";
  function MenuUnitDefendersLocalPresenter(options) {
    MenuUnitDefendersLocalPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitDefendersLocalPresenter, CorePresenterElementMenu), MenuUnitDefendersLocalPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitDefendersLocalComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitDefendersLocalPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitAttackersLocal.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetAllianceRelationBadge, xy.dNames.components.widgetUnitsList, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsMenuListTitleBasic, ComponentsHabitatMenuElement, ComponentsWidgetAllianceRelationBadge, ComponentsWidgetUnitList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onPublishInAllianceClashClick: function(habitatId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuUnitAttackersLocal.publishInAllianceClash, { habitatId: habitatId })
    },
    render: function() {
      var settings = {
        habitat: null,
        currentHabitat: null,
        attackersGroupedObject: {},
        habitats: {}
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], currentHabitat = settings.currentHabitat, habitatId = currentHabitat.id;
      if (settings.attackersGroupedObject.groupsKeys.forEach(function(habitatId, index) {
                var localComponentSettings, habitat = settings.habitats[habitatId];
                sectionComponentSettings = {
                  classes: "first",
                  initialComponent: this,
                  habitat: habitat,
                  showAllianceRelationBadge: !1
                }, componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
                  settings: sectionComponentSettings,
                  key: "menu-element-habitat-details-" + habitat.id
                })), localComponentSettings = {
                  initialComponent: this,
                  habitat: habitat,
                  unitsList: settings.attackersGroupedObject.groups[index]
                }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
                  settings: localComponentSettings,
                  key: "menu-unit-block-origin-" + habitat.id
                }))
              }, this), currentHabitat.nextBattleDate && (sectionComponentSettings = { text: servicesInternationalization.localize("Next battle: %@", utilsDateTime.getLocaleDateTimeString(currentHabitat.nextBattleDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
                settings: sectionComponentSettings,
                key: "menu-text-next-battle"
              }))), settings.habitat.isOwnByPlayer) {
        var isSharedWithAlliance = !!servicesGameDataManager.alliancesCollection.warClashedSet.habitats[habitatId], buttonTitle = "Call Help", alreadySharedText = "You have already sought help for this attack", iconClashButton = "icon-game icon-DefenceIcon";
        isSharedWithAlliance && (sectionComponentSettings = { text: servicesInternationalization.localize(alreadySharedText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-clash-already-shared"
        }))), sectionComponentSettings = {
          iconLeft: iconClashButton,
          onClick: this.onPublishInAllianceClashClick.bind(this, habitatId),
          title: servicesInternationalization.localize(buttonTitle),
          disabled: isSharedWithAlliance
        }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-clash-button"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitAttackersLocal.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuUnitAttackerLocalController(options) {
    MenuUnitAttackerLocalController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Offending troops")
  }

  return utilsOop.extend(MenuUnitAttackerLocalController, CoreControllerElementMenu), MenuUnitAttackerLocalController.prototype[xy.eNames.menuUnitAttackersLocal.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuUnitAttackersLocal.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data))
  }, MenuUnitAttackerLocalController.prototype[xy.eNames.menuUnitAttackersLocal.publishInAllianceClash] = function(options) {
    this.dataSource.publishBattleClashInAlliance(options)
  }, MenuUnitAttackerLocalController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate(), this.isActive && this.dataSource.prepareUnitAttackerLocalData({ habitat: this.initialOptions.habitat })
  }, MenuUnitAttackerLocalController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitAttackersLocal.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuUnitAttackerLocalDataSource(options) {
    var menuAllianceClashDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceClashes.dataSource);
    this.forLinking = [{
      resourceClass: menuAllianceClashDataSource,
      methodName: "publishBattleClashInAlliance"
    }], MenuUnitAttackerLocalDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitAttackerLocalDataSource, CoreDataSource), MenuUnitAttackerLocalDataSource.prototype.prepareUnitAttackerLocalData = function(options) {
    var attackersLocal, localHabitatUnitsArray, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), habitat = options.habitat || currentHabitat, habitats = {}, battleType = {};
    return habitat.isOwnByPlayer ? (localHabitatUnitsArray = habitat.localHabitatUnitArray, data.attackerExternal = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: habitat.remoteHabitatUnitArray })) : localHabitatUnitsArray = servicesGameDataManager.unitsCollection.getForeignerHabitatLocalUnits(habitat.id), battleType[settingsGameConstant.BATTLE_TYPE.ATTACKER] = !0, attackersLocal = servicesGameDataManager.unitsCollection.getGroupedUnitsByHabitat({
      habitatUnitArray: localHabitatUnitsArray,
      battleTypes: battleType,
      groupingField: "sourceHabitat"
    }), attackersLocal.groups.length ? (attackersLocal.groupsKeys.forEach(function(habitatId) {
      var attackersHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      habitats[habitatId] = attackersHabitat
    }), data.attackersGroupedObject = attackersLocal, data.currentHabitat = currentHabitat, data.habitat = habitat, data.habitats = habitats, void this.notify(xy.eNames.menuUnitAttackersLocal.dataIsReady, data)) : void this.notify(xy.eNames.menu.onDataExpired)
  }, MenuUnitAttackerLocalDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitAttackersLocal.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitAttackersLocal.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitAttackerLocalComponent) {
  "use strict";
  function MenuUnitAttackerLocalPresenter(options) {
    MenuUnitAttackerLocalPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitAttackerLocalPresenter, CorePresenterElementMenu), MenuUnitAttackerLocalPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitAttackerLocalComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitAttackerLocalPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersExternal.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.unitsListReturnFromHabitat, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsUnitsListReturnFromHabitat) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    recallAction: function(sourceHabitat, units, habitatUnitsToFlush) {
      this.props.presenter.notify(xy.eNames.menuUnitDefendersExternal.recallUnits, {
        sourceHabitat: sourceHabitat,
        destinationHabitat: this.props.settings.currentHabitat,
        units: units,
        habitatUnitsToFlush: habitatUnitsToFlush
      })
    },
    render: function() {
      var settings = {
        currentHabitat: null,
        forceRedraw: !1,
        defendersGroupedObject: null,
        massSendBackActionType: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var componentsSections = [];
      settings.defendersGroupedObject && settings.defendersGroupedObject.groups && settings.defendersGroupedObject.groups.length && (titleSettings.rightButton = {
        icon: servicesTheme.themeSettings.imagesClassNames.units.massSendBackControl,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuUnitsMassSendBack.name,
          options: { habitatId: settings.currentHabitat.id, massSendBackActionType: settings.massSendBackActionType }
        })
      }, settings.defendersGroupedObject.groupsKeys.forEach(function(habitatId, index) {
        var localComponentSettings, habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
        localComponentSettings = {
          forceRedraw: settings.forceRedraw,
          initialComponent: this,
          isDefendersExternal: !0,
          habitat: habitat,
          sourceHabitat: habitat,
          destinationHabitat: settings.currentHabitat,
          unitsList: settings.defendersGroupedObject.groups[index],
          onRecallAction: this.recallAction.bind(this, habitat)
        }, componentsSections.push(React.createElement(ComponentsUnitsListReturnFromHabitat, {
          settings: localComponentSettings,
          key: "menu-defenders-external-block-" + habitatId
        }))
      }, this));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersExternal.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, utilsObject, servicesInternationalization) {
  "use strict";
  function MenuUnitDefendersExternalController(options) {
    MenuUnitDefendersExternalController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Outbound defending troops"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuUnitDefendersExternalController, CoreControllerElementMenu), MenuUnitDefendersExternalController.prototype[xy.eNames.menuUnitDefendersExternal.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuUnitDefendersExternal.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data))
  }, MenuUnitDefendersExternalController.prototype[xy.eNames.menuUnitDefendersExternal.recallUnits] = function(options) {
    var text, successCallBack;
    return utilsObject.effectiveLength(options.units) ? (successCallBack = this.dataSource.recallUnitsBackToOriginHabitat.bind(this.dataSource, options), text = servicesInternationalization.localize("global.confirm"), void this.showDialogDialog({
      title: "",
      text: text,
      callbackSuccess: successCallBack
    })) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Recall troops"),
      text: servicesInternationalization.localize("You haven't chosen any units")
    })
  }, MenuUnitDefendersExternalController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate();
    var data = {
      habitat: this.initialOptions.habitat,
      massSendBackActionType: this.initialOptions.massSendBackActionType
    };
    this.isActive && (this.forceNextRedrawUpdate && (this.forceNextRedrawUpdate = !1, data.forceNextRedrawUpdate = !0), this.dataSource.prepareUnitDefendersExternalData(data))
  }, MenuUnitDefendersExternalController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersExternal.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuUnitDefendersExternalDataSource(options) {
    var menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }], MenuUnitDefendersExternalDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitDefendersExternalDataSource, CoreDataSource), MenuUnitDefendersExternalDataSource.prototype.prepareUnitDefendersExternalData = function(options) {
    var defendersExternal, data = {}, battleType = {}, habitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    habitat.isOwnByPlayer && (battleType[settingsGameConstant.BATTLE_TYPE.EXTERNAL_UNITS_TO_DEFENSE] = !0, defendersExternal = servicesGameDataManager.unitsCollection.getGroupedUnitsByHabitat({
      habitatUnitArray: habitat.remoteHabitatUnitArray,
      battleTypes: battleType
    }), data.defendersGroupedObject = defendersExternal), data.massSendBackActionType = options.massSendBackActionType, data.currentHabitat = habitat, data.forceRedraw = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuUnitDefendersExternal.dataIsReady, data)
  }, MenuUnitDefendersExternalDataSource.prototype.recallUnitsBackToOriginHabitat = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.DEFENSE_RETURN, options.habitatUnitsToFlush && servicesGameDataManager.unitsCollection.flushHabittasUnits(options.habitatUnitsToFlush), this.startTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuUnitDefendersExternalDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsDefendersExternal.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitsDefendersExternal.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitDefendersExternalComponent) {
  "use strict";
  function MenuUnitDefendersExternalPresenter(options) {
    MenuUnitDefendersExternalPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitDefendersExternalPresenter, CorePresenterElementMenu), MenuUnitDefendersExternalPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitDefendersExternalComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitDefendersExternalPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsAttackersExternal.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.unitsListReturnFromHabitat, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListButtonBasic, ComponentsUnitsListReturnFromHabitat) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onPublishInAllianceClashClick: function(habitatId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuUnitAttackersExternal.publishInAllianceClash, { habitatId: habitatId })
    },
    recallAction: function(sourceHabitat, destinationHabitat, units, habitatUnitsToFlush) {
      this.props.presenter.notify(xy.eNames.menuUnitAttackersExternal.recallUnits, {
        sourceHabitat: sourceHabitat,
        destinationHabitat: destinationHabitat,
        units: units,
        habitatUnitsToFlush: habitatUnitsToFlush
      })
    },
    render: function() {
      var settings = {
        currentHabitat: null,
        habitat: {},
        forceRedraw: !1,
        isForeignerHabitatMode: !1,
        isPlayerInAlliance: !1,
        attackersGroupedObject: null,
        massSendBackActionType: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, sync, componentsSections = [], addClashButton = function(habitatId) {
        var isSharedWithAlliance = !!servicesGameDataManager.alliancesCollection.warClashedSet.habitats[habitatId], buttonTitle = "Plan Attack", alreadySharedText = "You've already shared this attack with your alliance", iconClashButton = "icon-game icon-AttackIcon";
        return isSharedWithAlliance && (sectionComponentSettings = { text: servicesInternationalization.localize(alreadySharedText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-clash-already-shared-at-" + habitatId
        }))), sectionComponentSettings = {
          iconLeft: iconClashButton,
          onClick: this.onPublishInAllianceClashClick.bind(this, habitatId),
          title: servicesInternationalization.localize(buttonTitle),
          disabled: isSharedWithAlliance
        }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-clash-button-at-" + habitatId
        })), !0
      }.bind(this);
      settings.attackersGroupedObject && settings.attackersGroupedObject.groups && settings.attackersGroupedObject.groups.length && (titleSettings.rightButton = {
        icon: servicesTheme.themeSettings.imagesClassNames.units.massSendBackControl,
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuUnitsMassSendBack.name,
          options: { habitatId: settings.habitat.id, massSendBackActionType: settings.massSendBackActionType }
        })
      }, settings.attackersGroupedObject.groupsKeys.forEach(function(habitatId, index) {
        var localComponentSettings, destinationHabitat, recallHabitat, habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
        settings.isForeignerHabitatMode ? (destinationHabitat = habitat, recallHabitat = settings.habitat) : (destinationHabitat = settings.currentHabitat, recallHabitat = habitat), localComponentSettings = {
          forceRedraw: settings.forceRedraw,
          initialComponent: this,
          isAttackersExternal: !0,
          habitat: habitat,
          sourceHabitat: habitat,
          destinationHabitat: destinationHabitat,
          unitsList: settings.attackersGroupedObject.groups[index],
          onRecallAction: this.recallAction.bind(this, recallHabitat, destinationHabitat)
        }, componentsSections.push(React.createElement(ComponentsUnitsListReturnFromHabitat, {
          settings: localComponentSettings,
          key: "menu-defenders-external-block-" + habitatId
        })), habitat.nextBattleDate && (sectionComponentSettings = { text: servicesInternationalization.localize("Next battle: %@", utilsDateTime.getLocaleDateTimeString(habitat.nextBattleDate)) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-text-next-battle-at-" + habitatId
        }))), !settings.isForeignerHabitatMode && settings.isPlayerInAlliance && (sync = addClashButton(habitatId))
      }, this)), settings.isForeignerHabitatMode && settings.isPlayerInAlliance && (sync = addClashButton(settings.habitat.id));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsAttackersExternal.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, utilsObject, servicesInternationalization) {
  "use strict";
  function MenuUnitAttackersExternalController(options) {
    MenuUnitAttackersExternalController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Outbound attacking troops"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuUnitAttackersExternalController, CoreControllerElementMenu), MenuUnitAttackersExternalController.prototype[xy.eNames.menuUnitAttackersExternal.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuUnitAttackersExternal.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data))
  }, MenuUnitAttackersExternalController.prototype[xy.eNames.menuUnitAttackersExternal.publishInAllianceClash] = function(options) {
    this.dataSource.publishBattleClashInAlliance(options)
  }, MenuUnitAttackersExternalController.prototype[xy.eNames.menuUnitAttackersExternal.recallUnits] = function(options) {
    return utilsObject.effectiveLength(options.units) ? void this.showDialogDialog({
      title: servicesInternationalization.localize("Recall troops"),
      text: servicesInternationalization.localize("Verify"),
      callbackSuccess: this.dataSource.recallUnitsFromWar.bind(this.dataSource, options)
    }) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Recall troops"),
      text: servicesInternationalization.localize("You haven't chosen any units")
    })
  }, MenuUnitAttackersExternalController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = this.forceNextRedrawUpdate;
    this.isActive && (this.dataSource.prepareUnitAttackerExternalData({
      habitatId: this.initialOptions.habitatId,
      forceNextRedrawUpdate: forceNextRedrawUpdate,
      massSendBackActionType: this.initialOptions.massSendBackActionType
    }), this.forceNextRedrawUpdate = !1)
  }, MenuUnitAttackersExternalController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsAttackersExternal.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.groupable, function(gameInstance, CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuUnitAttackersExternalDataSource(options) {
    var menuAllianceClashDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceClashes.dataSource), menuTransitOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuTransitOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuTransitOverviewDataSource,
      methodName: "startTransit"
    }, {
      resourceClass: menuTransitOverviewDataSource,
      methodName: "onStartTransit"
    }, {
      resourceClass: menuAllianceClashDataSource,
      methodName: "publishBattleClashInAlliance"
    }], MenuUnitAttackersExternalDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitAttackersExternalDataSource, CoreDataSource), MenuUnitAttackersExternalDataSource.prototype.prepareUnitAttackerExternalData = function(options) {
    var habitat, attackersExternal, groupingField, data = {}, battleType = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), isForeignerHabitatMode = !1;
    habitat = options.habitatId ? servicesGameDataManager.habitatsCollection.getHabitat(options.habitatId) : currentHabitat;
    var remoteHabitatUnitArray;
    return habitat.isOwnByPlayer ? (groupingField = "habitat", remoteHabitatUnitArray = habitat.remoteHabitatUnitArray, data.attackerExternal = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: habitat.remoteHabitatUnitArray })) : (isForeignerHabitatMode = !0, groupingField = "sourceHabitat", remoteHabitatUnitArray = servicesGameDataManager.unitsCollection.getForeignerHabitatLocalUnits(habitat.id)), battleType[settingsGameConstant.BATTLE_TYPE.ATTACKER] = !0, attackersExternal = servicesGameDataManager.unitsCollection.getGroupedUnitsByHabitat({
      habitatUnitArray: remoteHabitatUnitArray,
      battleTypes: battleType,
      groupingField: groupingField
    }), attackersExternal.groups.length ? (data.attackersGroupedObject = attackersExternal, data.isPlayerInAlliance = !!servicesGameDataManager.alliancesCollection.getAlliance(), data.massSendBackActionType = options.massSendBackActionType, data.forceRedraw = options.forceNextRedrawUpdate, data.currentHabitat = currentHabitat, data.habitat = habitat, data.isForeignerHabitatMode = isForeignerHabitatMode, void this.notify(xy.eNames.menuUnitAttackersExternal.dataIsReady, data)) : void this.notify(xy.eNames.menu.onDataExpired)
  }, MenuUnitAttackersExternalDataSource.prototype.recallUnitsFromWar = function(options) {
    options.transitType = settingsGameConstant.TRANSIT_TYPE.ATTACK_RETURN, options.habitatUnitsToFlush && servicesGameDataManager.unitsCollection.flushHabittasUnits(options.habitatUnitsToFlush), this.startTransit(options), this.controller.forceNextRedrawUpdate = !0
  }, MenuUnitAttackersExternalDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsAttackersExternal.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitsAttackersExternal.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitAttackersExternalComponent) {
  "use strict";
  function MenuUnitAttackersExternalPresenter(options) {
    MenuUnitAttackersExternalPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitAttackersExternalPresenter, CorePresenterElementMenu), MenuUnitAttackersExternalPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitAttackersExternalComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitAttackersExternalPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitChooser.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onUnitChoose: function(newSortingUnitIndex, modeledUnit, event) {
      switch (event.preventDefault(), this.props.settings.mode) {
        case settingsGameConstant.UNIT_CHOOSER_LIST_MODE.HABITAT_SORTING:
          this.props.presenter.notify(xy.eNames.menuUnitChooser.onUnitChoose, newSortingUnitIndex), this.handlerTitleLeftButtonClick();
          break;
        case settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_EXCHANGE:
          this.handlerNextClick({
            next: xy.dNames.game.menuMassFunctionExchange.name,
            options: { chosenResourceId: this.props.settings.chosenResourceId, chosenUnit: modeledUnit }
          });
          break;
        case settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_RECRUIT:
          this.handlerNextClick({
            next: xy.dNames.game.menuMassFunctionRecruitment.name,
            options: { chosenUnit: modeledUnit }
          })
      }
    },
    render: function() {
      var settings = { unitsList: [], sortingOwnLocalUnitArrayIndex: null, chosenResourceId: null, mode: null };
      Object.assign(settings, this.props.settings);
      var titleSettings = { title: this.props.settingsTitle.localizedTitle };
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var unitsList = [];
      if (settings.mode === settingsGameConstant.UNIT_CHOOSER_LIST_MODE.HABITAT_SORTING) {
        var allUnitsSettings = {
          classes: "element-with-unit",
          title: servicesInternationalization.localize("all_units"),
          iconLeft: "icon-unit monochrome-black icon-unit-" + settings.unitsList[0].primaryKey
        };
        settingsGameConstant.SORTING_HABITAT_BY_UNIT_KEYS.ALL_UNITS === settings.sortingOwnLocalUnitArrayIndex ? allUnitsSettings.classes += " active" : (allUnitsSettings.onClick = this.onUnitChoose.bind(this, settingsGameConstant.SORTING_HABITAT_BY_UNIT_KEYS.ALL_UNITS, null), allUnitsSettings.iconRight = "controls menu-next"), unitsList.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: allUnitsSettings,
          key: "all_units"
        }))
      }
      settings.unitsList.forEach(function(unit, index) {
        var elementSettings = { classes: "element-with-unit", title: unit.title, iconLeft: unit.icon };
        null !== settings.sortingOwnLocalUnitArrayIndex && index === settings.sortingOwnLocalUnitArrayIndex ? elementSettings.classes += " active" : (elementSettings.onClick = this.onUnitChoose.bind(this, index, unit), elementSettings.iconRight = "controls menu-next"), unitsList.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: elementSettings,
          key: unit.identifier
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: unitsList
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitChooser.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuUnitChooserHabitatSortingController(options) {
    MenuUnitChooserHabitatSortingController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Unit Selection")
  }

  return utilsOop.extend(MenuUnitChooserHabitatSortingController, CoreControllerElementMenu), MenuUnitChooserHabitatSortingController.prototype[xy.eNames.menuUnitChooser.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuUnitChooserHabitatSortingController.prototype[xy.eNames.menuUnitChooser.onUnitChoose] = function(newSortingUnitIndex) {
    this.dataSource.setNewSortingUnitIndex(newSortingUnitIndex)
  }, MenuUnitChooserHabitatSortingController.prototype.prepareDataForDraw = function() {
    var mode = this.initialOptions.mode, data = { mode: mode };
    mode === settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_EXCHANGE && (data.chosenResourceId = this.initialOptions.chosenResourceId), this.isActive && this.dataSource.buildUnitsList(data)
  }, MenuUnitChooserHabitatSortingController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitChooser.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesSortable) {
  "use strict";
  function MenuUnitChooserHabitatSortingDataSource(options) {
    MenuUnitChooserHabitatSortingDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitChooserHabitatSortingDataSource, CoreDataSource), MenuUnitChooserHabitatSortingDataSource.prototype.buildUnitsList = function(options) {
    var unitsList, data = {};
    switch (options.mode) {
      case settingsGameConstant.UNIT_CHOOSER_LIST_MODE.HABITAT_SORTING:
        data.sortingOwnLocalUnitArrayIndex = servicesGameDataManager.habitatsCollection.sortingOwnLocalUnitArrayIndex, unitsList = servicesGameDataManager.unitsCollection.getUnitsList();
        break;
      case settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_EXCHANGE:
        data.chosenResourceId = options.chosenResourceId, unitsList = servicesGameDataManager.unitsCollection.getAvailableForExchangeUnitsList();
        break;
      case settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_RECRUIT:
        unitsList = servicesGameDataManager.unitsCollection.getAvailableForRecruitmentUnitsList();
        break;
      default:
        unitsList = servicesGameDataManager.unitsCollection.getUnitsList()
    }
    unitsList.sort(servicesSortable.byField("order")), data.unitsList = unitsList, data.mode = options.mode, this.notify(xy.eNames.menuUnitChooser.dataIsReady, data)
  }, MenuUnitChooserHabitatSortingDataSource.prototype.setNewSortingUnitIndex = function(newSortingOwnLocalUnitArrayIndex) {
    servicesGameDataManager.habitatsCollection.sortingOwnLocalUnitArrayIndex = newSortingOwnLocalUnitArrayIndex, servicesGameDataManager.habitatsCollection.sortOwnHabitat()
  }, MenuUnitChooserHabitatSortingDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitChooser.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitChooser.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitChooserComponent) {
  "use strict";
  function MenuUnitChooserHabitatSortingPresenter(options) {
    MenuUnitChooserHabitatSortingPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitChooserHabitatSortingPresenter, CorePresenterElementMenu), MenuUnitChooserHabitatSortingPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitChooserComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitChooserHabitatSortingPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitOverview.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.overviewWidgetConstructCost, xy.dNames.components.overviewWidgetBattleAbilityList, xy.dNames.components.icon, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsWidgetConstructBuildingCost, ComponentsOverviewWidgetBattleAbilityList, ComponentsIcon) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = {
        unit: {},
        currentHabitat: null,
        abilitiesWithModifiers: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], unit = settings.unit, building = settings.building;
      if (sectionComponentSettings = {
                iconLeft: unit.icon,
                title: unit.title
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "unit-overview-name"
              })), sectionComponentSettings = { icon: unit.image }, componentsSections.push(React.createElement(ComponentsIcon, {
                settings: sectionComponentSettings,
                key: "unit-overview-image"
              })), sectionComponentSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.units.descriptionKey + unit.primaryKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "unit-overview-description"
              })), sectionComponentSettings = {
                constructingEntity: unit,
                performingBuilding: building,
                currentHabitat: settings.currentHabitat,
                initialComponent: this
              }, componentsSections.push(React.createElement(ComponentsWidgetConstructBuildingCost, {
                settings: sectionComponentSettings,
                key: "unit-overview-cost"
              })), settings.abilitiesWithModifiers.movementSpeed) {
        var speedInMinutes = (settings.abilitiesWithModifiers.movementSpeed / 60).toFixed(1);
        sectionComponentSettings = {
          title: servicesInternationalization.localize("Speed"),
          rightColumnDataValue: servicesInternationalization.localize("%0.1f minutes per field", speedInMinutes)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "unit-overview-speed"
        }))
      }
      sectionComponentSettings = {
        title: servicesInternationalization.localize("Transport amount"),
        rightColumnDataValue: unit.storeAmount
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "unit-overview-transport-capacity"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("Corps"),
        rightColumnDataValue: servicesInternationalization.localize(unit.corps),
        rightIcon: "icon-game icon-Corps" + unit.corps
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "unit-overview-transport-unit-type"
      })), settings.abilitiesWithModifiers.battleAbility && (sectionComponentSettings = { battleAbility: settings.abilitiesWithModifiers.battleAbility }, componentsSections.push(React.createElement(ComponentsOverviewWidgetBattleAbilityList, {
        settings: sectionComponentSettings,
        key: "unit-overview-battle-ability"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, function(CoreControllerElementMenu, utilsOop) {
  "use strict";
  function MenuUnitOverviewController(options) {
    MenuUnitOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }]
  }

  return utilsOop.extend(MenuUnitOverviewController, CoreControllerElementMenu), MenuUnitOverviewController.prototype.prepareDataForDraw = function() {
    var data, unit = this.initialOptions.unit, building = this.initialOptions.building;
    this.localizedName = unit.title, this.isActive && (data = this.dataSource.prepareUnitOverviewData({
      unit: unit,
      building: building
    }), this.presenter.draw(data))
  }, MenuUnitOverviewController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitOverview.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuUnitOverviewDataSource(options) {
    MenuUnitOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitOverviewDataSource, CoreDataSource), MenuUnitOverviewDataSource.prototype.prepareUnitOverviewData = function(options) {
    var abilitiesWithModifiers, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), unit = options.unit, building = options.building;
    return abilitiesWithModifiers = currentHabitat.applyModifiers({
      targetObject: "Unit",
      corps: unit.corps,
      rawData: unit.battleValueDictionary,
      movementSpeed: unit.secondsPerField
    }), data.abilitiesWithModifiers = abilitiesWithModifiers, data.currentHabitat = currentHabitat, data.unit = unit, data.building = building, data
  }, MenuUnitOverviewDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitOverviewComponent) {
  "use strict";
  function MenuUnitOverviewPresenter(options) {
    MenuUnitOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitOverviewPresenter, CorePresenterElementMenu), MenuUnitOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitOverviewPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitConstruction.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.overviewWidgetConstructCost, xy.dNames.components.widgetRangeSlider, xy.dNames.components.icon, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsWidgetConstructBuildingCost, ComponentsWidgetRangeSlider, ComponentsIcon) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { amountForRecruitment: 1 }
    }, onSetValueByRangeSlider: function(flag, value) {
      flag && this.setState({ amountForRecruitment: value }, null)
    }, onConstructClick: function(flag) {
      flag && this.state.amountForRecruitment && this.props.presenter.notify(xy.eNames.menuUnitConstruction.construct, {
        amountForRecruitment: this.state.amountForRecruitment,
        unit: this.props.settings.unit,
        habitat: this.props.settings.currentHabitat,
        paymentGranted: !1
      })
    }, render: function() {
      var settings = {
        unit: {},
        currentHabitat: null,
        unitRecruitmentInHabitat: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], unit = settings.unit, building = settings.building, unitRecruitmentIcons = servicesTheme.themeSettings.imagesClassNames.units;
      sectionComponentSettings = { icon: unit.image }, componentsSections.push(React.createElement(ComponentsIcon, {
        settings: sectionComponentSettings,
        key: "unit-construction-image"
      })), sectionComponentSettings = {
        constructingEntity: unit,
        performingBuilding: building,
        currentHabitat: settings.currentHabitat,
        initialComponent: this,
        disableRequiredSection: !0,
        multiplier: this.state.amountForRecruitment
      }, componentsSections.push(React.createElement(ComponentsWidgetConstructBuildingCost, {
        settings: sectionComponentSettings,
        key: "unit-construction-cost"
      })), sectionComponentSettings = {
        handleIcon: unit.icon,
        currentValue: this.state.amountForRecruitment,
        minValue: 1,
        maxValue: settings.unitRecruitmentInHabitat.amountPossible,
        showButtons: !0,
        onChange: this.onSetValueByRangeSlider.bind(this, !0),
        showAcceptButton: !0,
        acceptButtonIcon: unitRecruitmentIcons.recruit,
        acceptButtonCallBack: this.onConstructClick.bind(this, !0)
      }, componentsSections.push(React.createElement(ComponentsWidgetRangeSlider, {
        settings: sectionComponentSettings,
        key: "unit-construction-range-slider"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitConstruction.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.internationalization, xy.dNames.services.eventManager, function(CoreControllerElementMenu, utilsOop, servicesGameDataManager, servicesWorldSettings, servicesInternationalization, servicesEventManager) {
  "use strict";
  function MenuUnitConstructionController(options) {
    MenuUnitConstructionController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }]
  }

  return utilsOop.extend(MenuUnitConstructionController, CoreControllerElementMenu), MenuUnitConstructionController.prototype.prepareDataForDraw = function() {
    var data, unit = this.initialOptions.unit, building = this.initialOptions.building;
    this.localizedName = unit.title, this.isActive && (servicesEventManager.handleClientEvent("menu-unit-construction--open--" + unit.niceIdentifier), data = this.dataSource.prepareUnitConstructData({
      unit: unit,
      building: building
    }), this.presenter.draw(data))
  }, MenuUnitConstructionController.prototype[xy.eNames.menuUnitConstruction.completeAllRecruitment] = function(options) {
    var costMultiplierBase, habitatId, finishArray, habitatsObject = options.habitatsObject, cost = 0, gold = servicesGameDataManager.playersCollection.getPlayer().gold, dataSourceOptions = { actions: {} };
    for (habitatId in habitatsObject)habitatsObject.hasOwnProperty(habitatId) && (finishArray = [], habitatsObject[habitatId].upgrades.forEach(function(upgrade) {
      costMultiplierBase = upgrade.inProgressModel.isLessThanHalfConstructionTimeRemain() ? 1 : 2, cost += costMultiplierBase * upgrade.unitModel.buildSpeedupCost * upgrade.inProgressModel.orderAmount, finishArray.push(upgrade.inProgressModel.id)
    }), dataSourceOptions.actions[habitatId] = [{ finish: finishArray }]);
    if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
    dataSourceOptions.cost = cost;
    var text, localizationString = "Do you want to finish all active recruitments for %1$d %2$@? You have %3$d %4$@.";
    text = servicesInternationalization.localize(localizationString, cost, "Gold", gold, "Gold"), this.showDialogDialog({
      title: servicesInternationalization.localize("Finish build"),
      text: text,
      callbackSuccess: this.dataSource.batchRecruitmentActions.bind(this.dataSource, dataSourceOptions)
    })
  }, MenuUnitConstructionController.prototype[xy.eNames.menuUnitConstruction.construct] = function(options) {
    if (!options.amountForRecruitment) {
      if (options.globalRecruitmentView)return void this.showDialogAlert({
        title: servicesInternationalization.localize("Unit Recruiting"),
        text: servicesInternationalization.localize("Select a Unit")
      });
      this[xy.eNames.menu.openPrevView]()
    }
    var habitat = options.habitat, constructionQueueLimit = +servicesWorldSettings.settings.unitRecruitingListBoundaryByHabitatType[habitat.habitatType];
    if (habitat.habitatUnitOrderArray.length >= constructionQueueLimit) {
      options.paymentGranted = !0;
      var text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, costOfConstruction = options.unit.buildSpeedupCost * options.amountForRecruitment;
      if (costOfConstruction > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, costOfConstruction - gold);
      text = servicesInternationalization.localize("Your unit order queue is full. An additional slot costs %d %@\\nYou have %d %@", costOfConstruction, "Gold", gold, "Gold"), this.showDialogDialog({
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.buildUnit.bind(this.dataSource, options)
      })
    } else this.dataSource.buildUnit(options)
  }, MenuUnitConstructionController.prototype[xy.eNames.menuUnitConstruction.speedUpRecruitment] = function(options) {
    var localizationString, text, successCallBack, gold = servicesGameDataManager.playersCollection.getPlayer().gold, costOfSpeedUp = options.unit.buildSpeedupCost * options.unitInProgress.orderAmount;
    return costOfSpeedUp > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, costOfSpeedUp - gold) : (options.unitInProgress.isLessThanHalfConstructionTimeRemain() ? (localizationString = "Finishing recruiting %d x %@ instantly costs %d %@. You have %d %@.", successCallBack = this.dataSource.finishUnit.bind(this.dataSource, options)) : (localizationString = "Reducing recruition time for %d x %@ costs %d %@. You have %d %@.", successCallBack = this.dataSource.speedUpUnit.bind(this.dataSource, options)), text = servicesInternationalization.localize(localizationString, options.unitInProgress.orderAmount, options.unit.title, costOfSpeedUp, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Gold"),
      text: text,
      callbackSuccess: successCallBack
    }))
  }, MenuUnitConstructionController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitConstruction.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager) {
  "use strict";
  function MenuUnitConstructionDataSource(options) {
    MenuUnitConstructionDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitConstructionDataSource, CoreDataSource), MenuUnitConstructionDataSource.prototype.prepareUnitConstructData = function(options) {
    var data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), unit = options.unit, building = options.building;
    return data.unitRecruitmentInHabitat = currentHabitat.unitRecruitmentInHabitat(unit), data.currentHabitat = currentHabitat, data.unit = unit, data.building = building, data
  }, MenuUnitConstructionDataSource.prototype.buildUnit = function(options) {
    this.request({
      habitatID: options.habitat.id,
      primaryKey: options.unit.primaryKey,
      orderAmount: options.amountForRecruitment,
      paymentGranted: options.paymentGranted
    }, "HabitatAction/buildUnit", { callBack: this.handleSessionUpdateResponse }), options.globalRecruitmentView || this.notify(xy.eNames.menu.openPrevView)
  }, MenuUnitConstructionDataSource.prototype.speedUpUnit = function(options) {
    this.request({ id: options.unitInProgress.id }, "HabitatAction/speedupBuildUnit", { callBack: this.handleSessionUpdateResponse })
  }, MenuUnitConstructionDataSource.prototype.finishUnit = function(options) {
    this.request({ id: options.unitInProgress.id }, "HabitatAction/finishBuildUnit", { callBack: this.handleSessionUpdateResponse })
  }, MenuUnitConstructionDataSource.prototype.batchRecruitmentActions = function(options) {
    var params = {};
    options.cost && (params.paymentAmount = options.cost), params.actions = utilsNetwork.dictionaryToQueryString(options.actions, {
      trailingCommaFlag: !1,
      noStringFlag: !0
    }), this.request(params, "HabitatAction/batchUnitOrder", { callBack: this.handleSessionUpdateResponse })
  }, MenuUnitConstructionDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitConstruction.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitConstruction.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitConstructionComponent) {
  "use strict";
  function MenuUnitConstructionPresenter(options) {
    MenuUnitConstructionPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitConstructionPresenter, CorePresenterElementMenu), MenuUnitConstructionPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitConstructionComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitConstructionPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsMassSendBack.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function(settings) {
      var selectedAmount = 0, selectedUnits = {};
      return settings.unitsObject.forEach(function(unitObject) {
        selectedAmount += unitObject.amount, selectedUnits[unitObject.unit.primaryKey] = !0
      }, this), { selectedUnits: selectedUnits, selectedAmount: selectedAmount }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id && this.setState(this.getNewState(newProps.settings), null)
    }, onSelectUnitCheckboxClick: function(unitId, amount) {
      var selectedUnits = this.state.selectedUnits, selectedAmount = this.state.selectedAmount;
      selectedUnits[unitId] = !selectedUnits[unitId], selectedUnits[unitId] ? selectedAmount += amount : selectedAmount -= amount, this.setState({
        selectedUnits: selectedUnits,
        selectedAmount: selectedAmount
      }, null)
    }, onSelectDeselectAllUnits: function() {
      var status = !0, selectedUnits = this.state.selectedUnits, selectedAmount = this.state.selectedAmount;
      this.possibleSelectedAmount === selectedAmount ? (status = !1, selectedAmount = 0) : selectedAmount = this.possibleSelectedAmount, this.props.settings.unitsObject.forEach(function(unitObject) {
        selectedUnits[unitObject.unit.primaryKey] = status
      }, this), this.setState({ selectedUnits: selectedUnits, selectedAmount: selectedAmount }, null)
    }, sendAllUnitsBack: function() {
      this.props.presenter.notify(xy.eNames.menuUnitsMassSendBack.sendAllUnitsBack, {
        initialHabitat: this.props.settings.initialHabitat,
        units: this.state.selectedUnits,
        selectedAmount: this.state.selectedAmount,
        massSendBackActionType: this.props.settings.massSendBackActionType
      })
    }, render: function() {
      var settings = {
        unitsObject: [],
        currentHabitat: {},
        initialHabitat: {},
        massSendBackActionType: !1
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], componentsSectionUnitsList = [], lang = gameInstance.getGameLanguage();
      this.possibleSelectedAmount = 0, settings.unitsObject && settings.unitsObject instanceof Array && settings.unitsObject.length && (settings.unitsObject.forEach(function(unitObject) {
        var unit = unitObject.unit;
        this.possibleSelectedAmount += unitObject.amount, sectionComponentSettings = {
          classes: "element-with-unit",
          title: unit.title,
          iconLeft: unit.icon,
          isSelectable: !0,
          isSelected: this.state.selectedUnits[unit.primaryKey],
          onSelect: this.onSelectUnitCheckboxClick.bind(this, unit.primaryKey, unitObject.amount)
        }, componentsSectionUnitsList.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: unit.identifier
        }))
      }, this), sectionComponentSettings = {
        iconLeft: "icon-game icon-Recruit_inactive",
        classes: "first",
        title: this.possibleSelectedAmount !== this.state.selectedAmount ? servicesInternationalization.localize("Select all unit types") : servicesInternationalization.localize("Deselect all unit types"),
        onClick: this.onSelectDeselectAllUnits
      }, servicesTheme.themeSettings.faqLinks.massReturnUnits && (sectionComponentSettings.iconRight = servicesTheme.themeSettings.imagesClassNames.controls.info, sectionComponentSettings.iconRightOnClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: servicesTheme.themeSettings.faqLinks.baseURL + servicesTheme.themeSettings.faqLinks.massReturnUnits + "&l=" + lang }
      })), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-deselect-all-returning-units"
      })), sectionComponentSettings = {
        iconLeft: servicesTheme.themeSettings.imagesClassNames.units.massSendBack,
        classes: "last",
        rightColumnDataValue: this.state.selectedAmount,
        title: servicesInternationalization.localize(servicesTheme.themeSettings.sendAllUnitsBack[settings.massSendBackActionType]),
        onClick: this.sendAllUnitsBack
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "send-selected-units-home"
      })), componentsSections = componentsSections.concat(componentsSectionUnitsList));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsMassSendBack.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.internationalization, xy.dNames.services.theme, function(gameInstance, CoreControllerElementMenu, utilsOop, utilsObject, servicesInternationalization, servicesTheme) {
  "use strict";
  function MenuUnitsMassSendBackController(options) {
    MenuUnitsMassSendBackController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Recall troops"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuUnitsMassSendBackController, CoreControllerElementMenu), MenuUnitsMassSendBackController.prototype[xy.eNames.menuUnitsMassSendBack.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuUnitsMassSendBackController.prototype[xy.eNames.menuUnitsMassSendBack.sendAllUnitsBack] = function(options) {
    var title = servicesInternationalization.localize(servicesTheme.themeSettings.sendAllUnitsBack[options.massSendBackActionType]);
    return utilsObject.effectiveLength(options.units) ? void this.showDialogDialog({
      title: title,
      text: servicesInternationalization.localize("Do you really want to recall %ld troops?", options.selectedAmount),
      callbackSuccess: this.dataSource.sendAllUnitsBack.bind(this.dataSource, options)
    }) : void this.showDialogAlert({
      title: title,
      text: servicesInternationalization.localize("You haven't chosen any units")
    })
  }, MenuUnitsMassSendBackController.prototype[xy.eNames.menuUnitsMassSendBack.onSendAllUnitsBack] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuUnitsMassSendBackController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.prepareUnitsMassReturnData({
      habitatId: this.initialOptions.habitatId,
      massSendBackActionType: this.initialOptions.massSendBackActionType
    })
  }, MenuUnitsMassSendBackController
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsMassSendBack.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.log, function(gameInstance, CoreDataSource, utilsOop, utilsNetwork, settingsGameConstant, servicesGameDataManager, servicesLog) {
  "use strict";
  function MenuUnitsMassSendBackDataSource(options) {
    MenuUnitsMassSendBackDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitsMassSendBackDataSource, CoreDataSource), MenuUnitsMassSendBackDataSource.prototype.prepareUnitsMassReturnData = function(options) {
    var initialHabitat, unitsForSendingBack, habitatUnitsArray, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    switch (initialHabitat = options.habitatId ? servicesGameDataManager.habitatsCollection.getHabitat(options.habitatId) : currentHabitat, options.massSendBackActionType) {
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RETURN_LOCAL_DEFENDERS:
        unitsForSendingBack = servicesGameDataManager.unitsCollection.getOwnExternalDefendersUnits({ habitatUnitArray: currentHabitat.localHabitatUnitArray });
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_LOCAL_DEFENDERS:
        habitatUnitsArray = servicesGameDataManager.unitsCollection.getForeignerHabitatLocalUnits(initialHabitat.id), unitsForSendingBack = servicesGameDataManager.unitsCollection.getOwnExternalDefendersUnits({ habitatUnitArray: habitatUnitsArray });
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_EXTERNAL_DEFENDERS:
        unitsForSendingBack = servicesGameDataManager.unitsCollection.getOwnExternalDefendersUnits({ habitatUnitArray: currentHabitat.remoteHabitatUnitArray });
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_EXTERNAL_ATTACKERS:
        unitsForSendingBack = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: currentHabitat.remoteHabitatUnitArray });
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_LOCAL_ATTACKERS:
        habitatUnitsArray = servicesGameDataManager.unitsCollection.getForeignerHabitatLocalUnits(initialHabitat.id), unitsForSendingBack = servicesGameDataManager.unitsCollection.getAttackerUnits({ habitatUnitArray: habitatUnitsArray });
        break;
      default:
        servicesLog("warn", "Unknown type of mass send back action")
    }
    data.massSendBackActionType = options.massSendBackActionType, data.unitsObject = unitsForSendingBack, data.initialHabitat = initialHabitat, data.currentHabitat = currentHabitat, this.notify(xy.eNames.menuUnitsMassSendBack.dataIsReady, data)
  }, MenuUnitsMassSendBackDataSource.prototype.sendAllUnitsBack = function(options) {
    var action, unitPk, unitIdArray = [], params = {};
    for (unitPk in options.units)options.units.hasOwnProperty(unitPk) && options.units[unitPk] && unitIdArray.push(unitPk);
    switch (params.unitIDArray = unitIdArray, options.massSendBackActionType) {
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RETURN_LOCAL_DEFENDERS:
        action = "TransitAction/returnUnitsOfTypesFromHabitat", params.sourceHabitatID = options.initialHabitat.id;
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_EXTERNAL_DEFENDERS:
        action = "TransitAction/recallDefendingUnitsOfTypesToHabitat", params.destinationHabitatID = options.initialHabitat.id;
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_EXTERNAL_ATTACKERS:
        action = "TransitAction/recallAttackingUnitsOfTypesToHabitat", params.destinationHabitatID = options.initialHabitat.id;
        break;
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_LOCAL_ATTACKERS:
      case settingsGameConstant.SEND_ALL_UNITS_BACK.RECALL_LOCAL_DEFENDERS:
        action = "TransitAction/recallUnitsOfTypesFromHabitat", params.sourceHabitatID = options.initialHabitat.id;
        break;
      default:
        servicesLog("warn", "Unknown type of mass send back action")
    }
    this.request(params, action, { callBack: this.onSendAllUnits })
  }, MenuUnitsMassSendBackDataSource.prototype.onSendAllUnits = function(data) {
    this.handleSessionUpdateResponse(data), this.notify(xy.eNames.menuUnitsMassSendBack.onSendAllUnitsBack)
  }, MenuUnitsMassSendBackDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.menuUnitsMassSendBack.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuUnitsMassSendBack.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuUnitsMassSendBackComponent) {
  "use strict";
  function MenuUnitsMassSendBackPresenter(options) {
    MenuUnitsMassSendBackPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuUnitsMassSendBackPresenter, CorePresenterElementMenu), MenuUnitsMassSendBackPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuUnitsMassSendBackComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuUnitsMassSendBackPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuExternalIFrameInjection.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.services.log, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, function(componentsEngine, mixinsMenuComponentHandlers, servicesLog, ComponentsMenuSection, ComponentsMenuTitleBarMain) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], onIFrameLoaded: function() {
      var tif = componentsEngine.findDOMNode(this.refs.targetIFrame), container = componentsEngine.findDOMNode(this.refs.mainContainer), loaderContainer = componentsEngine.findDOMNode(this.refs.loaderContainer), titleContainer = componentsEngine.findDOMNode(this.refs.titleContainer), containerHeight = container.clientHeight || container.scrollHeight || container.offsetHeight, titleHeight = titleContainer.clientHeight || titleContainer.scrollHeight || titleContainer.offsetHeight;
      loaderContainer.setAttribute("style", "display: none"), tif.setAttribute("style", "height: " + (containerHeight - titleHeight - 10) + "px;display: block"), this.refs.targetIFrame.forceUpdate(null), this.refs.loaderContainer.forceUpdate(null)
    }, render: function() {
      var settings = { url: "http://www.xyrality.com" };
      Object.assign(settings, this.props.settings);
      var titleSettings = { title: this.props.settingsTitle.localizedTitle };
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var componentsSections = [];
      componentsSections.push(React.createElement("div", {
        ref: "loaderContainer",
        className: "i-frame-loader--container",
        dangerouslySetAttributes: { style: "display: block" },
        key: "loader-image"
      }, React.createElement("img", { src: xy.res.loadingAnimation }))), componentsSections.push(React.createElement("iframe", {
        ref: "targetIFrame",
        className: "menu-i-frame",
        src: settings.url,
        seamless: !0,
        onLoad: this.onIFrameLoaded,
        dangerouslySetAttributes: { style: "display: none" },
        key: "iframe"
      }, "If you see this message, it means that your browser does not support frames or they are disabled. You can access the information shown in this frame ", React.createElement("a", { href: settings.url }, " ", "here", " ")));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, {
          settings: titleSettings,
          ref: "titleContainer"
        }), tapBar: null, searchBar: null, bottomBar: null, content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: "mainContainer",
        key: this.props.presenter.controller.instanceId
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuExternalIFrameInjection.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.log, function(CoreControllerElementMenu, utilsOop, servicesLog) {
  "use strict";
  function MenuExternalIFrameInjectionController(options) {
    MenuExternalIFrameInjectionController.__super__.constructor.call(this, options), this.localizedName = ""
  }

  return utilsOop.extend(MenuExternalIFrameInjectionController, CoreControllerElementMenu), MenuExternalIFrameInjectionController.prototype.prepareDataForDraw = function() {
    var data = {};
    return this.initialOptions && this.initialOptions.targetURL ? (data.url = this.initialOptions.targetURL, this.initialOptions.menuTitle && (this.localizedName = this.initialOptions.menuTitle), void this.presenter.draw(data)) : void servicesLog("error", "An attempt to create if menu-external-i-frame-injection without passing a url")
  }, MenuExternalIFrameInjectionController
}]),xy.dStaticInjector.set(xy.dNames.game.menuExternalIFrameInjection.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, function(CoreDataSource, utilsOop) {
  "use strict";
  function MenuExternalIFrameInjectionDataSource(options) {
    MenuExternalIFrameInjectionDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuExternalIFrameInjectionDataSource, CoreDataSource), MenuExternalIFrameInjectionDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuExternalIFrameInjection.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuExternalIFrameInjection.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuExternalIFrameInjectionComponent) {
  "use strict";
  function MenuExternalIFrameInjectionPresenter(options) {
    MenuExternalIFrameInjectionPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuExternalIFrameInjectionPresenter, CorePresenterElementMenu), MenuExternalIFrameInjectionPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuExternalIFrameInjectionComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuExternalIFrameInjectionPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuTransitOverview.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetUnitsList, xy.dNames.components.widgetResourcesList, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTextBasic, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsHabitatMenuElement, ComponentsWidgetUnitList, ComponentsWidgetResourcesList) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onPublishInAllianceClashClick: function(transitId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuTransitOverview.publishInAllianceClash, { transitId: transitId })
    },
    onCallForHelpButtonClick: function(habitatId, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuTransitOverview.callForHelpInAlliance, { habitatId: habitatId })
    },
    render: function() {
      var settings = {
        transit: {},
        ownPlayerId: 0,
        sourceHabitat: null,
        destinationHabitat: {},
        units: null,
        resources: null,
        slowestUnit: null,
        clash: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var addHabitatWithDetails = function(extendedObject, options) {
        options = options || {};
        var localSettings, habitatIcon, habitatDescription, transitOrigin, transitOriginCondition, habitatId = extendedObject.habitat.id, titleForSection = "Source habitat", transit = settings.transit, themeIcons = servicesTheme.themeSettings.imagesClassNames, currentHabitatId = servicesGameDataManager.habitatsCollection.getCurrentHabitatId();
        options.isDestinationHabitat && (titleForSection = "Target habitat", transitOriginCondition = transit.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK ? servicesGameDataManager.habitatsCollection.isHabitatOwnByPlayer(transit.destinationHabitat) : currentHabitatId === transit.destinationHabitat, transitOrigin = transitOriginCondition ? settingsGameConstant.TRANSIT_SUMMARY_TYPE.INCOMING : settingsGameConstant.TRANSIT_SUMMARY_TYPE.OUTGOING, habitatIcon = themeIcons.transitSummary[transitOrigin][transit.transitType], habitatDescription = utilsDateTime.remainTime(settings.transit.destinationETA) + " - " + utilsDateTime.getLocaleDateTimeString(settings.transit.destinationETA)), localSettings = { title: servicesInternationalization.localize(titleForSection) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: localSettings,
          key: "menu-title-details" + habitatId
        })), localSettings = {
          habitat: extendedObject.habitat,
          initialComponent: this
        }, options.isDestinationHabitat && (localSettings.description = habitatDescription, localSettings.iconLeft = habitatIcon), componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
          settings: localSettings,
          key: "menu-element-habitat-details" + habitatId
        })), localSettings = {
          title: extendedObject.player.nick,
          description: extendedObject.player.points,
          iconLeft: "icon-game icon-ButtonPlayer"
        }, extendedObject.player.isEmpty || (localSettings.onClick = this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuPlayerProfileExternal.name,
          options: { playerId: extendedObject.player.id }
        }), localSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localSettings,
          key: "menu-element-player-details" + habitatId
        })), localSettings = {
          title: extendedObject.alliance.name,
          description: extendedObject.alliance.points,
          iconLeft: "icon-game icon-ButtonAlliance"
        }, extendedObject.alliance.isEmpty || (localSettings.onClick = this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuAllianceProfile.name,
          options: { allianceId: extendedObject.alliance.id }
        }), localSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localSettings,
          key: "menu-element-ally-details" + habitatId
        }))
      }.bind(this);
      if (settings.sourceHabitat && addHabitatWithDetails(settings.sourceHabitat), addHabitatWithDetails(settings.destinationHabitat, { isDestinationHabitat: !0 }), settings.units && (sectionComponentSettings = { title: servicesInternationalization.localize("Troops") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "menu-title-troops"
              })), sectionComponentSettings = {
                initialComponent: this,
                unitsList: settings.units
              }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
                settings: sectionComponentSettings,
                key: "menu--troops-list"
              }))), settings.resources && (sectionComponentSettings = { title: servicesInternationalization.localize("Transit resources") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "component-title-resource"
              })), sectionComponentSettings = { resourcesDictionary: settings.resources }, componentsSections.push(React.createElement(ComponentsWidgetResourcesList, {
                settings: sectionComponentSettings,
                key: "component-resource-list-widget"
              }))), settings.slowestUnit && (sectionComponentSettings = { title: servicesInternationalization.localize("Slowest unit") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "menu-title-troops"
              })), sectionComponentSettings = {
                initialComponent: this,
                unitsList: settings.slowestUnit
              }, componentsSections.push(React.createElement(ComponentsWidgetUnitList, {
                settings: sectionComponentSettings,
                key: "menu--slowest-troops-list"
              }))), settings.clash) {
        var buttonTitle, alreadySharedText, iconClashButton, clashOnClick;
        switch (settings.clash.isPlayerUnderAttack) {
          case!0:
            buttonTitle = "Call Help", alreadySharedText = "You have already sought help for this attack", iconClashButton = "icon-game icon-Defence", clashOnClick = this.onCallForHelpButtonClick.bind(this, settings.destinationHabitat.habitat.id);
            break;
          case!1:
            buttonTitle = "Plan Attack", alreadySharedText = "You have already sought help for this attack", iconClashButton = "icon-game icon-AttackIcon", clashOnClick = this.onPublishInAllianceClashClick.bind(this, settings.transit.id)
        }
        settings.clash.isSharedWithAlliance && (sectionComponentSettings = { text: servicesInternationalization.localize(alreadySharedText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-clash-already-shared"
        }))), sectionComponentSettings = {
          iconLeft: iconClashButton,
          onClick: clashOnClick,
          title: servicesInternationalization.localize(buttonTitle),
          description: servicesInternationalization.localize("share with alliance"),
          disabled: settings.clash.isSharedWithAlliance
        }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "menu-element-clash-button"
        }))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuTransitOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuTransitOverviewController(options) {
    MenuTransitOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Transits")
  }

  return utilsOop.extend(MenuTransitOverviewController, CoreControllerElementMenu), MenuTransitOverviewController.prototype[xy.eNames.menuTransitOverview.dataIsReady] = function(data, options) {
    options = options || {}, data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuTransitOverview.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data)
  }, MenuTransitOverviewController.prototype[xy.eNames.menuTransitOverview.publishInAllianceClash] = function(options) {
    this.dataSource.publishTransitClashInAlliance(options)
  }, MenuTransitOverviewController.prototype[xy.eNames.menuTransitOverview.callForHelpInAlliance] = function(options) {
    this.dataSource.shareSupportBridgeWithAlliance({
      habitatId: options.habitatId,
      callBack: this.dataSource.doSessionUpdate
    })
  }, MenuTransitOverviewController.prototype[xy.eNames.menuTransitOverview.speedUpTransit] = function(modeledTransit) {
    var cost = modeledTransit.getSpeedUpTransitCost(), data = {
      transitId: modeledTransit.id,
      cost: cost
    }, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
    if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
    if (cost) {
      var localizationString = "Speeding up the transit costs %1$d gold coins. You own %2$d gold coins.", text = servicesInternationalization.localize(localizationString, cost, gold), settings = {
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.speedUpTransit.bind(this.dataSource, data)
      };
      this.showDialogDialog(settings)
    } else this.dataSource.speedUpTransit(data)
  }, MenuTransitOverviewController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate(), this.isVisible() && this.dataSource.prepareTransitOverviewData(this.initialOptions.transitId)
  }, MenuTransitOverviewController
}]),xy.dStaticInjector.set(xy.dNames.game.menuTransitOverview.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.storage, function(gameInstance, CoreDataSource, utilsOop, utilsObject, utilsNetwork, settingsGameConstant, servicesGameDataManager, servicesInternationalization, serviceStorage) {
  "use strict";
  function MenuTransitOverviewDataSource(options) {
    var menuAllianceClashDataSource = gameInstance.injector.get(xy.dNames.game.menuAllianceClashes.dataSource), menuSupportBridgeDataSource = gameInstance.injector.get(xy.dNames.game.menuSupportBridge.dataSource);
    this.forLinking = [{
      resourceClass: menuAllianceClashDataSource,
      methodName: "publishTransitClashInAlliance"
    }, {
      resourceClass: menuSupportBridgeDataSource,
      methodName: "shareSupportBridgeWithAlliance"
    }], MenuTransitOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuTransitOverviewDataSource, CoreDataSource), MenuTransitOverviewDataSource.prototype.prepareTransitOverviewData = function(transitId) {
    var data = {}, transit = servicesGameDataManager.transitsCollection.getTransit(transitId);
    if (!transit)return void this.notify(xy.eNames.menu.onDataExpired);
    if (data.transit = transit, data.ownPlayerId = servicesGameDataManager.getPlayerId(), data.isTimerable = !0, transit.sourceHabitat && (data.sourceHabitat = servicesGameDataManager.habitatsCollection.getExtendedHabitatData(transit.sourceHabitat, {
              extendWithPLayer: !0,
              extendWithAlliance: !0
            })), data.destinationHabitat = servicesGameDataManager.habitatsCollection.getExtendedHabitatData(transit.destinationHabitat, {
              extendWithPLayer: !0,
              extendWithAlliance: !0
            }), utilsObject.isEmpty(transit.unitDictionary) || (data.units = servicesGameDataManager.unitsCollection.getUnitsListForUnitDictionary(transit.unitDictionary)), utilsObject.isEmpty(transit.resourceDictionary) || (data.resources = transit.resourceDictionary), transit.slowestUnitId) {
      var slowestUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: transit.slowestUnitId });
      data.slowestUnit = [{ unit: slowestUnit }]
    }
    var isOwnHabitat = servicesGameDataManager.habitatsCollection.isHabitatOwnByPlayer(transit.destinationHabitat), hasAttackers = !!transit.slowestUnitId, isPlayerUnderAttack = isOwnHabitat && hasAttackers, isPlayerInAlliance = servicesGameDataManager.alliancesCollection.getAlliance();
    transit.transitType === settingsGameConstant.TRANSIT_TYPE.ATTACK && isPlayerInAlliance && (data.clash = {
      isSharedWithAlliance: !1,
      isPlayerUnderAttack: !1
    }, isPlayerUnderAttack && (data.clash.isPlayerUnderAttack = !0, servicesGameDataManager.alliancesCollection.warClashedSet.habitats[transit.destinationHabitat] && (data.clash.isSharedWithAlliance = !0)), servicesGameDataManager.alliancesCollection.warClashedSet.transits[transitId] && (data.clash.isSharedWithAlliance = !0)), this.notify(xy.eNames.menuTransitOverview.dataIsReady, data, { isForced: !0 })
  }, MenuTransitOverviewDataSource.prototype.speedUpTransit = function(data) {
    data && data.transitId && this.request({
      transitID: data.transitId,
      paymentAmount: data.cost
    }, "TransitAction/finishReturningTransit", { callBack: this.speedUpTransitResponse })
  }, MenuTransitOverviewDataSource.prototype.speedUpTransitResponse = function(data) {
    data && data.error && data.error === settingsGameConstant.SERVER_ERRORS.NO_TRANSIT ? this.controller.showDialogAlert({
      title: servicesInternationalization.localize("Error"),
      text: servicesInternationalization.localize("Your transport has already returned to the castle")
    }) : this.handleSessionUpdateResponse(data)
  }, MenuTransitOverviewDataSource.prototype.startTransit = function(options) {
    options = options || {};
    var sourceHabitatId = options.sourceHabitat.id, destinationHabitatId = options.destinationHabitat.id, param = {
      sourceHabitatID: sourceHabitatId,
      destinationHabitatID: destinationHabitatId,
      transitType: options.transitType,
      unitDictionary: utilsNetwork.dictionaryToQueryString(options.units)
    };
    options.resources && (param.resourceDictionary = utilsNetwork.dictionaryToQueryString(options.resources)), options.earliestArrivalTime && (param.earliestArrivalTime = options.earliestArrivalTime.valueOf()), this.request(param, "TransitAction/startTransit", { callBack: this.onStartTransit.bind(this, options) })
  }, MenuTransitOverviewDataSource.prototype.synchronizeTransit = function(options) {
    options = options || {};
    var param = {
      sourceHabitatID: options.sourceHabitat.id,
      destinationHabitatID: options.destinationHabitat.id,
      transitType: options.transitType,
      unitDictionary: utilsNetwork.dictionaryToQueryString(options.units),
      transitID: options.transit.id
    };
    options.resources && (param.resourceDictionary = utilsNetwork.dictionaryToQueryString(options.resources)), this.request(param, "TransitAction/synchronizeTransit", { callBack: this.onStartTransit.bind(this, options) })
  }, MenuTransitOverviewDataSource.prototype.onStartTransit = function(options, data) {
    if (!data.error && options.hasOwnProperty("lastFormationMode") && !options.disableLastFormationCacheRewriting) {
      var cacheObject = { lastFormationMode: options.lastFormationMode, unitsDictionary: options.units };
      options.resources && (cacheObject.resourcesDictionary = options.resources), serviceStorage.storeLastFormationUnits(cacheObject)
    }
    this.handleSessionUpdateResponse(data)
  }, MenuTransitOverviewDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuTransitOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuTransitOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuTransitOverviewComponent) {
  "use strict";
  function MenuTransitOverviewPresenter(options) {
    MenuTransitOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuTransitOverviewPresenter, CorePresenterElementMenu), MenuTransitOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuTransitOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuTransitOverviewPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeChooser.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.tapBarHabitatType, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesGameDataManager, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsTapBarHabitatType) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    updateCurrentMode: function(newTabMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuAllianceClashes.onTabSwitch, { newTabMode: newTabMode })
    },
    onKnowledgeChoose: function(knowledge, habitatTypeMode) {
      switch (this.props.settings.mode) {
        case settingsGameConstant.KNOWLEDGE_CHOOSER_LIST_MODE.MASS_KNOWLEDGE:
          this.handlerNextClick({
            next: xy.dNames.game.menuMassFunctionKnowledge.name,
            options: { chosenKnowledge: knowledge, habitatTypeMode: habitatTypeMode }
          })
      }
    },
    render: function() {
      var settings = {
        availableHabitatTypes: {},
        mode: settingsGameConstant.KNOWLEDGE_CHOOSER_LIST_MODE.MASS_KNOWLEDGE,
        tabMode: settingsGameConstant.HABITAT_TYPE.CASTLE,
        knowledgesList: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var tapBar = null, tapBarSettings = null;
      utilsObject.effectiveLength(settings.availableHabitatTypes) > 1 && (tapBarSettings = {
        tabMode: settings.tabMode,
        availableHabitatTypes: settings.availableHabitatTypes,
        onBarButtonClick: this.updateCurrentMode
      }, tapBar = React.createElement(ComponentsTapBarHabitatType, { settings: tapBarSettings })), settings.knowledgesList.forEach(function(knowledgeAvailableForRunStudyObject) {
        var localComponentSettings = {
          title: knowledgeAvailableForRunStudyObject.knowledge.title,
          iconLeft: knowledgeAvailableForRunStudyObject.knowledge.icon,
          iconRight: "controls menu-next",
          onClick: this.onKnowledgeChoose.bind(this, knowledgeAvailableForRunStudyObject.knowledge, settings.tabMode)
        };
        settings.mode === settingsGameConstant.KNOWLEDGE_CHOOSER_LIST_MODE.MASS_KNOWLEDGE && (localComponentSettings.disabled = !0, localComponentSettings.rightColumnDataValue = knowledgeAvailableForRunStudyObject.availableForRunStudy.toString(), knowledgeAvailableForRunStudyObject.availableForRunStudy > 0 && (localComponentSettings.disabled = !1)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localComponentSettings,
          key: "knowledges-in-list-" + knowledgeAvailableForRunStudyObject.knowledge.primaryKey
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: tapBar,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeChooser.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  function MenuKnowledgeChooserController(options) {
    MenuKnowledgeChooserController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.allianceClashes,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.currentTabMode = servicesGameDataManager.habitatsCollection.getDefaultHabitatTabMode(), this.localizedName = servicesInternationalization.localize("Knowledge Selection"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuKnowledgeChooserController, CoreControllerElementMenu), MenuKnowledgeChooserController.prototype[xy.eNames.menuKnowledgeChooser.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuKnowledgeChooserController.prototype[xy.eNames.menuAllianceClashes.onTabSwitch] = function(options) {
    this.currentTabMode = options.newTabMode, this.prepareDataForDraw()
  }, MenuKnowledgeChooserController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.prepareKnowledgeLists({
      tabMode: this.currentTabMode,
      mode: this.initialOptions.mode
    })
  }, MenuKnowledgeChooserController
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeChooser.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.worldSettings, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.sortable, function(CoreDataSource, utilsOop, settingsGameConstant, servicesWorldSettings, servicesGameDataManager, servicesTheme, servicesSortable) {
  "use strict";
  function MenuKnowledgeChooserDataSource(options) {
    MenuKnowledgeChooserDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuKnowledgeChooserDataSource, CoreDataSource), MenuKnowledgeChooserDataSource.prototype.prepareKnowledgeLists = function(options) {
    var availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), knowledgesPKList = servicesTheme.themeSettings.knowledges.listsByHabitatType[options.tabMode], ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [], knowledgesList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      habitatsList.push(modeledHabitat)
    }), knowledgesPKList.forEach(function(knowledgePK) {
      var i, availableForRunStudy = 0, modeledKnowledge = servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: knowledgePK }), len = habitatsList.length;
      if (modeledKnowledge) {
        if (options.mode === settingsGameConstant.KNOWLEDGE_CHOOSER_LIST_MODE.MASS_KNOWLEDGE)for (i = 0; i < len; i += 1)habitatsList[i].canHabitatRunStudyOnKnowledge(modeledKnowledge) && (availableForRunStudy += 1);
        knowledgesList.push({ knowledge: modeledKnowledge, availableForRunStudy: availableForRunStudy })
      }
    }), knowledgesList.sort(servicesSortable.byField("knowledge", "order"));
    var data = {};
    data.availableHabitatTypes = availableHabitatTypes, data.mode = options.mode, data.tabMode = options.tabMode, data.knowledgesList = knowledgesList, this.notify(xy.eNames.menuKnowledgeChooser.dataIsReady, data)
  }, MenuKnowledgeChooserDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeChooser.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuKnowledgeChooser.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuKnowledgeListComponent) {
  "use strict";
  function MenuKnowledgeChooserPresenter(options) {
    MenuKnowledgeChooserPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuKnowledgeChooserPresenter, CorePresenterElementMenu), MenuKnowledgeChooserPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuKnowledgeListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuKnowledgeChooserPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeOverview.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.overviewWidgetConstructCost, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsWidgetConstructBuildingCost) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = {
        knowledge: {},
        enabledByKnowledge: null,
        currentHabitat: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], knowledge = settings.knowledge;
      if (sectionComponentSettings = {
                iconLeft: knowledge.icon,
                title: knowledge.title
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "knowledge-overview-name"
              })), sectionComponentSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.knowledges.descriptionKey + knowledge.primaryKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "knowledge-overview-description"
              })), sectionComponentSettings = {
                constructingEntity: knowledge,
                currentHabitat: settings.currentHabitat,
                initialComponent: this
              }, componentsSections.push(React.createElement(ComponentsWidgetConstructBuildingCost, {
                settings: sectionComponentSettings,
                key: "knowledge-overview-cost"
              })), knowledge.modifierArray instanceof Array && knowledge.modifierArray.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Modifies") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "knowledge-overview-bonus-title"
              })), knowledge.modifierArray.forEach(function(modifierPK) {
                var modifierModel = servicesGameDataManager.modifiersCollection.getModifier({ primaryKey: modifierPK }), localComponentSettings = {
                  iconLeft: modifierModel.icon,
                  title: modifierModel.title
                };
                componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                  settings: localComponentSettings,
                  key: "knowledge-overview-modifier-" + modifierPK
                }))
              }, this)), settings.enabledByKnowledge) {
        sectionComponentSettings = { title: servicesInternationalization.localize("Enables") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "knowledge-overview-enables-title"
        }));
        var entity, addEnables = function(entity, entityPrimaryKey) {
          var onClick, modeledEntity, title, localComponentSettings;
          switch (entity = +entity) {
            case settingsGameConstant.ENTITY.BUILDING:
              modeledEntity = servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: entityPrimaryKey }), title = servicesInternationalization.localize(modeledEntity.title) + " " + modeledEntity.level, onClick = this.handlerNextClick.bind(this, {
                next: xy.dNames.game.menuBuildingOverview.name,
                options: { classIdentifier: modeledEntity.classIdentifier }
              });
              break;
            case settingsGameConstant.ENTITY.UNIT:
              modeledEntity = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: entityPrimaryKey }), title = modeledEntity.title, onClick = this.handlerNextClick.bind(this, {
                next: xy.dNames.game.menuUnitOverview.name,
                options: { unit: modeledEntity }
              });
              break;
            case settingsGameConstant.ENTITY.KNOWLEDGE:
              modeledEntity = servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: entityPrimaryKey }), title = modeledEntity.title, onClick = this.handlerNextClick.bind(this, {
                next: xy.dNames.game.menuKnowledgeOverview.name,
                options: { knowledge: modeledEntity }
              })
          }
          localComponentSettings = {
            onClick: onClick,
            iconLeft: modeledEntity.icon,
            title: title,
            iconRight: "controls menu-next"
          }, sectionComponentSettings = { title: servicesInternationalization.localize("BKServerKnowledge-" + knowledge.primaryKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
            settings: localComponentSettings,
            key: "knowledge-overview-enables-" + entity + entityPrimaryKey
          }))
        };
        for (entity in settings.enabledByKnowledge)settings.enabledByKnowledge.hasOwnProperty(entity) && settings.enabledByKnowledge[entity].forEach(addEnables.bind(this, entity))
      }
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, function(CoreControllerElementMenu, utilsOop) {
  "use strict";
  function MenuKnowledgeOverviewController(options) {
    MenuKnowledgeOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }]
  }

  return utilsOop.extend(MenuKnowledgeOverviewController, CoreControllerElementMenu), MenuKnowledgeOverviewController.prototype.prepareDataForDraw = function() {
    var data, knowledge = this.initialOptions.knowledge;
    this.localizedName = knowledge.title, this.isActive && (data = this.dataSource.prepareKnowledgeOverviewData({ knowledge: knowledge }), this.presenter.draw(data))
  }, MenuKnowledgeOverviewController
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeOverview.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuKnowledgeOverviewDataSource(options) {
    MenuKnowledgeOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuKnowledgeOverviewDataSource, CoreDataSource), MenuKnowledgeOverviewDataSource.prototype.prepareKnowledgeOverviewData = function(options) {
    return {
      currentHabitat: servicesGameDataManager.habitatsCollection.getCurrentHabitat(),
      enabledByKnowledge: servicesGameDataManager.knowledgesCollection.getEnabledByKnowledge(options.knowledge.primaryKey),
      knowledge: options.knowledge
    }
  }, MenuKnowledgeOverviewDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuKnowledgeOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuKnowledgeOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuKnowledgeOverviewComponent) {
  "use strict";
  function MenuKnowledgeOverviewPresenter(options) {
    MenuKnowledgeOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuKnowledgeOverviewPresenter, CorePresenterElementMenu), MenuKnowledgeOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuKnowledgeOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuKnowledgeOverviewPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMissionOverview.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetBatchResourcesUnits, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsWidgetBatchResourcesUnits) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], render: function() {
      var settings = {
        mission: {},
        resourceProductionWithModifiers: {},
        currentHabitat: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], mission = settings.mission;
      sectionComponentSettings = {
        iconLeft: mission.icon,
        title: mission.title
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "mission-overview-name"
      })), sectionComponentSettings = { title: servicesInternationalization.localize(servicesTheme.themeSettings.missions.descriptionKey + mission.primaryKey) }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "mission-overview-description"
      })), sectionComponentSettings = {
        iconLeft: "icon-game icon-Duration",
        title: servicesInternationalization.localize("Duration"),
        rightColumnDataValue: utilsDateTime.secondsToTimeString(mission.duration)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "mission-overview-duration"
      })), utilsObject.isEmpty(mission.resourceConsumption) || (sectionComponentSettings = {
        title: servicesInternationalization.localize("Resources needed"),
        resources: mission.resourceConsumption,
        currentHabitat: settings.currentHabitat
      }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
        settings: sectionComponentSettings,
        key: "mission-overview-resources-consumption"
      }))), utilsObject.isEmpty(mission.unitConsumption) || (sectionComponentSettings = {
        title: servicesInternationalization.localize("Units needed"),
        units: mission.unitConsumption,
        currentHabitat: settings.currentHabitat
      }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
        settings: sectionComponentSettings,
        key: "mission-overview-units-consumption"
      })));
      var resourceVariance = mission.resourceProductionVarianceInt > 0 && mission.resourceProductionVarianceScale > 0 ? mission.resourceProductionVarianceInt / Math.pow(10, mission.resourceProductionVarianceScale) : 1;
      utilsObject.isEmpty(settings.resourceProductionWithModifiers) || (sectionComponentSettings = {
        title: servicesInternationalization.localize("Resources produced"),
        resources: settings.resourceProductionWithModifiers,
        resourceVariance: resourceVariance
      }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
        settings: sectionComponentSettings,
        key: "mission-overview-resources-production"
      })));
      var unitVariance = mission.unitProductionVarianceInt > 0 && mission.unitProductionVarianceScale > 0 ? mission.unitProductionVarianceInt / Math.pow(10, mission.unitProductionVarianceScale) : 1;
      utilsObject.isEmpty(mission.unitProduction) || 1 === unitVariance || (sectionComponentSettings = {
        title: servicesInternationalization.localize("Units produced"),
        units: mission.unitProduction,
        unitVariance: unitVariance
      }, componentsSections.push(React.createElement(ComponentsWidgetBatchResourcesUnits, {
        settings: sectionComponentSettings,
        key: "mission-overview-units-production"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMissionOverview.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, function(CoreControllerElementMenu, utilsOop) {
  "use strict";
  function MenuMissionOverviewController(options) {
    MenuMissionOverviewController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }]
  }

  return utilsOop.extend(MenuMissionOverviewController, CoreControllerElementMenu), MenuMissionOverviewController.prototype.prepareDataForDraw = function() {
    var data, mission = this.initialOptions.mission;
    this.localizedName = mission.title, this.isActive && (data = this.dataSource.prepareMissionOverviewData({ mission: mission }), this.presenter.draw(data))
  }, MenuMissionOverviewController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMissionOverview.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuMisssionOverviewDataSource(options) {
    MenuMisssionOverviewDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMisssionOverviewDataSource, CoreDataSource), MenuMisssionOverviewDataSource.prototype.prepareMissionOverviewData = function(options) {
    var currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), mission = options.mission, abilitiesWithModifiers = currentHabitat.applyModifiers({
      targetObject: "Mission",
      generateResource: mission.resourceProduction
    });
    return {
      currentHabitat: currentHabitat,
      resourceProductionWithModifiers: abilitiesWithModifiers.generateResource,
      mission: mission
    }
  }, MenuMisssionOverviewDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMissionOverview.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMissionOverview.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMissionOverviewComponent) {
  "use strict";
  function MenuMissionOverviewPresenter(options) {
    MenuMissionOverviewPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMissionOverviewPresenter, CorePresenterElementMenu), MenuMissionOverviewPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMissionOverviewComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMissionOverviewPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesExchangeableList.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onResourceClick: function(resourceId, event) {
      switch (this.props.settings.mode) {
        case settingsGameConstant.RESOURCE_EXCHANGEABLE_LIST_MODE.MASS_EXCHANGE:
          this.handlerNextClick({
            next: xy.dNames.game.menuUnitChooser.name,
            options: { chosenResourceId: +resourceId, mode: settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_EXCHANGE }
          }, event)
      }
    },
    render: function() {
      var settings = {
        resourcesList: [],
        mode: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, componentsSections = [], themeRosourcesSettings = servicesTheme.themeSettings.resources;
      settings.resourcesList.forEach(function(resourceId) {
        var nameResource = themeRosourcesSettings[resourceId];
        sectionComponentSettings = {
          iconLeft: "icon-resource icon-resource-" + resourceId,
          iconRight: "controls menu-next",
          title: servicesInternationalization.localize(nameResource),
          onClick: this.onResourceClick.bind(this, resourceId)
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "resource" + resourceId
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesExchangeableList.controller, [xy.dNames.gameInstance, xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(gameInstance, CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuResourcesExchangeableListController(options) {
    MenuResourcesExchangeableListController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Select resource")
  }

  return utilsOop.extend(MenuResourcesExchangeableListController, CoreControllerElementMenu), MenuResourcesExchangeableListController.prototype.prepareDataForDraw = function() {
    var data;
    this.isActive && (data = this.dataSource.prepareUnitListData(), data.mode = this.initialOptions.mode, this.presenter.draw(data))
  }, MenuResourcesExchangeableListController
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesExchangeableList.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuResourcesExchangeableListDataSource(options) {
    MenuResourcesExchangeableListDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuResourcesExchangeableListDataSource, CoreDataSource), MenuResourcesExchangeableListDataSource.prototype.prepareUnitListData = function() {
    var resourceId, data = {}, resourcesExchangeableThemeSettings = servicesTheme.themeSettings.resources.exchangeable, resourcesList = [];
    for (resourceId in resourcesExchangeableThemeSettings)resourcesExchangeableThemeSettings.hasOwnProperty(resourceId) && resourcesList.push(resourceId);
    return data.resourcesList = resourcesList, data
  }, MenuResourcesExchangeableListDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesExchangeableList.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuResourcesExchangeableList.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuResourcesExchangeableListComponent) {
  "use strict";
  function MenuResourcesExchangeableListPresenter(options) {
    MenuResourcesExchangeableListPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuResourcesExchangeableListPresenter, CorePresenterElementMenu), MenuResourcesExchangeableListPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuResourcesExchangeableListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuResourcesExchangeableListPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesMarket.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.moving, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListButtonBasic, xy.dNames.components.widgetRangeSliderDivider, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilMoving, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsMenuListButtonBasic, ComponentsWidgetRangeSliderDivider) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return {
        totalCapacity: 0,
        totalForExchange: 0,
        tradeResourceAmount: 0,
        unitDictionary: {},
        resourceDictionary: {}
      }
    }, componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceRedraw || newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id) && this.setState({
        totalCapacity: 0,
        totalForExchange: 0,
        tradeResourceAmount: 0,
        unitDictionary: {},
        resourceDictionary: {}
      }, null)
    }, onAutoFillClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var totalCapacity = utilMoving.computeUnitsCapacity(this.state.unitDictionary, this.props.settings.exchangeableResource), tempResourceDictionary = utilMoving.fillUnitsCapacity({
        availableResources: this.props.settings.availableResources,
        totalCapacity: totalCapacity
      }), totalLoaded = utilMoving.computeTotalResourcesLoaded(tempResourceDictionary);
      this.setState({
        resourceDictionary: tempResourceDictionary,
        totalForExchange: totalLoaded,
        tradeResourceAmount: utilMoving.getExpectedAmountOfExchangesResource({
          resourceDictionary: tempResourceDictionary,
          availableResources: this.props.settings.availableResources
        })
      }, null)
    }, onSetValueByRangeSlider: function(dictionaryKey, primaryKey, amount) {
      var totalLoaded, tempResourceDictionary, dictionary = this.state[dictionaryKey], newStates = {};
      switch (dictionary[primaryKey] = amount, dictionaryKey) {
        case"unitDictionary":
          var totalCapacity = utilMoving.computeUnitsCapacity(dictionary, this.props.settings.exchangeableResource);
          totalCapacity < utilMoving.computeTotalResourcesLoaded(this.state.resourceDictionary) && (tempResourceDictionary = utilMoving.fillUnitsCapacity({
            availableResources: this.props.settings.availableResources,
            totalCapacity: totalCapacity
          }), newStates.totalForExchange = utilMoving.computeTotalResourcesLoaded(tempResourceDictionary), newStates.resourceDictionary = tempResourceDictionary, newStates.tradeResourceAmount = utilMoving.getExpectedAmountOfExchangesResource({
            resourceDictionary: tempResourceDictionary,
            availableResources: this.props.settings.availableResources
          })), newStates.unitDictionary = dictionary, newStates.totalCapacity = totalCapacity, this.setState(newStates, null);
          break;
        case"resourceDictionary":
          totalLoaded = utilMoving.computeTotalResourcesLoaded(dictionary), newStates.resourceDictionary = dictionary, newStates.totalForExchange = totalLoaded, newStates.tradeResourceAmount = utilMoving.getExpectedAmountOfExchangesResource({
            resourceDictionary: dictionary,
            availableResources: this.props.settings.availableResources
          }), this.setState(newStates, null)
      }
    }, onTradeResourceClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuResourcesMarket.tradeResource, {
        resourceDictionary: this.state.resourceDictionary,
        unitDictionary: this.state.unitDictionary,
        tradingResourceId: this.props.settings.tradingResourceId,
        habitat: this.props.settings.currentHabitat
      })
    }, render: function() {
      var settings = {
        currentHabitat: null,
        tradingResourceId: 0,
        marketBuilding: 0,
        availableUnits: null,
        availableResources: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, rightActionButton, rightActionButtonSettings, componentsSections = [], tradingResourceId = settings.tradingResourceId, resourcesThemeSettings = servicesTheme.themeSettings.resources, themesIcons = servicesTheme.themeSettings.imagesClassNames.startTransit, wantedResourceTitle = servicesInternationalization.localize(resourcesThemeSettings[tradingResourceId]);
      sectionComponentSettings = { title: servicesInternationalization.localize("Wanted resource") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-wanted-resource"
      })), sectionComponentSettings = {
        iconLeft: "icon icon-resource icon-resource-" + tradingResourceId,
        title: wantedResourceTitle,
        rightColumnDataValue: this.state.tradeResourceAmount.toString()
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "wanted-resource"
      })), settings.availableUnits.length ? (sectionComponentSettings = { title: servicesInternationalization.localize("Transport units") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-transport-unit"
      })), settings.availableUnits.forEach(function(UnitAmountObject) {
        var unit = UnitAmountObject.unit, unitPrimaryKey = unit.primaryKey;
        sectionComponentSettings = {
          handleIcon: unit.icon,
          currentValue: this.state.unitDictionary[unitPrimaryKey] || 0,
          minValue: 0,
          maxValue: UnitAmountObject.amount,
          title: unit.title,
          onChange: this.onSetValueByRangeSlider.bind(this, "unitDictionary", unitPrimaryKey)
        }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
          settings: sectionComponentSettings,
          key: "transportation-unit-range-slider-" + unitPrimaryKey
        }))
      }, this)) : (sectionComponentSettings = { title: servicesInternationalization.localize("No units found in habitat.") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "title-no-unit"
      })));
      var transportTimeInSeconds = utilMoving.getTransportationTime(this.state.unitDictionary, { distance: settings.marketBuilding.marketDistance });
      sectionComponentSettings = {
        iconLeft: themesIcons.transportTime,
        title: servicesInternationalization.localize("Transport duration"),
        rightColumnDataValue: utilsDateTime.secondsToTimeString(transportTimeInSeconds, !0)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "transport-time"
      }));
      var arrivalDate = utilMoving.getArrivalTime(this.state.unitDictionary, { distance: settings.marketBuilding.marketDistance }), cycle = utilsDateTime.getDayCycle(arrivalDate);
      if (sectionComponentSettings = {
                iconLeft: themesIcons.transportTime,
                title: servicesInternationalization.localize("Destination ETA")
              }, utilsObject.effectiveLength(this.state.unitDictionary) ? (sectionComponentSettings.rightColumnLeftIcon = "icon-game colored icon-" + cycle + "Icon", sectionComponentSettings.rightColumnDataValue = utilsDateTime.getLocaleDateTimeString(arrivalDate)) : sectionComponentSettings.rightColumnDataValue = settingsGameConstant.ARRIVAL_DEFAULT_TIME, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings, key: "arrival-time"
              })), rightActionButtonSettings = {
                icon: "white " + themesIcons.fillTransport,
                onClick: this.onAutoFillClick
              }, rightActionButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightActionButtonSettings }), sectionComponentSettings = {
                iconLeft: themesIcons.capacity,
                title: servicesInternationalization.localize("Transport capacity"),
                rightColumnDataValue: this.state.totalForExchange + "/" + this.state.totalCapacity,
                iconRight: rightActionButton
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "capacity-total"
              })), sectionComponentSettings = { title: servicesInternationalization.localize("Offered resources") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "title-transport-resurces"
              })), settings.availableResources) {
        var resourceRangeSliderTitle = " : 1 " + wantedResourceTitle, freeSpace = this.state.totalCapacity - this.state.totalForExchange, maxLimitOnValue = freeSpace >= 0 ? freeSpace : 0;
        settings.availableResources.forEach(function(resourceIdAmountObject) {
          var resourceId = resourceIdAmountObject.resourceId, currentValue = this.state.resourceDictionary[resourceId] || 0;
          sectionComponentSettings = {
            handleIcon: "icon icon-resource icon-resource-" + resourceId,
            currentValue: currentValue,
            minValue: 0,
            maxValue: resourceIdAmountObject.amount,
            maxLimitOnCurrentValue: maxLimitOnValue + currentValue,
            changeStepValue: resourceIdAmountObject.exchangeRate,
            title: resourceIdAmountObject.exchangeRate + " " + servicesInternationalization.localize(resourcesThemeSettings[resourceId]) + resourceRangeSliderTitle,
            onChange: this.onSetValueByRangeSlider.bind(this, "resourceDictionary", resourceId)
          }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
            settings: sectionComponentSettings,
            key: "transportation-resource-range-slider-" + resourceId
          }))
        }, this)
      }
      sectionComponentSettings = {
        iconLeft: "icon icon-resource icon-resource-" + tradingResourceId,
        title: servicesInternationalization.localize("Barter %@", resourcesThemeSettings[tradingResourceId]),
        rightColumnDataValue: this.state.tradeResourceAmount.toString(),
        onClick: this.onTradeResourceClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-trade-resource"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesMarket.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, utilsObject, servicesInternationalization) {
  "use strict";
  function MenuResourcesMarketController(options) {
    MenuResourcesMarketController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Exchange resources"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuResourcesMarketController, CoreControllerElementMenu), MenuResourcesMarketController.prototype[xy.eNames.menuResourcesMarket.tradeResource] = function(options) {
    return utilsObject.effectiveLength(options.unitDictionary) ? utilsObject.effectiveLength(options.resourceDictionary) ? void this.dataSource.tradeResources(options) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("AlertMessageNoResourcesSelected")
    }) : void this.showDialogAlert({
      title: servicesInternationalization.localize("Insuffient Capacity"),
      text: servicesInternationalization.localize("Please assign more transport units or reduce the amount of resources")
    })
  }, MenuResourcesMarketController.prototype.prepareDataForDraw = function() {
    var data, forceRedraw = !1;
    this.isActive && (this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), data = this.dataSource.prepareDataForMarket({
      tradingResourceId: this.initialOptions.tradingResourceId,
      marketBuilding: this.initialOptions.building,
      forceRedraw: forceRedraw
    }), this.presenter.draw(data))
  }, MenuResourcesMarketController
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesMarket.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuResourcesMarketDataSource(options) {
    MenuResourcesMarketDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuResourcesMarketDataSource, CoreDataSource), MenuResourcesMarketDataSource.prototype.prepareDataForMarket = function(options) {
    var unitsAmountObject, data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat();
    unitsAmountObject = servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
      habitatId: currentHabitat.id,
      habitat: currentHabitat
    });
    var unitsPK, availableUnits = [];
    for (unitsPK in unitsAmountObject)unitsAmountObject.hasOwnProperty(unitsPK) && availableUnits.push({
      unit: servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitsPK }),
      amount: unitsAmountObject[unitsPK]
    });
    data.currentHabitat = currentHabitat, data.tradingResourceId = options.tradingResourceId, data.availableUnits = availableUnits;
    var availableResources = [], themeExchangeableResourceSetting = servicesTheme.themeSettings.resources.exchangeable;
    return themeExchangeableResourceSetting[options.tradingResourceId] instanceof Array && themeExchangeableResourceSetting[options.tradingResourceId].forEach(function(exchangeableResourceId) {
      availableResources.push({
        resourceId: exchangeableResourceId,
        amount: currentHabitat.habitatResourceDictionary[exchangeableResourceId].amount,
        exchangeRate: options.marketBuilding.marketRateDictionary[options.tradingResourceId][exchangeableResourceId]
      })
    }), data.exchangeableResource = themeExchangeableResourceSetting[options.tradingResourceId], data.availableResources = availableResources, data.marketBuilding = options.marketBuilding, data.forceRedraw = options.forceRedraw, data
  }, MenuResourcesMarketDataSource.prototype.tradeResources = function(options) {
    var resourcesDictionary = utilsNetwork.dictionaryToQueryString(options.resourceDictionary), unitDictionary = utilsNetwork.dictionaryToQueryString(options.unitDictionary);
    this.request({
      habitatID: options.habitat.id,
      wantedResourceID: options.tradingResourceId,
      resourceDictionary: resourcesDictionary,
      unitDictionary: unitDictionary
    }, "MarketAction/tradeResources", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuResourcesMarketDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesMarket.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuResourcesMarket.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuResourcesMarketComponent) {
  "use strict";
  function MenuResourcesMarketPresenter(options) {
    MenuResourcesMarketPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuResourcesMarketPresenter, CorePresenterElementMenu), MenuResourcesMarketPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuResourcesMarketComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data,
      key: this.instanceId
    }), document.getElementById(this.domElement))
  }, MenuResourcesMarketPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesNobleMarket.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.moving, xy.dNames.utils.dateTime, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListElementButtonAction, xy.dNames.components.menuListButtonBasic, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetRangeSliderDivider, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilMoving, utilsDateTime, utilsObject, settingsGameConstant, servicesInternationalization, servicesTheme, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic, ComponentsMenuListElementBasic, ComponentsMenuListElementButtonAction, ComponentsMenuListButtonBasic, ComponentsHabitatMenuElement, ComponentsWidgetRangeSliderDivider) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { totalCapacity: this.props.settings.totalCapacity, totalForExchange: 0, resourceDictionary: {} }
    }, componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceNextRedrawUpdate || newProps.settings.currentHabitat.id !== this.props.settings.currentHabitat.id) && this.setState({
        totalCapacity: newProps.settings.totalCapacity,
        totalForExchange: 0,
        resourceDictionary: {},
        tradeResourceAmount: 0
      }, null)
    }, onAutoFillClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var premiumResource = this.props.settings.availableResources[0], totalCapacity = this.state.totalCapacity / premiumResource.exchangeRate, tempResourceDictionary = utilMoving.fillUnitsCapacity({
        availableResources: this.props.settings.availableResources,
        totalCapacity: totalCapacity
      }), totalLoaded = utilMoving.computeTotalNobleResourcesLoaded(tempResourceDictionary, premiumResource);
      this.setState({
        resourceDictionary: tempResourceDictionary,
        totalForExchange: totalLoaded,
        tradeResourceAmount: totalLoaded * this.props.settings.availableResources[0].exchangeRate
      }, null)
    }, onSetValueByRangeSlider: function(dictionaryKey, primaryKey, amount) {
      var totalLoaded, dictionary = this.state[dictionaryKey], premiumResource = this.props.settings.availableResources[0], newStates = {};
      switch (dictionary[primaryKey] = amount, dictionaryKey) {
        case"resourceDictionary":
          totalLoaded = utilMoving.computeTotalNobleResourcesLoaded(dictionary, premiumResource), newStates.resourceDictionary = dictionary, newStates.totalForExchange = totalLoaded, this.setState(newStates, null)
      }
    }, onTradeNobleResourceClick: function(event) {
      event.preventDefault(), utilsObject.effectiveLength(this.state.resourceDictionary) && this.props.presenter.notify(xy.eNames.menuResourcesNobleMarket.tradeResource, {
        habitat: this.props.settings.currentHabitat,
        tradingAmount: this.state.totalForExchange,
        tradingResourceId: this.props.settings.tradingResourceId
      })
    }, render: function() {
      var settings = {
        currentHabitat: null,
        tradingResourceId: null,
        exchangeableResource: null,
        distance: 0,
        availableResources: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, rightActionButton, rightActionButtonSettings, componentsSections = [], tradingResourceId = settings.tradingResourceId, resourcesThemeSettings = servicesTheme.themeSettings.resources, themesIcons = servicesTheme.themeSettings.imagesClassNames.startTransit, wantedResourceTitle = servicesInternationalization.localize(resourcesThemeSettings[tradingResourceId]);
      gameInstance.getGameLanguage();
      if (sectionComponentSettings = { title: servicesInternationalization.localize("Wanted resource") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "title-wanted-resource"
              })), sectionComponentSettings = {
                iconLeft: "icon icon-resource icon-resource-" + tradingResourceId,
                title: wantedResourceTitle,
                rightColumnDataValue: this.state.totalForExchange.toString()
              }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "wanted-resource"
              })), sectionComponentSettings = { title: servicesInternationalization.localize("Offered resources") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "title-transport-resurces"
              })), settings.availableResources) {
        var freeSpace = this.state.totalCapacity - this.state.totalForExchange, maxLimitOnValue = freeSpace >= 0 ? freeSpace : 0;
        settings.availableResources.forEach(function(resourceIdAmountObject) {
          var resourceId = resourceIdAmountObject.resourceId, currentValue = this.state.resourceDictionary[resourceId] || 0;
          sectionComponentSettings = {
            handleIcon: "icon icon-resource icon-resource-" + resourceId,
            currentValue: currentValue,
            minValue: 0,
            maxValue: resourceIdAmountObject.amount,
            maxLimitOnCurrentValue: maxLimitOnValue / resourceIdAmountObject.exchangeRate + currentValue,
            changeStepValue: 1,
            title: servicesInternationalization.localize(resourcesThemeSettings[resourceId]),
            onChange: this.onSetValueByRangeSlider.bind(this, "resourceDictionary", resourceId)
          }, componentsSections.push(React.createElement(ComponentsWidgetRangeSliderDivider, {
            settings: sectionComponentSettings,
            key: "transportation-resource-range-slider-" + resourceId
          }))
        }, this)
      }
      rightActionButtonSettings = {
        icon: "white " + themesIcons.fillTransport,
        onClick: this.onAutoFillClick
      }, rightActionButton = React.createElement(ComponentsMenuListElementButtonAction, { settings: rightActionButtonSettings }), sectionComponentSettings = {
        iconLeft: themesIcons.capacity,
        title: servicesInternationalization.localize("Transport capacity"),
        rightColumnDataValue: this.state.totalForExchange + "/" + this.state.totalCapacity,
        iconRight: rightActionButton
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "capacity-total"
      })), sectionComponentSettings = {
        iconLeft: "icon icon-resource icon-resource-" + tradingResourceId,
        title: servicesInternationalization.localize("Barter %@", resourcesThemeSettings[tradingResourceId]),
        rightColumnDataValue: this.state.totalForExchange.toString(),
        onClick: this.onTradeNobleResourceClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-trade-resource"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesNobleMarket.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager, servicesTheme, servicesWorldSettings) {
  "use strict";
  function MenuResourcesNobleMarketController(options) {
    MenuResourcesNobleMarketController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Exchange Gold for goods"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuResourcesNobleMarketController, CoreControllerElementMenu), MenuResourcesNobleMarketController.prototype[xy.eNames.menuResourcesNobleMarket.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuResourcesNobleMarketController.prototype[xy.eNames.menuResourcesNobleMarket.tradeResource] = function(options) {
    var text, cost, localizationString, gold = servicesGameDataManager.playersCollection.getPlayer().gold, resourcesThemeSettings = servicesTheme.themeSettings.resources, nobleTradeName = resourcesThemeSettings.nobleMarketsNames.byId[options.tradingResourceId], nobleExchangeRate = servicesWorldSettings.settings[nobleTradeName] || resourcesThemeSettings.nobleMarkets[nobleTradeName].rate.premium;
    if (options.tradingAmount) {
      if (cost = Math.ceil(options.tradingAmount / nobleExchangeRate), cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      options.acceptedPayment = cost, localizationString = +options.tradingResourceId === resourcesThemeSettings.spyResourceId ? "Do yo like to trade %1$d gold coins for %2$d copper? You have %3$d gold coins." : "Do you like to trade %1$d gold coins for %2$d silver? You have %3$d gold coins.", text = servicesInternationalization.localize(localizationString, cost, options.tradingAmount, gold), this.showDialogDialog({
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.buyNobleMetal.bind(this.dataSource, options)
      })
    }
  }, MenuResourcesNobleMarketController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = !1;
    this.isActive && (this.forceNextRedrawUpdate && (forceNextRedrawUpdate = !0, this.forceNextRedrawUpdate = !1), this.dataSource.prepareDataForNobleMarket({
      forceNextRedrawUpdate: forceNextRedrawUpdate,
      tradingResourceId: this.initialOptions.tradingResourceId
    }))
  }, MenuResourcesNobleMarketController
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesNobleMarket.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.worldSettings, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, servicesWorldSettings) {
  "use strict";
  function MenuResourcesNobleMarketDataSource(options) {
    MenuResourcesNobleMarketDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuResourcesNobleMarketDataSource, CoreDataSource), MenuResourcesNobleMarketDataSource.prototype.prepareDataForNobleMarket = function(options) {
    var data = {}, tradingResourceId = options.tradingResourceId, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), gold = servicesGameDataManager.playersCollection.getPlayer().gold, emptySpaceForTradingResource = currentHabitat.getFreeSpaceForResource({ resourceId: tradingResourceId }), resourcesThemeSettings = servicesTheme.themeSettings.resources, nobleTradeName = resourcesThemeSettings.nobleMarketsNames.byId[tradingResourceId], nobleExchangeRate = servicesWorldSettings.settings[nobleTradeName] || resourcesThemeSettings.nobleMarkets[nobleTradeName].rate.premium, maxAmountMetalToBuy = gold * nobleExchangeRate, availableResources = [];
    availableResources.push({
      resourceId: "premium",
      amount: gold,
      exchangeRate: nobleExchangeRate
    }), data.tradingResourceId = tradingResourceId, data.totalCapacity = maxAmountMetalToBuy > emptySpaceForTradingResource ? emptySpaceForTradingResource : maxAmountMetalToBuy, data.availableResources = availableResources, data.exchangeableResource = [tradingResourceId], data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, data.currentHabitat = currentHabitat, this.notify(xy.eNames.menuResourcesNobleMarket.dataIsReady, data)
  }, MenuResourcesNobleMarketDataSource.prototype.buyNobleMetal = function(options) {
    this.request({
      wantedResourceID: options.tradingResourceId,
      paymentAmount: options.acceptedPayment,
      habitatID: options.habitat.id
    }, "MarketAction/buyNobleMetal", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuResourcesNobleMarketDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuResourcesNobleMarket.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuResourcesNobleMarket.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuResourcesNobleMarketComponent) {
  "use strict";
  function MenuResourcesNobleMaraketPresenter(options) {
    MenuResourcesNobleMaraketPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuResourcesNobleMaraketPresenter, CorePresenterElementMenu), MenuResourcesNobleMaraketPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuResourcesNobleMarketComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data,
      key: this.instanceId
    }), document.getElementById(this.domElement))
  }, MenuResourcesNobleMaraketPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuHabitatUpgradeConstruction.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.moving, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.habitatUpgradesConstructUpgradeCenter, xy.dNames.components.habitatUpgradesExpandUpgradeCenter, xy.dNames.components.habitatUpgradesConstructUpgrade, xy.dNames.components.habitatUpgradesExpandedList, xy.dNames.components.habitatUpgradesExpandingList, xy.dNames.components.habitatUpgradesHabitatsForExpansion, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListTextBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilMoving, utilsDateTime, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsConstructUpgradeCenter, ComponentsExpandUpgradeCenter, ComponentsConstructUpgrade, ComponentsExpandedList, ComponentsExpandingList, ComponentsHabitatsForExpansion, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListTitleBasic, ComponentsMenuListTextBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onConstructHabitatUpgradeCenterClick: function(event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings;
      this.props.presenter.notify(xy.eNames.menuHabitatUpgradeConstruction.buildHabitatUpgradeCenter, {
        habitat: settings.currentHabitat,
        habitatUpgradeMode: settings.upgradeObject.original.affectedHabitatType
      })
    },
    onExpansionHabitatUpgradeCenterClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings;
      this.props.presenter.notify(xy.eNames.menuHabitatUpgradeConstruction.linkToHabitatCenter, {
        habitatUpgradeCenter: settings.currentHabitat,
        habitatUpgradeMode: settings.upgradeObject.original.affectedHabitatType,
        habitatToLink: options.habitatToLink,
        upgrade: options.upgrade
      })
    },
    onUpgradeProgressSpeedUpClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings;
      this.props.presenter.notify(xy.eNames.menuHabitatUpgradeConstruction.upgradeProgressSpeedUp, {
        habitatUpgradeCenter: settings.currentHabitat,
        inProgress: options.inProgress,
        upgrade: options.upgrade
      })
    },
    onConstructHabitatUpgradeClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings;
      this.props.presenter.notify(xy.eNames.menuHabitatUpgradeConstruction.buildHabitatUpgrade, {
        habitatUpgradeCenter: options.habitatUpgradeCenter,
        habitatUpgradeMode: settings.upgradeObject.original.affectedHabitatType
      })
    },
    onCancelExpandClick: function(options, event) {
      event.preventDefault(), event.stopPropagation();
      var settings = this.props.settings;
      this.props.presenter.notify(xy.eNames.menuHabitatUpgradeConstruction.cancelExpand, {
        habitatUpgradeCenter: settings.currentHabitat,
        expandedHabitat: options.habitat,
        habitatUpgradeMode: options.habitatUpgradeMode
      })
    },
    render: function() {
      var settings = {
        currentHabitat: null,
        upgradeObject: null,
        connectedToNamesText: null,
        haveToExpand: null,
        habitatsForExpandingList: null,
        habitatsExpandedList: [],
        habitatsExpandingList: null
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), this.props.settingsTitle.isRoot ? (titleSettings.leftButton = !0, titleSettings.leftButtonIcon = "controls menu-close", titleSettings.leftButtonOnClick = this.handlerCloseButtonClick) : (titleSettings.leftButton = !0, titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButtonOnClick = this.handlerPrevClick);
      var sectionComponentSettings, expandingHabitatUpgradesAmount, expandedHabitatUpgradesAmount, showHabitatsForExpandingList, componentsSections = [], canStartExpansion = !1, habitatUpgradeMode = settings.upgradeObject.original.affectedHabitatType, habitatUpgradeThemeSettings = servicesTheme.themeSettings.habitatUpgrades[habitatUpgradeMode];
      switch (settings.upgradeObject.original.primaryKey) {
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_CENTER:
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_CENTER:
          sectionComponentSettings = {
            upgradeObject: settings.upgradeObject,
            currentHabitat: settings.currentHabitat,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsConstructUpgradeCenter, {
            settings: sectionComponentSettings,
            key: "section-habitats-to-habitat-upgrade-center"
          }));
          break;
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_EXPANSION:
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_EXPANSION:
          sectionComponentSettings = {
            upgradeObject: settings.upgradeObject,
            currentHabitat: settings.currentHabitat,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsExpandUpgradeCenter, {
            settings: sectionComponentSettings,
            key: "section-habitats-to-habitat-upgrade-center"
          }));
          break;
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS:
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY:
          sectionComponentSettings = {
            upgradeObject: settings.upgradeObject,
            currentHabitat: settings.currentHabitat,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsConstructUpgrade, {
            settings: sectionComponentSettings,
            key: "section-habitats-to-habitat-upgrade-center"
          }))
      }
      switch (settings.connectedToNamesText && (sectionComponentSettings = { text: servicesInternationalization.localize(habitatUpgradeThemeSettings.alreadyConnected, settings.connectedToNamesText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "section-habitats-also-expand-this-habitat"
      }))), settings.upgradeObject.original.primaryKey) {
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_EXPANSION:
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS:
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_EXPANSION:
        case settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY:
          canStartExpansion = !0, sectionComponentSettings = {
            isInProgress: settings.upgradeObject.ready.isInProgress,
            list: settings.habitatsExpandedList,
            habitatUpgradeCenter: settings.currentHabitat,
            haveToExpand: settings.haveToExpand,
            habitatUpgradeMode: habitatUpgradeMode,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsExpandedList, {
            settings: sectionComponentSettings,
            key: "section-habitats-expanded-list"
          })), settings.habitatsExpandingList && (sectionComponentSettings = {
            list: settings.habitatsExpandingList,
            initialComponent: this
          }, componentsSections.push(React.createElement(ComponentsExpandingList, {
            settings: sectionComponentSettings,
            key: "section-habitats-expanding-list"
          })))
      }
      expandingHabitatUpgradesAmount = settings.habitatsExpandingList instanceof Array ? settings.habitatsExpandingList.length : 0, expandedHabitatUpgradesAmount = settings.habitatsExpandedList instanceof Array ? settings.habitatsExpandedList.length : 0, showHabitatsForExpandingList = !settings.upgradeObject.original.habitatAmount || expandingHabitatUpgradesAmount + expandedHabitatUpgradesAmount < settings.upgradeObject.original.habitatAmount, settings.habitatsForExpandingList && showHabitatsForExpandingList && (sectionComponentSettings = {
        list: settings.habitatsForExpandingList,
        initialComponent: this,
        habitatUpgradeMode: habitatUpgradeMode,
        canStartExpansion: canStartExpansion
      }, componentsSections.push(React.createElement(ComponentsHabitatsForExpansion, {
        settings: sectionComponentSettings,
        key: "section-habitats-for-expand"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuHabitatUpgradeConstruction.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.services.log, function(CoreControllerElementMenu, utilsOop, utilsObject, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesTheme, servicesLog) {
  "use strict";
  function MenuHabitatUpgradeConstructionController(options) {
    MenuHabitatUpgradeConstructionController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }, {
      entity: xy.eNames.dataListeners.dataEntity.habitat,
      identifier: xy.eNames.dataListeners.dataIdentifiers.setCurrentHabitat,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }]
  }

  return utilsOop.extend(MenuHabitatUpgradeConstructionController, CoreControllerElementMenu), MenuHabitatUpgradeConstructionController.prototype.setLocalizationdName = function(habitatUpgradeMode) {
    var name, habitatUpgradeThemeSettings = servicesTheme.themeSettings.habitatUpgrades;
    switch (habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        name = habitatUpgradeThemeSettings.fortress.title;
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        name = habitatUpgradeThemeSettings.city.title
    }
    this.localizedName = servicesInternationalization.localize(name)
  }, MenuHabitatUpgradeConstructionController.prototype.extendHabitatUpgradeCenterCheckForOtherHabitatUpgradeCenter = function(options) {
    var text, successCallBack = this.extendHabitatUpgradeCenterCheckForAlreadyLinkedToOtherHabitatUpgradeCenter.bind(this, options), habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades;
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        options.habitatToLink.habitatType === settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER ? (text = servicesInternationalization.localize("ThisÂ castleÂ isÂ alreadyÂ aÂ fortressÂ center.Â DoÂ youÂ wantÂ toÂ linkÂ thisÂ castleÂ toÂ anotherÂ fortressÂ center?"), this.showDialogDialog({
          title: servicesInternationalization.localize(habitatUpgradesThemeSettings.fortress.FortressExpansion),
          text: text,
          callbackSuccess: successCallBack
        })) : this.extendHabitatUpgradeCenterCheckForAlreadyLinkedToOtherHabitatUpgradeCenter(options);
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        options.habitatToLink.habitatType === settingsGameConstant.HABITAT_TYPE.CITY_CENTER ? (text = servicesInternationalization.localize("ThisÂ fortressÂ isÂ alreadyÂ aÂ cityÂ center.Â DoÂ youÂ wantÂ toÂ linkÂ thisÂ fortressÂ toÂ anotherÂ cityÂ center?"), this.showDialogDialog({
          title: servicesInternationalization.localize(habitatUpgradesThemeSettings.city.CityExpansion),
          text: text,
          callbackSuccess: successCallBack
        })) : this.extendHabitatUpgradeCenterCheckForAlreadyLinkedToOtherHabitatUpgradeCenter(options);
        break;
      default:
        servicesLog("warn", "unknown habitat upgrade mode")
    }
  }, MenuHabitatUpgradeConstructionController.prototype.extendHabitatUpgradeCenterCheckForAlreadyLinkedToOtherHabitatUpgradeCenter = function(options) {
    if (options.habitatToLink.isLinkedToAnyHabitatUpgradeCenter()) {
      var text, title, successCallBack, habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades;
      switch (successCallBack = this.extendHabitatUpgradeCenterCheckAdditionalUpgradePayment.bind(this, options), options.habitatUpgradeMode) {
        case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
          text = "TheÂ castleÂ isÂ alreadyÂ linkedÂ toÂ anotherÂ fortressÂ center.Â AreÂ youÂ sureÂ youÂ wouldÂ likeÂ toÂ connectÂ thisÂ castleÂ toÂ theÂ fortressÂ center?", title = habitatUpgradesThemeSettings.fortress.FortressExpansion;
          break;
        case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
          text = "TheÂ fortressÂ isÂ alreadyÂ linkedÂ toÂ anotherÂ cityÂ center.Â AreÂ youÂ sureÂ youÂ wouldÂ likeÂ toÂ connectÂ thisÂ fortressÂ toÂ theÂ cityÂ center?", title = habitatUpgradesThemeSettings.city.CityExpansion;
          break;
        default:
          servicesLog("warn", "unknown habitat upgrade mode")
      }
      this.showDialogDialog({
        title: servicesInternationalization.localize(title),
        text: servicesInternationalization.localize(text),
        callbackSuccess: successCallBack
      })
    } else this.extendHabitatUpgradeCenterCheckAdditionalUpgradePayment(options)
  }, MenuHabitatUpgradeConstructionController.prototype.extendHabitatUpgradeCenterCheckAdditionalUpgradePayment = function(options) {
    var upgradePk, upgrade, currentlyIsInProgress = options.habitatUpgradeCenter.habitatUpgradeOrderArray instanceof Array ? options.habitatUpgradeCenter.habitatUpgradeOrderArray.length : 0;
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        upgradePk = settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_EXPANSION;
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        upgradePk = settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_EXPANSION;
        break;
      default:
        servicesLog("warn", "unknown habitat upgrade mode")
    }
    if (upgrade = servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: upgradePk }), upgrade.listBoundary <= currentlyIsInProgress) {
      var text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = upgrade.buildSpeedupCost;
      if (upgrade.buildSpeedupCost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      options.paymentAmount = cost, text = servicesInternationalization.localize("Your upgrade queue is full. An additional slot costs %d %@\\nYou have %d %@", cost, "Gold", gold, "Gold"), this.showDialogDialog({
        title: servicesInternationalization.localize("Additional upgrade slot"),
        text: text,
        callbackSuccess: this.dataSource.constructHabitatUpgradeExpansion.bind(this.dataSource, options)
      })
    } else this.dataSource.constructHabitatUpgradeExpansion(options)
  }, MenuHabitatUpgradeConstructionController.prototype[xy.eNames.menuHabitatUpgradeConstruction.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (this.presenter.draw(data), data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuHabitatUpgradeConstruction.dataIsReady].bind(this, data), options.isForced))
  }, MenuHabitatUpgradeConstructionController.prototype[xy.eNames.menuHabitatUpgradeConstruction.buildHabitatUpgradeCenter] = function(options) {
    this.dataSource.constructHabitatUpgradeCenter({
      habitatId: options.habitat.id,
      habitatUpgradeMode: options.habitatUpgradeMode
    })
  }, MenuHabitatUpgradeConstructionController.prototype[xy.eNames.menuHabitatUpgradeConstruction.linkToHabitatCenter] = function(options) {
    this.extendHabitatUpgradeCenterCheckForOtherHabitatUpgradeCenter(options)
  }, MenuHabitatUpgradeConstructionController.prototype[xy.eNames.menuHabitatUpgradeConstruction.upgradeProgressSpeedUp] = function(options) {
    var localizationString, text, upgrade = options.upgrade, cost = upgrade.buildSpeedupCost, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
    return cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (options.paymentAmount = cost, localizationString = options.inProgress.isLessThanHalfConstructionTimeRemain() ? "Finishing upgrade instantly costs %1$d %2$@. You have %3$d %4$@." : "Upgrade time reduction costs %1$d %2$@. You have %3$d %4$@.", text = servicesInternationalization.localize(localizationString, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Gold"),
      text: text,
      callbackSuccess: this.dataSource.speedupHabitatUpgradeUpgrade.bind(this.dataSource, options)
    }))
  }, MenuHabitatUpgradeConstructionController.prototype[xy.eNames.menuHabitatUpgradeConstruction.buildHabitatUpgrade] = function(options) {
    this.dataSource.constructHabitatUpgrade(options)
  }, MenuHabitatUpgradeConstructionController.prototype[xy.eNames.menuHabitatUpgradeConstruction.cancelExpand] = function(options) {
    var habitatUpgradesThemeSettings = servicesTheme.themeSettings.habitatUpgrades[options.habitatUpgradeMode], text = servicesInternationalization.localize(habitatUpgradesThemeSettings.cancelExpand, options.expandedHabitat.name, options.habitatUpgradeCenter.name);
    this.showDialogDialog({
      title: servicesInternationalization.localize("Remove expansion"),
      text: text,
      callbackSuccess: this.dataSource.removeHabitatUpgradeExpansion.bind(this.dataSource, options)
    })
  }, MenuHabitatUpgradeConstructionController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate(), this.isActive && this.dataSource.checkDataForHabitatUpgradeConstruction({ habitatUpgradeMode: this.initialOptions.habitatUpgradeMode })
  }, MenuHabitatUpgradeConstructionController
}]),xy.dStaticInjector.set(xy.dNames.game.menuHabitatUpgradeConstruction.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.sortable, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesWorldSettings, servicesSortable) {
  "use strict";
  function MenuHabitatUpgradeConstructionDataSource(options) {
    MenuHabitatUpgradeConstructionDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatUpgradeConstructionDataSource, CoreDataSource), MenuHabitatUpgradeConstructionDataSource.prototype.checkDataForHabitatUpgradeConstruction = function(options) {
    var habitatsForExpanding, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), currentHabitatPublicType = currentHabitat.publicHabitatType, isFortressEnabled = servicesWorldSettings.settings.featureFortress, isCityEnabled = servicesWorldSettings.settings.featureCity;
    return currentHabitatPublicType === settingsGameConstant.HABITAT_TYPE.CITY || !isFortressEnabled && currentHabitatPublicType === settingsGameConstant.HABITAT_TYPE.CASTLE || !isCityEnabled && currentHabitatPublicType === settingsGameConstant.HABITAT_TYPE.FORTRESS ? void this.notify(xy.eNames.menu.onDataError, "Current habitat can not have a habitat upgrade") : (habitatsForExpanding = servicesGameDataManager.habitatUpgradesConstructionsCollection.getExpansionOptions({ habitatId: currentHabitat.id }), this.habitatUpgradeMode = options.habitatUpgradeMode, void(habitatsForExpanding ? this.prepareDataForHabitatUpgradeConstruction() : this.getHabitatsForExpanding({ habitatId: currentHabitat.id })))
  }, MenuHabitatUpgradeConstructionDataSource.prototype.prepareDataForHabitatUpgradeConstruction = function() {
    var data = {}, currentHabitat = servicesGameDataManager.habitatsCollection.getCurrentHabitat(), upgrade = currentHabitat.getHabitatUpgrade(!0), habitatUpgradeMode = upgrade.original.affectedHabitatType;
    if (this.controller.setLocalizationdName(habitatUpgradeMode), currentHabitat.isLinkedToAnyHabitatUpgradeCenter() && (data.connectedToNamesText = currentHabitat.getLinkedToAnotherHabitatUpgradeCenterText()), upgrade.original.primaryKey === settingsGameConstant.HABITAT_UPGRADE_TYPE.FORTRESS_EXPANSION || upgrade.original.primaryKey === settingsGameConstant.HABITAT_UPGRADE_TYPE.CITY_EXPANSION) {
      var expanded = currentHabitat.fortressExpansionArray instanceof Array ? currentHabitat.fortressExpansionArray.length : 0;
      data.haveToExpand = upgrade.original.habitatAmount - expanded
    }
    var isWrongHabitatType, habitatsForExpandingList = [], habitatsExpandedList = [], habitatsExpandingList = [], habitatIdsForExpandingList = servicesGameDataManager.habitatUpgradesConstructionsCollection.getExpansionOptions({ habitatId: currentHabitat.id }), habitatExpandingData = {}, habitatExpandedData = {};
    currentHabitat.fortressExpansionArray instanceof Array && currentHabitat.fortressExpansionArray.forEach(function(expandedHabitatId) {
      habitatExpandedData[expandedHabitatId] = !0, habitatsExpandedList.push(servicesGameDataManager.habitatsCollection.getHabitat(expandedHabitatId))
    }), currentHabitat.habitatUpgradeOrderArray instanceof Array && currentHabitat.habitatUpgradeOrderArray.forEach(function(upgradeInProgressId) {
      var modeledInProgress = servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgradeInProgress({ id: upgradeInProgressId });
      habitatExpandingData[modeledInProgress.destinationHabitat] = modeledInProgress
    }), habitatIdsForExpandingList && habitatIdsForExpandingList.length && habitatIdsForExpandingList.forEach(function(habitatId) {
      var modeledHabitat, player;
      if (!habitatExpandedData[habitatId]) {
        switch (modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), player = modeledHabitat.player ? servicesGameDataManager.playersCollection.getPlayer(modeledHabitat.player) : servicesGameDataManager.playersCollection.getEmptyPlayer(modeledHabitat), habitatUpgradeMode) {
          case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
            isWrongHabitatType = modeledHabitat.habitatType !== settingsGameConstant.HABITAT_TYPE.CASTLE && modeledHabitat.publicHabitatType !== settingsGameConstant.HABITAT_TYPE.CASTLE && modeledHabitat.habitatType !== settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER && modeledHabitat.publicHabitatType !== settingsGameConstant.HABITAT_TYPE.FORTRESS_CENTER;
            break;
          case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
            isWrongHabitatType = modeledHabitat.habitatType !== settingsGameConstant.HABITAT_TYPE.FORTRESS && modeledHabitat.publicHabitatType !== settingsGameConstant.HABITAT_TYPE.FORTRESS && modeledHabitat.habitatType !== settingsGameConstant.HABITAT_TYPE.CITY_CENTER && modeledHabitat.publicHabitatType !== settingsGameConstant.HABITAT_TYPE.CITY_CENTER
        }
        player && !isWrongHabitatType && (modeledHabitat.isOwnByPlayer ? habitatExpandingData[habitatId] ? habitatsExpandingList.push({
          modeledHabitat: modeledHabitat,
          upgradeInProgress: habitatExpandingData[habitatId],
          upgradeObject: servicesGameDataManager.habitatUpgradesConstructionsCollection.getUpgrade({ primaryKey: habitatExpandingData[habitatId].upgradeId })
        }) : habitatsForExpandingList.push({
          isOwnByPlayer: !0,
          modeledHabitat: modeledHabitat,
          upgradeObject: modeledHabitat.getHabitatUpgradeExtension({ habitatUpgradeMode: habitatUpgradeMode })
        }) : habitatsForExpandingList.push({
          isOwnByPlayer: !1,
          otherPlayer: player,
          modeledHabitat: modeledHabitat,
          upgradeObject: modeledHabitat.getHabitatUpgradeExtension({ habitatUpgradeMode: habitatUpgradeMode })
        }))
      }
    }), habitatsForExpandingList.length && (habitatsForExpandingList.sort(servicesSortable.habitatsForExpandingList), data.habitatsForExpandingList = habitatsForExpandingList), habitatsExpandedList.length && (data.habitatsExpandedList = habitatsExpandedList), habitatsExpandingList.length && (habitatsExpandingList.sort(servicesSortable.byField("upgradeInProgress", "complete")), data.habitatsExpandingList = habitatsExpandingList, data.isTimerable = !0), data.currentHabitat = currentHabitat, data.upgradeObject = upgrade, this.notify(xy.eNames.menuHabitatUpgradeConstruction.dataIsReady, data, { isForced: !0 })
  }, MenuHabitatUpgradeConstructionDataSource.prototype.getHabitatsForExpanding = function(options) {
    this.habitatId = options.habitatId, this.request({ habitatID: options.habitatId }, "HabitatUpgradeAction/surroundingHabitats", { callBack: this.surroundingHabitatsReceived })
  }, MenuHabitatUpgradeConstructionDataSource.prototype.surroundingHabitatsReceived = function(data) {
    var sync = servicesGameDataManager.habitatUpgradesConstructionsCollection.updateExpansionOptionsData({
      habitatId: this.habitatId,
      data: data.Data
    });
    sync && this.prepareDataForHabitatUpgradeConstruction()
  }, MenuHabitatUpgradeConstructionDataSource.prototype.constructHabitatUpgradeCenter = function(options) {
    var action;
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        action = "HabitatUpgradeAction/constructFortressCenter";
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        action = "HabitatUpgradeAction/constructCityCenter"
    }
    this.request({ habitatID: options.habitatId }, action, { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatUpgradeConstructionDataSource.prototype.constructHabitatUpgradeExpansion = function(options) {
    var action;
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        action = "HabitatUpgradeAction/constructFortressExpansion";
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        action = "HabitatUpgradeAction/constructCityExpansion"
    }
    this.request({
      habitatID: options.habitatUpgradeCenter.id,
      id: options.habitatToLink.id,
      paymentAmount: options.paymentAmount || 0
    }, action, { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatUpgradeConstructionDataSource.prototype.speedupHabitatUpgradeUpgrade = function(options) {
    var habitatUpgradeIdArray = [];
    habitatUpgradeIdArray.push(options.inProgress.id), this.request({
      habitatUpgradeIdArray: habitatUpgradeIdArray,
      paymentAmount: options.paymentAmount
    }, "HabitatUpgradeAction/speedupUpgrade", { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatUpgradeConstructionDataSource.prototype.constructHabitatUpgrade = function(options) {
    var action;
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        action = "HabitatUpgradeAction/constructFortress";
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        action = "HabitatUpgradeAction/constructCity"
    }
    this.request({ habitatID: options.habitatUpgradeCenter.id }, action, { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatUpgradeConstructionDataSource.prototype.removeHabitatUpgradeExpansion = function(options) {
    var action;
    switch (options.habitatUpgradeMode) {
      case settingsGameConstant.HABITAT_UPGRADE_MODE.FORTRESS:
        action = "HabitatUpgradeAction/removeFortressExpansion";
        break;
      case settingsGameConstant.HABITAT_UPGRADE_MODE.CITY:
        action = "HabitatUpgradeAction/removeCityExpansion"
    }
    this.request({
      habitatID: options.habitatUpgradeCenter.id,
      id: options.expandedHabitat.id
    }, action, { callBack: this.handleSessionUpdateResponse })
  }, MenuHabitatUpgradeConstructionDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuHabitatUpgradeConstruction.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuHabitatUpgradeConstruction.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuHabitatUpgradeConstructionComponent) {
  "use strict";
  function MenuHabitatUpgradeConstructionPresenter(options) {
    MenuHabitatUpgradeConstructionPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuHabitatUpgradeConstructionPresenter, CorePresenterElementMenu), MenuHabitatUpgradeConstructionPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuHabitatUpgradeConstructionComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data,
      key: this.instanceId
    }), document.getElementById(this.domElement))
  }, MenuHabitatUpgradeConstructionPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionList.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    handlerLogOutButtonClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.sceneGame.onLogoutEvent)
    },
    render: function() {
      var settings = { habitatAmount: 1 };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var habitatAmount = settings.habitatAmount, massFunctionsIconsThemeSettings = servicesTheme.themeSettings.imagesClassNames.massFunction || {}, massSilverMerchantLimit = servicesWorldSettings.settings.massAutomaticConquestPointTradingCastleCount;
      servicesWorldSettings.settings.featureMassAutomaticConquestPointTrading && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Silver merchant"),
        iconLeft: massFunctionsIconsThemeSettings.silverMerchantIcon,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuMassFunctionSilverMerchant.name })
      }, massSilverMerchantLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massSilverMerchantLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-silver-merchant"
      })));
      var massRestockLimit = servicesWorldSettings.settings.massRestockCastleCount;
      massRestockLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Fill resource stock"),
        iconLeft: massFunctionsIconsThemeSettings.massRestockIcon,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuMassFunctionRestock.name })
      }, massRestockLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massRestockLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-restock"
      })));
      var massBuffLimit = servicesWorldSettings.settings.massBuffCastleCount;
      massBuffLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Raise the banners"),
        iconLeft: massFunctionsIconsThemeSettings.massBuff,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuMassFunctionRiseBuffs.name })
      }, massBuffLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massBuffLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-buff"
      })));
      var massExchangeLimit = servicesWorldSettings.settings.massMarketCastleCount;
      massExchangeLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Exchange resources"),
        iconLeft: massFunctionsIconsThemeSettings.massExchange,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuResourcesExchangeableList.name,
          options: { mode: settingsGameConstant.RESOURCE_EXCHANGEABLE_LIST_MODE.MASS_EXCHANGE }
        })
      }, massExchangeLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massExchangeLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-exchange"
      })));
      var massKnowledgeLimit = servicesWorldSettings.settings.massKnowledgeResearchCastleCount;
      massKnowledgeLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Execute research"),
        iconLeft: massFunctionsIconsThemeSettings.massKnowledge,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuKnowledgeChooser.name,
          options: { mode: settingsGameConstant.KNOWLEDGE_CHOOSER_LIST_MODE.MASS_KNOWLEDGE }
        })
      }, massKnowledgeLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massKnowledgeLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-mass-research"
      })));
      var massMissionLimit = servicesWorldSettings.settings.massMissionCastleCount;
      massMissionLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Carry out mission"),
        iconLeft: massFunctionsIconsThemeSettings.massMission,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuMassFunctionMissions.name })
      }, massMissionLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massMissionLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-missions"
      })));
      var massRecruitmentLimit = servicesWorldSettings.settings.massRecruitmentCastleCount;
      massRecruitmentLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Mass unit recruiting"),
        iconLeft: massFunctionsIconsThemeSettings.massRecruitment,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuUnitChooser.name,
          options: { mode: settingsGameConstant.UNIT_CHOOSER_LIST_MODE.MASS_RECRUIT }
        })
      }, massRecruitmentLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massRecruitmentLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-recruitment"
      })));
      var massBuildingLimit = servicesWorldSettings.settings.massBuildingUpgradeCastleCount;
      massBuildingLimit && (sectionComponentSettings = {
        title: servicesInternationalization.localize("Upgrade Building"),
        iconLeft: massFunctionsIconsThemeSettings.massBuilding,
        iconRight: "controls menu-next",
        onClick: this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuBuildingChooser.name,
          options: { mode: settingsGameConstant.BUILDING_CHOOSER_LIST_MODE.MASS_BUILDING }
        })
      }, massBuildingLimit > habitatAmount && (sectionComponentSettings.disabled = !0, sectionComponentSettings.description = servicesInternationalization.localize("Required: %@", massBuildingLimit)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "component-buildings"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionList.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuMassFunctionListController(options) {
    MenuMassFunctionListController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("General Functions")
  }

  return utilsOop.extend(MenuMassFunctionListController, CoreControllerElementMenu), MenuMassFunctionListController.prototype.prepareDataForDraw = function() {
    if (this.isActive) {
      var data = this.dataSource.prepareMassFunctionListData();
      this.presenter.draw(data)
    }
  }, MenuMassFunctionListController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionList.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionListDataSource(options) {
    MenuMassFunctionListDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionListDataSource, CoreDataSource), MenuMassFunctionListDataSource.prototype.prepareMassFunctionListData = function() {
    var habitatAmount, data = {};
    return habitatAmount = servicesGameDataManager.habitatsCollection.getOwnHabitatsWeightedAmount(), data.habitatAmount = habitatAmount, data
  }, MenuMassFunctionListDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionList.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionList.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionListComponent) {
  "use strict";
  function MenuMassFunctionListPresenter(options) {
    MenuMassFunctionListPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionListPresenter, CorePresenterElementMenu), MenuMassFunctionListPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionListComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionListPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRestock.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.storage, xy.dNames.utils.dateTime, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatOverview, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, servicesStorage, utilsDateTime, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatOverview) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function() {
      var selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({ massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.RESTOCK });
      return { selectedHabitats: selectedHabitats || {} }
    }, getInitialState: function() {
      return this.getNewState()
    }, storeHabitatsSelection: function() {
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: this.state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.RESTOCK
      })
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(), null)
    }, onFillUpClick: function() {
      var habitatId, selectedAmount = 0, stateSelectedHabitats = this.state.selectedHabitats, selectedHabitats = {};
      selectedAmount += this.selectedAmount[0], selectedAmount += this.selectedAmount[2], selectedAmount += this.selectedAmount[4];
      for (habitatId in stateSelectedHabitats)stateSelectedHabitats.hasOwnProperty(habitatId) && stateSelectedHabitats[habitatId] && this.possibleHabitatSet[habitatId] && (selectedHabitats[habitatId] = this.possibleHabitatSet[habitatId]);
      this.props.presenter.notify(xy.eNames.menuMassFunctionRestock.fillUp, {
        selectedAmount: selectedAmount,
        habitats: selectedHabitats
      })
    }, onSelectDeselectAllClick: function(habitatTypeCode) {
      var status = !0, selectedHabitats = this.state.selectedHabitats, selectedAmount = this.selectedAmount, possibleSelectedAmountOfType = this.possibleSelectedAmount[habitatTypeCode];
      possibleSelectedAmountOfType === selectedAmount[habitatTypeCode] && (status = !1), this.possibleHabitatsIdForSelection[habitatTypeCode].forEach(function(habitatId) {
        selectedHabitats[habitatId] = status
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, onHabitatSelectClick: function(habitat, event) {
      event.stopPropagation(), event.preventDefault();
      var habitatId = habitat.id, selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitatId] = !selectedHabitats[habitatId], this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, render: function() {
      var settings = { availableHabitatTypes: {}, currentHabitatId: null, habitatsList: [] };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      }, this.possibleSelectedAmount = { 0: 0, 2: 0, 4: 0 }, this.possibleHabitatsIdForSelection = {
        0: [],
        2: [],
        4: []
      }, this.possibleHabitatSet = {}, this.selectedAmount = { 0: 0, 2: 0, 4: 0 };
      var themeSettings = servicesTheme.themeSettings, massFunctionsIconsThemeSettings = themeSettings.imagesClassNames.massFunction || {}, totalSelectedHabitat = 0;
      settings.habitatsList.forEach(function(habitat) {
        var isRestockEnabled = habitat.canRefill(), publicHabitatType = habitat.publicHabitatType, habitatId = habitat.id, habitatSettings = {
          habitat: habitat,
          isCurrentHabitat: habitatId === settings.currentHabitatId,
          onSelect: this.onHabitatSelectClick.bind(this, habitat),
          hideUnits: !1,
          restockRow: !0
        };
        isRestockEnabled ? (habitatSettings.isSelectable = !0, this.possibleSelectedAmount[publicHabitatType] += 1, this.possibleHabitatsIdForSelection[publicHabitatType].push(habitatId), this.possibleHabitatSet[habitatId] = !0, this.state.selectedHabitats[habitatId] && (habitatSettings.isSelected = !0, this.selectedAmount[publicHabitatType] += 1, totalSelectedHabitat += 1)) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatOverview, {
          settings: habitatSettings,
          key: "habitat-in-list-" + habitat.id
        }))
      }, this);
      var selectingTitle, selectionIcon, selectedAll, habitatTypeCode, publicHabitatTypeCodes = themeSettings.habitat.publicHabitatTypeCodes;
      habitatTypeCode = publicHabitatTypeCodes.Castle, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.massFunctionIcon, sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massFunctionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-castles"
      })), settings.availableHabitatTypes[publicHabitatTypeCodes.Fortress] && (habitatTypeCode = publicHabitatTypeCodes.Fortress, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-fortresses"
      }))), settings.availableHabitatTypes[publicHabitatTypeCodes.City] && (habitatTypeCode = publicHabitatTypeCodes.City, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-cities"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.massRestockIcon,
        title: servicesInternationalization.localize("Fill resource stock"),
        rightColumnDataValue: totalSelectedHabitat || "",
        onClick: this.onFillUpClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "rfill-up-button"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massRestockIcon,
        title: servicesInternationalization.localize("Fill resource stock"),
        rightColumnDataValue: totalSelectedHabitat || "",
        onClick: this.onFillUpClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "fill-up-bottom-button"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRestock.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionRestockController(options) {
    MenuMassFunctionRestockController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Fill resource stock"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionRestockController, CoreControllerElementMenu), MenuMassFunctionRestockController.prototype[xy.eNames.menuMassFunctionRestock.dataIsReady] = function(data, options) {
    options = options || {}, this.isActive && (data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuMassFunctionRestock.dataIsReady].bind(this, data), options.isForced), this.presenter.draw(data))
  }, MenuMassFunctionRestockController.prototype[xy.eNames.menuMassFunctionRestock.fillUp] = function(options) {
    var text, amount, habitatId, modeledHabitat, newOptions, cost = 0, gold = servicesGameDataManager.playersCollection.getPlayer().gold, rUnit = servicesWorldSettings.settings.restockingResourcesUnit, rCost = servicesWorldSettings.settings.restockingResourcesCostPerUnit, habitatsIdArray = [], habitatsDictionary = options.habitats;
    if (options.selectedAmount < 1)return void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    });
    for (habitatId in habitatsDictionary)habitatsDictionary.hasOwnProperty(habitatId) && habitatsDictionary[habitatId] && (modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), amount = modeledHabitat.getRestockResourceAmount(), cost += Math.ceil(amount / rUnit) * rCost, habitatsIdArray.push(habitatId));
    if (0 !== amount) {
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      newOptions = {
        habitatsIdArray: habitatsIdArray,
        acceptedPayment: cost
      }, text = servicesInternationalization.localize("Filling up the stock of resources costs %1$d gold coins. You own %2$d gold coins.", cost, gold), this.showDialogDialog({
        title: servicesInternationalization.localize("Fill up the stock"),
        text: text,
        callbackSuccess: this.dataSource.restockHabitatsStock.bind(this.dataSource, newOptions)
      })
    }
  }, MenuMassFunctionRestockController.prototype.prepareDataForDraw = function() {
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), this.dataSource.prepareMassFunctionRestockData({ forceNextRedrawUpdate: forceRedraw })
  }, MenuMassFunctionRestockController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRestock.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, utilsDateTime, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionRestockDataSource(options) {
    MenuMassFunctionRestockDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRestockDataSource, CoreDataSource), MenuMassFunctionRestockDataSource.prototype.prepareMassFunctionRestockData = function(options) {
    options = options || {};
    var data = {};
    data.currentHabitatId = servicesGameDataManager.habitatsCollection.getHabitat(), data.isTimerable = !1;
    var availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), restockDate = habitat.nextLegalRestockDate;
      restockDate && utilsDateTime.remainTimeInSeconds(restockDate) > 0 && (data.isTimerable = !0), habitatsList.push(habitat)
    }), data.habitatsList = habitatsList, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, data.availableHabitatTypes = availableHabitatTypes, this.notify(xy.eNames.menuMassFunctionRestock.dataIsReady, data, { isForced: !0 })
  }, MenuMassFunctionRestockDataSource.prototype.restockHabitatsStock = function(options) {
    this.request({
      habitatIDArray: options.habitatsIdArray,
      paymentAmount: options.acceptedPayment
    }, "HabitatAction/restockResourceStorageInHabitatArray", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionRestockDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRestock.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionRestock.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionRestockComponent) {
  "use strict";
  function MenuMassFunctionRestockPresenter(options) {
    MenuMassFunctionRestockPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRestockPresenter, CorePresenterElementMenu), MenuMassFunctionRestockPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionRestockComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionRestockPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRiseBuffs.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatOverview, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, servicesStorage, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatOverview) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function() {
      var selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({ massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.RISE_BUFFS });
      return { selectedHabitats: selectedHabitats || {} }
    }, getInitialState: function() {
      return this.getNewState()
    }, storeHabitatsSelection: function() {
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: this.state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.RISE_BUFFS
      })
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(), null)
    }, onRiseBuffsClick: function() {
      var habitatId, selectedAmount = 0, selectedHabitats = {}, stateSelectedHabitats = this.state.selectedHabitats;
      selectedAmount += this.selectedAmount[0], selectedAmount += this.selectedAmount[2], selectedAmount += this.selectedAmount[4];
      for (habitatId in stateSelectedHabitats)stateSelectedHabitats.hasOwnProperty(habitatId) && stateSelectedHabitats[habitatId] && this.possibleHabitatSet[habitatId] && (selectedHabitats[habitatId] = this.possibleHabitatSet[habitatId]);
      this.props.presenter.notify(xy.eNames.menuMassFunctionRiseBuffs.riseUp, {
        selectedAmount: selectedAmount,
        habitats: selectedHabitats
      })
    }, onSelectDeselectAllClick: function(habitatTypeCode) {
      var status = !0, selectedHabitats = this.state.selectedHabitats, selectedAmount = this.selectedAmount, possibleSelectedAmountOfType = this.possibleSelectedAmount[habitatTypeCode];
      possibleSelectedAmountOfType === selectedAmount[habitatTypeCode] && (status = !1), this.possibleHabitatsIdForSelection[habitatTypeCode].forEach(function(habitatId) {
        selectedHabitats[habitatId] = status
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, onHabitatSelectClick: function(habitat, selectedBuffs, event) {
      event.stopPropagation(), event.preventDefault();
      var habitatId = habitat.id, selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitatId] = !selectedHabitats[habitatId], this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, render: function() {
      var settings = { availableHabitatTypes: {}, habitatsList: [] };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      }, this.possibleSelectedAmount = {
        0: 0,
        2: 0,
        4: 0
      }, this.possibleHabitatSet = {}, this.possibleHabitatsIdForSelection = {
        0: [],
        2: [],
        4: []
      }, this.selectedAmount = { 0: 0, 2: 0, 4: 0 };
      var themeSettings = servicesTheme.themeSettings, massFunctionsIconsThemeSettings = themeSettings.imagesClassNames.massFunction || {}, totalSelectedBannersAmount = 0;
      settings.habitatsList.forEach(function(habitatHabitatBuffsObject) {
        var buffsAmount = habitatHabitatBuffsObject.buffs.length, habitat = habitatHabitatBuffsObject.habitat, buffs = habitatHabitatBuffsObject.buffs, publicHabitatType = habitat.publicHabitatType, habitatId = habitat.id, habitatSettings = {
          habitat: habitat,
          isCurrentHabitat: !1,
          onSelect: this.onHabitatSelectClick.bind(this, habitat, buffs),
          hideUnits: !1
        };
        buffsAmount > 0 ? (habitatSettings.isSelectable = !0, this.possibleSelectedAmount[publicHabitatType] += 1, this.possibleHabitatsIdForSelection[publicHabitatType].push(habitatId), this.possibleHabitatSet[habitatId] = buffs, habitatSettings.buffsRow = {
          buffs: habitatHabitatBuffsObject.buffs,
          activeBuffs: habitatHabitatBuffsObject.activeBuffs
        }, this.state.selectedHabitats[habitatId] && (totalSelectedBannersAmount += buffsAmount, this.selectedAmount[publicHabitatType] += 1, habitatSettings.isSelected = !0)) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatOverview, {
          settings: habitatSettings,
          key: "habitat-in-list-" + habitatHabitatBuffsObject.habitat.id
        }))
      }, this);
      var selectingTitle, selectionIcon, selectedAll, habitatTypeCode, publicHabitatTypeCodes = themeSettings.habitat.publicHabitatTypeCodes;
      habitatTypeCode = publicHabitatTypeCodes.Castle, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.massFunctionIcon, sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massFunctionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-castles"
      })), settings.availableHabitatTypes[publicHabitatTypeCodes.Fortress] && (habitatTypeCode = publicHabitatTypeCodes.Fortress, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-fortresses"
      }))), settings.availableHabitatTypes[publicHabitatTypeCodes.City] && (habitatTypeCode = publicHabitatTypeCodes.City, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-cities"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.massBuff,
        title: servicesInternationalization.localize("Raise the banners"),
        rightColumnDataValue: totalSelectedBannersAmount || "",
        onClick: this.onRiseBuffsClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "rise-banners-top-button"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massBuff,
        title: servicesInternationalization.localize("Raise the banners"),
        rightColumnDataValue: totalSelectedBannersAmount || "",
        onClick: this.onRiseBuffsClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "rise-banners-bottom-button"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRiseBuffs.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionRiseBuffsController(options) {
    MenuMassFunctionRiseBuffsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Raise the banners"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionRiseBuffsController, CoreControllerElementMenu), MenuMassFunctionRiseBuffsController.prototype[xy.eNames.menuMassFunctionRiseBuffs.dataIsReady] = function(data, options) {
    options = options || {}, data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuMassFunctionRiseBuffs.dataIsReady].bind(this, data), options.isForced), this.forceNextRedrawUpdate && (this.forceNextRedrawUpdate = !1, data.forceNextRedrawUpdate = !0), this.presenter.draw(data)
  }, MenuMassFunctionRiseBuffsController.prototype[xy.eNames.menuMassFunctionRiseBuffs.riseUp] = function(options) {
    var text, habitatId, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0, newHabitats = {}, addToCost = function(habitatId, modeledBuff) {
      newHabitats.hasOwnProperty(habitatId) || (newHabitats[habitatId] = []), newHabitats[habitatId].push(modeledBuff.primaryKey), cost += modeledBuff.goldAmount
    };
    if (options.selectedAmount < 1)return void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    });
    for (habitatId in options.habitats)options.habitats.hasOwnProperty(habitatId) && options.habitats[habitatId] instanceof Array && options.habitats[habitatId].forEach(addToCost.bind(this, habitatId));
    if (0 !== cost) {
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      text = servicesInternationalization.localize("Raising the banners costs %1$d gold coins. You currently own %2$d gold coins.", cost, gold), this.showDialogDialog({
        title: servicesInternationalization.localize("Raise the banners"),
        text: text,
        callbackSuccess: this.dataSource.riseAllSelectedBuffs.bind(this.dataSource, { habitats: newHabitats })
      })
    }
  }, MenuMassFunctionRiseBuffsController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate(), this.isActive && this.dataSource.prepareMassFunctionRiseBuffsData()
  }, MenuMassFunctionRiseBuffsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRiseBuffs.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.utils.object, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, utilsNetwork, utilsObject, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionRiseBuffsDataSource(options) {
    MenuMassFunctionRiseBuffsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRiseBuffsDataSource, CoreDataSource), MenuMassFunctionRiseBuffsDataSource.prototype.prepareMassFunctionRiseBuffsData = function() {
    var data = {};
    data.isTimerable = !1;
    var availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), activeBuffs = modeledHabitat.getActiveBuffs();
      habitatsList.push({
        habitat: modeledHabitat,
        buffs: modeledHabitat.getPossibleBuffs(),
        activeBuffs: activeBuffs
      }), utilsObject.isEmpty(activeBuffs) || (data.isTimerable = !0)
    }), data.habitatsList = habitatsList, data.availableHabitatTypes = availableHabitatTypes, this.notify(xy.eNames.menuMassFunctionRiseBuffs.dataIsReady, data, { isForced: !0 })
  }, MenuMassFunctionRiseBuffsDataSource.prototype.riseAllSelectedBuffs = function(options) {
    var paramHabitatIDDictionary = utilsNetwork.dictionaryToQueryString(options.habitats);
    this.request({ habitatIDBuffIDArrayDictionary: paramHabitatIDDictionary }, "HabitatAction/activateBuffsInHabitatDictionary", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionRiseBuffsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRiseBuffs.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionRiseBuffs.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionRiseBuffsComponent) {
  "use strict";
  function MenuMassFunctionRiseBuffsPresenter(options) {
    MenuMassFunctionRiseBuffsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRiseBuffsPresenter, CorePresenterElementMenu), MenuMassFunctionRiseBuffsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionRiseBuffsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionRiseBuffsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionExchange.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.utils.moving, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatMassExchange, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, utilsMoving, servicesInternationalization, servicesTheme, servicesStorage, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatMassExchange) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function(settings) {
      var tradingResourceId = settings.tradingResourceId, unitPrimaryKey = settings.transportUnit.primaryKey, selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.EXCHANGE,
        field: tradingResourceId,
        subfield: unitPrimaryKey
      });
      return this.cacheBarterLoaded = {}, this.loadBarterData(settings), { selectedHabitats: selectedHabitats || {} }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, storeHabitatsSelection: function() {
      var tradingResourceId = this.props.settings.tradingResourceId, unitPrimaryKey = this.props.settings.transportUnit.primaryKey;
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: this.state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.EXCHANGE,
        field: tradingResourceId,
        subfield: unitPrimaryKey
      })
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(newProps.settings), null)
    }, onMassBarterButtonClick: function() {
      var habitatId, selectedHabitats = {}, stateSelectedHabitats = this.state.selectedHabitats, selectedAmount = 0;
      selectedAmount += this.selectedAmount[0], selectedAmount += this.selectedAmount[2], selectedAmount += this.selectedAmount[4];
      for (habitatId in stateSelectedHabitats)stateSelectedHabitats.hasOwnProperty(habitatId) && stateSelectedHabitats[habitatId] && this.possibleHabitatSet[habitatId] && (selectedHabitats[habitatId] = {
        unitDictionary: this.possibleHabitatSet[habitatId].units,
        resourceDictionary: this.possibleHabitatSet[habitatId].resources
      });
      this.props.presenter.notify(xy.eNames.menuMassFunctionExchange.barter, {
        selectedAmount: selectedAmount,
        tradingResourceId: this.props.settings.tradingResourceId,
        tradingHabitats: selectedHabitats
      })
    }, onSelectDeselectAllClick: function(habitatTypeCode) {
      var status = !0, selectedHabitats = this.state.selectedHabitats, selectedAmount = this.selectedAmount, possibleSelectedAmountOfType = this.possibleSelectedAmount[habitatTypeCode];
      possibleSelectedAmountOfType === selectedAmount[habitatTypeCode] && (status = !1), this.possibleHabitatsIdForSelection[habitatTypeCode].forEach(function(habitatId) {
        selectedHabitats[habitatId] = status
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, onHabitatSelectClick: function(habitatExchangeObject, event) {
      event.stopPropagation(), event.preventDefault();
      var selectedHabitats = this.state.selectedHabitats, habitat = habitatExchangeObject.habitat, habitatId = habitat.id;
      selectedHabitats[habitatId] = !selectedHabitats[habitatId], this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, loadBarterData: function(settings) {
      settings.habitatsList.forEach(function(habitatExchangeableObject) {
        var modeledHabitatId = habitatExchangeableObject.habitat.id;
        this.cacheBarterLoaded[modeledHabitatId] = utilsMoving.massExchangeLoad({
          exchangeableResource: settings.exchangeableResource,
          unitDictionary: habitatExchangeableObject.availableUnits,
          availableResources: habitatExchangeableObject.availableResources
        })
      }, this)
    }, render: function() {
      var settings = {
        habitatsList: [],
        tradingResourceId: 0,
        transportUnit: null,
        exchangeableResource: [],
        availableHabitatTypes: {}
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      }, this.possibleSelectedAmount = {
        0: 0,
        2: 0,
        4: 0
      }, this.possibleHabitatSet = {}, this.possibleHabitatsIdForSelection = {
        0: [],
        2: [],
        4: []
      }, this.selectedAmount = { 0: 0, 2: 0, 4: 0 };
      var totalTradeAmount = 0, tradingResourceId = settings.tradingResourceId, themeSettings = servicesTheme.themeSettings, massFunctionsIconsThemeSettings = themeSettings.imagesClassNames.massFunction || {}, resourcesThemeSettings = themeSettings.resources;
      settings.habitatsList.forEach(function(habitatExchangeableObject) {
        var habitatSettings, selectionState, resourceFreeSpace, modeledHabitat = habitatExchangeableObject.habitat, modeledHabitatId = modeledHabitat.id, publicHabitatType = modeledHabitat.publicHabitatType;
        habitatSettings = {
          habitat: modeledHabitat,
          tradingResourceId: settings.tradingResourceId,
          transportUnit: settings.transportUnit,
          exchangeableResource: settings.exchangeableResource,
          minRequiredAmountUnits: this.cacheBarterLoaded[modeledHabitatId].unitDictionary[settings.transportUnit.primaryKey],
          maxAvailableAmountTradingResource: this.cacheBarterLoaded[modeledHabitatId].barterAmount
        }, resourceFreeSpace = modeledHabitat.getFreeSpaceForResource({ resourceId: settings.tradingResourceId }), this.cacheBarterLoaded[modeledHabitatId].barterAmount > 0 && resourceFreeSpace > 0 ? (habitatSettings.isSelectable = !0, selectionState = {
          habitat: modeledHabitat,
          units: this.cacheBarterLoaded[modeledHabitatId].unitDictionary,
          resources: this.cacheBarterLoaded[modeledHabitatId].resourceDictionary
        }, this.possibleSelectedAmount[publicHabitatType] += 1, this.possibleHabitatsIdForSelection[publicHabitatType].push(modeledHabitatId), this.possibleHabitatSet[modeledHabitatId] = selectionState, habitatSettings.onSelect = this.onHabitatSelectClick.bind(this, selectionState), this.state.selectedHabitats[modeledHabitatId] && (habitatSettings.isSelected = !0, this.selectedAmount[publicHabitatType] += 1, totalTradeAmount += this.cacheBarterLoaded[modeledHabitatId].barterAmount)) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatMassExchange, {
          settings: habitatSettings,
          key: "habitat-in-list-" + modeledHabitatId
        }))
      }, this);
      var selectingTitle, selectionIcon, selectedAll, habitatTypeCode, publicHabitatTypeCodes = themeSettings.habitat.publicHabitatTypeCodes;
      habitatTypeCode = publicHabitatTypeCodes.Castle, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.massFunctionIcon, sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massFunctionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-castles"
      })), settings.availableHabitatTypes[publicHabitatTypeCodes.Fortress] && (habitatTypeCode = publicHabitatTypeCodes.Fortress, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-fortresses"
      }))), settings.availableHabitatTypes[publicHabitatTypeCodes.City] && (habitatTypeCode = publicHabitatTypeCodes.City, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-cities"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: "icon icon-resource icon-resource-" + tradingResourceId,
        title: servicesInternationalization.localize("Barter %@", resourcesThemeSettings[tradingResourceId]),
        rightColumnDataValue: totalTradeAmount.toString(),
        onClick: this.onMassBarterButtonClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "trade-goods-1"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first",
        iconLeft: "icon icon-resource icon-resource-" + tradingResourceId,
        title: servicesInternationalization.localize("Barter %@", resourcesThemeSettings[tradingResourceId]),
        rightColumnDataValue: totalTradeAmount.toString(),
        onClick: this.onMassBarterButtonClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "barter-goods-2"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionExchange.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuMassFunctionRiseBuffsController(options) {
    MenuMassFunctionRiseBuffsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Exchange resources"),
            this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionRiseBuffsController, CoreControllerElementMenu), MenuMassFunctionRiseBuffsController.prototype[xy.eNames.menuMassFunctionExchange.dataIsReady] = function(data, options) {
    options = options || {}, data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuMassFunctionExchange.dataIsReady].bind(this, data), options.isForced), this.forceNextRedrawUpdate && (this.forceNextRedrawUpdate = !1, data.forceNextRedrawUpdate = !0), this.presenter.draw(data)
  }, MenuMassFunctionRiseBuffsController.prototype[xy.eNames.menuMassFunctionExchange.barter] = function(options) {
    return options.selectedAmount < 1 ? void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    }) : void this.dataSource.massBarterResources(options)
  }, MenuMassFunctionRiseBuffsController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate();
    var options = {
      transportUnit: this.initialOptions.chosenUnit,
      tradingResourceId: this.initialOptions.chosenResourceId
    };
    this.isActive && this.dataSource.prepareMassFunctionExchangeData(options)
  }, MenuMassFunctionRiseBuffsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionExchange.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, xy.dNames.services.theme, function(CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager, servicesTheme) {
  "use strict";
  function MenuMassFunctionRiseBuffsDataSource(options) {
    MenuMassFunctionRiseBuffsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRiseBuffsDataSource, CoreDataSource), MenuMassFunctionRiseBuffsDataSource.prototype.prepareMassFunctionExchangeData = function(options) {
    var data = {};
    data.isTimerable = !1;
    var availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [], resourcesThemeSettings = servicesTheme.themeSettings.resources, marketResourcesBuildingIdentifierClass = resourcesThemeSettings.marketResourcesBuildingsByHabitatType, marketMetalBuildingIdentifierClass = resourcesThemeSettings.marketMetalBuildingsByHabitatType;
    ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), buildingResourcesMarket = servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
        habitat: modeledHabitat,
        buildingClass: marketResourcesBuildingIdentifierClass[modeledHabitat.publicHabitatType]
      }), buildingMetalMarket = servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
        habitat: modeledHabitat,
        buildingClass: marketMetalBuildingIdentifierClass[modeledHabitat.publicHabitatType]
      }), marketDictionary = {};
      Object.assign(marketDictionary, buildingResourcesMarket.marketRateDictionary), Object.assign(marketDictionary, buildingMetalMarket.marketRateDictionary);
      var unitsAmountObject, availableUnits = {};
      unitsAmountObject = servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
        habitatId: modeledHabitat.id,
        habitat: modeledHabitat
      }), availableUnits[options.transportUnit.primaryKey] = unitsAmountObject[options.transportUnit.primaryKey];
      var availableResources = [];
      resourcesThemeSettings.exchangeable[options.tradingResourceId] instanceof Array && resourcesThemeSettings.exchangeable[options.tradingResourceId].forEach(function(exchangeableResourceId) {
        availableResources.push({
          resourceId: exchangeableResourceId,
          amount: modeledHabitat.habitatResourceDictionary[exchangeableResourceId].amount,
          exchangeRate: marketDictionary[options.tradingResourceId][exchangeableResourceId]
        })
      }), habitatsList.push({
        habitat: modeledHabitat,
        availableUnits: availableUnits,
        availableResources: availableResources
      })
    }), data.habitatsList = habitatsList, data.tradingResourceId = options.tradingResourceId, data.transportUnit = options.transportUnit, data.exchangeableResource = resourcesThemeSettings.exchangeable[options.tradingResourceId], data.availableHabitatTypes = availableHabitatTypes, this.notify(xy.eNames.menuMassFunctionExchange.dataIsReady, data, { isForced: !0 })
  }, MenuMassFunctionRiseBuffsDataSource.prototype.massBarterResources = function(options) {
    var paramHabitatIDictionary = utilsNetwork.dictionaryToQueryString(options.tradingHabitats);
    servicesGameDataManager.unitsCollection.resetHabitatInits = !0, this.request({
      wantedResourceID: options.tradingResourceId,
      habitatIDResourceAndUnitDictionary: paramHabitatIDictionary
    }, "MarketAction/tradeResourcesForHabitatDictionary", {
      callBack: this.handleSessionUpdateResponse,
      shouldFullyUpdate: !0
    }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionRiseBuffsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionExchange.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionExchange.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionExchangeComponent) {
  "use strict";
  function MenuMassFunctionRiseBuffsPresenter(options) {
    MenuMassFunctionRiseBuffsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRiseBuffsPresenter, CorePresenterElementMenu), MenuMassFunctionRiseBuffsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionExchangeComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionRiseBuffsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionMissions.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatOverview, function(componentsEngine, mixinsMenuComponentHandlers, utilsObject, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesTheme, servicesStorage, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatOverview) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function() {
      var selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({ massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.MISSIONS });
      return { selectedHabitats: selectedHabitats || {} }
    }, getInitialState: function() {
      return this.getNewState()
    }, storeHabitatsSelection: function() {
      var state = this.state;
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.MISSIONS
      })
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(), null)
    }, onRunMassMissions: function() {
      var habitatId, selectedAmount = 0, selectedHabitats = {}, stateSelectedHabitats = this.state.selectedHabitats;
      selectedAmount += this.selectedAmount[0], selectedAmount += this.selectedAmount[2], selectedAmount += this.selectedAmount[4];
      for (habitatId in stateSelectedHabitats)stateSelectedHabitats.hasOwnProperty(habitatId) && stateSelectedHabitats[habitatId] && this.possibleHabitatSet[habitatId] && (selectedHabitats[habitatId] = this.possibleHabitatSet[habitatId]);
      this.props.presenter.notify(xy.eNames.menuMassFunctionMissions.runMissions, {
        selectedAmount: selectedAmount,
        habitats: selectedHabitats
      })
    }, onSpeedUpAllMissionClick: function(activeMissions) {
      this.props.presenter.notify(xy.eNames.menuMassFunctionMissions.speedUpAllMissions, { activeMissions: activeMissions })
    }, onCancelAllMissionClick: function(missionsForCancel) {
      this.props.presenter.notify(xy.eNames.menuMassFunctionMissions.cancelAllMissions, { activeMissions: missionsForCancel })
    }, onSelectDeselectAllClick: function(habitatTypeCode) {
      var status = !0, selectedHabitats = this.state.selectedHabitats, selectedAmount = this.selectedAmount, possibleSelectedAmountOfType = this.possibleSelectedAmount[habitatTypeCode];
      possibleSelectedAmountOfType === selectedAmount[habitatTypeCode] && (status = !1), this.possibleHabitatsIdForSelection[habitatTypeCode].forEach(function(habitatId) {
        selectedHabitats[habitatId] = status
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, onHabitatSelectClick: function(habitat, selectedMissions, event) {
      event.stopPropagation(), event.preventDefault();
      var habitatId = habitat.id, selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitatId] = !selectedHabitats[habitatId], this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, render: function() {
      var settings = { availableHabitatTypes: {}, habitatsList: [] };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [], themeSettings = servicesTheme.themeSettings;
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      }, this.possibleSelectedAmount = {
        0: 0,
        2: 0,
        4: 0
      }, this.possibleMissionsAmount = 0, this.possibleHabitatSet = {}, this.possibleHabitatsIdForSelection = {
        0: [],
        2: [],
        4: []
      }, this.selectedAmount = { 0: 0, 2: 0, 4: 0 };
      var massFunctionsIconsThemeSettings = servicesTheme.themeSettings.imagesClassNames.massFunction || {}, totalSelectedMissionsAmount = 0, missionsForSpeedUp = [], missionsForCancel = [];
      settings.habitatsList.forEach(function(habitat) {
        var isSomethingMissingInHabitatToAffordMission, habitatSettings, activeMissionsAmount = habitat.habitatMissionArray.length || 0, activeMissions = {}, availableMissions = habitat.possibleMissionsIds || [], possibleMissionsAmount = 0, selectedMissions = {}, publicHabitatType = habitat.publicHabitatType, habitatId = habitat.id;
        habitat.habitatMissionArray.forEach(function(missionInProgressId) {
          var modeledMissionInProgress = servicesGameDataManager.missionsCollection.getMissionInProgress(missionInProgressId);
          activeMissions[modeledMissionInProgress.missionId] = modeledMissionInProgress, modeledMissionInProgress.wasSpeedUp() ? missionsForCancel.push({
            habitat: habitat,
            missionInProgress: modeledMissionInProgress
          }) : missionsForSpeedUp.push(modeledMissionInProgress)
        });
        var i, modeledMission, len = availableMissions.length;
        for (i = 0; i < len; i += 1)modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: availableMissions[i] }), activeMissions.hasOwnProperty(modeledMission.primaryKey) || (isSomethingMissingInHabitatToAffordMission = habitat.whatMissingInHabitatToAffordMission(modeledMission, {
          previouslySelected: selectedMissions,
          multiSelectionMode: !0
        }), settingsGameConstant.ENTITY.NONE === isSomethingMissingInHabitatToAffordMission && (selectedMissions[modeledMission.primaryKey] = modeledMission, possibleMissionsAmount += 1));
        habitatSettings = {
          habitat: habitat,
          isCurrentHabitat: habitat.id === settings.currentHabitatId,
          onSelect: this.onHabitatSelectClick.bind(this, habitat, selectedMissions),
          hideUnits: !1,
          missionsRow: { possibleMissions: possibleMissionsAmount, activeMissions: activeMissionsAmount }
        }, possibleMissionsAmount ? (habitatSettings.isSelectable = !0, this.possibleSelectedAmount[publicHabitatType] += 1, this.possibleHabitatsIdForSelection[publicHabitatType].push(habitatId), this.possibleMissionsAmount += possibleMissionsAmount, this.possibleHabitatSet[habitatId] = selectedMissions, this.state.selectedHabitats[habitatId] && (habitatSettings.isSelected = !0, this.selectedAmount[publicHabitatType] += 1, totalSelectedMissionsAmount += utilsObject.effectiveLength(selectedMissions))) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatOverview, {
          settings: habitatSettings,
          key: "habitat-in-list-" + habitat.id
        }))
      }, this);
      var selectingTitle, selectionIcon, selectedAll, habitatTypeCode, publicHabitatTypeCodes = themeSettings.habitat.publicHabitatTypeCodes;
      habitatTypeCode = publicHabitatTypeCodes.Castle, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.massFunctionIcon, sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massFunctionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-castles"
      })), settings.availableHabitatTypes[publicHabitatTypeCodes.Fortress] && (habitatTypeCode = publicHabitatTypeCodes.Fortress, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-fortresses"
      }))), settings.availableHabitatTypes[publicHabitatTypeCodes.City] && (habitatTypeCode = publicHabitatTypeCodes.City, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === +this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-cities"
      }))), missionsForSpeedUp.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massMissionSpeedUp,
        title: servicesInternationalization.localize("Speedup all running missions"),
        rightColumnDataValue: missionsForSpeedUp.length,
        onClick: this.onSpeedUpAllMissionClick.bind(this, missionsForSpeedUp)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "speed-up-missions"
      }))), missionsForCancel.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massMissionCancel,
        title: servicesInternationalization.localize("Cancel all missions"),
        rightColumnDataValue: missionsForCancel.length,
        onClick: this.onCancelAllMissionClick.bind(this, missionsForCancel)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "cancel-missions"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.massMission,
        title: servicesInternationalization.localize("Carry out mission"),
        rightColumnDataValue: totalSelectedMissionsAmount || "",
        onClick: this.onRunMassMissions
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-missions-top-button"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massMission,
        title: servicesInternationalization.localize("Carry out mission"),
        rightColumnDataValue: totalSelectedMissionsAmount || "",
        onClick: this.onRunMassMissions
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-missions-bottom-button"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionMissions.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionMissionsController(options) {
    MenuMassFunctionMissionsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Carry out mission"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionMissionsController, CoreControllerElementMenu), MenuMassFunctionMissionsController.prototype[xy.eNames.menuMassFunctionMissions.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuMassFunctionMissionsController.prototype[xy.eNames.menuMassFunctionMissions.runMissions] = function(options) {
    return options.selectedAmount < 1 ? void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    }) : void this.dataSource.runMassMissions(options)
  }, MenuMassFunctionMissionsController.prototype[xy.eNames.menuMassFunctionMissions.speedUpAllMissions] = function(options) {
    var localizationString, text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0;
    return localizationString = "Mission time reduction for %1$d missions costs %2$d %3$@. You have %4$d %5$@.", options.activeMissions.forEach(function(missionInProgress) {
      var modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: missionInProgress.missionId });
      cost += modeledMission.buildSpeedupCost
    }), cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (text = servicesInternationalization.localize(localizationString, options.activeMissions.length, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Speedup all running missions"),
      text: text,
      callbackSuccess: this.dataSource.massMissionsSpeedUp.bind(this.dataSource, { cost: cost })
    }))
  }, MenuMassFunctionMissionsController.prototype[xy.eNames.menuMassFunctionMissions.cancelAllMissions] = function(options) {
    var localizationString, text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0, habitats = {};
    return localizationString = "Do you like to cancel the mission for %1$ld %2$@. You have %3$ld %4$@. Caution! Canceled missions don't produce resources.", options.activeMissions.forEach(function(habitatMissionInProgressObject) {
      var modeledMission, habitatId = habitatMissionInProgressObject.habitat.id;
      modeledMission = servicesGameDataManager.missionsCollection.getMission({ primaryKey: habitatMissionInProgressObject.missionInProgress.missionId }), habitats[habitatId] || (habitats[habitatId] = []), habitats[habitatId].push(modeledMission.primaryKey), cost += modeledMission.buildSpeedupCost
    }), cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (text = servicesInternationalization.localize(localizationString, cost, "Gold", gold, "Gold"), void this.showDialogDialog({
      title: servicesInternationalization.localize("Cancel all missions"),
      text: text,
      callbackSuccess: this.dataSource.massMissionsCancel.bind(this.dataSource, { habitats: habitats, cost: cost })
    }))
  }, MenuMassFunctionMissionsController.prototype.prepareDataForDraw = function() {
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), this.isActive && this.dataSource.prepareMassFunctionMissionsData({ forceNextRedrawUpdate: forceRedraw })
  }, MenuMassFunctionMissionsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionMissions.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.services.gameDataManager, function(gameInstance, CoreDataSource, utilsOop, utilsNetwork, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionMissionsDataSource(options) {
    var menuBuildingOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuBuildingOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuBuildingOverviewDataSource,
      methodName: "missionCancel"
    }], MenuMassFunctionMissionsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionMissionsDataSource, CoreDataSource), MenuMassFunctionMissionsDataSource.prototype.prepareMassFunctionMissionsData = function(options) {
    options = options || {};
    var data = {}, availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      habitatsList.push(modeledHabitat)
    }), data.habitatsList = habitatsList, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, data.availableHabitatTypes = availableHabitatTypes, this.notify(xy.eNames.menuMassFunctionMissions.dataIsReady, data)
  }, MenuMassFunctionMissionsDataSource.prototype.runMassMissions = function(options) {
    var habitatId, missionPK, missionObject, missionsPKList, preparedObject = {};
    for (habitatId in options.habitats)if (options.habitats.hasOwnProperty(habitatId) && (missionsPKList = [], options.habitats[habitatId])) {
      missionObject = options.habitats[habitatId];
      for (missionPK in missionObject)missionObject.hasOwnProperty(missionPK) && missionObject[missionPK] && missionsPKList.push(missionPK);
      missionsPKList.length && (preparedObject[habitatId] = missionsPKList)
    }
    var paramHabitatIDictionary = utilsNetwork.dictionaryToQueryString(preparedObject);
    servicesGameDataManager.unitsCollection.resetHabitatInits = !0, this.request({ habitatIDMissionIDArrayDictionary: paramHabitatIDictionary }, "HabitatAction/executeMissionsInHabitatDictionary", {
      callBack: this.handleSessionUpdateResponse,
      shouldFullyUpdate: !0
    }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionMissionsDataSource.prototype.massMissionsSpeedUp = function(options) {
    this.request({ paymentAmount: options.cost }, "HabitatAction/speedupMissionOnHabitat", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionMissionsDataSource.prototype.massMissionsCancel = function(options) {
    var dicToString = utilsNetwork.dictionaryToQueryString(options.habitats);
    this.request({
      habitatIDMissionIDArrayDictionary: dicToString,
      paymentAmount: options.cost
    }, "HabitatAction/cancelMissionsInHabitatDictionary", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionMissionsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionMissions.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionMissions.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionMissionsComponent) {
  "use strict";
  function MenuMassFunctionMissionsPresenter(options) {
    MenuMassFunctionMissionsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionMissionsPresenter, CorePresenterElementMenu), MenuMassFunctionMissionsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionMissionsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionMissionsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRecruitment.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.storage, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.sortable, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatOverview, xy.dNames.components.tapBarHabitatType, xy.dNames.components.widgetRangeSlider, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsObject, settingsGameConstant, servicesGameDataManager, servicesWorldSettings, servicesStorage, servicesInternationalization, servicesTheme, servicesSortable, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatOverview, ComponentsTapBarHabitatType, ComponentsWidgetRangeSlider) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], initializeExtraData: function(settings, currentUnitLimit) {
      this.possibleSelectedAmount = 0, this.unitsInProgressAmount = {}, this.activeUnitConstruction = {}, this.unitsInProgress = {}, this.habitatAmountForRecruitmentObject = {}, this.habitatsAmountOfType = {
        0: 0,
        2: 0,
        4: 0
      };
      var unitsForComplete = [], unitsForSpeedUp = [], unitsForCompleteAmount = 0, unitsForSpeedUpAmount = 0;
      settings.habitatsDataList.forEach(function(habitatDataObject) {
        var habitat = habitatDataObject.habitat, activeUnitConstruction = [], isCurrentTabMode = habitat.publicHabitatType === settings.tabMode;
        if (habitat.habitatUnitOrderArray.forEach(function(unitInProgressId) {
                  var modeledUnitInProgress = servicesGameDataManager.unitsCollection.getUnitInProgress(unitInProgressId), modeledUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: modeledUnitInProgress.unitId });
                  isCurrentTabMode && activeUnitConstruction.push({
                    unit: modeledUnit,
                    amount: modeledUnitInProgress.orderAmount
                  }), modeledUnitInProgress.isLessThanHalfConstructionTimeRemain() ? (unitsForComplete.push(modeledUnitInProgress), unitsForCompleteAmount += modeledUnitInProgress.orderAmount) : (unitsForSpeedUp.push(modeledUnitInProgress), unitsForSpeedUpAmount += modeledUnitInProgress.orderAmount)
                }), isCurrentTabMode) {
          var possibleUnitsAmount = habitat.canHabitatProduceUnit(settings.chosenUnit) ? habitat.unitRecruitmentInHabitat(settings.chosenUnit).amountPossible || 0 : 0, unitsAmountTillLimit = currentUnitLimit - habitatDataObject.currentAmountOfUnit;
          activeUnitConstruction.sort(servicesSortable.byField("unit", "order")), this.activeUnitConstruction[habitat.id] = activeUnitConstruction, settings.isUnitLimitAvailable && (unitsAmountTillLimit < 0 && (unitsAmountTillLimit = 0), possibleUnitsAmount > unitsAmountTillLimit && (possibleUnitsAmount = unitsAmountTillLimit)), possibleUnitsAmount && (this.possibleSelectedAmount += 1, this.habitatAmountForRecruitmentObject[habitat.id] = {
            habitat: habitat,
            amountForRecruitment: possibleUnitsAmount
          })
        }
      }, this), this.unitsInProgressAmount = {
        complete: unitsForCompleteAmount,
        speedUp: unitsForSpeedUpAmount
      }, this.unitsInProgress = { complete: unitsForComplete, speedUp: unitsForSpeedUp }
    }, getNewState: function(settings) {
      var currentUnitLimit, maxLimit, massRecruitmentLimitDictionary = servicesWorldSettings.settings.massRecruitmentLimitDictionary, tabMode = settings.tabMode, unitPrimaryKey = settings.chosenUnit.primaryKey, selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.RECRUITMENT,
        field: unitPrimaryKey,
        subfield: tabMode
      });
      return maxLimit = massRecruitmentLimitDictionary && massRecruitmentLimitDictionary[unitPrimaryKey] ? +massRecruitmentLimitDictionary[unitPrimaryKey][tabMode] : settingsGameConstant.MAX_MASS_RECRUITMENT_LIMIT_DEFAULT, currentUnitLimit = servicesStorage.getMassRecruitmentUnitLimits(tabMode, unitPrimaryKey) || maxLimit, this.initializeExtraData(settings, currentUnitLimit), this.unitLimitMax = maxLimit, {
        savedUnitLimit: currentUnitLimit,
        stopLocalUpdateFlag: !1,
        currentUnitLimit: currentUnitLimit,
        selectedHabitats: selectedHabitats || {}
      }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, storeSelectedHabitats: function() {
      var settings = this.props.settings, state = this.state, tabMode = settings.tabMode, unitPrimaryKey = settings.chosenUnit.primaryKey;
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.RECRUITMENT,
        field: unitPrimaryKey,
        subfield: tabMode
      })
    }, componentWillReceiveProps: function(newProps) {
      (newProps.settings.forceNextRedrawUpdate || newProps.settings.tabMode !== this.props.settings.tabMode) && (this.setState(this.getNewState(newProps.settings), null), this.scrollToTop(settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER))
    }, updateCurrentMode: function(newTabMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuMassFunctionRecruitment.onTabSwitch, { newTabMode: newTabMode })
    }, onSetUnitLimitValueByRangeSlider: function(flag, value) {
      flag && this.setState({ currentUnitLimit: value }, null)
    }, onSaveUnitLimitButtonClick: function() {
      var settings = this.props.settings, tabMode = settings.tabMode, unitPrimaryKey = settings.chosenUnit.primaryKey, currentUnitLimit = this.state.currentUnitLimit;
      this.initializeExtraData(this.props.settings, currentUnitLimit), this.setState({ savedUnitLimit: currentUnitLimit }), servicesStorage.storeMassRecruitmentUnitLimits(tabMode, unitPrimaryKey, +currentUnitLimit)
    }, onRunMassRecruitmentClick: function() {
      var habitatId, selectedHabitat = {}, stateSelectedHabitat = this.state.selectedHabitats;
      for (habitatId in stateSelectedHabitat)stateSelectedHabitat.hasOwnProperty(habitatId) && stateSelectedHabitat[habitatId] && this.habitatAmountForRecruitmentObject[habitatId] && (selectedHabitat[habitatId] = this.habitatAmountForRecruitmentObject[habitatId]);
      this.props.presenter.notify(xy.eNames.menuMassFunctionRecruitment.runRecruitment, {
        selectedAmount: this.selectedAmount,
        chosenUnit: this.props.settings.chosenUnit,
        habitats: selectedHabitat
      })
    }, onReduceTimeAllRecruitmentClick: function(unitsInProgress, mode) {
      this.props.presenter.notify(xy.eNames.menuMassFunctionRecruitment.reduceTimeAllUnitsConstructions, {
        mode: mode,
        unitsInProgress: unitsInProgress
      })
    }, onSelectDeselectAllClick: function() {
      var status = !0, selectedHabitats = this.state.selectedHabitats;
      this.possibleSelectedAmount === this.selectedAmount && (status = !1), this.props.settings.habitatsDataList.forEach(function(habitatDataObject) {
        var habitat = habitatDataObject.habitat;
        this.habitatAmountForRecruitmentObject[habitat.id] && (selectedHabitats[habitat.id] = status)
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeSelectedHabitats)
    }, onHabitatSelectClick: function(habitat, possibleAmount, event) {
      event.stopPropagation(), event.preventDefault();
      var selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitat.id] = !selectedHabitats[habitat.id], this.setState({ selectedHabitats: selectedHabitats }, this.storeSelectedHabitats)
    }, onDragStart: function() {
      this.setState({ stopLocalUpdateFlag: !0 })
    }, onDragEnd: function() {
      this.setState({ stopLocalUpdateFlag: !1 })
    }, render: function() {
      var settings = {
        tabMode: 0,
        isUnitLimitAvailable: !1,
        chosenUnit: null,
        habitatsDataList: [],
        availableHabitatTypes: {}
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle,
              titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      };
      var tapBarSettings, massFunctionsIconsThemeSettings = servicesTheme.themeSettings.imagesClassNames.massFunction, tapBar = null;
      utilsObject.effectiveLength(settings.availableHabitatTypes) > 1 && (tapBarSettings = {
        tabMode: settings.tabMode,
        availableHabitatTypes: settings.availableHabitatTypes,
        onBarButtonClick: this.updateCurrentMode
      }, tapBar = React.createElement(ComponentsTapBarHabitatType, { settings: tapBarSettings })), this.state.stopLocalUpdateFlag || (this.selectedAmount = 0, this.selectedUnitsAmount = 0), this.habitatsAmountOfType = {
        0: 0,
        2: 0,
        4: 0
      }, settings.habitatsDataList.forEach(function(habitatDataObject) {
        if (!(this.state.stopLocalUpdateFlag && this.habitatsAmountOfType[habitatDataObject.habitat.publicHabitatType] > settingsGameConstant.MAX_ACTIVE_ITEMS_RENDER_AMOUNT.MASS_RECRUITMENT)) {
          var habitat = habitatDataObject.habitat, isCurrentTabMode = habitat.publicHabitatType === settings.tabMode;
          if (isCurrentTabMode) {
            var habitatSettings, possibleUnitAmount = this.habitatAmountForRecruitmentObject[habitat.id] ? this.habitatAmountForRecruitmentObject[habitat.id].amountForRecruitment : 0;
            habitatSettings = {
              habitat: habitat,
              onSelect: this.onHabitatSelectClick.bind(this, habitat, possibleUnitAmount),
              massRecruitmentRow: {
                possibleUnitConstruction: { unit: settings.chosenUnit, amount: possibleUnitAmount },
                activeUnitConstruction: this.activeUnitConstruction[habitat.id]
              }
            }, this.habitatsAmountOfType[habitat.publicHabitatType] += 1, possibleUnitAmount ? (habitatSettings.isSelectable = !0, this.state.selectedHabitats[habitat.id] && (habitatSettings.isSelected = !0, this.state.stopLocalUpdateFlag || (this.selectedAmount += 1, this.selectedUnitsAmount += possibleUnitAmount))) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatOverview, {
              settings: habitatSettings,
              key: "habitat-in-list-" + habitat.id
            }))
          }
        }
      }, this), settings.isUnitLimitAvailable && (sectionComponentSettings = {
        classes: "first",
        handleIcon: settings.chosenUnit.icon,
        currentValue: this.state.currentUnitLimit,
        minValue: 1,
        maxValue: this.unitLimitMax,
        showButtons: !0,
        handleDragStart: this.onDragStart,
        handleDragEnd: this.onDragEnd,
        onChange: this.onSetUnitLimitValueByRangeSlider.bind(this, !0),
        showAcceptButton: !1
      }, componentsSections.push(React.createElement(ComponentsWidgetRangeSlider, {
        settings: sectionComponentSettings,
        key: "unit-limit-range-slider"
      })), sectionComponentSettings = {
        classes: this.state.currentUnitLimit === this.state.savedUnitLimit ? "disabled " : "",
        iconLeft: massFunctionsIconsThemeSettings.massRecruitmentSaveUnitLimit + settings.chosenUnit.primaryKey,
        title: servicesInternationalization.localize("Save unit limit"),
        onClick: this.onSaveUnitLimitButtonClick
      }, faqLink = servicesTheme.themeSettings.faqLinks.crossCastleRecruitmentUnitLimit, faqLink && (sectionComponentSettings = this.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "save-unit-limit"
      })));
      var selectingTitle, selectionIcon, faqLink, selectedAll = this.possibleSelectedAmount > 0 && this.possibleSelectedAmount === this.selectedAmount;
      switch (settings.tabMode) {
        case settingsGameConstant.HABITAT_TYPE.CASTLE:
          selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.selectCastles;
          break;
        case settingsGameConstant.HABITAT_TYPE.FORTRESS:
          selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress;
          break;
        case settingsGameConstant.HABITAT_TYPE.CITY:
          selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities
      }
      sectionComponentSettings = {
        classes: "first ",
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick
      }, faqLink = servicesTheme.themeSettings.faqLinks.crossCastleRecruitment, faqLink && (sectionComponentSettings = this.addFAQButton(sectionComponentSettings, faqLink)), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-de-select-all"
      })), this.unitsInProgress.speedUp instanceof Array && this.unitsInProgress.speedUp.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massUnitSpeedUp,
        title: servicesInternationalization.localize("Speedup recruiting"),
        rightColumnDataValue: this.unitsInProgressAmount.speedUp || 0,
        onClick: this.onReduceTimeAllRecruitmentClick.bind(this, this.unitsInProgress.speedUp, settingsGameConstant.UNIT_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "speed-up-missions"
      }))), this.unitsInProgress.complete instanceof Array && this.unitsInProgress.complete.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massUnitComplete,
        title: servicesInternationalization.localize("Finish recruitment"),
        rightColumnDataValue: this.unitsInProgressAmount.complete || 0,
        onClick: this.onReduceTimeAllRecruitmentClick.bind(this, this.unitsInProgress.complete, settingsGameConstant.UNIT_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "cancel-missions"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.massUnitRecruit,
        title: servicesInternationalization.localize("Unit Recruiting"),
        rightColumnDataValue: this.selectedUnitsAmount || "",
        onClick: this.onRunMassRecruitmentClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-missions-top"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massUnitRecruit,
        title: servicesInternationalization.localize("Unit Recruiting"),
        rightColumnDataValue: this.selectedUnitsAmount || "",
        onClick: this.onRunMassRecruitmentClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-missions-bottom"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: tapBar,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRecruitment.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionRecruitmentController(options) {
    MenuMassFunctionRecruitmentController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Mass unit recruiting"), this.tabMode = servicesGameDataManager.habitatsCollection.getDefaultHabitatTabMode(), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionRecruitmentController, CoreControllerElementMenu), MenuMassFunctionRecruitmentController.prototype[xy.eNames.menuMassFunctionRecruitment.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuMassFunctionRecruitmentController.prototype[xy.eNames.menuMassFunctionRecruitment.onTabSwitch] = function(options) {
    this.tabMode = options.newTabMode, this.prepareDataForDraw()
  }, MenuMassFunctionRecruitmentController.prototype[xy.eNames.menuMassFunctionRecruitment.runRecruitment] = function(options) {
    var constructionQueueLimit, modeledHabitat, habitatId, cost = 0, habitats = options.habitats, orderDictionary = {}, paramOptions = { orderDictionary: {} };
    if (options.selectedAmount < 1)return void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    });
    for (habitatId in habitats)habitats.hasOwnProperty(habitatId) && habitats[habitatId] && (orderDictionary[habitatId] = {}, orderDictionary[habitatId][options.chosenUnit.primaryKey] = habitats[habitatId].amountForRecruitment, modeledHabitat = habitats[habitatId].habitat, constructionQueueLimit = +servicesWorldSettings.settings.unitRecruitingListBoundaryByHabitatType[modeledHabitat.habitatType], modeledHabitat.habitatUnitOrderArray.length >= constructionQueueLimit && (cost += options.chosenUnit.buildSpeedupCost * habitats[habitatId].amountForRecruitment));
    if (paramOptions.orderDictionary = orderDictionary, cost > 0) {
      var text, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      paramOptions.cost = cost, text = servicesInternationalization.localize("Your unit order queue is full. An additional slot costs %d %@\\nYou have %d %@", cost, "Gold", gold, "Gold"), this.showDialogDialog({
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.runMassRecruitmentWithLimit.bind(this.dataSource, paramOptions)
      })
    } else this.dataSource.runMassRecruitmentWithLimit(paramOptions)
  }, MenuMassFunctionRecruitmentController.prototype[xy.eNames.menuMassFunctionRecruitment.reduceTimeAllUnitsConstructions] = function(options) {
    var localizationString, localizationTitle, text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0, amount = 0;
    switch (options.mode) {
      case settingsGameConstant.UNIT_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP:
        localizationString = "Reducing recruition time for %d x %@ costs %d %@. You have %d %@.", localizationTitle = "Speedup recruiting";
        break;
      case settingsGameConstant.UNIT_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE:
        localizationString = "Finishing recruiting %d x %@ instantly costs %d %@. You have %d %@.", localizationTitle = "Finish recruitment"
    }
    if (options.unitsInProgress.forEach(function(unitsInProgress) {
              var modeledUnit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitsInProgress.unitId });
              cost += unitsInProgress.orderAmount * modeledUnit.buildSpeedupCost, amount += unitsInProgress.orderAmount
            }), cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
    var paramOptions = { cost: cost, mode: options.mode };
    text = servicesInternationalization.localize(localizationString, amount, "Units", cost, "Gold", gold, "Gold"), this.showDialogDialog({
      title: servicesInternationalization.localize(localizationTitle),
      text: text,
      callbackSuccess: this.dataSource.massRecruitmentSpeedUp.bind(this.dataSource, paramOptions)
    })
  }, MenuMassFunctionRecruitmentController.prototype.prepareDataForDraw = function() {
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), this.isActive && this.dataSource.prepareMassFunctionRecruitmentData({
      chosenUnit: this.initialOptions.chosenUnit,
      forceNextRedrawUpdate: forceRedraw,
      tabMode: this.tabMode
    })
  }, MenuMassFunctionRecruitmentController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRecruitment.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreDataSource, utilsOop, utilsNetwork, settingsGameConstant, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionRecruitmentDataSource(options) {
    MenuMassFunctionRecruitmentDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRecruitmentDataSource, CoreDataSource), MenuMassFunctionRecruitmentDataSource.prototype.prepareMassFunctionRecruitmentData = function(options) {
    options = options || {};
    var data = {}, ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsDataList = [], availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer();
    ownHabitatsIdsList.forEach(function(habitatId) {
      var currentAmount, modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      currentAmount = servicesGameDataManager.unitsCollection.findAllUnitsOfKindForHabitat({
        primaryKey: options.chosenUnit.primaryKey,
        habitat: modeledHabitat
      }), habitatsDataList.push({ habitat: modeledHabitat, currentAmountOfUnit: currentAmount })
    }), data.isUnitLimitAvailable = servicesWorldSettings.settings.featureMassRecruitmentWithLimit, data.tabMode = options.tabMode, data.availableHabitatTypes = availableHabitatTypes, data.habitatsDataList = habitatsDataList, data.chosenUnit = options.chosenUnit, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuMassFunctionRecruitment.dataIsReady, data)
  }, MenuMassFunctionRecruitmentDataSource.prototype.runMassRecruitment = function(options) {
    var param = { unitID: options.chosenUnit.primaryKey, habitatIDArray: options.selectedHabitatsId };
    options.paymentGranted && (param.paymentGranted = !0), this.request(param, "HabitatAction/buildUnitInHabitatArray", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionRecruitmentDataSource.prototype.runMassRecruitmentWithLimit = function(options) {
    var param = { unitsOfAmountDictionary: utilsNetwork.dictionaryToQueryString(options.orderDictionary) };
    options.cost && (param.paymentAmount = options.cost), this.request(param, "HabitatAction/buildUnitsInHabitatDictionary", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionRecruitmentDataSource.prototype.massRecruitmentSpeedUp = function(options) {
    var url;
    switch (options.mode) {
      case settingsGameConstant.UNIT_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP:
        url = "HabitatAction/speedupBuildAllUnitsOnEveryHabitat";
        break;
      case settingsGameConstant.UNIT_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE:
        url = "HabitatAction/finishBuildAllUnitsOnEveryHabitat"
    }
    this.request({ paymentAmount: options.cost }, url, { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionRecruitmentDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionRecruitment.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionRecruitment.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionRecruitmentComponent) {
  "use strict";
  function MenuMassFunctionRecruitmentPresenter(options) {
    MenuMassFunctionRecruitmentPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionRecruitmentPresenter, CorePresenterElementMenu), MenuMassFunctionRecruitmentPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionRecruitmentComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionRecruitmentPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionKnowledge.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.sortable, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatOverview, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsObject, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesTheme, servicesSortable, servicesStorage, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatOverview) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function(settings) {
      var knowledgePrimaryKey = settings.chosenKnowledge.primaryKey, selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.KNOWLEDGE,
        field: knowledgePrimaryKey
      });
      return { selectedHabitats: selectedHabitats || {} }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, storeHabitatsSelection: function() {
      var settings = this.props.settings, state = this.state, knowledgePrimaryKey = settings.chosenKnowledge.primaryKey;
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.KNOWLEDGE,
        field: knowledgePrimaryKey
      })
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(newProps.settings), null)
    }, onRunMassResearchesClick: function() {
      var habitatId, selectedHabitats = {}, stateSelectedHabitats = this.state.selectedHabitats;
      for (habitatId in stateSelectedHabitats)stateSelectedHabitats.hasOwnProperty(habitatId) && stateSelectedHabitats[habitatId] && this.objectForSelectAll[habitatId] && (selectedHabitats[habitatId] = this.objectForSelectAll[habitatId]);
      this.props.presenter.notify(xy.eNames.menuMassFunctionKnowledge.conductResearch, {
        selectedAmount: +this.selectedAmount,
        chosenKnowledge: this.props.settings.chosenKnowledge,
        habitats: selectedHabitats
      })
    }, onReduceTimeAllResearchesClick: function(researchesInProgress, mode) {
      this.props.presenter.notify(xy.eNames.menuMassFunctionKnowledge.reduceTimeAllResearches, {
        mode: mode,
        researchesInProgress: researchesInProgress
      })
    }, onSelectDeselectAllClick: function() {
      var status = !0, selectedHabitats = this.state.selectedHabitats;
      this.possibleSelectedAmount === +this.selectedAmount && (status = !1), this.props.settings.habitatsList.forEach(function(habitat) {
        this.objectForSelectAll[habitat.id] && (selectedHabitats[habitat.id] = status)
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, onHabitatSelectClick: function(habitat, event) {
      event.stopPropagation(), event.preventDefault();
      var selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitat.id] = !selectedHabitats[habitat.id], this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, render: function() {
      var settings = {
        chosenKnowledge: null,
        habitatTypeMode: settingsGameConstant.HABITAT_TYPE.CASTLE,
        habitatsList: []
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      };
      var massFunctionsIconsThemeSettings = servicesTheme.themeSettings.imagesClassNames.massFunction || {}, lang = gameInstance.getGameLanguage();
      this.possibleSelectedAmount = 0, this.selectedAmount = 0, this.objectForSelectAll = {};
      var knowledgesForSpeedUp = [], knowledgesForComplete = [], knowledgesForSpeedUpAmount = 0, knowledgesForCompleteAmount = 0;
      settings.habitatsList.forEach(function(habitat) {
        var habitatSettings, currentResearchList = habitat.habitatKnowledgeOrderArray, isResearchPossible = habitat.canHabitatRunStudyOnKnowledge(settings.chosenKnowledge), activeResearchesAmount = 0;
        currentResearchList instanceof Array && currentResearchList.length && currentResearchList.forEach(function(knowledgeInProgressId) {
          var modeledKnowledgeInProgress = servicesGameDataManager.knowledgesCollection.getKnowledgeInProgress(knowledgeInProgressId);
          activeResearchesAmount += 1, modeledKnowledgeInProgress.isLessThanHalfConstructionTimeRemain() ? (knowledgesForComplete.push(modeledKnowledgeInProgress), knowledgesForCompleteAmount += 1) : (knowledgesForSpeedUp.push(modeledKnowledgeInProgress), knowledgesForSpeedUpAmount += 1)
        }), settings.habitatTypeMode === habitat.publicHabitatType && (habitatSettings = {
          habitat: habitat,
          onSelect: this.onHabitatSelectClick.bind(this, habitat),
          massKnowledgeRow: {
            possibleKnowledge: {
              knowledge: settings.chosenKnowledge,
              amount: isResearchPossible ? 1 : 0
            }, activeResearchesAmount: activeResearchesAmount
          }
        }, isResearchPossible ? (habitatSettings.isSelectable = !0, this.possibleSelectedAmount += 1, this.objectForSelectAll[habitat.id] = habitat, this.state.selectedHabitats[habitat.id] && (this.selectedAmount += 1, habitatSettings.isSelected = !0)) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatOverview, {
          settings: habitatSettings,
          key: "habitat-in-list-" + habitat.id
        })))
      }, this);
      var selectingTitle, selectionIcon, selectedAll = this.possibleSelectedAmount > 0 && this.possibleSelectedAmount === +this.selectedAmount;
      switch (settings.habitatTypeMode) {
        case settingsGameConstant.HABITAT_TYPE.CASTLE:
          selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.selectCastles;
          break;
        case settingsGameConstant.HABITAT_TYPE.FORTRESS:
          selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress;
          break;
        case settingsGameConstant.HABITAT_TYPE.CITY:
          selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities
      }
      sectionComponentSettings = {
        classes: "first ",
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick
      }, servicesTheme.themeSettings.faqLinks.crossCastleUpgrades && (sectionComponentSettings.iconRight = "controls menu-info", sectionComponentSettings.iconRightOnClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: servicesTheme.themeSettings.faqLinks.baseURL + servicesTheme.themeSettings.faqLinks.crossCastleUpgrades + "&l=" + lang }
      })), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-deselcet-all"
      })), knowledgesForSpeedUp.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massResearchSpeedUp,
        title: servicesInternationalization.localize("Speedup research"),
        rightColumnDataValue: knowledgesForSpeedUpAmount,
        onClick: this.onReduceTimeAllResearchesClick.bind(this, knowledgesForSpeedUp, settingsGameConstant.KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "speed-up-research"
      }))), knowledgesForComplete.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massResearchComplete,
        title: servicesInternationalization.localize("Finish research"),
        rightColumnDataValue: knowledgesForCompleteAmount,
        onClick: this.onReduceTimeAllResearchesClick.bind(this, knowledgesForComplete, settingsGameConstant.KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "complete-research"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.massResearchRun,
        title: servicesInternationalization.localize("Execute research"),
        rightColumnDataValue: this.selectedAmount || "",
        onClick: this.onRunMassResearchesClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-research-1"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first",
        iconLeft: massFunctionsIconsThemeSettings.massResearchRun,
        title: servicesInternationalization.localize("Execute research"),
        rightColumnDataValue: this.selectedAmount || "",
        onClick: this.onRunMassResearchesClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-research-2"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionKnowledge.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionKnowledgeController(options) {
    MenuMassFunctionKnowledgeController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Execute research"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionKnowledgeController, CoreControllerElementMenu), MenuMassFunctionKnowledgeController.prototype[xy.eNames.menuMassFunctionKnowledge.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuMassFunctionKnowledgeController.prototype[xy.eNames.menuMassFunctionKnowledge.conductResearch] = function(options) {
    var researchLimit, modeledHabitat, habitatId, cost = 0, habitats = options.habitats, chooseKnowledgePK = options.chosenKnowledge.primaryKey, chooseKnowledgeCost = options.chosenKnowledge.buildSpeedupCost, knowledgeResearchDictionary = {}, paramOptions = {
      knowledgeResearchDictionary: {},
      paymentAmount: 0
    };
    if (options.selectedAmount < 1)return void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    });
    for (habitatId in habitats)habitats.hasOwnProperty(habitatId) && habitats[habitatId] && (knowledgeResearchDictionary[habitatId] = [chooseKnowledgePK], modeledHabitat = habitats[habitatId], researchLimit = +servicesWorldSettings.settings.knowledgeResearchListBoundaryByHabitatType[modeledHabitat.habitatType], modeledHabitat.habitatKnowledgeOrderArray.length >= researchLimit && (cost += chooseKnowledgeCost));
    if (paramOptions.knowledgeResearchDictionary = knowledgeResearchDictionary, cost > 0) {
      var text, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      paramOptions.paymentAmount = cost, text = servicesInternationalization.localize("Your knowledge order queue is full. An additional slot costs %1$d %2$@\\nYou have %3$d %4$@", cost, "Gold", gold, "Gold"), this.showDialogDialog({
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.runMassResearches.bind(this.dataSource, paramOptions)
      })
    } else this.dataSource.runMassResearches(paramOptions)
  }, MenuMassFunctionKnowledgeController.prototype[xy.eNames.menuMassFunctionKnowledge.reduceTimeAllResearches] = function(options) {
    var localizationString, localizationTitle, text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0;
    switch (options.mode) {
      case settingsGameConstant.KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP:
        localizationString = "Would you like to pay %1$ld %2$@ to speed up all ongoing researches? You own %3$ld %4$@", localizationTitle = "Speedup research";
        break;
      case settingsGameConstant.KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE:
        localizationString = "Would you like to pay %1$ld %2$@ to complete all ongoing researches? You own %3$ld %4$@", localizationTitle = "Finish research"
    }
    if (options.researchesInProgress.forEach(function(researchInProgress) {
              var modeledKnowledge = servicesGameDataManager.knowledgesCollection.getKnowledge({ primaryKey: researchInProgress.knowledgeId });
              cost += modeledKnowledge.buildSpeedupCost
            }), cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
    var paramOptions = { cost: cost, mode: options.mode };
    text = servicesInternationalization.localize(localizationString, cost, "Gold", gold, "Gold"), this.showDialogDialog({
      title: servicesInternationalization.localize(localizationTitle),
      text: text,
      callbackSuccess: this.dataSource.massKnowledgeSpeedUp.bind(this.dataSource, paramOptions)
    })
  }, MenuMassFunctionKnowledgeController.prototype.prepareDataForDraw = function() {
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), this.isActive && this.dataSource.prepareMassFunctionKnowledgeData({
      chosenKnowledge: this.initialOptions.chosenKnowledge,
      habitatTypeMode: this.initialOptions.habitatTypeMode,
      forceNextRedrawUpdate: forceRedraw
    })
  }, MenuMassFunctionKnowledgeController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionKnowledge.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(gameInstance, CoreDataSource, utilsOop, utilsNetwork, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionKnowledgeDataSource(options) {
    MenuMassFunctionKnowledgeDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionKnowledgeDataSource, CoreDataSource), MenuMassFunctionKnowledgeDataSource.prototype.prepareMassFunctionKnowledgeData = function(options) {
    options = options || {};
    var data = {}, ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      habitatsList.push(modeledHabitat)
    }), data.habitatsList = habitatsList, data.chosenKnowledge = options.chosenKnowledge, data.habitatTypeMode = options.habitatTypeMode, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuMassFunctionKnowledge.dataIsReady, data)
  }, MenuMassFunctionKnowledgeDataSource.prototype.runMassResearches = function(options) {
    var param = {
      knowledgeResearchDictionary: utilsNetwork.dictionaryToQueryString(options.knowledgeResearchDictionary, { trailingCommaFlag: !1 }),
      paymentAmount: options.paymentAmount
    };
    this.request(param, "HabitatAction/researchMultipleKnowledge", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionKnowledgeDataSource.prototype.massKnowledgeSpeedUp = function(options) {
    var url;
    switch (options.mode) {
      case settingsGameConstant.KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP:
        url = "HabitatAction/speedupAllRunningResearch";
        break;
      case settingsGameConstant.KNOWLEDGE_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE:
        url = "HabitatAction/finishAllRunningResearch"
    }
    this.request({ paymentAmount: options.cost }, url, { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionKnowledgeDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionKnowledge.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionKnowledge.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionKnowledgeComponent) {
  "use strict";
  function MenuMassFunctionKnowledgePresenter(options) {
    MenuMassFunctionKnowledgePresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionKnowledgePresenter, CorePresenterElementMenu), MenuMassFunctionKnowledgePresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionKnowledgeComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionKnowledgePresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionBuildings.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.object, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.sortable, xy.dNames.services.storage, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetHabitatOverview, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsObject, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesTheme, servicesSortable, servicesStorage, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetHabitatOverview) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getNewState: function(settings) {
      var buildingClassIdentifier = settings.chosenBuildingClassIdentifier, selectedHabitats = servicesStorage.getMassFunctionsHabitatsSelection({
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.BUILDINGS,
        field: buildingClassIdentifier
      });
      return { selectedHabitats: selectedHabitats || {} }
    }, getInitialState: function() {
      return this.getNewState(this.props.settings)
    }, storeHabitatsSelection: function() {
      var buildingClassIdentifier = this.props.settings.chosenBuildingClassIdentifier;
      servicesStorage.storeMassFunctionsHabitatsSelection({
        selectedHabitats: this.state.selectedHabitats,
        massFunctionsType: settingsGameConstant.MASS_FUNCTIONS.BUILDINGS,
        field: buildingClassIdentifier
      })
    }, componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(newProps.settings), null)
    }, onRunMassUpgradeClick: function() {
      var habitatId, selectedHabitats = {}, stateSelectedHabitats = this.state.selectedHabitats;
      for (habitatId in stateSelectedHabitats)stateSelectedHabitats.hasOwnProperty(habitatId) && stateSelectedHabitats[habitatId] && this.objectForSelectAll[habitatId] && (selectedHabitats[habitatId] = this.objectForSelectAll[habitatId]);
      this.props.presenter.notify(xy.eNames.menuMassFunctionBuildings.runConstructions, {
        selectedAmount: +this.selectedAmount,
        chosenBuildingClassIdentifier: this.props.settings.chosenBuildingClassIdentifier,
        habitats: selectedHabitats
      })
    }, onReduceTimeAllRecruitmentClick: function(buildingsInProgress, mode) {
      this.props.presenter.notify(xy.eNames.menuMassFunctionBuildings.reduceTimeAllBuildingConstructions, {
        mode: mode,
        buildingsInProgress: buildingsInProgress
      })
    }, onSelectDeselectAllClick: function() {
      var status = !0, selectedHabitats = this.state.selectedHabitats;
      this.possibleSelectedAmount === +this.selectedAmount && (status = !1), this.props.settings.habitatsList.forEach(function(habitat) {
        this.objectForSelectAll[habitat.id] && (selectedHabitats[habitat.id] = status)
      }, this), this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, onHabitatSelectClick: function(habitat, resultBuildingModel, event) {
      event.stopPropagation(), event.preventDefault();
      var selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitat.id] = !selectedHabitats[habitat.id], this.setState({ selectedHabitats: selectedHabitats }, this.storeHabitatsSelection)
    }, render: function() {
      var settings = {
        chosenBuildingClassIdentifier: null,
        habitatTypeMode: settingsGameConstant.BUILDING_CHOOSER_LIST_TAB_MODE.HABITAT_TYPE_O,
        habitatsList: []
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      };
      var massFunctionsIconsThemeSettings = servicesTheme.themeSettings.imagesClassNames.massFunction || {}, lang = gameInstance.getGameLanguage();
      this.possibleSelectedAmount = 0, this.selectedAmount = 0, this.objectForSelectAll = {};
      var buildingsForSpeedUp = [], buildingsForComplete = [], buildingsForSpeedUpAmount = 0, buildingsForCompleteAmount = 0;
      settings.habitatsList.forEach(function(habitat) {
        var habitatSettings, building, currentConstructionsList, buildingClassIdentifier = settings.chosenBuildingClassIdentifier, isUpgradePossible = !1;
        currentConstructionsList = servicesGameDataManager.buildingsCollection.getHabitatBuildingUpgrades({
          habitat: habitat,
          buildingClass: buildingClassIdentifier
        }), building = currentConstructionsList.length ? currentConstructionsList[currentConstructionsList.length - 1].resultBuilding : servicesGameDataManager.buildingsCollection.getHabitatBuildingOfClass({
          habitat: habitat,
          buildingClass: buildingClassIdentifier
        });
        var resultBuildingModel, upgradingBuildingPK = building ? building.getResultBuildingPK() : null;
        upgradingBuildingPK && (resultBuildingModel = servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: upgradingBuildingPK }), habitat.canHabitatAffordUpgrade(resultBuildingModel) && (isUpgradePossible = !0));
        var i, buildingInProgressId, modeledBuildingInProgress, len = habitat.habitatBuildingUpgradeArray.length, activeBuildingConstructionAmount = len;
        for (i = 0; i < len; i += 1)buildingInProgressId = habitat.habitatBuildingUpgradeArray[i], modeledBuildingInProgress = servicesGameDataManager.buildingsCollection.getBuildingInProgress(buildingInProgressId), modeledBuildingInProgress.isLessThanHalfConstructionTimeRemain() ? (buildingsForComplete.push(modeledBuildingInProgress), buildingsForCompleteAmount += 1) : (buildingsForSpeedUp.push(modeledBuildingInProgress), buildingsForSpeedUpAmount += 1);
        settings.habitatTypeMode === habitat.publicHabitatType && (habitatSettings = {
          habitat: habitat,
          onSelect: this.onHabitatSelectClick.bind(this, habitat, resultBuildingModel),
          massBuildingRow: {
            possibleBuildingConstruction: {
              buildingClassIdentifier: settings.chosenBuildingClassIdentifier,
              amount: isUpgradePossible ? 1 : 0
            }, activeBuildingConstructionAmount: activeBuildingConstructionAmount
          }
        }, isUpgradePossible ? (habitatSettings.isSelectable = !0, this.possibleSelectedAmount += 1, this.objectForSelectAll[habitat.id] = {
          habitat: habitat,
          targetBuilding: resultBuildingModel
        }, this.state.selectedHabitats[habitat.id] && (this.selectedAmount += 1, habitatSettings.isSelected = !0)) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(ComponentsWidgetHabitatOverview, {
          settings: habitatSettings,
          key: "habitat-in-list-" + habitat.id
        })))
      }, this);
      var selectingTitle, selectionIcon, selectedAll = this.possibleSelectedAmount > 0 && this.possibleSelectedAmount === +this.selectedAmount;
      switch (settings.habitatTypeMode) {
        case settingsGameConstant.BUILDING_CHOOSER_LIST_TAB_MODE.HABITAT_TYPE_O:
          selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.selectCastles;
          break;
        case settingsGameConstant.BUILDING_CHOOSER_LIST_TAB_MODE.HABITAT_TYPE_2:
          selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress;
          break;
        case settingsGameConstant.BUILDING_CHOOSER_LIST_TAB_MODE.HABITAT_TYPE_4:
          selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities
      }
      sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick
      }, servicesTheme.themeSettings.faqLinks.crossCastleUpgrades && (sectionComponentSettings.iconRight = "controls menu-info", sectionComponentSettings.iconRightOnClick = this.handlerNextClick.bind(this, {
        next: xy.dNames.game.menuExternalIFrameInjection.name,
        options: { targetURL: servicesTheme.themeSettings.faqLinks.baseURL + servicesTheme.themeSettings.faqLinks.crossCastleUpgrades + "&l=" + lang }
      })), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-deselcet-all"
      })), buildingsForSpeedUp.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massBuildingSpeedUp,
        title: servicesInternationalization.localize("Speedup Upgrade"),
        rightColumnDataValue: buildingsForSpeedUpAmount,
        onClick: this.onReduceTimeAllRecruitmentClick.bind(this, buildingsForSpeedUp, settingsGameConstant.BUILDING_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "speed-up-building"
      }))), buildingsForComplete.length && (sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massBuildingComplete,
        title: servicesInternationalization.localize("Complete Upgrade"),
        rightColumnDataValue: buildingsForCompleteAmount,
        onClick: this.onReduceTimeAllRecruitmentClick.bind(this, buildingsForComplete, settingsGameConstant.BUILDING_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "complete-building"
      }))), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.massBuilding,
        title: servicesInternationalization.localize("Upgrade Building"),
        rightColumnDataValue: this.selectedAmount || "",
        onClick: this.onRunMassUpgradeClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-constructions-1"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first",
        iconLeft: massFunctionsIconsThemeSettings.massBuilding,
        title: servicesInternationalization.localize("Upgrade Building"),
        rightColumnDataValue: this.selectedAmount || "",
        onClick: this.onRunMassUpgradeClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "run-constructions-2"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionBuildings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionBuildingsController(options) {
    MenuMassFunctionBuildingsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Upgrade Building"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionBuildingsController, CoreControllerElementMenu), MenuMassFunctionBuildingsController.prototype[xy.eNames.menuMassFunctionBuildings.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuMassFunctionBuildingsController.prototype[xy.eNames.menuMassFunctionBuildings.runConstructions] = function(options) {
    var constructionQueueLimit, modeledHabitat, habitatId, cost = 0, habitats = options.habitats, buildingOrderDictionary = {}, paramOptions = {
      buildingOrderDictionary: {},
      paymentAmount: 0
    };
    if (options.selectedAmount < 1)return void this.showDialogAlert({
      title: servicesInternationalization.localize("No selection"),
      text: servicesInternationalization.localize("Select at least one castle")
    });
    for (habitatId in habitats)habitats.hasOwnProperty(habitatId) && habitats[habitatId] && (buildingOrderDictionary[habitatId] = [habitats[habitatId].targetBuilding.primaryKey], modeledHabitat = habitats[habitatId].habitat, constructionQueueLimit = +servicesWorldSettings.settings.buildingUpgradeListBoundaryByHabitatType[modeledHabitat.habitatType], modeledHabitat.habitatBuildingUpgradeArray.length >= constructionQueueLimit && (cost += habitats[habitatId].targetBuilding.buildSpeedupCost));
    if (paramOptions.buildingOrderDictionary = buildingOrderDictionary, cost > 0) {
      var text, gold = servicesGameDataManager.playersCollection.getPlayer().gold;
      if (cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
      paramOptions.paymentAmount = cost, text = servicesInternationalization.localize("Your building upgrade queue is full. An additional slot costs %d %@\nYou have %d %@", cost, "Gold", gold, "Gold"), this.showDialogDialog({
        title: servicesInternationalization.localize("Gold"),
        text: text,
        callbackSuccess: this.dataSource.runMassBuildingsUpgrade.bind(this.dataSource, paramOptions)
      })
    } else this.dataSource.runMassBuildingsUpgrade(paramOptions)
  }, MenuMassFunctionBuildingsController.prototype[xy.eNames.menuMassFunctionBuildings.reduceTimeAllBuildingConstructions] = function(options) {
    var localizationObject, localizationTitle, text, gold = servicesGameDataManager.playersCollection.getPlayer().gold, cost = 0;
    switch (options.mode) {
      case settingsGameConstant.BUILDING_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP:
        localizationObject = "Halving the build time costs %1$dÂ %2$@.You have %3$dÂ %4$@.", localizationTitle = "Speedup Upgrade";
        break;
      case settingsGameConstant.BUILDING_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE:
        localizationObject = "The immediate completion of the building upgrade costs %1$d %2$@.\\nYou have %3$d %4$@.", localizationTitle = "Complete Upgrade"
    }
    if (options.buildingsInProgress.forEach(function(buildingInProgress) {
              var modeledBuilding = servicesGameDataManager.buildingsCollection.getBuilding({ primaryKey: buildingInProgress.buildingTargetID });
              cost += modeledBuilding.buildSpeedupCost
            }), cost > gold)return void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold);
    var paramOptions = { cost: cost, mode: options.mode };
    text = servicesInternationalization.localize(localizationObject, cost, "Gold", gold, "Gold"), this.showDialogDialog({
      title: servicesInternationalization.localize(localizationTitle),
      text: text,
      callbackSuccess: this.dataSource.massBuildingSpeedUp.bind(this.dataSource, paramOptions)
    })
  }, MenuMassFunctionBuildingsController.prototype.prepareDataForDraw = function() {
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), this.isActive && this.dataSource.prepareMassFunctionBuildingsData({
      chosenBuildingClassIdentifier: this.initialOptions.chosenBuildingClassIdentifier,
      habitatTypeMode: this.initialOptions.habitatTypeMode,
      forceNextRedrawUpdate: forceRedraw
    })
  }, MenuMassFunctionBuildingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionBuildings.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, function(gameInstance, CoreDataSource, utilsOop, utilsNetwork, settingsGameConstant, servicesGameDataManager) {
  "use strict";
  function MenuMassFunctionBuildingsDataSource(options) {
    MenuMassFunctionBuildingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionBuildingsDataSource, CoreDataSource), MenuMassFunctionBuildingsDataSource.prototype.prepareMassFunctionBuildingsData = function(options) {
    options = options || {};
    var data = {}, ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      habitatsList.push(modeledHabitat)
    }), data.habitatsList = habitatsList, data.chosenBuildingClassIdentifier = options.chosenBuildingClassIdentifier, data.habitatTypeMode = options.habitatTypeMode, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, this.notify(xy.eNames.menuMassFunctionBuildings.dataIsReady, data)
  }, MenuMassFunctionBuildingsDataSource.prototype.runMassBuildingsUpgrade = function(options) {
    var param = {
      buildingOrderDictionary: utilsNetwork.dictionaryToQueryString(options.buildingOrderDictionary, { trailingCommaFlag: !1 }),
      paymentAmount: options.paymentAmount
    };
    this.request(param, "HabitatAction/upgradeBuildings", { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionBuildingsDataSource.prototype.massBuildingSpeedUp = function(options) {
    var url;
    switch (options.mode) {
      case settingsGameConstant.BUILDING_REDUCE_TIME_CONSTRUCTION_MODE.SPEED_UP:
        url = "HabitatAction/speedupAllRunningBuildingUpgrades";
        break;
      case settingsGameConstant.BUILDING_REDUCE_TIME_CONSTRUCTION_MODE.COMPLETE:
        url = "HabitatAction/finishAllRunningBuildingUpgrades"
    }
    this.request({ paymentAmount: options.cost }, url, { callBack: this.handleSessionUpdateResponse }), this.controller.forceNextRedrawUpdate = !0
  }, MenuMassFunctionBuildingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionBuildings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionBuildings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionBuildingsComponent) {
  "use strict";
  function MenuMassFunctionBuildingsPresenter(options) {
    MenuMassFunctionBuildingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionBuildingsPresenter, CorePresenterElementMenu), MenuMassFunctionBuildingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionBuildingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionBuildingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionSilverMerchant.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.log, xy.dNames.utils.dateTime, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTextBasic, xy.dNames.components.widgetHabitatOverview, xy.dNames.components.widgetTimePicker, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, servicesLog, utilsDateTime, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListTextBasic, WidgetHabitatOverview, WidgetTimePicker) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    possibleSelectedAmount: {},
    possibleHabitatsIdForSelection: {},
    hadChangesInHabitats: !1,
    componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(newProps), null)
    },
    getNewState: function(props) {
      this.selectedAmount = {}, this.possibleSelectedAmount = {}, this.possibleHabitatsIdForSelection = {}, this.hadChangesInHabitats = !1;
      var selectedHabitats = {};
      try {
        props.settings.merchantSettingsModel.habitatArray.length && props.settings.merchantSettingsModel.habitatArray.forEach(function(habitatId) {
          selectedHabitats[habitatId] = !0
        }, this)
      } catch (eX) {
        servicesLog("warn", "There are no silver merchant settings")
      }
      return { selectedHabitats: selectedHabitats }
    },
    getInitialState: function() {
      return this.getNewState(this.props)
    },
    onActivateSilverMerchant: function() {
      var settings = this.props.settings;
      this.props.presenter.notify(xy.eNames.eventMassFunctionSilverMerchant.activate, {
        merchantSettingsModel: settings.merchantSettingsModel,
        selectedHabitats: this.state.selectedHabitats,
        hadChangesInHabitats: this.hadChangesInHabitats
      })
    },
    onSelectDeselectAllClick: function(habitatTypeCode) {
      var status = !0, selectedHabitats = this.state.selectedHabitats, possibleSelectedAmountOfType = this.possibleSelectedAmount[habitatTypeCode];
      possibleSelectedAmountOfType === this.selectedAmount[habitatTypeCode] ? (status = !1, this.selectedAmount[habitatTypeCode] = 0) : this.selectedAmount[habitatTypeCode] = possibleSelectedAmountOfType, this.possibleHabitatsIdForSelection[habitatTypeCode].forEach(function(habitatId) {
        selectedHabitats[habitatId] = status
      }, this), this.hadChangesInHabitats = !0, this.setState({ selectedHabitats: selectedHabitats }, null)
    },
    onHabitatSelectClick: function(habitat, event) {
      event.stopPropagation(), event.preventDefault();
      var habitatId = habitat.id, publicHabitatType = habitat.publicHabitatType, selectedHabitats = this.state.selectedHabitats;
      selectedHabitats[habitatId] ? (selectedHabitats[habitatId] = !1, this.selectedAmount[publicHabitatType] -= 1) : (selectedHabitats[habitatId] = !0, this.selectedAmount[publicHabitatType] += 1), this.hadChangesInHabitats = !0, this.setState({ selectedHabitats: selectedHabitats }, null)
    },
    onSaveSelectionButtonClick: function() {
      this.props.presenter.notify(xy.eNames.eventMassFunctionSilverMerchant.saveSelection, { selectedHabitats: this.state.selectedHabitats })
    },
    onSilverMerchantTimeSubmit: function(date) {
      this.props.presenter.notify(xy.eNames.eventMassFunctionSilverMerchant.setTime, { date: date })
    },
    render: function() {
      var settings = {
        reSchedulingCooldownInHours: settingsGameConstant.MAX_MASS_SILVER_MERCHANT_RE_SCHEDULE_LIMIT_DEFAULT,
        merchantSettingsModel: {},
        availableHabitatTypes: {},
        habitatsList: []
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [], componentsSectionsHabitatsList = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER)
      };
      var themeSettings = servicesTheme.themeSettings, massFunctionsIconsThemeSettings = themeSettings.imagesClassNames.massFunction || {}, totalSelectedHabitat = 0;
      this.selectedAmount = { 0: 0, 2: 0, 4: 0 }, this.possibleSelectedAmount = {
        0: 0,
        2: 0,
        4: 0
      }, this.possibleHabitatsIdForSelection = {
        0: [],
        2: [],
        4: []
      }, settings.habitatsList.forEach(function(habitat) {
        var resourceFreeSpace, habitatSettings = {
          habitat: habitat,
          isCurrentHabitat: habitat.id === settings.currentHabitatId,
          hideUnits: !0
        }, habitatId = habitat.id, publicHabitatType = habitat.publicHabitatType;
        resourceFreeSpace = habitat.getFreeSpaceForResource({ resourceId: servicesTheme.themeSettings.resources.conquestResourceId }), resourceFreeSpace > 0 ? (habitatSettings.isSelectable = !0, habitatSettings.onSelect = this.onHabitatSelectClick.bind(this, habitat), this.possibleSelectedAmount[publicHabitatType] += 1, this.possibleHabitatsIdForSelection[publicHabitatType].push(habitatId), this.state.selectedHabitats[habitat.id] && (habitatSettings.isSelected = !0, this.selectedAmount[publicHabitatType] += 1, totalSelectedHabitat += 1)) : habitatSettings.inactive = !0, componentsSectionsHabitatsList.push(React.createElement(WidgetHabitatOverview, {
          settings: habitatSettings,
          key: "habitat-in-list-" + habitat.id
        }))
      }, this);
      var selectingTitle, selectionIcon, selectedAll, habitatTypeCode, publicHabitatTypeCodes = themeSettings.habitat.publicHabitatTypeCodes;
      habitatTypeCode = publicHabitatTypeCodes.Castle, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all castles" : "Select all castles", selectionIcon = massFunctionsIconsThemeSettings.massFunctionIcon, sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.massFunctionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-castles"
      })), settings.availableHabitatTypes[publicHabitatTypeCodes.Fortress] && (habitatTypeCode = publicHabitatTypeCodes.Fortress, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all fortresses" : "Select all fortresses", selectionIcon = massFunctionsIconsThemeSettings.selectFortress, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-fortresses"
      }))), settings.availableHabitatTypes[publicHabitatTypeCodes.City] && (habitatTypeCode = publicHabitatTypeCodes.City, selectedAll = this.possibleSelectedAmount[habitatTypeCode] > 0 && this.possibleSelectedAmount[habitatTypeCode] === this.selectedAmount[habitatTypeCode], selectingTitle = selectedAll ? "Deselect all cities" : "Select all cities", selectionIcon = massFunctionsIconsThemeSettings.selectCities, sectionComponentSettings = {
        iconLeft: selectionIcon,
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick.bind(this, habitatTypeCode)
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "select-cities"
      }))), sectionComponentSettings = {
        iconLeft: massFunctionsIconsThemeSettings.massFunctionIcon,
        title: servicesInternationalization.localize("Save selection"),
        rightColumnDataValue: totalSelectedHabitat || "0",
        onClick: this.onSaveSelectionButtonClick
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "save-castle-selection"
      })), sectionComponentSettings = {
        forceNextRedrawUpdate: settings.forceNextRedrawUpdate,
        currentTime: settings.merchantSettingsModel.nextTradeTime,
        onSubmit: this.onSilverMerchantTimeSubmit
      }, componentsSections.push(React.createElement(WidgetTimePicker, {
        settings: sectionComponentSettings,
        key: "time-picker"
      })), sectionComponentSettings = {
        classes: "last ",
        iconLeft: massFunctionsIconsThemeSettings.silverMerchantIcon,
        onClick: this.onActivateSilverMerchant
      }, settings.merchantSettingsModel.getActiveStatus() ? (sectionComponentSettings.timer = settings.merchantSettingsModel.activatedUntil, sectionComponentSettings.title = servicesInternationalization.localize("Extend silver merchant")) : sectionComponentSettings.title = servicesInternationalization.localize("Activate silver merchant"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "activate-up-button"
      })), sectionComponentSettings = { text: servicesInternationalization.localize("Changing the time will only take effect after %1$d hours.", settings.reSchedulingCooldownInHours.toString()) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
        settings: sectionComponentSettings,
        key: "warning-info-text"
      })), componentsSections = componentsSections.concat(componentsSectionsHabitatsList), sectionComponentSettings = {
        classes: "first ",
        iconLeft: massFunctionsIconsThemeSettings.silverMerchantIcon,
        onClick: this.onActivateSilverMerchant
      }, settings.merchantSettingsModel.getActiveStatus() ? (sectionComponentSettings.timer = settings.merchantSettingsModel.activatedUntil, sectionComponentSettings.title = servicesInternationalization.localize("Extend silver merchant")) : sectionComponentSettings.title = servicesInternationalization.localize("Activate silver merchant"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "activate-bottom-button"
      }));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.MASS_FUNCTIONS.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionSilverMerchant.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, xy.dNames.services.theme, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager, servicesWorldSettings, servicesTheme) {
  "use strict";
  function MenuMassFunctionSilverMerchantController(options) {
    MenuMassFunctionSilverMerchantController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.localizedName = servicesInternationalization.localize("Silver merchant"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuMassFunctionSilverMerchantController, CoreControllerElementMenu), MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.setTime] = function(options) {
    this.dataSource.prepareTradeTimeForStoring(options)
  }, MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.saveSelection] = function(options) {
    this.dataSource.prepareHabitatSelectionForStoring(options)
  }, MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.activate] = function(options) {
    var merchantSettingsModel = options.merchantSettingsModel;
    if (!options.isForcedToPayPopUp && !merchantSettingsModel.habitatArray.length)return void(merchantSettingsModel.getActiveStatus() ? this[xy.eNames.eventMassFunctionSilverMerchant.showAdvicePopUp1](options) : this[xy.eNames.eventMassFunctionSilverMerchant.showSystemPopUp]());
    if (!options.isForcedToPayPopUp && options.hadChangesInHabitats && !merchantSettingsModel.areAllSelectedHabitatSaved(options.selectedHabitats))return void this[xy.eNames.eventMassFunctionSilverMerchant.showAdvicePopUp2](options);
    var title, text, cost = servicesWorldSettings.settings.massAutomaticConquestPointTradingPrice, gold = servicesGameDataManager.playersCollection.getPlayer().gold, premiumResourceLocalizationKey = servicesTheme.themeSettings.resources.premium;
    return cost > gold ? void this.notify(xy.eNames.sceneGame.needMoreGold, cost - gold) : (merchantSettingsModel.getActiveStatus() ? (title = servicesInternationalization.localize("Extend silver merchant"), text = servicesInternationalization.localize("Extend silver merchant costs %1$d %2$@. You have %3$d %4$@.", cost, premiumResourceLocalizationKey, gold, premiumResourceLocalizationKey)) : (title = servicesInternationalization.localize("Activate silver merchant"), text = servicesInternationalization.localize("Activating silver merchant costs %1$d %2$@. You have %3$d %4$@.", cost, premiumResourceLocalizationKey, gold, premiumResourceLocalizationKey)),
            void this.showDialogDialog({
              title: title,
              text: text,
              callbackSuccess: this.dataSource.runSilverMerchant.bind(this.dataSource, { cost: cost })
            }))
  }, MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.showSystemPopUp] = function() {
    this.showDialogAlert({ text: servicesInternationalization.localize("SilverMerchantSystemPopupMessage") })
  }, MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.showAdvicePopUp1] = function(options) {
    options.isForcedToPayPopUp = !0, this.showDialogDialog({
      text: servicesInternationalization.localize("SilverMerchantAdvicePopup1Message"),
      callbackSuccess: this[xy.eNames.eventMassFunctionSilverMerchant.activate].bind(this, options)
    })
  }, MenuMassFunctionSilverMerchantController.prototype[xy.eNames.eventMassFunctionSilverMerchant.showAdvicePopUp2] = function(options) {
    options.isForcedToPayPopUp = !0, this.showDialogDialog({
      text: servicesInternationalization.localize("SilverMerchantAdvicePopup2Message"),
      callbackSuccess: this[xy.eNames.eventMassFunctionSilverMerchant.activate].bind(this, options)
    })
  }, MenuMassFunctionSilverMerchantController.prototype.prepareDataForDraw = function() {
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), this.dataSource.getMassFunctionSilverMerchantData({ forceNextRedrawUpdate: forceRedraw })
  }, MenuMassFunctionSilverMerchantController
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionSilverMerchant.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuMassFunctionSilverMerchantDataSource(options) {
    MenuMassFunctionSilverMerchantDataSource.__super__.constructor.call(this, options), this.currentOptions = {}
  }

  return utilsOop.extend(MenuMassFunctionSilverMerchantDataSource, CoreDataSource), MenuMassFunctionSilverMerchantDataSource.prototype.getMassFunctionSilverMerchantData = function(options) {
    options = options || {};
    var settings = servicesGameDataManager.massFunctionsCollection.getAutomaticConquestPointTradingSettings();
    settings ? (this.currentOptions = options || {}, this.prepareMassFunctionSilverMerchantData()) : this.request({}, "MarketAction/automaticConquestPointTradingSettings", { callBack: this.onGetSettingsResponse })
  }, MenuMassFunctionSilverMerchantDataSource.prototype.prepareTradeTimeForStoring = function(options) {
    options = options || {};
    var time = options.date, tradeTimeStamp = time.getTime();
    tradeTimeStamp && this.setSilverMerchantSetting({ tradeTime: tradeTimeStamp })
  }, MenuMassFunctionSilverMerchantDataSource.prototype.prepareHabitatSelectionForStoring = function(options) {
    options = options || {};
    var habitatId, habitatArray = [];
    if (options.selectedHabitats)for (habitatId in options.selectedHabitats)options.selectedHabitats.hasOwnProperty(habitatId) && options.selectedHabitats[habitatId] && habitatArray.push(+habitatId);
    this.setSilverMerchantSetting({ habitatArray: habitatArray })
  }, MenuMassFunctionSilverMerchantDataSource.prototype.setSilverMerchantSetting = function(options) {
    options = options || {};
    var params = {};
    options.habitatArray && (params.habitatArray = options.habitatArray), options.tradeTime && (params.tradeTime = options.tradeTime), this.currentOptions.forceNextRedrawUpdate = !0, this.request(params, "MarketAction/setAutomaticConquestPointTradeSettings", { callBack: this.onGetSettingsResponse })
  }, MenuMassFunctionSilverMerchantDataSource.prototype.runSilverMerchant = function(options) {
    options = options || {}, this.currentOptions.forceNextRedrawUpdate = !0, this.request({ paymentAmount: options.cost }, "MarketAction/activateAutomaticConquestPointTrading", { callBack: this.onGetSettingsResponse })
  }, MenuMassFunctionSilverMerchantDataSource.prototype.onGetSettingsResponse = function(data) {
    data && !data.error ? (servicesGameDataManager.massFunctionsCollection.updateAutomaticConquestPointTradingSettingsCache(data), this.prepareMassFunctionSilverMerchantData()) : this.notify(xy.eNames.menu.onDataError)
  }, MenuMassFunctionSilverMerchantDataSource.prototype.prepareMassFunctionSilverMerchantData = function() {
    var settings = servicesGameDataManager.massFunctionsCollection.getAutomaticConquestPointTradingSettings(), data = {}, availableHabitatTypes = servicesGameDataManager.habitatsCollection.getHabitatTypesBelongToPlayer(), ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), habitatsList = [];
    ownHabitatsIdsList.forEach(function(habitatId) {
      var habitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId);
      habitatsList.push(habitat)
    }), data.merchantSettingsModel = settings, data.habitatsList = habitatsList, data.availableHabitatTypes = availableHabitatTypes;
    var cooldown = servicesWorldSettings.settings.massAutomaticConquestPointTradingReschedulingCooldownInHours;
    data.reSchedulingCooldownInHours = cooldown || settingsGameConstant.MAX_MASS_SILVER_MERCHANT_RE_SCHEDULE_LIMIT_DEFAULT, this.currentOptions.forceNextRedrawUpdate && (data.forceNextRedrawUpdate = !0, this.currentOptions.forceNextRedrawUpdate = !1), this.notify(xy.eNames.eventMassFunctionSilverMerchant.dataIsReady, data)
  }, MenuMassFunctionSilverMerchantDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuMassFunctionSilverMerchant.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuMassFunctionSilverMerchant.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuMassFunctionSilverMerchantComponent) {
  "use strict";
  function MenuMassFunctionSilverMerchantPresenter(options) {
    MenuMassFunctionSilverMerchantPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuMassFunctionSilverMerchantPresenter, CorePresenterElementMenu), MenuMassFunctionSilverMerchantPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuMassFunctionSilverMerchantComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuMassFunctionSilverMerchantPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeFinder.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.internationalization, xy.dNames.services.worldSettings, xy.dNames.components.menuSection, xy.dNames.components.menuSectionContent, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuTapBar, xy.dNames.components.habitatMenuElement, xy.dNames.components.widgetDateTimePicker, xy.dNames.components.widgetTimeDurationPicker, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesInternationalization, servicesWorldSettings, ComponentsMenuSection, ComponentsMenuSectionContent, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic, ComponentsMenuTapBar, ComponentsHabitatMenuElement, WidgetDateTimePicker, WidgetTimeDurationPicker) {
  "use strict";
  return componentsEngine.createClass({
    shouldComponentScroll: !1,
    mixins: [mixinsMenuComponentHandlers],
    setScrollPosition: function() {
      this.scrollToMenuElement({
        container: settingsGameConstant.COMPONENTS_REFS.ARRIVAL_TIME_FINDER.CONTAINER,
        target: settingsGameConstant.COMPONENTS_REFS.ARRIVAL_TIME_FINDER.TARGET
      })
    },
    componentWillReceiveProps: function(newProps) {
      if (newProps.settings.tabMode === this.props.settings.tabMode)switch (newProps.settings.tabMode) {
        case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME:
          this.shouldComponentScroll = newProps.settings.completeArrivalTime;
          break;
        case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.TRANSPORT_TIME:
          this.shouldComponentScroll = newProps.settings.completeTransportTime
      }
    },
    componentDidUpdate: function() {
      this.shouldComponentScroll && (this.shouldComponentScroll = !1, this.setScrollPosition())
    },
    updateCurrentMode: function(newTabMode, event) {
      event.preventDefault(), event.stopPropagation(), this.props.presenter.notify(xy.eNames.menuArrivalTimeFinder.onTabSwitch, { newTabMode: newTabMode })
    },
    onHabitatChoose: function(habitat) {
      var mode = settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK;
      switch (this.props.settings.settingsChosenActionKey) {
        case 1:
          mode = settingsGameConstant.SEND_UNITS_RESOURCES_MODE.ATTACK;
          break;
        case 2:
          mode = settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SUPPORT;
          break;
        case 3:
          mode = settingsGameConstant.SEND_UNITS_RESOURCES_MODE.SEND_RESOURCES
      }
      this.props.presenter.notify(xy.eNames.menuArrivalTimeFinder.setCurrentHabitat, habitat) && this.handlerNextClick({
        next: xy.dNames.game.menuHabitatSendUnitsResources.name,
        options: { mode: mode, attackingHabitat: this.props.settings.affectedHabitat }
      })
    },
    onTransportTimeSubmit: function(options) {
      this.props.presenter.notify(xy.eNames.menuArrivalTimeFinder.setTransportTime, options)
    },
    onArrivalDateSubmit: function(date) {
      this.props.presenter.notify(xy.eNames.menuArrivalTimeFinder.setArrivalDate, { date: date })
    },
    render: function() {
      var settings = {
        forceNextRedrawUpdate: !1,
        affectedHabitat: {},
        tabMode: settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME,
        settingsMode: null,
        settingsChosenUnit: null,
        settingsChosenActionKey: null,
        completeArrivalTime: !1,
        completeTransportTime: !1,
        currentArrivalDate: null,
        currentHours: 0,
        currentMinutes: 0,
        currentSeconds: 0,
        habitatsList: []
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, componentsSections = [], themeSettings = servicesTheme.themeSettings;
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = {
        icon: "controls jump-to-top-button",
        onClick: this.scrollToTop.bind(this, settingsGameConstant.COMPONENTS_REFS.ARRIVAL_TIME_FINDER.CONTAINER)
      };
      var tapBar, tapBarSettings;
      if (tapBarSettings = {
                buttons: [{
                  isActive: settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME === settings.tabMode,
                  title: servicesInternationalization.localize("Destination ETA"),
                  onClick: this.updateCurrentMode.bind(this, settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME)
                }, {
                  isActive: settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.TRANSPORT_TIME === settings.tabMode,
                  title: servicesInternationalization.localize("Transport duration"),
                  onClick: this.updateCurrentMode.bind(this, settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.TRANSPORT_TIME)
                }]
              }, tapBar = React.createElement(ComponentsMenuTapBar, { settings: tapBarSettings }), settings.settingsChosenUnit && settings.settingsChosenActionKey) {
        sectionComponentSettings = { title: servicesInternationalization.localize("Preferences") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
          settings: sectionComponentSettings,
          key: "settings-title"
        }));
        var action = settingsGameConstant.ARRIVAL_CALCULATOR_ACTIONS[settings.settingsChosenActionKey];
        sectionComponentSettings = {
          iconLeft: themeSettings.imagesClassNames.icon[action],
          title: servicesInternationalization.localize(action),
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuArrivalTimeSettings.name,
            options: {
              settingsMode: settings.settingsMode,
              settingsChosenUnit: settings.settingsChosenUnit,
              settingsChosenActionKey: settings.settingsChosenActionKey
            }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "settings-action"
        })), sectionComponentSettings = {
          iconLeft: settings.settingsChosenUnit.icon,
          title: settings.settingsChosenUnit.title,
          iconRight: "controls menu-next",
          onClick: this.handlerNextClick.bind(this, {
            next: xy.dNames.game.menuArrivalTimeSettings.name,
            options: {
              settingsMode: settings.settingsMode,
              settingsChosenUnit: settings.settingsChosenUnit,
              settingsChosenActionKey: settings.settingsChosenActionKey
            }
          })
        }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: sectionComponentSettings,
          key: "settings-unit"
        }))
      }
      var showColorCodes = !1, arrivalTimeFinderMaxHours = 24 * servicesWorldSettings.settings.arrivalTimeFinderMaximumArrivalTimeInDays;
      switch (settings.tabMode) {
        case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME:
          sectionComponentSettings = {
            standAloneMode: !1,
            classes: "first",
            forceNextRedrawUpdate: settings.forceNextRedrawUpdate,
            maxHours: arrivalTimeFinderMaxHours,
            currentDate: settings.currentArrivalDate,
            onSubmit: this.onArrivalDateSubmit
          }, componentsSections.push(React.createElement(WidgetDateTimePicker, {
            settings: sectionComponentSettings,
            key: "time-picker"
          })), settings.completeArrivalTime && (showColorCodes = !0);
          break;
        case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.TRANSPORT_TIME:
          sectionComponentSettings = {
            forceNextRedrawUpdate: settings.forceNextRedrawUpdate,
            minString: "00:00:00",
            maxString: arrivalTimeFinderMaxHours + ":00:00",
            maxHours: arrivalTimeFinderMaxHours,
            currentHours: settings.currentHours,
            currentMinutes: settings.currentMinutes,
            currentSeconds: settings.currentSeconds,
            onSubmit: this.onTransportTimeSubmit
          }, componentsSections.push(React.createElement(WidgetTimeDurationPicker, {
            settings: sectionComponentSettings,
            key: "time-picker"
          })), settings.completeTransportTime && (showColorCodes = !0)
      }
      settings.habitatsList.length && (sectionComponentSettings = { title: servicesInternationalization.localize("Habitat list") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "habitat-list-title"
      })), settings.habitatsList.forEach(function(habitatArrivalObject, index) {
        var habitat = habitatArrivalObject.habitat, localComponentSettings = {
          initialComponent: this,
          habitat: habitat,
          onClick: this.onHabitatChoose.bind(this, habitatArrivalObject.habitat),
          showAllianceRelationBadge: !1,
          addIndex: index + 1
        };
        switch (settings.tabMode) {
          case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME:
            localComponentSettings.description = habitatArrivalObject.isTooFar ? servicesInternationalization.localize(themeSettings.arrivalTimeFinder.status[habitat.publicHabitatType]) : utilsDateTime.getLocaleDateTimeString(habitatArrivalObject.arrivingTime);
            break;
          case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.TRANSPORT_TIME:
            localComponentSettings.description = habitatArrivalObject.isTooFar ? servicesInternationalization.localize(themeSettings.arrivalTimeFinder.status[habitat.publicHabitatType]) : utilsDateTime.secondsToTimeString(habitatArrivalObject.transportTimeInSeconds, !0)
        }
        habitatArrivalObject.isTooFar ? localComponentSettings.disabled = !0 : showColorCodes && (habitatArrivalObject.noUnit ? localComponentSettings.classes = "bad-description" : habitatArrivalObject.isBestChoise && (localComponentSettings.classes = "good-description")), habitatArrivalObject.isBestChoise ? componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
          ref: settingsGameConstant.COMPONENTS_REFS.ARRIVAL_TIME_FINDER.TARGET,
          settings: localComponentSettings,
          key: "habitats-in-list-" + index
        })) : componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
          settings: localComponentSettings,
          key: "habitats-in-list-" + index
        }))
      }, this));
      var menuSectionContentSettings = { content: componentsSections }, componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: tapBar,
        searchBar: null,
        bottomBar: null,
        content: React.createElement(ComponentsMenuSectionContent, { settings: menuSectionContentSettings })
      };
      return React.createElement(ComponentsMenuSection, {
        settings: componentMenuSetting,
        ref: settingsGameConstant.COMPONENTS_REFS.ARRIVAL_TIME_FINDER.CONTAINER
      })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeFinder.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuArrivalTimeFinderController(options) {
    MenuArrivalTimeFinderController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.allianceClashes,
      identifier: xy.eNames.dataListeners.dataIdentifiers.flushed,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }], this.currentTabMode = settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME, this.localizedName = servicesInternationalization.localize("Arrival time finder"), this.arrivalDate = null, this.transportTime = null, this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuArrivalTimeFinderController, CoreControllerElementMenu), MenuArrivalTimeFinderController.prototype[xy.eNames.menuArrivalTimeFinder.dataIsReady] = function(data) {
    this.isActive && this.presenter.draw(data)
  }, MenuArrivalTimeFinderController.prototype[xy.eNames.menuArrivalTimeFinder.onTabSwitch] = function(options) {
    this.currentTabMode = options.newTabMode, this.prepareDataForDraw()
  }, MenuArrivalTimeFinderController.prototype[xy.eNames.menuArrivalTimeFinder.setArrivalDate] = function(options) {
    options.date instanceof Date && (this.arrivalDate = options.date, this.forceNextRedrawUpdate = !0), this.prepareDataForDraw()
  }, MenuArrivalTimeFinderController.prototype[xy.eNames.menuArrivalTimeFinder.setTransportTime] = function(options) {
    (options.hours > 0 || options.minutes > 0 || options.seconds > 0) && (this.transportTime = {
      hours: options.hours,
      minutes: options.minutes,
      seconds: options.seconds
    }, this.forceNextRedrawUpdate = !0), this.prepareDataForDraw()
  }, MenuArrivalTimeFinderController.prototype[xy.eNames.menuArrivalTimeFinder.setCurrentHabitat] = function(habitat) {
    return this.dataSource.setNewCurrentHabitat(habitat)
  }, MenuArrivalTimeFinderController.prototype.prepareDataForDraw = function() {
    var forceNextRedrawUpdate = !1;
    this.isActive && (this.forceNextRedrawUpdate && (forceNextRedrawUpdate = !0, this.forceNextRedrawUpdate = !1), this.dataSource.prepareArrivalFinderData({
      tabMode: this.currentTabMode,
      affectedHabitat: this.initialOptions.affectedHabitat,
      affectedPlayer: this.initialOptions.affectedPlayer,
      transportTime: this.transportTime,
      arrivalDate: this.arrivalDate,
      forceNextRedrawUpdate: forceNextRedrawUpdate
    }))
  }, MenuArrivalTimeFinderController
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeFinder.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, xy.dNames.services.worldSettings, function(CoreDataSource, utilsOop, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesSortable, servicesWorldSettings) {
  "use strict";
  function MenuArrivalTimeFinderDataSource(options) {
    MenuArrivalTimeFinderDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuArrivalTimeFinderDataSource, CoreDataSource), MenuArrivalTimeFinderDataSource.prototype.prepareArrivalFinderData = function(options) {
    var mode, isProtectedFromAttack = !1, isProtectedFull = !1, player = servicesGameDataManager.playersCollection.getPlayer();
    player.attackProtectionEndDate && utilsDateTime.remainTimeInSeconds(player.attackProtectionEndDate) > 0 ? isProtectedFull = !0 : options.affectedPlayer.attackProtectionEndDate && utilsDateTime.remainTimeInSeconds(options.affectedPlayer.attackProtectionEndDate) > 0 ? isProtectedFull = !0 : options.affectedPlayer.isOnVacation ? isProtectedFromAttack = !0 : options.affectedHabitat.noobProtectionEndDate && utilsDateTime.remainTimeInSeconds(options.affectedHabitat.noobProtectionEndDate) > 0 && (isProtectedFromAttack = !0), mode = isProtectedFromAttack ? settingsGameConstant.ARRIVAL_CALCULATOR_ACTION_MODES.PROTECTED_FROM_ATTACK : isProtectedFull ? settingsGameConstant.ARRIVAL_CALCULATOR_ACTION_MODES.PROTECTED_FULL : options.affectedHabitat.isOwnByPlayer ? settingsGameConstant.ARRIVAL_CALCULATOR_ACTION_MODES.OWN_MODE : options.affectedHabitat.isRenegade ? settingsGameConstant.ARRIVAL_CALCULATOR_ACTION_MODES.RENEGADE_MODE : settingsGameConstant.ARRIVAL_CALCULATOR_ACTION_MODES.FOREIGNER_MODE;
    var unitsList, unit, unitPk = this.notify(xy.eNames.menuArrivalTimeFinder.getUnitPK);
    unitPk || (unitsList = servicesGameDataManager.unitsCollection.getUnitsList(), unitsList.sort(servicesSortable.byField("order")), unitPk = unitsList[0].primaryKey, this.notify(xy.eNames.menuArrivalTimeFinder.setUnitPK, unitPk)), unit = servicesGameDataManager.unitsCollection.getUnit({ primaryKey: unitPk });
    var actionKey = this.notify(xy.eNames.menuArrivalTimeFinder.getActionKey);
    actionKey || (actionKey = settingsGameConstant.ARRIVAL_CALCULATOR_POSSIBLE_ACTION[mode][0], this.notify(xy.eNames.menuArrivalTimeFinder.setActionKey, actionKey));
    var ownHabitatsIdsList = servicesGameDataManager.habitatsCollection.getOwnHabitatList(), transitDistanceMultiplier = servicesWorldSettings.settings.transitDistanceMultiplier || 1, habitatsList = [], timeLimitInSeconds = 0, completeArrivalTime = !1, completeTransportTime = !1;
    switch (options.tabMode) {
      case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.ARRIVAL_TIME:
        options.arrivalDate instanceof Date && (timeLimitInSeconds = utilsDateTime.remainTimeInSeconds(options.arrivalDate)), timeLimitInSeconds && (completeArrivalTime = !0);
        break;
      case settingsGameConstant.ARRIVAL_CALCULATOR_TAB_MODE.TRANSPORT_TIME:
        options.transportTime && (options.transportTime.hours && (timeLimitInSeconds += 3600 * options.transportTime.hours), options.transportTime.minutes && (timeLimitInSeconds += 60 * options.transportTime.minutes), options.transportTime.seconds && (timeLimitInSeconds += options.transportTime.seconds)), timeLimitInSeconds && (completeTransportTime = !0)
    }
    ownHabitatsIdsList.forEach(function(habitatId) {
      var distance, transportTimeInSeconds, arrivingTime, habitatArrivalObject = {}, modeledHabitat = servicesGameDataManager.habitatsCollection.getHabitat(habitatId), now = new Date, unitAbilitiesWithModifiers = modeledHabitat.applyModifiers({
        targetObject: "Unit",
        movementSpeed: unit.secondsPerField
      }), unitSpeedWithModifiers = unitAbilitiesWithModifiers.movementSpeed;
      if (modeledHabitat.id !== options.affectedHabitat.id) {
        distance = modeledHabitat.computeDistanceBetweenHabitats(options.affectedHabitat), transportTimeInSeconds = distance * unitSpeedWithModifiers, arrivingTime = new Date(now.setSeconds(now.getSeconds() + transportTimeInSeconds)), habitatArrivalObject.habitat = modeledHabitat, habitatArrivalObject.distance = distance, habitatArrivalObject.transportTimeInSeconds = transportTimeInSeconds, habitatArrivalObject.arrivingTime = arrivingTime, habitatArrivalObject.closenessToOptimal = Math.abs(transportTimeInSeconds - timeLimitInSeconds), modeledHabitat.points / transitDistanceMultiplier < distance && (habitatArrivalObject.isTooFar = !0);
        var unitAmountObject = servicesGameDataManager.unitsCollection.getOwnLocalUnitsAmount({
          habitatId: modeledHabitat.id,
          habitat: modeledHabitat
        });
        (!unitAmountObject[unitPk] || unitAmountObject[unitPk] < 1) && (habitatArrivalObject.noUnit = !0), habitatsList.push(habitatArrivalObject)
      }
    }), habitatsList.sort(servicesSortable.arrivalTimeFinderOptimalTime);
    for (var o, i = 0, len = habitatsList.length; i < len;) {
      if (o = habitatsList[i], !o.isTooFar && !o.noUnit) {
        o.isBestChoise = !0;
        break
      }
      i += 1
    }
    habitatsList.sort(servicesSortable.arrivalTimeFinderDistance);
    var data = {};
    data.habitatsList = habitatsList, data.tabMode = options.tabMode, data.affectedHabitat = options.affectedHabitat, data.settingsMode = mode, data.settingsChosenUnit = unit, data.settingsChosenActionKey = actionKey, data.forceNextRedrawUpdate = options.forceNextRedrawUpdate, data.completeArrivalTime = completeArrivalTime, data.completeTransportTime = completeTransportTime, options.transportTime && (data.currentHours = options.transportTime.hours, data.currentMinutes = options.transportTime.minutes, data.currentSeconds = options.transportTime.seconds), options.arrivalDate && (data.currentArrivalDate = options.arrivalDate), this.notify(xy.eNames.menuArrivalTimeFinder.dataIsReady, data)
  }, MenuArrivalTimeFinderDataSource.prototype.setNewCurrentHabitat = function(habitat) {
    return servicesGameDataManager.habitatsCollection.setCurrentHabitatId(habitat.id), !0
  }, MenuArrivalTimeFinderDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeFinder.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuArrivalTimeFinder.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuArrivalTimeFinderComponent) {
  "use strict";
  function MenuArrivalTimeFinderPresenter(options) {
    MenuArrivalTimeFinderPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuArrivalTimeFinderPresenter, CorePresenterElementMenu), MenuArrivalTimeFinderPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuArrivalTimeFinderComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuArrivalTimeFinderPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridge.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.object, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.habitatMenuElement, xy.dNames.components.menuListTitleBasic, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, xy.dNames.components.menuListButtonDisplayLink, xy.dNames.components.menuListTextBasic, xy.dNames.components.buttonPageListing, xy.dNames.components.widgetSupportBridgeRound, function(componentsEngine, mixinsMenuComponentHandlers, utilsObject, utilsDateTime, settingsGameConstant, servicesGameDataManager, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsHabitatMenuElement, ComponentsMenuListTitleBasic, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic, ComponentsMenuListButtonDisplayLink, ComponentsMenuListTextBasic, ComponentsButtonPageListing, ComponentsWidgetSupportBridgeRound) {
  "use strict";
  return componentsEngine.createClass({
    changed: {}, mixins: [mixinsMenuComponentHandlers], componentWillReceiveProps: function(newProps) {
      newProps.settings.forceNextRedrawUpdate && this.setState(this.getNewState(), null), newProps.settings.supportBridge.published !== this.props.settings.supportBridge.published && servicesGameDataManager.isModelHasActiveLink(newProps.settings.supportBridge) && this.clearActiveModelLink()
    }, getNewState: function() {
      return this.changed = {}, {
        activeModelLinkClicker: 0,
        edited: !1,
        visibleRounds: settingsGameConstant.SUPPORT_BRIDGE.VISIBLE_ROUNDS
      }
    }, getInitialState: function() {
      return this.getNewState()
    }, onPublishButtonClick: function() {
      this.props.presenter.notify(xy.eNames.menuSupportBridge.publish)
    }, onUnPublishButtonClick: function() {
      this.props.presenter.notify(xy.eNames.menuSupportBridge.unPublish)
    }, onShareWithAllianceClick: function() {
      this.props.presenter.notify(xy.eNames.menuSupportBridge.shareClash)
    }, onCalculateTransitsButtonClick: function() {
      this.props.presenter.notify(xy.eNames.menuSupportBridge.calculateTransits)
    }, onSaveChangesButtonClick: function() {
      var data = {};
      data.changed = this.changed, data.supportBridge = this.props.settings.supportBridge, this.props.presenter.notify(xy.eNames.menuSupportBridge.saveChanges, data)
    }, onRoundsStateChange: function(round, newState) {
      this.changed[round] = newState.toString(), this.setState({ edited: !0 }, null)
    }, onShowMoreRoundsClick: function() {
      var rounds = this.state.visibleRounds + settingsGameConstant.SUPPORT_BRIDGE.VISIBLE_ROUNDS, max = this.props.settings.supportBridge.entries.length || 0;
      rounds > max && (rounds = max), this.setState({ visibleRounds: rounds }, null)
    }, render: function() {
      var settings = {
        habitat: {},
        supportBridge: { entries: [], published: !1, nextAllowedCalculationTime: null, key: null },
        idSharePossible: !1,
        isSharedWithAlliance: !1,
        isForeignerMode: !1,
        player: null,
        alliance: null
      };
      Object.assign(settings, this.props.settings);
      var sectionComponentSettings, linkFAQ, titleSettings = { title: this.props.settingsTitle.localizedTitle }, componentsSections = [];
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, settings.isForeignerMode || (titleSettings.rightButton = [], titleSettings.rightButton.push({
        icon: "controls menu-bar-settings",
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuSupportBridgeSettings.name })
      }));
      var themeSettings = servicesTheme.themeSettings, iconsTheme = themeSettings.imagesClassNames, habitatTypeName = themeSettings.habitat.publicHabitatTypeNames[settings.habitat.publicHabitatType];
      if (sectionComponentSettings = { title: servicesInternationalization.localize(habitatTypeName) }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
                settings: sectionComponentSettings,
                key: "affected-habitat-title"
              })), sectionComponentSettings = {
                habitat: settings.habitat,
                initialComponent: this
              }, componentsSections.push(React.createElement(ComponentsHabitatMenuElement, {
                settings: sectionComponentSettings,
                key: "affected-habitat"
              })), settings.isForeignerMode && (sectionComponentSettings = {
                title: settings.player.nick,
                description: settings.player.points,
                iconLeft: "icon-game icon-ButtonPlayer"
              }, settings.player.isEmpty || (sectionComponentSettings.onClick = this.handlerNextClick.bind(this, {
                next: xy.dNames.game.menuPlayerProfileExternal.name,
                options: { playerId: settings.player.id }
              }), sectionComponentSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "menu-element-player-details"
              })), sectionComponentSettings = {
                title: settings.alliance.name,
                description: settings.alliance.points,
                iconLeft: "icon-game icon-ButtonAlliance"
              }, settings.alliance.isEmpty || (sectionComponentSettings.onClick = this.handlerNextClick.bind(this, {
                next: xy.dNames.game.menuAllianceProfile.name,
                options: { allianceId: settings.alliance.id }
              }), sectionComponentSettings.iconRight = "controls menu-next"), componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
                settings: sectionComponentSettings,
                key: "menu-element-ally-details"
              }))), !settings.isForeignerMode) {
        if (settings.idSharePossible) {
          var buttonTitle = "Call Help", alreadySharedText = "You have already sought help for this attack", iconClashButton = "icon-game icon-Defence";
          sectionComponentSettings = {
            iconLeft: iconClashButton,
            description: servicesInternationalization.localize("share with alliance"),
            onClick: this.onShareWithAllianceClick,
            title: servicesInternationalization.localize(buttonTitle),
            disabled: settings.isSharedWithAlliance
          }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
            settings: sectionComponentSettings,
            key: "menu-element-clash-button"
          })), settings.isSharedWithAlliance && (sectionComponentSettings = { text: servicesInternationalization.localize(alreadySharedText) }, componentsSections.push(React.createElement(ComponentsMenuListTextBasic, {
            settings: sectionComponentSettings,
            key: "menu-element-clash-already-shared"
          })))
        }
        sectionComponentSettings = {
          title: servicesInternationalization.localize("Publish"),
          onClick: this.onPublishButtonClick
        }, settings.supportBridge.published && (sectionComponentSettings.iconLeft = iconsTheme.icon.tickOff, sectionComponentSettings.onClick = this.onUnPublishButtonClick), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "publish-btn"
        })), settings.supportBridge.published && (sectionComponentSettings = {
          onClick: this.onGetModelLinkClick.bind(this, settings.supportBridge),
          targetModel: settings.supportBridge,
          defaultTitle: servicesInternationalization.localize("Display Bridge Link")
        }, componentsSections.push(React.createElement(ComponentsMenuListButtonDisplayLink, {
          settings: sectionComponentSettings,
          key: "menu-button-copy-sb-link"
        }))), sectionComponentSettings = {
          title: servicesInternationalization.localize("Calculate Transits"),
          onClick: this.onCalculateTransitsButtonClick
        }, settings.supportBridge.isCalculationCallPossible() || (sectionComponentSettings.disabled = !0,
                sectionComponentSettings.description = utilsDateTime.remainTime(settings.supportBridge.nextAllowedCalculationTime)), linkFAQ = servicesTheme.getFAQLink("supportBridge"), linkFAQ && (sectionComponentSettings.iconRight = "controls menu-info", sectionComponentSettings.iconRightOnClick = this.handlerNextClick.bind(this, {
          next: xy.dNames.game.menuExternalIFrameInjection.name,
          options: { targetURL: linkFAQ }
        })), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
          settings: sectionComponentSettings,
          key: "calculate-transits-btn"
        }))
      }
      sectionComponentSettings = {
        title: servicesInternationalization.localize("Save Alterations"),
        disabled: !0
      }, this.state.edited && (sectionComponentSettings.disabled = !1, sectionComponentSettings.onClick = this.onSaveChangesButtonClick), componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "save-btn"
      })), sectionComponentSettings = { title: servicesInternationalization.localize("Support Bridge") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "rounds-title"
      }));
      var round, index, entries = settings.supportBridge.entries, length = this.state.visibleRounds < entries.length ? this.state.visibleRounds : entries.length;
      for (index = 0; index < length; index += 1)round = entries[index], sectionComponentSettings = {
        round: index + 1,
        date: round.battleDate,
        state: this.changed[index] || round.state,
        initialComponent: this,
        affectedHabitat: settings.habitat,
        isForeignerMode: settings.isForeignerMode,
        onChange: this.onRoundsStateChange.bind(this, index)
      }, componentsSections.push(React.createElement(ComponentsWidgetSupportBridgeRound, {
        settings: sectionComponentSettings,
        key: "sb-round-" + index
      }));
      this.state.visibleRounds < entries.length && (sectionComponentSettings = {
        isDown: !0,
        onClick: this.onShowMoreRoundsClick
      }, componentsSections.push(React.createElement(ComponentsButtonPageListing, {
        settings: sectionComponentSettings,
        key: "button-next"
      })));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridge.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.gameDataManager, xy.dNames.services.worldSettings, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesGameDataManager, servicesWorldSettings) {
  "use strict";
  function MenuSupportBridgeController(options) {
    MenuSupportBridgeController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Support Bridge"), this.forceNextRedrawUpdate = !1
  }

  return utilsOop.extend(MenuSupportBridgeController, CoreControllerElementMenu), MenuSupportBridgeController.prototype[xy.eNames.menuSupportBridge.dataIsReady] = function(data, options) {
    options = options || {};
    var forceRedraw = !1;
    this.forceNextRedrawUpdate && (forceRedraw = !0, this.forceNextRedrawUpdate = !1), data.isTimerable && this.scheduleLocalUpdate(this[xy.eNames.menuSupportBridge.dataIsReady].bind(this, data), options.isForced), this.isActive && (data.forceNextRedrawUpdate = forceRedraw, this.presenter.draw(data))
  }, MenuSupportBridgeController.prototype[xy.eNames.menuSupportBridge.publish] = function() {
    this.dataSource.publishSupportBridge()
  }, MenuSupportBridgeController.prototype[xy.eNames.menuSupportBridge.unPublish] = function() {
    this.dataSource.unPublishSupportBridge()
  }, MenuSupportBridgeController.prototype[xy.eNames.menuSupportBridge.saveChanges] = function(data) {
    this.dataSource.saveChangesInSupportBridge(data)
  }, MenuSupportBridgeController.prototype[xy.eNames.menuSupportBridge.calculateTransits] = function() {
    this.dataSource.calculateSupportBridgeFromTransits()
  }, MenuSupportBridgeController.prototype[xy.eNames.menuSupportBridge.shareClash] = function() {
    this.dataSource.shareSupportBridgeWithAlliance()
  }, MenuSupportBridgeController.prototype.prepareDataForDraw = function() {
    this.stopLocalUpdate();
    var options = {};
    this.isActive && (this.initialOptions.habitatId && (options.habitatId = this.initialOptions.habitatId), this.initialOptions.key && (options.key = this.initialOptions.key), this.dataSource.setInitialSupportBridgeData(options), this.initialOptions.isInitialShare ? this.dataSource.shareSupportBridgeWithAlliance() : this.dataSource.prepareSupportBridgeViewData())
  }, MenuSupportBridgeController
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridge.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.core.modelSupportBridge, xy.dNames.utils.oop, xy.dNames.utils.network, xy.dNames.utils.object, xy.dNames.services.gameDataManager, function(gameInstance, CoreDataSource, CoreModelSupportBridge, utilsOop, utilsNetwork, utilsObject, servicesGameDataManager) {
  "use strict";
  function MenuSupportBridgeDataSource(options) {
    var menuBuildingOverviewDataSource = gameInstance.injector.get(xy.dNames.game.menuBuildingOverview.dataSource);
    this.forLinking = [{
      resourceClass: menuBuildingOverviewDataSource,
      methodName: "missionCancel"
    }], MenuSupportBridgeDataSource.__super__.constructor.call(this, options), this.data = new CoreModelSupportBridge, this.habitatId = null, this.key = null, this.isTimerable = !1
  }

  return utilsOop.extend(MenuSupportBridgeDataSource, CoreDataSource), MenuSupportBridgeDataSource.prototype.setInitialSupportBridgeData = function(options) {
    options = options || {};
    var key = options.key || null;
    this.habitatId = options.habitatId, key && (this.key = key)
  }, MenuSupportBridgeDataSource.prototype.prepareSupportBridgeViewData = function() {
    var params = { habitatID: this.habitatId };
    this.key && (params.key = this.key), this.request(params, "SupportBridgeAction/view", { callBack: this.handlerSupportBridgeData }), this.controller.forceNextRedrawUpdate = !0
  }, MenuSupportBridgeDataSource.prototype.prepareSupportBridgePresenterData = function() {
    var isTimerable = !1;
    this.isTimerable && (this.isTimerable = !1, isTimerable = !0);
    var habitat = servicesGameDataManager.habitatsCollection.getHabitat(this.habitatId), presenterData = {
      habitat: habitat,
      supportBridge: this.data,
      isTimerable: isTimerable
    };
    habitat.isOwnByPlayer || (presenterData.isForeignerMode = !0, habitat.player ? presenterData.player = servicesGameDataManager.playersCollection.getPlayer(habitat.player) : presenterData.player = servicesGameDataManager.playersCollection.getEmptyPlayer(habitat), presenterData.player.alliance ? presenterData.alliance = servicesGameDataManager.alliancesCollection.getAlliance(presenterData.player.alliance) : presenterData.alliance = servicesGameDataManager.alliancesCollection.getEmptyAlliance());
    var alliance = servicesGameDataManager.alliancesCollection.getAlliance();
    alliance && (presenterData.idSharePossible = !0, servicesGameDataManager.alliancesCollection.warClashedSet.habitats[this.habitatId] && (presenterData.isSharedWithAlliance = !0)), this.notify(xy.eNames.menuSupportBridge.dataIsReady, presenterData, { isForced: !0 })
  }, MenuSupportBridgeDataSource.prototype.publishSupportBridge = function() {
    this.request({ habitatID: this.habitatId }, "SupportBridgeAction/publish", { callBack: this.handlerSupportBridgePublishData })
  }, MenuSupportBridgeDataSource.prototype.unPublishSupportBridge = function() {
    this.request({ habitatID: this.habitatId }, "SupportBridgeAction/unpublish", { callBack: this.handlerSupportBridgeUnPublishData })
  }, MenuSupportBridgeDataSource.prototype.shareSupportBridgeWithAlliance = function(options) {
    options = options || {};
    var callback = this.prepareSupportBridgeViewData, habitatId = this.habitatId;
    options.emptyCallBack && (callback = null), options.callBack && (callback = options.callBack), options.habitatId && (habitatId = options.habitatId), this.request({ habitatID: habitatId }, "SupportBridgeAction/publishClash", { callBack: callback })
  }, MenuSupportBridgeDataSource.prototype.handlerSupportBridgeData = function(data) {
    data.Data && (data.Data.Habitat && servicesGameDataManager.updateHabitatsData(data.Data.Habitat, { isPeripheral: !0 }), data.Data.Player && servicesGameDataManager.updatePlayersData(data.Data.Player, { isPeripheral: !0 }), data.Data.Alliance && servicesGameDataManager.updateAlliancesData(data.Data.Alliance, { isPeripheral: !0 })), data.error || (data.habitatId = this.habitatId, this.data.update(data), this.prepareSupportBridgePresenterData())
  }, MenuSupportBridgeDataSource.prototype.handlerSupportBridgeUnPublishData = function(data) {
    data.error || (this.data.update({
      published: !1,
      key: null
    }), this.key = null, this.prepareSupportBridgePresenterData())
  }, MenuSupportBridgeDataSource.prototype.handlerSupportBridgePublishData = function(data) {
    !data.error && data.key && (this.data.update({
      published: !0,
      key: data.key
    }), this.key = data.key, this.prepareSupportBridgePresenterData())
  }, MenuSupportBridgeDataSource.prototype.saveChangesInSupportBridge = function(data) {
    if (!utilsObject.isEmpty(data.changed)) {
      var roundIndex, timeStamp, changed = data.changed, entries = data.supportBridge.entries, changes = {};
      for (roundIndex in changed)changed.hasOwnProperty(roundIndex) && (timeStamp = entries[+roundIndex].battleDate.valueOf(), changes[timeStamp] = changed[roundIndex]);
      var params = { habitatID: this.habitatId, changes: utilsNetwork.dictionaryToQueryString(changes) };
      this.key && (params.key = this.key), this.request(params, "SupportBridgeAction/save", { callBack: this.handlerSupportBridgeData }), this.controller.forceNextRedrawUpdate = !0
    }
  }, MenuSupportBridgeDataSource.prototype.calculateSupportBridgeFromTransits = function() {
    this.request({ habitatID: this.habitatId }, "SupportBridgeAction/calculateFromTransits", { callBack: this.handlerSupportBridgeData }), this.isTimerable = !0, this.controller.forceNextRedrawUpdate = !0
  }, MenuSupportBridgeDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridge.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuSupportBridge.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuSupportBridgeComponent) {
  "use strict";
  function MenuSupportBridgePresenter(options) {
    MenuSupportBridgePresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuSupportBridgePresenter, CorePresenterElementMenu), MenuSupportBridgePresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuSupportBridgeComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuSupportBridgePresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridgeSettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListButtonBasic, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesDameDataManager, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    possibleSelectedAmount: 0,
    mixins: [mixinsMenuComponentHandlers],
    getInitialState: function() {
      var relationId, status, checked = {}, diplomacyList = this.props.settings.diplomacyList, currentSupportBridgeDiplomacyFilter = this.props.settings.currentSupportBridgeDiplomacyFilter, selected = 0;
      diplomacyList.forEach(function(relationId) {
        checked[relationId] = !1
      });
      for (relationId in currentSupportBridgeDiplomacyFilter)currentSupportBridgeDiplomacyFilter.hasOwnProperty(relationId) && (status = currentSupportBridgeDiplomacyFilter[relationId], checked[relationId] = status, status && (selected += 1));
      return { checked: checked, selectedAmount: selected }
    },
    onSupportBoxDiplomaticRelationCheckBoxClick: function(relationId, event) {
      event.preventDefault();
      var checked = this.state.checked, selectedAmount = this.state.selectedAmount, status = checked[relationId] || !1;
      status ? selectedAmount -= 1 : selectedAmount += 1, checked[relationId] = !status, this.setState({
        checked: checked,
        selectedAmount: selectedAmount
      }, null)
    },
    onDoneClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuSupportBridgeSettings.saveSupportBridgeSettings, { settings: this.state.checked })
    },
    onSelectDeselectAllClick: function() {
      var relationId, status = !0, selected = +this.state.selectedAmount, checked = this.state.checked, possibleSelectedAmount = this.possibleSelectedAmount, newSelectedAmount = possibleSelectedAmount;
      possibleSelectedAmount === selected && (status = !1, newSelectedAmount = 0);
      for (relationId in checked)checked.hasOwnProperty(relationId) && (checked[relationId] = status, status && (selected += 1));
      this.setState({ checked: checked, selectedAmount: newSelectedAmount }, null)
    },
    render: function() {
      var settings = {
        diplomacyList: [],
        currentSupportBridgeDiplomacyFilter: {}
      }, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      Object.assign(settings, this.props.settings), titleSettings.leftButtonTitle = servicesInternationalization.localize("cancel"), titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick, titleSettings.rightButton = [], titleSettings.rightButton.push({
        onClick: this.onDoneClick,
        title: servicesInternationalization.localize("Finish")
      }), this.possibleSelectedAmount = settings.diplomacyList.length;
      var componentsSectionsSettings, componentsSections = [], selectedAll = this.possibleSelectedAmount > 0 && this.possibleSelectedAmount === +this.state.selectedAmount, selectingTitle = selectedAll ? "Remove All Markers" : "Select All";
      componentsSectionsSettings = {
        title: servicesInternationalization.localize(selectingTitle),
        onClick: this.onSelectDeselectAllClick
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: componentsSectionsSettings,
        key: "select-de-select-all"
      })), settings.diplomacyList.forEach(function(relationId) {
        var localSettings = {
          iconLeft: "icon-alliance-relationship relationship-" + relationId,
          title: servicesTheme.themeSettings.allianceDiplomacyName[relationId],
          isSelectable: !0,
          isSelected: this.state.checked[relationId] || !1,
          onSelect: this.onSupportBoxDiplomaticRelationCheckBoxClick.bind(this, relationId)
        };
        componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: localSettings,
          key: "menu-element-ally-relation-" + relationId
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridgeSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.settings.gameConstant, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, settingsGameConstant) {
  "use strict";
  function MenuSupportBridgeSettingsController(options) {
    MenuSupportBridgeSettingsController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw.bind(this, !0)
    }], this.localizedName = servicesInternationalization.localize("Preferences")
  }

  return utilsOop.extend(MenuSupportBridgeSettingsController, CoreControllerElementMenu), MenuSupportBridgeSettingsController.prototype[xy.eNames.menuSupportBridgeSettings.saveSupportBridgeSettings] = function(data) {
    this.dataSource.saveSupportBridgeSettings(data)
  }, MenuSupportBridgeSettingsController.prototype[xy.eNames.menuSupportBridgeSettings.onSavedSupportBridgeSettings] = function() {
    this[xy.eNames.menu.openPrevView]()
  }, MenuSupportBridgeSettingsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.presenter.draw(this.dataSource.getSupportBridgeSettingsList())
  }, MenuSupportBridgeSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridgeSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.services.gameDataManager, xy.dNames.services.theme, xy.dNames.settings.gameConstant, function(CoreDataSource, utilsOop, servicesGameDataManager, servicesTheme, settingsGameConstant) {
  "use strict";
  function MenuSupportBridgeSettingsDataSource(options) {
    MenuSupportBridgeSettingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuSupportBridgeSettingsDataSource, CoreDataSource), MenuSupportBridgeSettingsDataSource.prototype.getSupportBridgeSettingsList = function() {
    var ally = servicesGameDataManager.alliancesCollection.getAlliance(), diplomacyList = [settingsGameConstant.ALLIANCE_RELATIONSHIPS.MEMBER, settingsGameConstant.ALLIANCE_RELATIONSHIPS.VASSAL, settingsGameConstant.ALLIANCE_RELATIONSHIPS.ALLY, settingsGameConstant.ALLIANCE_RELATIONSHIPS.NAP, settingsGameConstant.ALLIANCE_RELATIONSHIPS.NEUTRAL, settingsGameConstant.ALLIANCE_RELATIONSHIPS.ENEMY], player = servicesGameDataManager.playersCollection.getPlayer(), activeSupportBridgeDiplomacyFilterArray = player.supportBridgeDiplomacyFilterArray, currentSupportBridgeDiplomacyFilter = {};
    return ally || (diplomacyList = [settingsGameConstant.ALLIANCE_RELATIONSHIPS.NEUTRAL]), activeSupportBridgeDiplomacyFilterArray && activeSupportBridgeDiplomacyFilterArray.forEach(function(relationId) {
      currentSupportBridgeDiplomacyFilter[relationId] = !0
    }), { diplomacyList: diplomacyList, currentSupportBridgeDiplomacyFilter: currentSupportBridgeDiplomacyFilter }
  }, MenuSupportBridgeSettingsDataSource.prototype.receiveSupportBridgeSettings = function(data) {
    data.error || (this.handleSessionUpdateResponse(data), this.notify(xy.eNames.menuSupportBridgeSettings.onSavedSupportBridgeSettings))
  }, MenuSupportBridgeSettingsDataSource.prototype.saveSupportBridgeSettings = function(data) {
    var relationId, newSetup = [], settings = data.settings;
    for (relationId in settings)settings.hasOwnProperty(relationId) && settings[relationId] && newSetup.push(relationId);
    this.request({ diplomacyFilterArray: newSetup }, "SupportBridgeAction/setDiplomacyFilter", { callBack: this.receiveSupportBridgeSettings })
  }, MenuSupportBridgeSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuSupportBridgeSettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuSupportBridgeSettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuSupportBridgeSettingsComponent) {
  "use strict";
  function MenuSupportBridgeSettingsPresenter(options) {
    MenuSupportBridgeSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuSupportBridgeSettingsPresenter, CorePresenterElementMenu), MenuSupportBridgeSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuSupportBridgeSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuSupportBridgeSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeSettings.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.menuListTitleBasic, function(componentsEngine, mixinsMenuComponentHandlers, settingsGameConstant, servicesInternationalization, servicesTheme, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsMenuListTitleBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers],
    onActionChoose: function(actionKey, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuArrivalTimeFinder.setActionKey, actionKey), this.handlerTitleLeftButtonClick()
    },
    onUnitChoose: function(unitPk, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuArrivalTimeFinder.setUnitPK, unitPk), this.handlerTitleLeftButtonClick()
    },
    render: function() {
      var settings = { selectedUnitPK: null, unitsList: [], selectedActionKey: null, actionsList: [] };
      Object.assign(settings, this.props.settings);
      var themeIcons = servicesTheme.themeSettings.imagesClassNames, titleSettings = { title: this.props.settingsTitle.localizedTitle };
      this.props.settingsTitle.isRoot ? titleSettings.leftButtonIcon = "controls menu-close" : titleSettings.leftButtonTitle = this.props.settingsTitle.localizedPrevViewTitle, titleSettings.leftButton = !0, titleSettings.leftButtonOnClick = this.handlerTitleLeftButtonClick;
      var sectionComponentSettings, componentsSections = [];
      sectionComponentSettings = { title: servicesInternationalization.localize("Action selection") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "action-selection-title"
      })), settings.actionsList.forEach(function(actionKey) {
        var action = settingsGameConstant.ARRIVAL_CALCULATOR_ACTIONS[actionKey], elementSettings = {
          iconLeft: themeIcons.icon[action],
          title: servicesInternationalization.localize(action),
          onClick: this.onActionChoose.bind(this, actionKey)
        };
        null !== settings.selectedActionKey && settings.selectedActionKey === actionKey ? (elementSettings.iconRight = themeIcons.controls.checked, elementSettings.classes += " active") : elementSettings.iconRight = themeIcons.controls.next, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: elementSettings,
          key: "action-in-list-" + actionKey
        }))
      }, this), sectionComponentSettings = { title: servicesInternationalization.localize("Unit Selection") }, componentsSections.push(React.createElement(ComponentsMenuListTitleBasic, {
        settings: sectionComponentSettings,
        key: "unit-selection-title"
      })), settings.unitsList.forEach(function(unit) {
        var elementSettings = {
          classes: "element-with-unit",
          title: unit.title,
          iconLeft: "icon-unit icon-unit-" + unit.primaryKey,
          onClick: this.onUnitChoose.bind(this, unit.primaryKey)
        };
        null !== settings.selectedUnitPK && settings.selectedUnitPK === unit.primaryKey ? (elementSettings.iconRight = themeIcons.controls.checked, elementSettings.classes += " active") : elementSettings.iconRight = themeIcons.controls.next, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
          settings: elementSettings,
          key: "unit-in-list-" + unit.identifier
        }))
      }, this);
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, settingsGameConstant, servicesInternationalization) {
  "use strict";
  function MenuArrivalTimeSettingsController(options) {
    MenuArrivalTimeSettingsController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Preferences")
  }

  return utilsOop.extend(MenuArrivalTimeSettingsController, CoreControllerElementMenu), MenuArrivalTimeSettingsController.prototype[xy.eNames.menuArrivalTimeSettings.dataIsReady] = function(data) {
    this.presenter.draw(data)
  }, MenuArrivalTimeSettingsController.prototype.prepareDataForDraw = function() {
    this.isActive && this.dataSource.prepareArrivalTimeSettingsData({
      settingsMode: this.initialOptions.settingsMode,
      settingsChosenUnit: this.initialOptions.settingsChosenUnit,
      settingsChosenActionKey: this.initialOptions.settingsChosenActionKey
    })
  }, MenuArrivalTimeSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.gameDataManager, xy.dNames.services.sortable, function(CoreDataSource, utilsOop, settingsGameConstant, servicesGameDataManager, servicesSortable) {
  "use strict";
  function MenuArrivalTimeSettingsDataSource(options) {
    MenuArrivalTimeSettingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuArrivalTimeSettingsDataSource, CoreDataSource), MenuArrivalTimeSettingsDataSource.prototype.prepareArrivalTimeSettingsData = function(options) {
    var data = {}, unitsList = servicesGameDataManager.unitsCollection.getUnitsList();
    unitsList.sort(servicesSortable.byField("order")), data.selectedUnitPK = options.settingsChosenUnit.primaryKey, data.unitsList = unitsList, data.selectedActionKey = options.settingsChosenActionKey, data.actionsList = settingsGameConstant.ARRIVAL_CALCULATOR_POSSIBLE_ACTION[options.settingsMode], this.notify(xy.eNames.menuArrivalTimeSettings.dataIsReady, data)
  }, MenuArrivalTimeSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuArrivalTimeSettings.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuArrivalTimeSettings.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuArrivalTimeSettingsComponent) {
  "use strict";
  function MenuArrivalTimeSettingsPresenter(options) {
    MenuArrivalTimeSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuArrivalTimeSettingsPresenter, CorePresenterElementMenu), MenuArrivalTimeSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuArrivalTimeSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuArrivalTimeSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettings.component, [xy.dNames.gameInstance, xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListButtonBasic, function(gameInstance, componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesDameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListButtonBasic) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return { selectedPermissionIdsSet: {} }
    }, onCheckboxClick: function(permission, event) {
      event.preventDefault();
      var selectedPermissionIdsSet = this.state.selectedPermissionIdsSet, status = selectedPermissionIdsSet.hasOwnProperty(permission.id) ? selectedPermissionIdsSet[permission.id] : permission.grant;
      selectedPermissionIdsSet[permission.id] = !status, this.setState({ selectedPermissionIdsSet: selectedPermissionIdsSet }, null)
    }, onDoneClick: function(event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.menuAllianceRightsSettings.saveRightsSettings, {
        initialSettings: this.props.settings.permissionSettingList,
        changesInSettings: this.state.selectedPermissionIdsSet
      })
    }, render: function() {
      var sectionComponentSettings, titleSettings = {
        title: this.props.settingsTitle.localizedTitle,
        leftButton: !0,
        leftButtonTitle: this.props.settingsTitle.localizedPrevViewTitle,
        leftButtonOnClick: this.handlerTitleLeftButtonClick
      }, componentsSections = [];
      sectionComponentSettings = {
        title: servicesInternationalization.localize("TableCellTitleMusic"),
        disabled: gameInstance.isMobileMode(),
        onClick: this.handlerNextClick.bind(this, { next: xy.dNames.game.menuGameSettingsMusic.name })
      }, componentsSections.push(React.createElement(ComponentsMenuListButtonBasic, {
        settings: sectionComponentSettings,
        key: "button-music"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettings.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, function(CoreControllerElementMenu, utilsOop, servicesInternationalization) {
  "use strict";
  function MenuGameSettingsController(options) {
    MenuGameSettingsController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("Preferences"), this.currentPlayer = null
  }

  return utilsOop.extend(MenuGameSettingsController, CoreControllerElementMenu), MenuGameSettingsController.prototype.prepareDataForDraw = function() {
    this.presenter.draw()
  }, MenuGameSettingsController
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettings.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, function(CoreDataSource, utilsOop) {
  "use strict";
  function MenuGameSettingsDataSource(options) {
    MenuGameSettingsDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuGameSettingsDataSource, CoreDataSource), MenuGameSettingsDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettings.presenter, [xy.dNames.componentsEngine, xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.game.menuGameSettings.component, function(componentsEngine, CorePresenterElementMenu, utilsOop, MenuGameSettingsComponent) {
  "use strict";
  function MenuGameSettingsPresenter(options) {
    MenuGameSettingsPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuGameSettingsPresenter, CorePresenterElementMenu), MenuGameSettingsPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuGameSettingsComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuGameSettingsPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettingsMusic.component, [xy.dNames.componentsEngine, xy.dNames.mixins.menuComponentHandlers, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.components.menuSection, xy.dNames.components.menuTitleBarMain, xy.dNames.components.menuListElementBasic, xy.dNames.components.widgetRangeSlider, function(componentsEngine, mixinsMenuComponentHandlers, utilsDateTime, settingsGameConstant, servicesTheme, servicesDameDataManager, servicesInternationalization, ComponentsMenuSection, ComponentsMenuTitleBarMain, ComponentsMenuListElementBasic, ComponentsWidgetRangeSlider) {
  "use strict";
  return componentsEngine.createClass({
    mixins: [mixinsMenuComponentHandlers], getInitialState: function() {
      return this.constructState(this.props.settings)
    }, componentWillReceiveProps: function(props) {
      this.setState(this.constructState(props.settings), null)
    }, constructState: function(settings) {
      return {
        musicStateIsOn: settings.musicStateIsOn,
        musicVolume: settings.musicVolume,
        sfxStateIsOn: settings.sfxStateIsOn,
        sfxVolume: settings.sfxVolume
      }
    }, onSetValueByRangeSlider: function(mediaType, value) {
      var o = {}, toSave = {};
      mediaType && this.state[mediaType + "StateIsOn"] && (o[mediaType + "Volume"] = value, Object.assign(toSave, this.state), Object.assign(toSave, o), this.props.presenter.notify(xy.eNames.eventGameSettingsMusic.changeMusicSettingsObject, toSave), this.setState(o, null))
    }, onCheckboxClick: function(mediaType, event) {
      event.preventDefault();
      var o = {}, toSave = {};
      mediaType && (o[mediaType + "StateIsOn"] = !this.state[mediaType + "StateIsOn"], Object.assign(toSave, this.state), Object.assign(toSave, o), this.props.presenter.notify(xy.eNames.eventGameSettingsMusic.changeMusicSettingsObject, toSave), this.setState(o, null))
    }, render: function() {
      var sectionComponentSettings, titleSettings = {
        title: this.props.settingsTitle.localizedTitle,
        leftButton: !0,
        leftButtonTitle: this.props.settingsTitle.localizedPrevViewTitle,
        leftButtonOnClick: this.handlerTitleLeftButtonClick
      }, componentsSections = [];
      sectionComponentSettings = {
        title: servicesInternationalization.localize("TableCellTitleMusic"),
        classes: "first",
        hideBorders: !0,
        isSelectable: !0,
        isSelected: this.state.musicStateIsOn,
        onSelect: this.onCheckboxClick.bind(this, "music")
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "check-box-music"
      })), sectionComponentSettings = {
        currentValue: this.state.musicStateIsOn ? this.state.musicVolume : 0,
        minValue: 0,
        maxValue: 100,
        showButtons: !1,
        onChange: this.onSetValueByRangeSlider.bind(this, "music")
      }, componentsSections.push(React.createElement(ComponentsWidgetRangeSlider, {
        settings: sectionComponentSettings,
        key: "music-volume-range-slider"
      })), sectionComponentSettings = {
        title: servicesInternationalization.localize("TableCellTitleSoundEffects"),
        classes: "first",
        hideBorders: !0,
        isSelectable: !0,
        isSelected: this.state.sfxStateIsOn,
        onSelect: this.onCheckboxClick.bind(this, "sfx")
      }, componentsSections.push(React.createElement(ComponentsMenuListElementBasic, {
        settings: sectionComponentSettings,
        key: "check-box-sfx"
      })), sectionComponentSettings = {
        currentValue: this.state.sfxStateIsOn ? this.state.sfxVolume : 0,
        minValue: 0,
        maxValue: 100,
        showButtons: !1,
        onChange: this.onSetValueByRangeSlider.bind(this, "sfx")
      }, componentsSections.push(React.createElement(ComponentsWidgetRangeSlider, {
        settings: sectionComponentSettings,
        key: "sfx-volume-range-slider"
      }));
      var componentMenuSetting = {
        titleBar: React.createElement(ComponentsMenuTitleBarMain, { settings: titleSettings }),
        tapBar: null,
        searchBar: null,
        bottomBar: null,
        content: componentsSections
      };
      return React.createElement(ComponentsMenuSection, { settings: componentMenuSetting })
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettingsMusic.controller, [xy.dNames.core.controllerElementMenu, xy.dNames.utils.oop, xy.dNames.services.internationalization, xy.dNames.services.storage, xy.dNames.services.eventManager, function(CoreControllerElementMenu, utilsOop, servicesInternationalization, servicesStorage, servicesEventManager) {
  "use strict";
  function MenuGameSettingsMusicController(options) {
    MenuGameSettingsMusicController.__super__.constructor.call(this, options), this.localizedName = servicesInternationalization.localize("TableCellTitleMusic"), this.currentPlayer = null
  }

  return utilsOop.extend(MenuGameSettingsMusicController, CoreControllerElementMenu), MenuGameSettingsMusicController.prototype.prepareDataForDraw = function() {
    this.presenter.draw(servicesStorage.getMusicSettingsObject())
  }, MenuGameSettingsMusicController.prototype[xy.eNames.eventGameSettingsMusic.changeMusicSettingsObject] = function(musicSettingsObject) {
    servicesStorage.storeMusicSettingsObject(musicSettingsObject) && servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.changesInMusicSettingsObject)
  }, MenuGameSettingsMusicController
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettingsMusic.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, function(CoreDataSource, utilsOop) {
  "use strict";
  function MenuGameSettingsMusicDataSource(options) {
    MenuGameSettingsMusicDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuGameSettingsMusicDataSource, CoreDataSource), MenuGameSettingsMusicDataSource
}]),xy.dStaticInjector.set(xy.dNames.game.menuGameSettingsMusic.presenter, [xy.dNames.core.presenterElementMenu, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.menuGameSettingsMusic.component, function(CorePresenterElementMenu, utilsOop, componentsEngine, MenuGameSettingsMusicComponent) {
  "use strict";
  function MenuGameSettingsMusicPresenter(options) {
    MenuGameSettingsMusicPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(MenuGameSettingsMusicPresenter, CorePresenterElementMenu), MenuGameSettingsMusicPresenter.prototype.draw = function(data) {
    var settingsTitle = {
      localizedTitle: this.controller.localizedName,
      localizedPrevViewTitle: this.controller.localizedNameOfPreviousView,
      isRoot: this.controller.isRoot
    };
    componentsEngine.render(React.createElement(MenuGameSettingsMusicComponent, {
      presenter: this,
      settingsTitle: settingsTitle,
      settings: data
    }), document.getElementById(this.domElement))
  }, MenuGameSettingsMusicPresenter
}]),xy.dStaticInjector.set(xy.dNames.game.popUpTutorial.component, [xy.dNames.componentsEngine, xy.dNames.gameInstance, xy.dNames.utils.string, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.eventManager, xy.dNames.mixins.dialogHandlers, xy.dNames.components.buttonMain, xy.dNames.components.icon, xy.dNames.components.resourceIconAmount, function(componentEngine, gameInstance, utilsString, servicesInternationalization, servicesTheme, servicesEventManager, mixinDialogHandlers, ComponentsControlButtonMain, ComponentsIcon, ComponentsResourceIconAmount) {
  "use strict";
  return componentEngine.createClass({
    mixins: [mixinDialogHandlers], onDeclineTutorialDialog: function() {
      this.props.presenter.notify(xy.eNames.eventPopUpTutorial.declineTutorialStep)
    }, onAcceptTutorialDialog: function() {
      servicesEventManager.handleClientEvent(xy.eNames.eventListeners.identifier.tutorialButtonOkClick), this.props.presenter.notify(xy.eNames.eventPopUpTutorial.acceptTutorialStep)
    }, render: function() {
      var settings = { title: "", stepText: "", rewards: null, highlightArea: !1, showPointer: !1, popUpPosition: "" };
      Object.assign(settings, this.props.settings);
      var closeSection, closeIconSettings, themeIcons = servicesTheme.themeSettings.imagesClassNames, mentorIcon = themeIcons.tutorial.mentor, buttonSettings = {
        title: servicesInternationalization.localize("ok"),
        onClick: this.onAcceptTutorialDialog,
        type: "submit"
      }, mainSection = null, rewardListSection = [];
      settings.rewards && 0 !== settings.rewards.length ? (settings.rewards.forEach(function(reward, index) {
        reward.showFill = !1, reward.classes = " dark", rewardListSection.push(React.createElement(ComponentsResourceIconAmount, {
          settings: reward,
          key: "reward-" + index
        }))
      }), mainSection = React.createElement("div", { className: "reward-list" }, rewardListSection)) : (closeIconSettings = { icon: themeIcons.icon.closeDialog }, closeSection = React.createElement("div", {
        className: "dialog--close-button",
        onClick: this.onDeclineTutorialDialog
      }, React.createElement(ComponentsIcon, { settings: closeIconSettings })), mainSection = React.createElement("div", { className: "text" }, settings.stepText));
      var buttonSection = null, buttonSectionExtraClass = " with-no-button-section";
      settings.highlightArea && settings.showPointer || (buttonSectionExtraClass = "", buttonSection = React.createElement("div", { className: "dialog--button-section" }, React.createElement(ComponentsControlButtonMain, { settings: buttonSettings })));
      var popUpPosition = settings.popUpPosition ? settings.popUpPosition : "";
      return React.createElement("div", { className: "dialog dialog--tutorial " + popUpPosition + this.state.alertStatus }, React.createElement("div", { className: mentorIcon }), closeSection, React.createElement("div", { className: "dialog--title-container" }, settings.title), React.createElement("div", { className: "dialog--container" + buttonSectionExtraClass }, React.createElement("div", { className: "dialog--text-section" }, mainSection), buttonSection))
    }
  })
}]),xy.dStaticInjector.set(xy.dNames.game.popUpTutorial.componentCover, [xy.dNames.core.graphicalEngineNode, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.theme, function(CoreGraphicEngineNode, utilsOop, servicesLog, servicesTheme) {
  "use strict";
  function PopUpTutorialCover(presenter) {
    PopUpTutorialCover.__super__.constructor.call(this, presenter), this.addImageFrames({
      image: xy.res.tutorialImages,
      frameSetName: "tutorial",
      framesData: xy.res.tutorialPlist
    }), this.objectToHighlight = null, this.__clickHandler = null, this.canvas = null
  }

  return utilsOop.extend(PopUpTutorialCover, CoreGraphicEngineNode), PopUpTutorialCover.prototype.updateTutorialCover = function(data) {
    return this._drawCover(data)
  }, PopUpTutorialCover.prototype._getCanvas = function() {
    var container, canvas = document.getElementById(xy.DomElements.gameTutorialOverLayer);
    return canvas || (canvas = document.createElement("canvas"), canvas.setAttribute("id", xy.DomElements.gameTutorialOverLayer), container = document.getElementById(xy.DomElements.gameTutorialOverLayerContainer), container.appendChild(canvas)), canvas.setAttribute("class", "in"), this.canvas = canvas, canvas
  }, PopUpTutorialCover.prototype.drawEmpty = function() {
    var canvas = this._getCanvas();
    canvas.removeEventListener("mouseup", this.__clickHandler), canvas.removeEventListener("touchend", this.__clickHandler);
    var ctx = canvas.getContext("2d"), width = window.innerWidth, height = window.innerHeight;
    ctx.clearRect(0, 0, width, height), ctx.fillStyle = "rgba(0,0,0,0.7)", ctx.fillRect(0, 0, width, height), this.__clickHandler = null
  }, PopUpTutorialCover.prototype._drawCover = function(data) {
    if (data.highlightArea && data.objectToHighlight) {
      var canvas, ctx, width = window.innerWidth, height = window.innerHeight;
      if (canvas = this._getCanvas(), this.canvas = canvas, this.__clickHandler && (canvas.removeEventListener("mouseup", this.__clickHandler), canvas.removeEventListener("touchend", this.__clickHandler)), !canvas)return servicesLog("warn", "No canvas was supplied for tutorial cover"), !1;
      ctx = canvas.getContext("2d"), ctx.clearRect(0, 0, width, height);
      var objectToHighlight = data.objectToHighlight, scaleX = objectToHighlight.scaleX || 1, scaleY = objectToHighlight.scaleY || 1, x = (objectToHighlight.x || width / 2) / scaleX, y = (objectToHighlight.y || height / 2) / scaleY, r = Math.max(objectToHighlight.r || 0, 50), r1 = r - r / 2, r2 = r;
      this.objectToHighlight = objectToHighlight, canvas.width = width, canvas.height = height, ctx.clearRect(0, 0, width, height), ctx.beginPath();
      var rad = ctx.createRadialGradient(x, y, r1, x, y, r2);
      if (rad.addColorStop(0, "rgba(0, 0, 0, 0)"), rad.addColorStop(1, "rgba(0, 0, 0, 0.7)"), ctx.fillStyle = rad, ctx.scale(scaleX, scaleY), ctx.fillRect(0, 0, width / scaleX, height / scaleY), this.__clickHandler = null, data.showPointer) {
        this.__clickHandler = function(event) {
          try {
            var mouseX = event.clientX, mouseY = event.clientY, x = this.objectToHighlight.x, width = this.objectToHighlight.r * this.objectToHighlight.scaleX, x1 = x - width / 2, x2 = x + width / 2, y = this.objectToHighlight.y, height = this.objectToHighlight.r * this.objectToHighlight.scaleY, y1 = y - height / 2, y2 = y + height / 2, clickOnHighLight = !1;
            if (mouseX > x1 && mouseX < x2 && mouseY > y1 && mouseY < y2 && (clickOnHighLight = !0), clickOnHighLight) {
              canvas.setAttribute("class", "");
              var e, hiddenElement = document.elementFromPoint(mouseX, mouseY);
              hiddenElement.id === xy.DomElements.gameCanvas ? (e = new MouseEvent("mouseup", {
                view: window,
                bubbles: !0,
                cancelable: !1,
                clientX: mouseX,
                clientY: mouseY,
                layerX: mouseX,
                layerY: mouseY,
                offsetX: mouseX,
                offsetY: mouseY,
                pageX: mouseX,
                pageY: mouseY,
                x: mouseX,
                y: mouseY
              }), e.isTutorialFake = !0) : (e = document.createEvent("HTMLEvents"), e.initEvent("click", !0, !0)), hiddenElement.dispatchEvent(e) && servicesLog("warn", "Click on highlighted was attepted to cancel"), canvas.setAttribute("class", "in")
            }
            event.preventDefault(), event.stopPropagation()
          } catch (eX) {
            servicesLog("warn", "Can not decide clicking area"), servicesLog("debug", eX), event.preventDefault(), event.stopPropagation()
          }
        }.bind(this), canvas.addEventListener("mouseup", this.__clickHandler, !1), canvas.addEventListener("touchend", this.__clickHandler, !1);
        var xPointer, yPointer, pointerSize = servicesTheme.themeSettings.featureTutorial.pointerSize;
        switch (data.pointerDirection) {
          case"left":
            xPointer = objectToHighlight.x + r2, yPointer = objectToHighlight.y - pointerSize / 2;
            break;
          case"right":
            xPointer = objectToHighlight.x - (r2 + pointerSize), yPointer = objectToHighlight.y - pointerSize / 2;
            break;
          case"bottom":
            xPointer = objectToHighlight.x - pointerSize / 2, yPointer = objectToHighlight.y - (r2 + pointerSize);
            break;
          case"top":
            xPointer = objectToHighlight.x - pointerSize / 2, yPointer = objectToHighlight.y + r2;
            break;
          default:
            xPointer = 0, yPointer = 0
        }
        return ctx.drawImage(this.getImageFromFrame({
          imageName: "tutorial",
          frameName: data.pointerDirection
        }), 0, 0, pointerSize, pointerSize, xPointer / scaleX, yPointer / scaleY, pointerSize / scaleX, pointerSize / scaleY)
      }
    } else this.drawEmpty()
  }, PopUpTutorialCover
}]),xy.dStaticInjector.set(xy.dNames.game.popUpTutorial.controller, [xy.dNames.core.controllerElement, xy.dNames.utils.oop, xy.dNames.settings.gameConstant, xy.dNames.services.log, xy.dNames.services.internationalization, xy.dNames.services.eventManager, xy.dNames.services.theme, xy.dNames.services.gameDataManager, function(CoreControllerElement, utilsOop, settingsGameConstant, servicesLog, servicesInternationalization, servicesEventManager, servicesTheme, servicesGameDataManager) {
  "use strict";
  function PopUpTutorialController(options) {
    PopUpTutorialController.__super__.constructor.call(this, options), this.isActive = !1, this.currentEventListenerIdentifier = "", this.currentEventListenerCounter = 0, this.isReadyToHide = !1
  }

  return utilsOop.extend(PopUpTutorialController, CoreControllerElement), PopUpTutorialController.prototype.start = function() {
    this.show()
  }, PopUpTutorialController.prototype.hide = function() {
    this.isReadyToHide = !0, setTimeout(function() {
      this.isReadyToHide && this.forcedHide()
    }.bind(this), settingsGameConstant.NEXT_DIALOG_SCHEDULE_INTERVAL)
  }, PopUpTutorialController.prototype.forcedHide = function() {
    this.isReadyToHide = !1, this.isActive = !1, this.presenter.clear()
  }, PopUpTutorialController.prototype.show = function(options) {
    options = options || {};
    var eventModel = options.event || this.initialData.event;
    eventModel && this.dataSource.setTutorialEvent(eventModel), options.isResize ? this.isActive && this.dataSource.updateHighlightedAreaCoordinates(options) : this.dataSource.prepareDataForTutorialStep()
  }, PopUpTutorialController.prototype[xy.eNames.eventPopUpTutorial.onCanceled] = function() {
    this.hide()
  }, PopUpTutorialController.prototype[xy.eNames.eventPopUpTutorial.onDataError] = function() {
    this.hide()
  }, PopUpTutorialController.prototype[xy.eNames.eventPopUpTutorial.dataIsReady] = function(data, options) {
    this.cacheCurrentData = data, this.cacheCurrentOptions = options, this.isReadyToHide = !1, this.isActive = !0, options = options || {}, void 0 !== options.successEventListener && this.registerCurrentEventListener(options.successEventListener), data ? (options.isResize ? this.presenter.update(data) : this.presenter.draw(data), data.activeSceneMode && (settingsGameConstant.SCENE_MODE[data.activeSceneMode] ? this.notify(xy.eNames.sceneGame.onNewSceneChoosing, {
      newSceneMode: settingsGameConstant.SCENE_MODE[data.activeSceneMode],
      softUpdate: !0
    }) : (this.hide(), servicesLog("warn", "Data contains unknown activeSceneMode for tutorial step"), servicesLog("debug", data)))) : (this.hide(), servicesLog("warn", "There are no data to show tutorial pop up"), servicesLog("debug", this))
  }, PopUpTutorialController.prototype[xy.eNames.eventPopUpTutorial.declineTutorialStep] = function() {
    this.onCancelTutorialHandler()
  }, PopUpTutorialController.prototype[xy.eNames.eventPopUpTutorial.acceptTutorialStep] = function() {
    var stepIdentifier = this.dataSource.getCurrentSubordinateStepIdentifier(), tutorialThemeSettings = servicesTheme.themeSettings.featureTutorial, stepTutorialThemeSettings = tutorialThemeSettings[stepIdentifier];
    switch (stepIdentifier) {
      case tutorialThemeSettings.receivedRewardOnCancellation:
      case tutorialThemeSettings.receivedRewardOnSuccess:
        this.hide();
        break;
      default:
        stepTutorialThemeSettings && stepTutorialThemeSettings.hideOnAccept && this.hide()
    }
  }, PopUpTutorialController.prototype.centerMapOnClosestFreeHabitat = function() {
    var habitat = servicesGameDataManager.habitatsCollection.getClosestFreeHabitat();
    return this.notify(xy.eNames.sceneGame.centerMapByCoordinates, { mapX: habitat.mapX, mapY: habitat.mapY }), habitat
  }, PopUpTutorialController.prototype.onCancelTutorialHandler = function() {
    this.forcedHide(), this.showDialogDialog({
      title: servicesInternationalization.localize("Cancel Tutorial"),
      text: servicesInternationalization.localize("Do you really want to finish the tutorial? It can't be accessed at any later time."),
      callbackSuccess: this.dataSource.cancelTutorialRequest.bind(this.dataSource),
      callbackCancel: this[xy.eNames.eventPopUpTutorial.dataIsReady].bind(this, this.cacheCurrentData, this.cacheCurrentOptions)
    })
  }, PopUpTutorialController.prototype.deRegisterCurrentEventListener = function() {
    var result = !1;
    return this.currentEventListenerIdentifier && (result = servicesEventManager.deRegisterEventListener({
      identifier: this.currentEventListenerIdentifier.slice(0),
      listenerUniqueId: this.instanceId
    }), this.currentEventListenerIdentifier = null), result
  }, PopUpTutorialController.prototype.registerCurrentEventListener = function(identifier) {
    identifier && (servicesEventManager.registerEventListener({
      identifier: identifier,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.successEventHandler
    }), this.currentEventListenerIdentifier = identifier)
  }, PopUpTutorialController.prototype.successEventHandler = function(data) {
    var successEventData, stepIdentifier = this.dataSource.getCurrentSubordinateStepIdentifier(), stepTutorialThemeSettings = servicesTheme.themeSettings.featureTutorial[stepIdentifier];
    if (stepTutorialThemeSettings && (successEventData = stepTutorialThemeSettings.successEventData, data && data.value && successEventData && (!successEventData.filter || successEventData.filter === data.filter)))switch (successEventData.comparator) {
      case"<=":
        if (successEventData.value > data.value)return !1
    }
    this.presenter.activateEmptyCover(), this.presenter.clearPopUpTutorial(), this.deRegisterCurrentEventListener() && this.dataSource.finishTutorialSubordinateStep(data)
  }, PopUpTutorialController
}]);
xy.dStaticInjector.set(xy.dNames.game.popUpTutorial.dataSource, [xy.dNames.gameInstance, xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.object, xy.dNames.services.log, xy.dNames.services.gameDataManager, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.storage, function(gameInstance, CoreDataSource, utilsOop, utilsObject, servicesLog, servicesGameDataManager, servicesInternationalization, servicesTheme, servicesStorage) {
  "use strict";
  function PopUpTutorialDataSource(options) {
    PopUpTutorialDataSource.__super__.constructor.call(this, options), this.cachedTutorialEvent = null, this.cachedSubordinateStepIdentifier = "", this.cachedCurrentSubordinateStepData = null, this.cachedResponceData = null
  }

  return utilsOop.extend(PopUpTutorialDataSource, CoreDataSource), PopUpTutorialDataSource.prototype.prepareDataForTutorialStep = function() {
    var stepTutorialThemeSettings, data, successEventListener, stepIdentifier = this.getCurrentSubordinateStepIdentifier(), tutorialThemeSettings = servicesTheme.themeSettings.featureTutorial;
    switch (stepIdentifier) {
      case tutorialThemeSettings.canceled:
        return void this.notify(xy.eNames.eventPopUpTutorial.onCanceled);
      case tutorialThemeSettings.receivedRewardOnSuccess:
      case tutorialThemeSettings.receivedRewardOnCancellation:
        return void this.finishTutorialSubordinateStep()
    }
    if (this.cachedTutorialEvent && void 0 !== this.cachedTutorialEvent.success)switch (this.cachedTutorialEvent.success) {
      case!0:
        this.successTutorialRequest();
        break;
      case!1:
        this.successTutorialCancellationRequest();
        break;
      default:
        servicesLog("warn", "Unknown success status in tutorial event")
    } else try {
      stepTutorialThemeSettings = tutorialThemeSettings[stepIdentifier], data = {
        stepText: servicesInternationalization.localize(stepTutorialThemeSettings.translationKey),
        highlightArea: stepTutorialThemeSettings.highlightArea,
        showPointer: stepTutorialThemeSettings.showPointer,
        pointerDirection: stepTutorialThemeSettings.pointerDirection || "bottom",
        objectToHighlight: null,
        activeSceneMode: stepTutorialThemeSettings.activeSceneMode,
        popUpPosition: stepTutorialThemeSettings.popUpPosition,
        rewards: null
      }, data.highlightArea && (data.objectToHighlight = this.controller.presenter.getObjectToHighlight(data.highlightArea)), stepTutorialThemeSettings.successEventListener ? successEventListener = stepTutorialThemeSettings.successEventListener : (stepTutorialThemeSettings.hardTutorialSubordinateStepReset && this.setCurrentSubordinateStepIdentifier(null), stepTutorialThemeSettings.hardSessionUpdate || servicesGameDataManager.eventsCollection.setInitTutorialEventFlag(!0), successEventListener = null), this.cachedCurrentSubordinateStepData = data, this.notify(xy.eNames.eventPopUpTutorial.dataIsReady, data, { successEventListener: successEventListener })
    } catch (eX) {
      servicesLog("warn", "Error on data preparation process for " + stepIdentifier), servicesLog("debug", this.cachedTutorialEvent), servicesLog("debug", eX), servicesGameDataManager.eventsCollection.setInitTutorialEventFlag(!0), this.notify(xy.eNames.eventPopUpTutorial.onDataError)
    }
  }, PopUpTutorialDataSource.prototype.updateHighlightedAreaCoordinates = function(options) {
    var data = this.cachedCurrentSubordinateStepData;
    data.highlightArea && (data.objectToHighlight = this.controller.presenter.getObjectToHighlight(data.highlightArea)), this.notify(xy.eNames.eventPopUpTutorial.dataIsReady, data, options)
  }, PopUpTutorialDataSource.prototype.getCurrentSubordinateStepIdentifier = function() {
    var stepIdentifier = this.cachedSubordinateStepIdentifier || null;
    if (!stepIdentifier)try {
      var firstSteps = servicesTheme.themeSettings.featureTutorial.firstSteps;
      stepIdentifier = firstSteps[this.cachedTutorialEvent.eventName]
    } catch (eX) {
      servicesLog("warn", "Can not request first step for tutorial event"), servicesLog("debug", eX)
    }
    return this.cachedSubordinateStepIdentifier = stepIdentifier, stepIdentifier
  }, PopUpTutorialDataSource.prototype.setCurrentSubordinateStepIdentifier = function(identifier) {
    this.cachedSubordinateStepIdentifier = identifier
  }, PopUpTutorialDataSource.prototype.updateGameDataAfterTutorialActions = function(isForcedSessionUpdate) {
    this.cachedCurrentSubordinateStepData = null, !this.cachedResponceData || isForcedSessionUpdate ? this.doSessionUpdate() : this.handleSessionUpdateResponse(this.cachedResponceData)
  }, PopUpTutorialDataSource.prototype.finishTutorialSubordinateStep = function() {
    var stepTutorialThemeSettings, stepIdentifier = this.getCurrentSubordinateStepIdentifier(), tutorialThemeSettings = servicesTheme.themeSettings.featureTutorial;
    switch (stepIdentifier) {
      case tutorialThemeSettings.hardSessionUpdate:
        this.setCurrentSubordinateStepIdentifier(null), servicesGameDataManager.eventsCollection.setInitTutorialEventFlag(!0), this.updateGameDataAfterTutorialActions(!0);
        break;
      case tutorialThemeSettings.receivedRewardOnCancellation:
        this.setCurrentSubordinateStepIdentifier(tutorialThemeSettings.canceled), this.updateGameDataAfterTutorialActions(!1);
        break;
      case tutorialThemeSettings.receivedRewardOnSuccess:
        this.setCurrentSubordinateStepIdentifier(null), servicesGameDataManager.eventsCollection.setInitTutorialEventFlag(!0), this.updateGameDataAfterTutorialActions(!0);
        break;
      default:
        stepTutorialThemeSettings = tutorialThemeSettings[stepIdentifier], stepTutorialThemeSettings.next ? (this.setCurrentSubordinateStepIdentifier(stepTutorialThemeSettings.next), this.prepareDataForTutorialStep()) : stepTutorialThemeSettings.hardSessionUpdate ? (servicesGameDataManager.eventsCollection.setInitTutorialEventFlag(!0), this.updateGameDataAfterTutorialActions(!0)) : this.cachedTutorialEvent.isEventCanNotBeFinished ? this.skipForSuccessTutorialRequest() : stepTutorialThemeSettings.extraEventListenerOnCompletedAction ? (this.setCurrentSubordinateStepIdentifier(tutorialThemeSettings.hardSessionUpdate), this.controller.registerCurrentEventListener(stepTutorialThemeSettings.extraEventListenerOnCompletedAction)) : (servicesGameDataManager.eventsCollection.setInitTutorialEventFlag(!0), this.updateGameDataAfterTutorialActions(!1), servicesLog("warn", "hard session update"), servicesLog("warn", "check successEventListener and next properties of " + stepIdentifier))
    }
  }, PopUpTutorialDataSource.prototype.cancelTutorialResponseHandler = function(responseData) {
    if (this.cachedResponceData = responseData, !responseData.errors) {
      var tutorialThemeSettings = servicesTheme.themeSettings.featureTutorial;
      if (this.setCurrentSubordinateStepIdentifier(tutorialThemeSettings.receivedRewardOnCancellation), utilsObject.effectiveLength(this.cachedTutorialEvent.rewardsOnFailure)) {
        var data = this.cachedCurrentSubordinateStepData || {};
        data.title = servicesInternationalization.localize("Received reward!"), data.activeSceneMode = null, data.popUpPosition = "", data.highlightArea = !1, data.showPointer = !1, data.rewards = this.prepareRewards(this.cachedTutorialEvent.rewardsOnFailure), this.cachedCurrentSubordinateStepData = data, this.notify(xy.eNames.eventPopUpTutorial.dataIsReady, data, { successEventListener: xy.eNames.eventListeners.identifier.tutorialButtonOkClick })
      } else this.finishTutorialSubordinateStep()
    }
  }, PopUpTutorialDataSource.prototype.successTutorialResponseHandler = function(responseData) {
    if (this.cachedResponceData = responseData, !responseData.errors) {
      var tutorialThemeSettings = servicesTheme.themeSettings.featureTutorial;
      if (this.setCurrentSubordinateStepIdentifier(tutorialThemeSettings.receivedRewardOnSuccess), utilsObject.effectiveLength(this.cachedTutorialEvent.rewards)) {
        var data = this.cachedCurrentSubordinateStepData || {};
        data.title = servicesInternationalization.localize("Received reward!"), data.activeSceneMode = null, data.popUpPosition = "", data.highlightArea = !1, data.showPointer = !1, data.rewards = this.prepareRewards(this.cachedTutorialEvent.rewards), this.cachedCurrentSubordinateStepData = data, this.notify(xy.eNames.eventPopUpTutorial.dataIsReady, data, { successEventListener: xy.eNames.eventListeners.identifier.tutorialButtonOkClick })
      } else this.finishTutorialSubordinateStep()
    }
  }, PopUpTutorialDataSource.prototype.cancelTutorialRequest = function() {
    this.cachedResponceData = null, this.request({ id: this.cachedTutorialEvent.id }, "TrackableEventAction/abandon", { callBack: this.successTutorialCancellationRequest })
  }, PopUpTutorialDataSource.prototype.successTutorialCancellationRequest = function() {
    this.cachedResponceData = null;
    var params = {
      id: this.cachedTutorialEvent.id,
      habitatID: servicesGameDataManager.eventsCollection.getRewardedHabitatId(),
      rewardOnAcknowledge: !0
    };
    this.request(params, "TrackableEventAction/acknowledge", { callBack: this.cancelTutorialResponseHandler })
  }, PopUpTutorialDataSource.prototype.skipForSuccessTutorialRequest = function() {
    this.cachedResponceData = null;
    var callBack = utilsObject.effectiveLength(this.cachedTutorialEvent.rewards) ? this.successTutorialRequest : this.successTutorialResponseHandler;
    this.request({ id: this.cachedTutorialEvent.id }, "TrackableEventAction/skip", { callBack: callBack })
  }, PopUpTutorialDataSource.prototype.successTutorialRequest = function() {
    this.cachedResponceData = null;
    var params = {
      id: this.cachedTutorialEvent.id,
      habitatID: servicesGameDataManager.eventsCollection.getRewardedHabitatId(),
      rewardOnAcknowledge: !0
    };
    this.request(params, "TrackableEventAction/acknowledge", { callBack: this.successTutorialResponseHandler })
  }, PopUpTutorialDataSource.prototype.setTutorialEvent = function(event) {
    this.cachedTutorialEvent = event
  }, PopUpTutorialDataSource.prototype.getTutorialEvent = function() {
    return this.cachedTutorialEvent
  }, PopUpTutorialDataSource.prototype.prepareRewards = function(rewardObject) {
    var reward = [];
    return rewardObject && utilsObject.effectiveLength(rewardObject) && Object.keys(rewardObject).forEach(function(rewardKey) {
      reward.push({ icon: servicesTheme.getImageClassName(rewardKey, "event"), amount: rewardObject[rewardKey] })
    }, this), reward
  }, PopUpTutorialDataSource
}]);
xy.dStaticInjector.set(xy.dNames.game.popUpTutorial.presenter, [xy.dNames.core.presenterElement, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.theme, xy.dNames.services.gameDataManager, xy.dNames.componentsEngine, xy.dNames.game.popUpTutorial.component, xy.dNames.game.popUpTutorial.componentCover, xy.dNames.components.rendererRequestPending, function(CorePresenterElement, utilsOop, servicesLog, servicesTheme, servicesGameDataManager, componentsEngine, PopUpTutorialComponent, PopUpTutorialComponentCover, componentsRendererRequestPending) {
  "use strict";
  function PopUpTutorialPresenter(options) {
    PopUpTutorialPresenter.__super__.constructor.call(this, options), this.cover = new PopUpTutorialComponentCover(this), this.isEmptyCover = !1
  }

  return utilsOop.extend(PopUpTutorialPresenter, CorePresenterElement), PopUpTutorialPresenter.prototype.draw = function(data) {
    this.isEmptyCover = !1, this.activateCover(data), componentsRendererRequestPending.addShadowCover(), componentsEngine.render(React.createElement(PopUpTutorialComponent, {
      presenter: this,
      settings: data
    }), document.getElementById(xy.DomElements.gamePopUpLayer))
  }, PopUpTutorialPresenter.prototype.update = function(data) {
    this.isEmptyCover ? this.activateEmptyCover() : this.activateCover(data)
  }, PopUpTutorialPresenter.prototype.clear = function() {
    for (var tutorialContainer = document.getElementById(xy.DomElements.gameTutorialOverLayerContainer); tutorialContainer.firstChild;)tutorialContainer.removeChild(tutorialContainer.firstChild);
    return componentsRendererRequestPending.removeShadowCover(), this.clearPopUpTutorial(), !0
  }, PopUpTutorialPresenter.prototype.activateCover = function(data) {
    this.cover.updateTutorialCover(data)
  }, PopUpTutorialPresenter.prototype.activateEmptyCover = function() {
    this.cover.drawEmpty()
  }, PopUpTutorialPresenter.prototype.clearPopUpTutorial = function() {
    componentsEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gamePopUpLayer))
  }, PopUpTutorialPresenter.prototype.getObjectToHighlight = function(highlightArea) {
    var result = null;
    switch (highlightArea.type) {
      case"node":
        try {
          var offsetEl, left, top, width, height, r, scaleX, scaleY, container = document.getElementById(highlightArea.targetContainer), el = container.getElementsByClassName(highlightArea.targetClassName)[0];
          if (el) {
            if (highlightArea.scrollableParent) {
              var containersPaddingTop, containerEl = container.getElementsByClassName(highlightArea.scrollableParent)[0], paddedEl = containerEl.getElementsByClassName("menu--content-section")[0];
              if (containerEl) {
                try {
                  containersPaddingTop = getComputedStyle(paddedEl).getPropertyValue("padding-top")
                } catch (e) {
                  containersPaddingTop = paddedEl.currentStyle.paddingTop
                }
                containersPaddingTop = Math.round(containersPaddingTop.replace("px", "")), containerEl.scrollTop = el.offsetTop - containersPaddingTop
              }
            }
            offsetEl = el.getBoundingClientRect(), left = offsetEl.left + window.scrollX, top = offsetEl.top + window.scrollY, width = offsetEl.width, height = offsetEl.height, width <= height ? (r = width, scaleX = 1, scaleY = height / width) : (r = height, scaleX = width / height, scaleY = 1), result = {
              x: left + width / 2,
              y: top + height / 2,
              r: r,
              scaleX: scaleX,
              scaleY: scaleY
            }
          }
        } catch (eX) {
          servicesLog("warn", "Can not find a node to highlighting")
        }
        break;
      case"habitat-scene":
        result = this.notify(xy.eNames.sceneGame.requestBuildingObjectToHighlight, { buildingClassIdentifier: highlightArea.targetClassName });
        break;
      case"map-scene":
        if ("free-habitat" === highlightArea.targetClassName) {
          var habitat = this.controller.centerMapOnClosestFreeHabitat(), tileGameMap = (servicesGameDataManager.habitatsCollection.getCurrentHabitat(), servicesTheme.themeSettings.settings.map.tileGameMap);
          habitat && (result = {
            x: window.innerWidth / 2 + tileGameMap.width / 2,
            y: window.innerHeight / 2 + tileGameMap.height / 2,
            r: tileGameMap.height,
            scaleX: 1,
            scaleY: 1
          })
        }
    }
    return result
  }, PopUpTutorialPresenter
}]), xy.dStaticInjector.set(xy.dNames.game.popUpEvent.component, [xy.dNames.componentsEngine, xy.dNames.utils.dateTime, xy.dNames.settings.gameConstant, xy.dNames.services.internationalization, function(componentsEngine, utilsDateTime, settingsGameConstant, servicesInternationalization) {
  "use strict";
  return componentsEngine.createClass({
    handlerButtonClick: function(gameEvent, button, event) {
      event.preventDefault(), this.props.presenter.notify(xy.eNames.popUpEvent.onClickButton, button, { event: gameEvent }), this.eventDeadlineTimer && clearInterval(this.eventDeadlineTimer), button.isDismissible && componentsEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gameDialogLayer))
    }, getNewState: function() {
      return { eventCountdown: utilsDateTime.remainTime(this.deadline, !0) }
    }, getInitialState: function() {
      return this.deadline = this.props.event.playerDeadline || this.props.event.deadline, this.deadline && !this.props.event.success && this.deadline - new Date > 0 ? (this.eventDeadlineTimer = setInterval(this.updateEventDeadlineTimer, settingsGameConstant.EVENT_DEADLINE_UPDATE_INTERVAL), this.getNewState()) : null
    }, updateEventDeadlineTimer: function() {
      this.setState(this.getNewState(), null)
    }, render: function() {
      var popUpTitle, eventTitle, imageClass, eventDeadline, rewardSection, buttonsSection, event = {}, rewardSectionArray = [], buttonsSectionArray = [], now = new Date, buildRewardsSection = function(section) {
        var sectionArray = [];
        return section.blocks.forEach(function(reward) {
          sectionArray.push(React.createElement("div", { className: "reward-column" }, React.createElement("div", { className: "icon " + reward.icon }), React.createElement("div", { className: "reward-amount" }, reward.amount, " ")));
        }), React.createElement("div", { className: section.classes }, React.createElement("div", { className: "reward-title" }, section.title), React.createElement("div", { className: "reward-list" }, sectionArray))
      };
      if (Object.assign(event, this.props.event), event.success ? (popUpTitle = React.createElement("div", { className: "event-pop-up-title success" }, servicesInternationalization.localize("Congratulation!")), eventTitle = event.clientInfo.successTitle, imageClass = "image-success--background") : (popUpTitle = React.createElement("div", { className: "event-pop-up-title  " + event.type }, event.eventTypeTitle), eventTitle = event.clientInfo.title, imageClass = "", this.deadline && (eventDeadline = this.deadline - now > 0 ? React.createElement("div", { className: "event-pop-up-deadline" }, this.state.eventCountdown) : null)), event.rewardsSection) {
        var reward;
        for (reward in event.rewardsSection)event.rewardsSection.hasOwnProperty(reward) && event.rewardsSection[reward].blocks && event.rewardsSection[reward].blocks instanceof Array && event.rewardsSection[reward].blocks.length && rewardSectionArray.push(buildRewardsSection(event.rewardsSection[reward]))
      }
      return rewardSection = React.createElement("div", { className: "event-rewards-section" }, rewardSectionArray), event.buttonSection && (event.buttonSection.buttons.forEach(function(button) {
        var onClickFunction = this.handlerButtonClick.bind(this, event, button);
        buttonsSectionArray.push(React.createElement("div", {
          className: button.classes + " event-button",
          onClick: onClickFunction
        }, React.createElement("div", { className: "event-pop-up-button " + button.icon }), React.createElement("div", null, button.title)))
      }, this), buttonsSection = React.createElement("div", { className: "event-list-buttons " + event.buttonSection.classes }, buttonsSectionArray)), React.createElement("div", { className: "event-pop-up" }, React.createElement("div", { className: "event-pop-up-top-border" }), React.createElement("div", { className: "event-pop-up-bottom-border" }), popUpTitle, React.createElement("div", { className: "event-pop-up-content--container" }, React.createElement("div", { className: "event-pop-up-content--title" }, eventTitle, React.createElement("div", { className: "underline" }), eventDeadline), React.createElement("div", { className: "event-image-block" }, React.createElement("div", { className: imageClass }, React.createElement("div", { className: "event-pop-up-main-image " + event.mainImage }))), React.createElement("div", { className: "event-description" }, event.clientInfo.description), rewardSection, buttonsSection))
    }
  })
}]), xy.dStaticInjector.set(xy.dNames.game.popUpEvent.controller, [xy.dNames.core.controllerElement, xy.dNames.utils.oop, xy.dNames.services.log, xy.dNames.services.internationalization, function(CoreControllerElement, utilsOop, servicesLog, servicesInternationalization) {
  "use strict";
  function PopUpEventController(options) {
    PopUpEventController.__super__.constructor.call(this, options), this.dataListneners = [{
      entity: xy.eNames.dataListeners.dataEntity.gameData,
      identifier: xy.eNames.dataListeners.dataIdentifiers.sessionUpdate,
      listenerUniqueId: this.instanceId,
      listenerContext: this,
      listenerCalBackFunction: this.prepareDataForDraw
    }]
  }

  return utilsOop.extend(PopUpEventController, CoreControllerElement), PopUpEventController.prototype.start = function() {
    this.registerAllDataListeners(), this.prepareDataForDraw(), this[xy.eNames.core.pendingModeOn]()
  }, PopUpEventController.prototype.destroy = function() {
    PopUpEventController.__super__.destroy.call(this), this.notify(xy.eNames.popUpEvent.onDestroy), this[xy.eNames.core.pendingModeOff]()
  }, PopUpEventController.prototype.prepareDataForDraw = function(data) {
    data && (this.initialData.event = data);
    try {
      var preparedData = this.dataSource.preProsedData(this.initialData.event);
      this.presenter.draw(preparedData)
    } catch (e) {
      servicesLog("debug", e), this.destroy()
    }
  }, PopUpEventController.prototype[xy.eNames.popUpEvent.onClickButton] = function(data, options) {
    var event = options.event, eventId = event.id;
    switch (data.action) {
      case xy.eNames.popUpEvent.actions.skip:
        this.dataSource.skip(eventId);
        break;
      case xy.eNames.popUpEvent.actions.openLink:
        break;
      case xy.eNames.popUpEvent.actions.start:
        this.dataSource.start(eventId);
        break;
      case xy.eNames.popUpEvent.actions.accept:
        this.dataSource.acknowledge(eventId)
    }
    this.destroy()
  }, PopUpEventController
}]), xy.dStaticInjector.set(xy.dNames.game.popUpEvent.dataSource, [xy.dNames.core.dataSource, xy.dNames.utils.oop, xy.dNames.utils.dateTime, xy.dNames.services.internationalization, xy.dNames.services.theme, xy.dNames.services.gameDataManager, function(CoreDataSource, utilsOop, utilsDateTime, servicesInternationalization, servicesTheme, servicesGameDataManager) {
  "use strict";
  function PopUpEventDataSource(options) {
    PopUpEventDataSource.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(PopUpEventDataSource, CoreDataSource), PopUpEventDataSource.prototype.preProsedData = function(data) {
    if (data.isDemo && (data = servicesGameDataManager.getEvent(data.id)), !data)throw new Error("Can not create event pop up event does not exist");
    switch (data.type) {
      case"task":
        data.eventTypeTitle = servicesInternationalization.localize("Quest");
        break;
      case"world":
        data.eventTypeTitle = servicesInternationalization.localize("Event");
        break;
      case"info":
        data.eventTypeTitle = servicesInternationalization.localize("Hint");
        break;
      default:
        data.eventTypeTitle = servicesInternationalization.localize(data.type)
    }
    var i, rewardsSection = {
      requires: { blocks: [] },
      reward: { blocks: [] },
      maxReward: { blocks: [] }
    }, reqImageKey = data.clientInfo.requirementImageKey || "", iconRequires = servicesTheme.getImageClassName(reqImageKey.replace(" ", ""), "event"), rewardAmount = !1, rewardIcon = !1, len = data.requiresAllConditions ? data.conditions.length : 1;
    for (i = 0; i < len; i += 1)rewardsSection.requires.blocks.push({
      icon: iconRequires,
      amount: data.conditions[i].value
    });
    rewardsSection.requires.title = servicesInternationalization.localize("Requires"), rewardsSection.requires.classes = "columns-" + rewardsSection.requires.blocks.length;
    var key;
    for (key in data.rewards)data.rewards.hasOwnProperty(key) && (rewardAmount = +data.rewards[key], rewardIcon = servicesTheme.getImageClassName(key.replace(" ", ""), "event"), rewardsSection.reward.blocks.push({
      icon: rewardIcon,
      amount: rewardAmount
    }));
    rewardsSection.reward.title = servicesInternationalization.localize("Reward"), rewardsSection.reward.classes = "columns-" + rewardsSection.reward.blocks.length, data.completionLimit && rewardAmount && rewardIcon && rewardsSection.maxReward.blocks.push({
      icon: rewardIcon,
      amount: rewardAmount * data.completionLimit
    }), rewardsSection.maxReward.title = servicesInternationalization.localize("Max. Reward"), rewardsSection.maxReward.classes = "columns-" + rewardsSection.maxReward.blocks.length, rewardsSection.requires.anyRewards = !!rewardsSection.requires.blocks.length, rewardsSection.reward.anyRewards = !!rewardsSection.reward.blocks.length, rewardsSection.maxReward.anyRewards = !!rewardsSection.maxReward.blocks.length, data.rewardsSection = rewardsSection;
    var buttonSection = { classes: "", buttons: [] };
    if (data.canSkip && buttonSection.buttons.push({
              columnClasses: "col-" + (buttonSection.buttons.length + 1),
              icon: servicesTheme.getImageClassName("skipButton", "event"),
              title: servicesInternationalization.localize("Skip"),
              isDismissible: !0,
              action: xy.eNames.popUpEvent.actions.skip
            }), data.success === !0 && buttonSection.buttons.push({
              columnClasses: "col-" + (buttonSection.buttons.length + 1),
              icon: servicesTheme.getImageClassName("backButton", "event"),
              title: servicesInternationalization.localize("Back"),
              isDismissible: !0,
              action: xy.eNames.popUpEvent.actions.dismiss
            }), data.clientInfo.buttonList) {
      var currentButton, addButton;
      for (i = 0, len = data.clientInfo.buttonList.length; i < len; i += 1)currentButton = data.clientInfo.buttonList[i], addButton = {
        columnClasses: "col-" + (buttonSection.buttons.length + 1),
        icon: servicesTheme.getImageClassName(currentButton.iconKey, "event"),
        title: servicesInternationalization.localize(currentButton.textLocKey),
        link: currentButton.link,
        isDismissible: "true" === currentButton.dismissesEvent,
        action: xy.eNames.popUpEvent.actions.openLink
      }, buttonSection.buttons.push(addButton)
    }
    var acceptAction = "";
    return acceptAction = data.isTrackable ? xy.eNames.popUpEvent.actions.start : data.isDemo && data.success !== !0 ? xy.eNames.popUpEvent.actions.dismiss : xy.eNames.popUpEvent.actions.accept, buttonSection.buttons.push({
      columnClasses: "col-" + (buttonSection.buttons.length + 1),
      action: acceptAction,
      icon: servicesTheme.getImageClassName("acceptButton", "event"),
      title: servicesInternationalization.localize("Accept"),
      isDismissible: !0
    }), data.mainImage = servicesTheme.getImageClassName(data.clientInfo.imageKey, "event").toLowerCase(), buttonSection.classes = "columns-" + buttonSection.buttons.length, data.buttonSection = buttonSection, data
  }, PopUpEventDataSource.prototype.start = function(id) {
    this.request({ id: id }, "TrackableEventAction/start", { callBack: this.handleSessionUpdateResponse })
  }, PopUpEventDataSource.prototype.acknowledge = function(id) {
    var params = {
      id: id,
      habitatID: servicesGameDataManager.eventsCollection.getRewardedHabitatId(),
      rewardOnAcknowledge: !0
    };
    this.request(params, "TrackableEventAction/acknowledge", { callBack: this.handleSessionUpdateResponse })
  }, PopUpEventDataSource.prototype.skip = function(id) {
    this.request({ id: id }, "TrackableEventAction/skip", { callBack: this.handleSessionUpdateResponse })
  }, PopUpEventDataSource
}]), xy.dStaticInjector.set(xy.dNames.game.popUpEvent.presenter, [xy.dNames.core.presenterElement, xy.dNames.utils.oop, xy.dNames.componentsEngine, xy.dNames.game.popUpEvent.component, function(CorePresenterElement, utilsOop, componentsEngine, PopUpEventComponent) {
  "use strict";
  function PopUpEventPresenter(options) {
    PopUpEventPresenter.__super__.constructor.call(this, options)
  }

  return utilsOop.extend(PopUpEventPresenter, CorePresenterElement), PopUpEventPresenter.prototype.draw = function(data) {
    componentsEngine.render(React.createElement(PopUpEventComponent, {
      presenter: this,
      event: data
    }), document.getElementById(xy.DomElements.gamePopUpLayer))
  }, PopUpEventPresenter.prototype.clear = function() {
    componentsEngine.unmountComponentAtNode(document.getElementById(xy.DomElements.gamePopUpLayer))
  }, PopUpEventPresenter
}]), window.addEventListener("DOMContentLoaded", function() {
  "use strict";
  var loadingStatus = !0, gameName = "lordsandknights", environment = window.ENVIRONMENT || "live", gameInstance = new xy.gameClass;
  React.initializeTouchEvents(!0), gameInstance.injector.set(xy.dNames.componentsEngine, React), gameInstance.initGame({
    game: gameName,
    environment: environment
  }), gameInstance.loadGameResources({
    resources: xy.resourcePreloadingArray, onLoaded: function() {
      gameInstance.initializationTheme(), gameInstance.initializationMusicManager();
      var serviceInternationalization = gameInstance.injector.get(xy.dNames.services.internationalization), serviceResourceManager = gameInstance.injector.get(xy.dNames.services.resourcesManager);
      serviceInternationalization.updateLocale({
        main: serviceResourceManager.getResourcesValue(xy.res.localizationMain),
        event: serviceResourceManager.getResourcesValue(xy.res.localizationEvent)
      });
      var factory = gameInstance.injector.get(xy.dNames.factories.game), firstScene = factory.create(xy.dNames.game.sceneLogin.name);
      firstScene.runScene();
      var loading = gameInstance.injector.get(xy.dNames.components.rendererLoadingGame);
      loading.clear();
      var gamePending = gameInstance.injector.get(xy.dNames.components.rendererRequestPending);
      gamePending.add()
    }, onProgress: function(flagError, loaded, totalToLoad) {
      var loading = gameInstance.injector.get(xy.dNames.components.rendererLoadingGame), percentage = loaded / totalToLoad * 100;
      !flagError && loaded < totalToLoad && loading.progress(percentage)
    }, onError: function() {
      var loading = gameInstance.injector.get(xy.dNames.components.rendererLoadingGame);
      loading.error(), loadingStatus = !1
    }
  })
}, !1);
/**
 * React v0.13.3
 *
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
!function(e) {
  if ("object" == typeof exports && "undefined" != typeof module)module.exports = e(); else if ("function" == typeof define && define.amd)define([], e); else {
    var t;
    t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, t.React = e()
  }
}(function() {
  return function e(t, n, r) {
    function o(a, u) {
      if (!n[a]) {
        if (!t[a]) {
          var s = "function" == typeof require && require;
          if (!u && s)return s(a, !0);
          if (i)return i(a, !0);
          var l = new Error("Cannot find module '" + a + "'");
          throw l.code = "MODULE_NOT_FOUND", l
        }
        var c = n[a] = { exports: {} };
        t[a][0].call(c.exports, function(e) {
          var n = t[a][1][e];
          return o(n ? n : e)
        }, c, c.exports, e, t, n, r)
      }
      return n[a].exports
    }

    for (var i = "function" == typeof require && require, a = 0; a < r.length; a++)o(r[a]);
    return o
  }({
    1: [function(e, t, n) {
      "use strict";
      var r = e(19), o = e(32), i = e(34), a = e(33), u = e(38), s = e(39), l = e(55), c = (e(56), e(40)), p = e(51), d = e(54), f = e(64), h = e(68), m = e(73), v = e(76), g = e(79), y = e(82), C = e(27), E = e(115), b = e(142);
      d.inject();
      var _ = l.createElement, x = l.createFactory, D = l.cloneElement, M = m.measure("React", "render", h.render), N = {
        Children: {
          map: o.map,
          forEach: o.forEach,
          count: o.count,
          only: b
        },
        Component: i,
        DOM: c,
        PropTypes: v,
        initializeTouchEvents: function(e) {
          r.useTouchEvents = e
        },
        createClass: a.createClass,
        createElement: _,
        cloneElement: D,
        createFactory: x,
        createMixin: function(e) {
          return e
        },
        constructAndRenderComponent: h.constructAndRenderComponent,
        constructAndRenderComponentByID: h.constructAndRenderComponentByID,
        findDOMNode: E,
        render: M,
        renderToString: y.renderToString,
        renderToStaticMarkup: y.renderToStaticMarkup,
        unmountComponentAtNode: h.unmountComponentAtNode,
        isValidElement: l.isValidElement,
        withContext: u.withContext,
        __spread: C
      };
      "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject && __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        CurrentOwner: s,
        InstanceHandles: f,
        Mount: h,
        Reconciler: g,
        TextComponent: p
      });
      N.version = "0.13.3", t.exports = N
    }, {
      115: 115,
      142: 142,
      19: 19,
      27: 27,
      32: 32,
      33: 33,
      34: 34,
      38: 38,
      39: 39,
      40: 40,
      51: 51,
      54: 54,
      55: 55,
      56: 56,
      64: 64,
      68: 68,
      73: 73,
      76: 76,
      79: 79,
      82: 82
    }],
    2: [function(e, t, n) {
      "use strict";
      var r = e(117), o = {
        componentDidMount: function() {
          this.props.autoFocus && r(this.getDOMNode())
        }
      };
      t.exports = o
    }, { 117: 117 }],
    3: [function(e, t, n) {
      "use strict";
      function r() {
        var e = window.opera;
        return "object" == typeof e && "function" == typeof e.version && parseInt(e.version(), 10) <= 12
      }

      function o(e) {
        return (e.ctrlKey || e.altKey || e.metaKey) && !(e.ctrlKey && e.altKey)
      }

      function i(e) {
        switch (e) {
          case T.topCompositionStart:
            return P.compositionStart;
          case T.topCompositionEnd:
            return P.compositionEnd;
          case T.topCompositionUpdate:
            return P.compositionUpdate
        }
      }

      function a(e, t) {
        return e === T.topKeyDown && t.keyCode === b
      }

      function u(e, t) {
        switch (e) {
          case T.topKeyUp:
            return -1 !== E.indexOf(t.keyCode);
          case T.topKeyDown:
            return t.keyCode !== b;
          case T.topKeyPress:
          case T.topMouseDown:
          case T.topBlur:
            return !0;
          default:
            return !1
        }
      }

      function s(e) {
        var t = e.detail;
        return "object" == typeof t && "data" in t ? t.data : null
      }

      function l(e, t, n, r) {
        var o, l;
        if (_ ? o = i(e) : w ? u(e, r) && (o = P.compositionEnd) : a(e, r) && (o = P.compositionStart), !o)return null;
        M && (w || o !== P.compositionStart ? o === P.compositionEnd && w && (l = w.getData()) : w = v.getPooled(t));
        var c = g.getPooled(o, n, r);
        if (l)c.data = l; else {
          var p = s(r);
          null !== p && (c.data = p)
        }
        return h.accumulateTwoPhaseDispatches(c), c
      }

      function c(e, t) {
        switch (e) {
          case T.topCompositionEnd:
            return s(t);
          case T.topKeyPress:
            var n = t.which;
            return n !== N ? null : (R = !0, I);
          case T.topTextInput:
            var r = t.data;
            return r === I && R ? null : r;
          default:
            return null
        }
      }

      function p(e, t) {
        if (w) {
          if (e === T.topCompositionEnd || u(e, t)) {
            var n = w.getData();
            return v.release(w), w = null, n
          }
          return null
        }
        switch (e) {
          case T.topPaste:
            return null;
          case T.topKeyPress:
            return t.which && !o(t) ? String.fromCharCode(t.which) : null;
          case T.topCompositionEnd:
            return M ? null : t.data;
          default:
            return null
        }
      }

      function d(e, t, n, r) {
        var o;
        if (o = D ? c(e, r) : p(e, r), !o)return null;
        var i = y.getPooled(P.beforeInput, n, r);
        return i.data = o, h.accumulateTwoPhaseDispatches(i), i
      }

      var f = e(15), h = e(20), m = e(21), v = e(22), g = e(91), y = e(95), C = e(139), E = [9, 13, 27, 32], b = 229, _ = m.canUseDOM && "CompositionEvent" in window, x = null;
      m.canUseDOM && "documentMode" in document && (x = document.documentMode);
      var D = m.canUseDOM && "TextEvent" in window && !x && !r(), M = m.canUseDOM && (!_ || x && x > 8 && 11 >= x), N = 32, I = String.fromCharCode(N), T = f.topLevelTypes, P = {
        beforeInput: {
          phasedRegistrationNames: {
            bubbled: C({ onBeforeInput: null }),
            captured: C({ onBeforeInputCapture: null })
          }, dependencies: [T.topCompositionEnd, T.topKeyPress, T.topTextInput, T.topPaste]
        },
        compositionEnd: {
          phasedRegistrationNames: {
            bubbled: C({ onCompositionEnd: null }),
            captured: C({ onCompositionEndCapture: null })
          }, dependencies: [T.topBlur, T.topCompositionEnd, T.topKeyDown, T.topKeyPress, T.topKeyUp, T.topMouseDown]
        },
        compositionStart: {
          phasedRegistrationNames: {
            bubbled: C({ onCompositionStart: null }),
            captured: C({ onCompositionStartCapture: null })
          }, dependencies: [T.topBlur, T.topCompositionStart, T.topKeyDown, T.topKeyPress, T.topKeyUp, T.topMouseDown]
        },
        compositionUpdate: {
          phasedRegistrationNames: {
            bubbled: C({ onCompositionUpdate: null }),
            captured: C({ onCompositionUpdateCapture: null })
          }, dependencies: [T.topBlur, T.topCompositionUpdate, T.topKeyDown, T.topKeyPress, T.topKeyUp, T.topMouseDown]
        }
      }, R = !1, w = null, O = {
        eventTypes: P, extractEvents: function(e, t, n, r) {
          return [l(e, t, n, r), d(e, t, n, r)]
        }
      };
      t.exports = O
    }, { 139: 139, 15: 15, 20: 20, 21: 21, 22: 22, 91: 91, 95: 95 }],
    4: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        return e + t.charAt(0).toUpperCase() + t.substring(1)
      }

      var o = {
        boxFlex: !0,
        boxFlexGroup: !0,
        columnCount: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        strokeDashoffset: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      }, i = ["Webkit", "ms", "Moz", "O"];
      Object.keys(o).forEach(function(e) {
        i.forEach(function(t) {
          o[r(t, e)] = o[e]
        })
      });
      var a = {
        background: { backgroundImage: !0, backgroundPosition: !0, backgroundRepeat: !0, backgroundColor: !0 },
        border: { borderWidth: !0, borderStyle: !0, borderColor: !0 },
        borderBottom: { borderBottomWidth: !0, borderBottomStyle: !0, borderBottomColor: !0 },
        borderLeft: { borderLeftWidth: !0, borderLeftStyle: !0, borderLeftColor: !0 },
        borderRight: { borderRightWidth: !0, borderRightStyle: !0, borderRightColor: !0 },
        borderTop: { borderTopWidth: !0, borderTopStyle: !0, borderTopColor: !0 },
        font: { fontStyle: !0, fontVariant: !0, fontWeight: !0, fontSize: !0, lineHeight: !0, fontFamily: !0 }
      }, u = { isUnitlessNumber: o, shorthandPropertyExpansions: a };
      t.exports = u
    }, {}],
    5: [function(e, t, n) {
      "use strict";
      var r = e(4), o = e(21), i = (e(106), e(111)), a = e(131), u = e(141), s = (e(150), u(function(e) {
        return a(e)
      })), l = "cssFloat";
      o.canUseDOM && void 0 === document.documentElement.style.cssFloat && (l = "styleFloat");
      var c = {
        createMarkupForStyles: function(e) {
          var t = "";
          for (var n in e)if (e.hasOwnProperty(n)) {
            var r = e[n];
            null != r && (t += s(n) + ":", t += i(n, r) + ";")
          }
          return t || null
        }, setValueForStyles: function(e, t) {
          var n = e.style;
          for (var o in t)if (t.hasOwnProperty(o)) {
            var a = i(o, t[o]);
            if ("float" === o && (o = l), a)n[o] = a; else {
              var u = r.shorthandPropertyExpansions[o];
              if (u)for (var s in u)n[s] = ""; else n[o] = ""
            }
          }
        }
      };
      t.exports = c
    }, { 106: 106, 111: 111, 131: 131, 141: 141, 150: 150, 21: 21, 4: 4 }],
    6: [function(e, t, n) {
      "use strict";
      function r() {
        this._callbacks = null, this._contexts = null
      }

      var o = e(28), i = e(27), a = e(133);
      i(r.prototype, {
        enqueue: function(e, t) {
          this._callbacks = this._callbacks || [], this._contexts = this._contexts || [], this._callbacks.push(e), this._contexts.push(t)
        }, notifyAll: function() {
          var e = this._callbacks, t = this._contexts;
          if (e) {
            a(e.length === t.length), this._callbacks = null, this._contexts = null;
            for (var n = 0, r = e.length; r > n; n++)e[n].call(t[n]);
            e.length = 0, t.length = 0
          }
        }, reset: function() {
          this._callbacks = null, this._contexts = null
        }, destructor: function() {
          this.reset()
        }
      }), o.addPoolingTo(r), t.exports = r
    }, { 133: 133, 27: 27, 28: 28 }],
    7: [function(e, t, n) {
      "use strict";
      function r(e) {
        return "SELECT" === e.nodeName || "INPUT" === e.nodeName && "file" === e.type
      }

      function o(e) {
        var t = x.getPooled(T.change, R, e);
        E.accumulateTwoPhaseDispatches(t), _.batchedUpdates(i, t)
      }

      function i(e) {
        C.enqueueEvents(e), C.processEventQueue()
      }

      function a(e, t) {
        P = e, R = t, P.attachEvent("onchange", o)
      }

      function u() {
        P && (P.detachEvent("onchange", o), P = null, R = null)
      }

      function s(e, t, n) {
        return e === I.topChange ? n : void 0
      }

      function l(e, t, n) {
        e === I.topFocus ? (u(), a(t, n)) : e === I.topBlur && u()
      }

      function c(e, t) {
        P = e, R = t, w = e.value, O = Object.getOwnPropertyDescriptor(e.constructor.prototype, "value"), Object.defineProperty(P, "value", k), P.attachEvent("onpropertychange", d)
      }

      function p() {
        P && (delete P.value, P.detachEvent("onpropertychange", d), P = null, R = null, w = null, O = null)
      }

      function d(e) {
        if ("value" === e.propertyName) {
          var t = e.srcElement.value;
          t !== w && (w = t, o(e))
        }
      }

      function f(e, t, n) {
        return e === I.topInput ? n : void 0
      }

      function h(e, t, n) {
        e === I.topFocus ? (p(), c(t, n)) : e === I.topBlur && p()
      }

      function m(e, t, n) {
        return e !== I.topSelectionChange && e !== I.topKeyUp && e !== I.topKeyDown || !P || P.value === w ? void 0 : (w = P.value, R)
      }

      function v(e) {
        return "INPUT" === e.nodeName && ("checkbox" === e.type || "radio" === e.type)
      }

      function g(e, t, n) {
        return e === I.topClick ? n : void 0
      }

      var y = e(15), C = e(17), E = e(20), b = e(21), _ = e(85), x = e(93), D = e(134), M = e(136), N = e(139), I = y.topLevelTypes, T = {
        change: {
          phasedRegistrationNames: {
            bubbled: N({ onChange: null }),
            captured: N({ onChangeCapture: null })
          },
          dependencies: [I.topBlur, I.topChange, I.topClick, I.topFocus, I.topInput, I.topKeyDown, I.topKeyUp, I.topSelectionChange]
        }
      }, P = null, R = null, w = null, O = null, S = !1;
      b.canUseDOM && (S = D("change") && (!("documentMode" in document) || document.documentMode > 8));
      var A = !1;
      b.canUseDOM && (A = D("input") && (!("documentMode" in document) || document.documentMode > 9));
      var k = {
        get: function() {
          return O.get.call(this)
        }, set: function(e) {
          w = "" + e, O.set.call(this, e)
        }
      }, L = {
        eventTypes: T, extractEvents: function(e, t, n, o) {
          var i, a;
          if (r(t) ? S ? i = s : a = l : M(t) ? A ? i = f : (i = m, a = h) : v(t) && (i = g), i) {
            var u = i(e, t, n);
            if (u) {
              var c = x.getPooled(T.change, u, o);
              return E.accumulateTwoPhaseDispatches(c), c
            }
          }
          a && a(e, t, n)
        }
      };
      t.exports = L
    }, { 134: 134, 136: 136, 139: 139, 15: 15, 17: 17, 20: 20, 21: 21, 85: 85, 93: 93 }],
    8: [function(e, t, n) {
      "use strict";
      var r = 0, o = {
        createReactRootIndex: function() {
          return r++
        }
      };
      t.exports = o
    }, {}],
    9: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        e.insertBefore(t, e.childNodes[n] || null)
      }

      var o = e(12), i = e(70), a = e(145), u = e(133), s = {
        dangerouslyReplaceNodeWithMarkup: o.dangerouslyReplaceNodeWithMarkup,
        updateTextContent: a,
        processUpdates: function(e, t) {
          for (var n, s = null, l = null, c = 0; c < e.length; c++)if (n = e[c], n.type === i.MOVE_EXISTING || n.type === i.REMOVE_NODE) {
            var p = n.fromIndex, d = n.parentNode.childNodes[p], f = n.parentID;
            u(d), s = s || {}, s[f] = s[f] || [], s[f][p] = d, l = l || [], l.push(d)
          }
          var h = o.dangerouslyRenderMarkup(t);
          if (l)for (var m = 0; m < l.length; m++)l[m].parentNode.removeChild(l[m]);
          for (var v = 0; v < e.length; v++)switch (n = e[v], n.type) {
            case i.INSERT_MARKUP:
              r(n.parentNode, h[n.markupIndex], n.toIndex);
              break;
            case i.MOVE_EXISTING:
              r(n.parentNode, s[n.parentID][n.fromIndex], n.toIndex);
              break;
            case i.TEXT_CONTENT:
              a(n.parentNode, n.textContent);
              break;
            case i.REMOVE_NODE:
          }
        }
      };
      t.exports = s
    }, { 12: 12, 133: 133, 145: 145, 70: 70 }],
    10: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        return (e & t) === t
      }

      var o = e(133), i = {
        MUST_USE_ATTRIBUTE: 1,
        MUST_USE_PROPERTY: 2,
        HAS_SIDE_EFFECTS: 4,
        HAS_BOOLEAN_VALUE: 8,
        HAS_NUMERIC_VALUE: 16,
        HAS_POSITIVE_NUMERIC_VALUE: 48,
        HAS_OVERLOADED_BOOLEAN_VALUE: 64,
        injectDOMPropertyConfig: function(e) {
          var t = e.Properties || {}, n = e.DOMAttributeNames || {}, a = e.DOMPropertyNames || {}, s = e.DOMMutationMethods || {};
          e.isCustomAttribute && u._isCustomAttributeFunctions.push(e.isCustomAttribute);
          for (var l in t) {
            o(!u.isStandardName.hasOwnProperty(l)), u.isStandardName[l] = !0;
            var c = l.toLowerCase();
            if (u.getPossibleStandardName[c] = l, n.hasOwnProperty(l)) {
              var p = n[l];
              u.getPossibleStandardName[p] = l, u.getAttributeName[l] = p
            } else u.getAttributeName[l] = c;
            u.getPropertyName[l] = a.hasOwnProperty(l) ? a[l] : l, s.hasOwnProperty(l) ? u.getMutationMethod[l] = s[l] : u.getMutationMethod[l] = null;
            var d = t[l];
            u.mustUseAttribute[l] = r(d, i.MUST_USE_ATTRIBUTE), u.mustUseProperty[l] = r(d, i.MUST_USE_PROPERTY), u.hasSideEffects[l] = r(d, i.HAS_SIDE_EFFECTS), u.hasBooleanValue[l] = r(d, i.HAS_BOOLEAN_VALUE), u.hasNumericValue[l] = r(d, i.HAS_NUMERIC_VALUE), u.hasPositiveNumericValue[l] = r(d, i.HAS_POSITIVE_NUMERIC_VALUE), u.hasOverloadedBooleanValue[l] = r(d, i.HAS_OVERLOADED_BOOLEAN_VALUE), o(!u.mustUseAttribute[l] || !u.mustUseProperty[l]), o(u.mustUseProperty[l] || !u.hasSideEffects[l]), o(!!u.hasBooleanValue[l] + !!u.hasNumericValue[l] + !!u.hasOverloadedBooleanValue[l] <= 1)
          }
        }
      }, a = {}, u = {
        ID_ATTRIBUTE_NAME: "data-reactid",
        isStandardName: {},
        getPossibleStandardName: {},
        getAttributeName: {},
        getPropertyName: {},
        getMutationMethod: {},
        mustUseAttribute: {},
        mustUseProperty: {},
        hasSideEffects: {},
        hasBooleanValue: {},
        hasNumericValue: {},
        hasPositiveNumericValue: {},
        hasOverloadedBooleanValue: {},
        _isCustomAttributeFunctions: [],
        isCustomAttribute: function(e) {
          for (var t = 0; t < u._isCustomAttributeFunctions.length; t++) {
            var n = u._isCustomAttributeFunctions[t];
            if (n(e))return !0
          }
          return !1
        },
        getDefaultValueForProperty: function(e, t) {
          var n, r = a[e];
          return r || (a[e] = r = {}), t in r || (n = document.createElement(e), r[t] = n[t]), r[t]
        },
        injection: i
      };
      t.exports = u
    }, { 133: 133 }],
    11: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        return null == t || o.hasBooleanValue[e] && !t || o.hasNumericValue[e] && isNaN(t) || o.hasPositiveNumericValue[e] && 1 > t || o.hasOverloadedBooleanValue[e] && t === !1
      }

      var o = e(10), i = e(143), a = (e(150), {
        createMarkupForID: function(e) {
          return o.ID_ATTRIBUTE_NAME + "=" + i(e)
        }, createMarkupForProperty: function(e, t) {
          if (o.isStandardName.hasOwnProperty(e) && o.isStandardName[e]) {
            if (r(e, t))return "";
            var n = o.getAttributeName[e];
            return o.hasBooleanValue[e] || o.hasOverloadedBooleanValue[e] && t === !0 ? n : n + "=" + i(t)
          }
          return o.isCustomAttribute(e) ? null == t ? "" : e + "=" + i(t) : null
        }, setValueForProperty: function(e, t, n) {
          if (o.isStandardName.hasOwnProperty(t) && o.isStandardName[t]) {
            var i = o.getMutationMethod[t];
            if (i)i(e, n); else if (r(t, n))this.deleteValueForProperty(e, t); else if (o.mustUseAttribute[t])e.setAttribute(o.getAttributeName[t], "" + n); else {
              var a = o.getPropertyName[t];
              o.hasSideEffects[t] && "" + e[a] == "" + n || (e[a] = n)
            }
          } else o.isCustomAttribute(t) && (null == n ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
        }, deleteValueForProperty: function(e, t) {
          if (o.isStandardName.hasOwnProperty(t) && o.isStandardName[t]) {
            var n = o.getMutationMethod[t];
            if (n)n(e, void 0); else if (o.mustUseAttribute[t])e.removeAttribute(o.getAttributeName[t]); else {
              var r = o.getPropertyName[t], i = o.getDefaultValueForProperty(e.nodeName, r);
              o.hasSideEffects[t] && "" + e[r] === i || (e[r] = i)
            }
          } else o.isCustomAttribute(t) && e.removeAttribute(t)
        }
      });
      t.exports = a
    }, { 10: 10, 143: 143, 150: 150 }],
    12: [function(e, t, n) {
      "use strict";
      function r(e) {
        return e.substring(1, e.indexOf(" "))
      }

      var o = e(21), i = e(110), a = e(112), u = e(125), s = e(133), l = /^(<[^ \/>]+)/, c = "data-danger-index", p = {
        dangerouslyRenderMarkup: function(e) {
          s(o.canUseDOM);
          for (var t, n = {}, p = 0; p < e.length; p++)s(e[p]), t = r(e[p]), t = u(t) ? t : "*", n[t] = n[t] || [], n[t][p] = e[p];
          var d = [], f = 0;
          for (t in n)if (n.hasOwnProperty(t)) {
            var h, m = n[t];
            for (h in m)if (m.hasOwnProperty(h)) {
              var v = m[h];
              m[h] = v.replace(l, "$1 " + c + '="' + h + '" ')
            }
            for (var g = i(m.join(""), a), y = 0; y < g.length; ++y) {
              var C = g[y];
              C.hasAttribute && C.hasAttribute(c) && (h = +C.getAttribute(c), C.removeAttribute(c), s(!d.hasOwnProperty(h)), d[h] = C, f += 1)
            }
          }
          return s(f === d.length), s(d.length === e.length), d
        }, dangerouslyReplaceNodeWithMarkup: function(e, t) {
          s(o.canUseDOM), s(t), s("html" !== e.tagName.toLowerCase());
          var n = i(t, a)[0];
          e.parentNode.replaceChild(n, e)
        }
      };
      t.exports = p
    }, { 110: 110, 112: 112, 125: 125, 133: 133, 21: 21 }],
    13: [function(e, t, n) {
      "use strict";
      var r = e(139), o = [r({ ResponderEventPlugin: null }), r({ SimpleEventPlugin: null }), r({ TapEventPlugin: null }), r({ EnterLeaveEventPlugin: null }), r({ ChangeEventPlugin: null }), r({ SelectEventPlugin: null }), r({ BeforeInputEventPlugin: null }), r({ AnalyticsEventPlugin: null }), r({ MobileSafariClickEventPlugin: null })];
      t.exports = o
    }, { 139: 139 }],
    14: [function(e, t, n) {
      "use strict";
      var r = e(15), o = e(20), i = e(97), a = e(68), u = e(139), s = r.topLevelTypes, l = a.getFirstReactDOM, c = {
        mouseEnter: {
          registrationName: u({ onMouseEnter: null }),
          dependencies: [s.topMouseOut, s.topMouseOver]
        }, mouseLeave: { registrationName: u({ onMouseLeave: null }), dependencies: [s.topMouseOut, s.topMouseOver] }
      }, p = [null, null], d = {
        eventTypes: c, extractEvents: function(e, t, n, r) {
          if (e === s.topMouseOver && (r.relatedTarget || r.fromElement))return null;
          if (e !== s.topMouseOut && e !== s.topMouseOver)return null;
          var u;
          if (t.window === t)u = t; else {
            var d = t.ownerDocument;
            u = d ? d.defaultView || d.parentWindow : window
          }
          var f, h;
          if (e === s.topMouseOut ? (f = t, h = l(r.relatedTarget || r.toElement) || u) : (f = u, h = t), f === h)return null;
          var m = f ? a.getID(f) : "", v = h ? a.getID(h) : "", g = i.getPooled(c.mouseLeave, m, r);
          g.type = "mouseleave", g.target = f, g.relatedTarget = h;
          var y = i.getPooled(c.mouseEnter, v, r);
          return y.type = "mouseenter", y.target = h, y.relatedTarget = f, o.accumulateEnterLeaveDispatches(g, y, m, v), p[0] = g, p[1] = y, p
        }
      };
      t.exports = d
    }, { 139: 139, 15: 15, 20: 20, 68: 68, 97: 97 }],
    15: [function(e, t, n) {
      "use strict";
      var r = e(138), o = r({ bubbled: null, captured: null }), i = r({
        topBlur: null,
        topChange: null,
        topClick: null,
        topCompositionEnd: null,
        topCompositionStart: null,
        topCompositionUpdate: null,
        topContextMenu: null,
        topCopy: null,
        topCut: null,
        topDoubleClick: null,
        topDrag: null,
        topDragEnd: null,
        topDragEnter: null,
        topDragExit: null,
        topDragLeave: null,
        topDragOver: null,
        topDragStart: null,
        topDrop: null,
        topError: null,
        topFocus: null,
        topInput: null,
        topKeyDown: null,
        topKeyPress: null,
        topKeyUp: null,
        topLoad: null,
        topMouseDown: null,
        topMouseMove: null,
        topMouseOut: null,
        topMouseOver: null,
        topMouseUp: null,
        topPaste: null,
        topReset: null,
        topScroll: null,
        topSelectionChange: null,
        topSubmit: null,
        topTextInput: null,
        topTouchCancel: null,
        topTouchEnd: null,
        topTouchMove: null,
        topTouchStart: null,
        topWheel: null
      }), a = { topLevelTypes: i, PropagationPhases: o };
      t.exports = a
    }, { 138: 138 }],
    16: [function(e, t, n) {
      var r = e(112), o = {
        listen: function(e, t, n) {
          return e.addEventListener ? (e.addEventListener(t, n, !1), {
            remove: function() {
              e.removeEventListener(t, n, !1)
            }
          }) : e.attachEvent ? (e.attachEvent("on" + t, n), {
            remove: function() {
              e.detachEvent("on" + t, n)
            }
          }) : void 0
        }, capture: function(e, t, n) {
          return e.addEventListener ? (e.addEventListener(t, n, !0), {
            remove: function() {
              e.removeEventListener(t, n, !0)
            }
          }) : { remove: r }
        }, registerDefault: function() {
        }
      };
      t.exports = o
    }, { 112: 112 }],
    17: [function(e, t, n) {
      "use strict";
      var r = e(18), o = e(19), i = e(103), a = e(118), u = e(133), s = {}, l = null, c = function(e) {
        if (e) {
          var t = o.executeDispatch, n = r.getPluginModuleForEvent(e);
          n && n.executeDispatch && (t = n.executeDispatch), o.executeDispatchesInOrder(e, t), e.isPersistent() || e.constructor.release(e)
        }
      }, p = null, d = {
        injection: {
          injectMount: o.injection.injectMount, injectInstanceHandle: function(e) {
            p = e
          }, getInstanceHandle: function() {
            return p
          }, injectEventPluginOrder: r.injectEventPluginOrder, injectEventPluginsByName: r.injectEventPluginsByName
        },
        eventNameDispatchConfigs: r.eventNameDispatchConfigs,
        registrationNameModules: r.registrationNameModules,
        putListener: function(e, t, n) {
          u(!n || "function" == typeof n);
          var r = s[t] || (s[t] = {});
          r[e] = n
        },
        getListener: function(e, t) {
          var n = s[t];
          return n && n[e]
        },
        deleteListener: function(e, t) {
          var n = s[t];
          n && delete n[e]
        },
        deleteAllListeners: function(e) {
          for (var t in s)delete s[t][e]
        },
        extractEvents: function(e, t, n, o) {
          for (var a, u = r.plugins, s = 0, l = u.length; l > s; s++) {
            var c = u[s];
            if (c) {
              var p = c.extractEvents(e, t, n, o);
              p && (a = i(a, p))
            }
          }
          return a
        },
        enqueueEvents: function(e) {
          e && (l = i(l, e))
        },
        processEventQueue: function() {
          var e = l;
          l = null, a(e, c), u(!l)
        },
        __purge: function() {
          s = {}
        },
        __getListenerBank: function() {
          return s
        }
      };
      t.exports = d
    }, { 103: 103, 118: 118, 133: 133, 18: 18, 19: 19 }],
    18: [function(e, t, n) {
      "use strict";
      function r() {
        if (u)for (var e in s) {
          var t = s[e], n = u.indexOf(e);
          if (a(n > -1), !l.plugins[n]) {
            a(t.extractEvents), l.plugins[n] = t;
            var r = t.eventTypes;
            for (var i in r)a(o(r[i], t, i))
          }
        }
      }

      function o(e, t, n) {
        a(!l.eventNameDispatchConfigs.hasOwnProperty(n)), l.eventNameDispatchConfigs[n] = e;
        var r = e.phasedRegistrationNames;
        if (r) {
          for (var o in r)if (r.hasOwnProperty(o)) {
            var u = r[o];
            i(u, t, n)
          }
          return !0
        }
        return e.registrationName ? (i(e.registrationName, t, n), !0) : !1
      }

      function i(e, t, n) {
        a(!l.registrationNameModules[e]), l.registrationNameModules[e] = t, l.registrationNameDependencies[e] = t.eventTypes[n].dependencies
      }

      var a = e(133), u = null, s = {}, l = {
        plugins: [],
        eventNameDispatchConfigs: {},
        registrationNameModules: {},
        registrationNameDependencies: {},
        injectEventPluginOrder: function(e) {
          a(!u), u = Array.prototype.slice.call(e), r()
        },
        injectEventPluginsByName: function(e) {
          var t = !1;
          for (var n in e)if (e.hasOwnProperty(n)) {
            var o = e[n];
            s.hasOwnProperty(n) && s[n] === o || (a(!s[n]), s[n] = o, t = !0)
          }
          t && r()
        },
        getPluginModuleForEvent: function(e) {
          var t = e.dispatchConfig;
          if (t.registrationName)return l.registrationNameModules[t.registrationName] || null;
          for (var n in t.phasedRegistrationNames)if (t.phasedRegistrationNames.hasOwnProperty(n)) {
            var r = l.registrationNameModules[t.phasedRegistrationNames[n]];
            if (r)return r
          }
          return null
        },
        _resetEventPlugins: function() {
          u = null;
          for (var e in s)s.hasOwnProperty(e) && delete s[e];
          l.plugins.length = 0;
          var t = l.eventNameDispatchConfigs;
          for (var n in t)t.hasOwnProperty(n) && delete t[n];
          var r = l.registrationNameModules;
          for (var o in r)r.hasOwnProperty(o) && delete r[o]
        }
      };
      t.exports = l
    }, { 133: 133 }],
    19: [function(e, t, n) {
      "use strict";
      function r(e) {
        return e === v.topMouseUp || e === v.topTouchEnd || e === v.topTouchCancel
      }

      function o(e) {
        return e === v.topMouseMove || e === v.topTouchMove
      }

      function i(e) {
        return e === v.topMouseDown || e === v.topTouchStart
      }

      function a(e, t) {
        var n = e._dispatchListeners, r = e._dispatchIDs;
        if (Array.isArray(n))for (var o = 0; o < n.length && !e.isPropagationStopped(); o++)t(e, n[o], r[o]); else n && t(e, n, r)
      }

      function u(e, t, n) {
        e.currentTarget = m.Mount.getNode(n);
        var r = t(e, n);
        return e.currentTarget = null, r
      }

      function s(e, t) {
        a(e, t), e._dispatchListeners = null, e._dispatchIDs = null
      }

      function l(e) {
        var t = e._dispatchListeners, n = e._dispatchIDs;
        if (Array.isArray(t)) {
          for (var r = 0; r < t.length && !e.isPropagationStopped(); r++)if (t[r](e, n[r]))return n[r]
        } else if (t && t(e, n))return n;
        return null
      }

      function c(e) {
        var t = l(e);
        return e._dispatchIDs = null, e._dispatchListeners = null, t
      }

      function p(e) {
        var t = e._dispatchListeners, n = e._dispatchIDs;
        h(!Array.isArray(t));
        var r = t ? t(e, n) : null;
        return e._dispatchListeners = null, e._dispatchIDs = null, r
      }

      function d(e) {
        return !!e._dispatchListeners
      }

      var f = e(15), h = e(133), m = {
        Mount: null, injectMount: function(e) {
          m.Mount = e
        }
      }, v = f.topLevelTypes, g = {
        isEndish: r,
        isMoveish: o,
        isStartish: i,
        executeDirectDispatch: p,
        executeDispatch: u,
        executeDispatchesInOrder: s,
        executeDispatchesInOrderStopAtTrue: c,
        hasDispatches: d,
        injection: m,
        useTouchEvents: !1
      };
      t.exports = g
    }, { 133: 133, 15: 15 }],
    20: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        var r = t.dispatchConfig.phasedRegistrationNames[n];
        return v(e, r)
      }

      function o(e, t, n) {
        var o = t ? m.bubbled : m.captured, i = r(e, n, o);
        i && (n._dispatchListeners = f(n._dispatchListeners, i), n._dispatchIDs = f(n._dispatchIDs, e))
      }

      function i(e) {
        e && e.dispatchConfig.phasedRegistrationNames && d.injection.getInstanceHandle().traverseTwoPhase(e.dispatchMarker, o, e)
      }

      function a(e, t, n) {
        if (n && n.dispatchConfig.registrationName) {
          var r = n.dispatchConfig.registrationName, o = v(e, r);
          o && (n._dispatchListeners = f(n._dispatchListeners, o), n._dispatchIDs = f(n._dispatchIDs, e))
        }
      }

      function u(e) {
        e && e.dispatchConfig.registrationName && a(e.dispatchMarker, null, e)
      }

      function s(e) {
        h(e, i)
      }

      function l(e, t, n, r) {
        d.injection.getInstanceHandle().traverseEnterLeave(n, r, a, e, t)
      }

      function c(e) {
        h(e, u)
      }

      var p = e(15), d = e(17), f = e(103), h = e(118), m = p.PropagationPhases, v = d.getListener, g = {
        accumulateTwoPhaseDispatches: s,
        accumulateDirectDispatches: c,
        accumulateEnterLeaveDispatches: l
      };
      t.exports = g
    }, { 103: 103, 118: 118, 15: 15, 17: 17 }],
    21: [function(e, t, n) {
      "use strict";
      var r = !("undefined" == typeof window || !window.document || !window.document.createElement), o = {
        canUseDOM: r,
        canUseWorkers: "undefined" != typeof Worker,
        canUseEventListeners: r && !(!window.addEventListener && !window.attachEvent),
        canUseViewport: r && !!window.screen,
        isInWorker: !r
      };
      t.exports = o
    }, {}],
    22: [function(e, t, n) {
      "use strict";
      function r(e) {
        this._root = e, this._startText = this.getText(), this._fallbackText = null
      }

      var o = e(28), i = e(27), a = e(128);
      i(r.prototype, {
        getText: function() {
          return "value" in this._root ? this._root.value : this._root[a()]
        }, getData: function() {
          if (this._fallbackText)return this._fallbackText;
          var e, t, n = this._startText, r = n.length, o = this.getText(), i = o.length;
          for (e = 0; r > e && n[e] === o[e]; e++);
          var a = r - e;
          for (t = 1; a >= t && n[r - t] === o[i - t]; t++);
          var u = t > 1 ? 1 - t : void 0;
          return this._fallbackText = o.slice(e, u), this._fallbackText
        }
      }), o.addPoolingTo(r), t.exports = r
    }, { 128: 128, 27: 27, 28: 28 }],
    23: [function(e, t, n) {
      "use strict";
      var r, o = e(10), i = e(21), a = o.injection.MUST_USE_ATTRIBUTE, u = o.injection.MUST_USE_PROPERTY, s = o.injection.HAS_BOOLEAN_VALUE, l = o.injection.HAS_SIDE_EFFECTS, c = o.injection.HAS_NUMERIC_VALUE, p = o.injection.HAS_POSITIVE_NUMERIC_VALUE, d = o.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
      if (i.canUseDOM) {
        var f = document.implementation;
        r = f && f.hasFeature && f.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")
      }
      var h = {
        isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
        Properties: {
          accept: null,
          acceptCharset: null,
          accessKey: null,
          action: null,
          allowFullScreen: a | s,
          allowTransparency: a,
          alt: null,
          async: s,
          autoComplete: null,
          autoPlay: s,
          cellPadding: null,
          cellSpacing: null,
          charSet: a,
          checked: u | s,
          classID: a,
          className: r ? a : u,
          cols: a | p,
          colSpan: null,
          content: null,
          contentEditable: null,
          contextMenu: a,
          controls: u | s,
          coords: null,
          crossOrigin: null,
          data: null,
          dateTime: a,
          defer: s,
          dir: null,
          disabled: a | s,
          download: d,
          draggable: null,
          encType: null,
          form: a,
          formAction: a,
          formEncType: a,
          formMethod: a,
          formNoValidate: s,
          formTarget: a,
          frameBorder: a,
          headers: null,
          height: a,
          hidden: a | s,
          high: null,
          href: null,
          hrefLang: null,
          htmlFor: null,
          httpEquiv: null,
          icon: null,
          id: u,
          label: null,
          lang: null,
          list: a,
          loop: u | s,
          low: null,
          manifest: a,
          marginHeight: null,
          marginWidth: null,
          max: null,
          maxLength: a,
          media: a,
          mediaGroup: null,
          method: null,
          min: null,
          multiple: u | s,
          muted: u | s,
          name: null,
          noValidate: s,
          open: s,
          optimum: null,
          pattern: null,
          placeholder: null,
          poster: null,
          preload: null,
          radioGroup: null,
          readOnly: u | s,
          rel: null,
          required: s,
          role: a,
          rows: a | p,
          rowSpan: null,
          sandbox: null,
          scope: null,
          scoped: s,
          scrolling: null,
          seamless: a | s,
          selected: u | s,
          shape: null,
          size: a | p,
          sizes: a,
          span: p,
          spellCheck: null,
          src: null,
          srcDoc: u,
          srcSet: a,
          start: c,
          step: null,
          style: null,
          tabIndex: null,
          target: null,
          title: null,
          type: null,
          useMap: null,
          value: u | l,
          width: a,
          wmode: a,
          autoCapitalize: null,
          autoCorrect: null,
          itemProp: a,
          itemScope: a | s,
          itemType: a,
          itemID: a,
          itemRef: a,
          property: null,
          unselectable: a
        },
        DOMAttributeNames: {
          acceptCharset: "accept-charset",
          className: "class",
          htmlFor: "for",
          httpEquiv: "http-equiv"
        },
        DOMPropertyNames: {
          autoCapitalize: "autocapitalize",
          autoComplete: "autocomplete",
          autoCorrect: "autocorrect",
          autoFocus: "autofocus",
          autoPlay: "autoplay",
          encType: "encoding",
          hrefLang: "hreflang",
          radioGroup: "radiogroup",
          spellCheck: "spellcheck",
          srcDoc: "srcdoc",
          srcSet: "srcset"
        }
      };
      t.exports = h
    }, { 10: 10, 21: 21 }],
    24: [function(e, t, n) {
      "use strict";
      function r(e) {
        l(null == e.props.checkedLink || null == e.props.valueLink)
      }

      function o(e) {
        r(e), l(null == e.props.value && null == e.props.onChange)
      }

      function i(e) {
        r(e), l(null == e.props.checked && null == e.props.onChange)
      }

      function a(e) {
        this.props.valueLink.requestChange(e.target.value)
      }

      function u(e) {
        this.props.checkedLink.requestChange(e.target.checked)
      }

      var s = e(76), l = e(133), c = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      }, p = {
        Mixin: {
          propTypes: {
            value: function(e, t, n) {
              return !e[t] || c[e.type] || e.onChange || e.readOnly || e.disabled ? null : new Error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.")
            }, checked: function(e, t, n) {
              return !e[t] || e.onChange || e.readOnly || e.disabled ? null : new Error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.")
            }, onChange: s.func
          }
        }, getValue: function(e) {
          return e.props.valueLink ? (o(e), e.props.valueLink.value) : e.props.value
        }, getChecked: function(e) {
          return e.props.checkedLink ? (i(e), e.props.checkedLink.value) : e.props.checked
        }, getOnChange: function(e) {
          return e.props.valueLink ? (o(e), a) : e.props.checkedLink ? (i(e), u) : e.props.onChange
        }
      };
      t.exports = p
    }, { 133: 133, 76: 76 }],
    25: [function(e, t, n) {
      "use strict";
      function r(e) {
        e.remove()
      }

      var o = e(30), i = e(103), a = e(118), u = e(133), s = {
        trapBubbledEvent: function(e, t) {
          u(this.isMounted());
          var n = this.getDOMNode();
          u(n);
          var r = o.trapBubbledEvent(e, t, n);
          this._localEventListeners = i(this._localEventListeners, r)
        }, componentWillUnmount: function() {
          this._localEventListeners && a(this._localEventListeners, r)
        }
      };
      t.exports = s
    }, { 103: 103, 118: 118, 133: 133, 30: 30 }],
    26: [function(e, t, n) {
      "use strict";
      var r = e(15), o = e(112), i = r.topLevelTypes, a = {
        eventTypes: null, extractEvents: function(e, t, n, r) {
          if (e === i.topTouchStart) {
            var a = r.target;
            a && !a.onclick && (a.onclick = o)
          }
        }
      };
      t.exports = a
    }, { 112: 112, 15: 15 }],
    27: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        if (null == e)throw new TypeError("Object.assign target cannot be null or undefined");
        for (var n = Object(e), r = Object.prototype.hasOwnProperty, o = 1; o < arguments.length; o++) {
          var i = arguments[o];
          if (null != i) {
            var a = Object(i);
            for (var u in a)r.call(a, u) && (n[u] = a[u])
          }
        }
        return n
      }

      t.exports = r
    }, {}],
    28: [function(e, t, n) {
      "use strict";
      var r = e(133), o = function(e) {
        var t = this;
        if (t.instancePool.length) {
          var n = t.instancePool.pop();
          return t.call(n, e), n
        }
        return new t(e)
      }, i = function(e, t) {
        var n = this;
        if (n.instancePool.length) {
          var r = n.instancePool.pop();
          return n.call(r, e, t), r
        }
        return new n(e, t)
      }, a = function(e, t, n) {
        var r = this;
        if (r.instancePool.length) {
          var o = r.instancePool.pop();
          return r.call(o, e, t, n), o
        }
        return new r(e, t, n)
      }, u = function(e, t, n, r, o) {
        var i = this;
        if (i.instancePool.length) {
          var a = i.instancePool.pop();
          return i.call(a, e, t, n, r, o), a
        }
        return new i(e, t, n, r, o)
      }, s = function(e) {
        var t = this;
        r(e instanceof t), e.destructor && e.destructor(), t.instancePool.length < t.poolSize && t.instancePool.push(e)
      }, l = 10, c = o, p = function(e, t) {
        var n = e;
        return n.instancePool = [], n.getPooled = t || c, n.poolSize || (n.poolSize = l), n.release = s, n
      }, d = {
        addPoolingTo: p,
        oneArgumentPooler: o,
        twoArgumentPooler: i,
        threeArgumentPooler: a,
        fiveArgumentPooler: u
      };
      t.exports = d
    }, { 133: 133 }],
    29: [function(e, t, n) {
      "use strict";
      var r = e(115), o = {
        getDOMNode: function() {
          return r(this)
        }
      };
      t.exports = o
    }, { 115: 115 }],
    30: [function(e, t, n) {
      "use strict";
      function r(e) {
        return Object.prototype.hasOwnProperty.call(e, m) || (e[m] = f++, p[e[m]] = {}), p[e[m]]
      }

      var o = e(15), i = e(17), a = e(18), u = e(59), s = e(102), l = e(27), c = e(134), p = {}, d = !1, f = 0, h = {
        topBlur: "blur",
        topChange: "change",
        topClick: "click",
        topCompositionEnd: "compositionend",
        topCompositionStart: "compositionstart",
        topCompositionUpdate: "compositionupdate",
        topContextMenu: "contextmenu",
        topCopy: "copy",
        topCut: "cut",
        topDoubleClick: "dblclick",
        topDrag: "drag",
        topDragEnd: "dragend",
        topDragEnter: "dragenter",
        topDragExit: "dragexit",
        topDragLeave: "dragleave",
        topDragOver: "dragover",
        topDragStart: "dragstart",
        topDrop: "drop",
        topFocus: "focus",
        topInput: "input",
        topKeyDown: "keydown",
        topKeyPress: "keypress",
        topKeyUp: "keyup",
        topMouseDown: "mousedown",
        topMouseMove: "mousemove",
        topMouseOut: "mouseout",
        topMouseOver: "mouseover",
        topMouseUp: "mouseup",
        topPaste: "paste",
        topScroll: "scroll",
        topSelectionChange: "selectionchange",
        topTextInput: "textInput",
        topTouchCancel: "touchcancel",
        topTouchEnd: "touchend",
        topTouchMove: "touchmove",
        topTouchStart: "touchstart",
        topWheel: "wheel"
      }, m = "_reactListenersID" + String(Math.random()).slice(2), v = l({}, u, {
        ReactEventListener: null,
        injection: {
          injectReactEventListener: function(e) {
            e.setHandleTopLevel(v.handleTopLevel), v.ReactEventListener = e
          }
        },
        setEnabled: function(e) {
          v.ReactEventListener && v.ReactEventListener.setEnabled(e)
        },
        isEnabled: function() {
          return !(!v.ReactEventListener || !v.ReactEventListener.isEnabled())
        },
        listenTo: function(e, t) {
          for (var n = t, i = r(n), u = a.registrationNameDependencies[e], s = o.topLevelTypes, l = 0, p = u.length; p > l; l++) {
            var d = u[l];
            i.hasOwnProperty(d) && i[d] || (d === s.topWheel ? c("wheel") ? v.ReactEventListener.trapBubbledEvent(s.topWheel, "wheel", n) : c("mousewheel") ? v.ReactEventListener.trapBubbledEvent(s.topWheel, "mousewheel", n) : v.ReactEventListener.trapBubbledEvent(s.topWheel, "DOMMouseScroll", n) : d === s.topScroll ? c("scroll", !0) ? v.ReactEventListener.trapCapturedEvent(s.topScroll, "scroll", n) : v.ReactEventListener.trapBubbledEvent(s.topScroll, "scroll", v.ReactEventListener.WINDOW_HANDLE) : d === s.topFocus || d === s.topBlur ? (c("focus", !0) ? (v.ReactEventListener.trapCapturedEvent(s.topFocus, "focus", n), v.ReactEventListener.trapCapturedEvent(s.topBlur, "blur", n)) : c("focusin") && (v.ReactEventListener.trapBubbledEvent(s.topFocus, "focusin", n), v.ReactEventListener.trapBubbledEvent(s.topBlur, "focusout", n)), i[s.topBlur] = !0, i[s.topFocus] = !0) : h.hasOwnProperty(d) && v.ReactEventListener.trapBubbledEvent(d, h[d], n), i[d] = !0)
          }
        },
        trapBubbledEvent: function(e, t, n) {
          return v.ReactEventListener.trapBubbledEvent(e, t, n)
        },
        trapCapturedEvent: function(e, t, n) {
          return v.ReactEventListener.trapCapturedEvent(e, t, n)
        },
        ensureScrollValueMonitoring: function() {
          if (!d) {
            var e = s.refreshScrollValues;
            v.ReactEventListener.monitorScrollValue(e), d = !0
          }
        },
        eventNameDispatchConfigs: i.eventNameDispatchConfigs,
        registrationNameModules: i.registrationNameModules,
        putListener: i.putListener,
        getListener: i.getListener,
        deleteListener: i.deleteListener,
        deleteAllListeners: i.deleteAllListeners
      });
      t.exports = v
    }, { 102: 102, 134: 134, 15: 15, 17: 17, 18: 18, 27: 27, 59: 59 }],
    31: [function(e, t, n) {
      "use strict";
      var r = e(79), o = e(116), i = e(132), a = e(147), u = {
        instantiateChildren: function(e, t, n) {
          var r = o(e);
          for (var a in r)if (r.hasOwnProperty(a)) {
            var u = r[a], s = i(u, null);
            r[a] = s
          }
          return r
        }, updateChildren: function(e, t, n, u) {
          var s = o(t);
          if (!s && !e)return null;
          var l;
          for (l in s)if (s.hasOwnProperty(l)) {
            var c = e && e[l], p = c && c._currentElement, d = s[l];
            if (a(p, d))r.receiveComponent(c, d, n, u), s[l] = c; else {
              c && r.unmountComponent(c, l);
              var f = i(d, null);
              s[l] = f
            }
          }
          for (l in e)!e.hasOwnProperty(l) || s && s.hasOwnProperty(l) || r.unmountComponent(e[l]);
          return s
        }, unmountChildren: function(e) {
          for (var t in e) {
            var n = e[t];
            r.unmountComponent(n)
          }
        }
      };
      t.exports = u
    }, { 116: 116, 132: 132, 147: 147, 79: 79 }],
    32: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        this.forEachFunction = e, this.forEachContext = t
      }

      function o(e, t, n, r) {
        var o = e;
        o.forEachFunction.call(o.forEachContext, t, r)
      }

      function i(e, t, n) {
        if (null == e)return e;
        var i = r.getPooled(t, n);
        f(e, o, i), r.release(i)
      }

      function a(e, t, n) {
        this.mapResult = e, this.mapFunction = t, this.mapContext = n
      }

      function u(e, t, n, r) {
        var o = e, i = o.mapResult, a = !i.hasOwnProperty(n);
        if (a) {
          var u = o.mapFunction.call(o.mapContext, t, r);
          i[n] = u
        }
      }

      function s(e, t, n) {
        if (null == e)return e;
        var r = {}, o = a.getPooled(r, t, n);
        return f(e, u, o), a.release(o), d.create(r)
      }

      function l(e, t, n, r) {
        return null
      }

      function c(e, t) {
        return f(e, l, null)
      }

      var p = e(28), d = e(61), f = e(149), h = (e(150), p.twoArgumentPooler), m = p.threeArgumentPooler;
      p.addPoolingTo(r, h), p.addPoolingTo(a, m);
      var v = { forEach: i, map: s, count: c };
      t.exports = v
    }, { 149: 149, 150: 150, 28: 28, 61: 61 }],
    33: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        var n = D.hasOwnProperty(t) ? D[t] : null;
        N.hasOwnProperty(t) && y(n === _.OVERRIDE_BASE), e.hasOwnProperty(t) && y(n === _.DEFINE_MANY || n === _.DEFINE_MANY_MERGED)
      }

      function o(e, t) {
        if (t) {
          y("function" != typeof t), y(!d.isValidElement(t));
          var n = e.prototype;
          t.hasOwnProperty(b) && M.mixins(e, t.mixins);
          for (var o in t)if (t.hasOwnProperty(o) && o !== b) {
            var i = t[o];
            if (r(n, o), M.hasOwnProperty(o))M[o](e, i); else {
              var a = D.hasOwnProperty(o), l = n.hasOwnProperty(o), c = i && i.__reactDontBind, p = "function" == typeof i, f = p && !a && !l && !c;
              if (f)n.__reactAutoBindMap || (n.__reactAutoBindMap = {}), n.__reactAutoBindMap[o] = i, n[o] = i; else if (l) {
                var h = D[o];
                y(a && (h === _.DEFINE_MANY_MERGED || h === _.DEFINE_MANY)), h === _.DEFINE_MANY_MERGED ? n[o] = u(n[o], i) : h === _.DEFINE_MANY && (n[o] = s(n[o], i))
              } else n[o] = i
            }
          }
        }
      }

      function i(e, t) {
        if (t)for (var n in t) {
          var r = t[n];
          if (t.hasOwnProperty(n)) {
            var o = n in M;
            y(!o);
            var i = n in e;
            y(!i), e[n] = r
          }
        }
      }

      function a(e, t) {
        y(e && t && "object" == typeof e && "object" == typeof t);
        for (var n in t)t.hasOwnProperty(n) && (y(void 0 === e[n]), e[n] = t[n]);
        return e
      }

      function u(e, t) {
        return function() {
          var n = e.apply(this, arguments), r = t.apply(this, arguments);
          if (null == n)return r;
          if (null == r)return n;
          var o = {};
          return a(o, n), a(o, r), o
        }
      }

      function s(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments)
        }
      }

      function l(e, t) {
        var n = t.bind(e);
        return n
      }

      function c(e) {
        for (var t in e.__reactAutoBindMap)if (e.__reactAutoBindMap.hasOwnProperty(t)) {
          var n = e.__reactAutoBindMap[t];
          e[t] = l(e, f.guard(n, e.constructor.displayName + "." + t))
        }
      }

      var p = e(34), d = (e(39), e(55)), f = e(58), h = e(65), m = e(66), v = (e(75), e(74), e(84)), g = e(27), y = e(133), C = e(138), E = e(139), b = (e(150), E({ mixins: null })), _ = C({
        DEFINE_ONCE: null,
        DEFINE_MANY: null,
        OVERRIDE_BASE: null,
        DEFINE_MANY_MERGED: null
      }), x = [], D = {
        mixins: _.DEFINE_MANY,
        statics: _.DEFINE_MANY,
        propTypes: _.DEFINE_MANY,
        contextTypes: _.DEFINE_MANY,
        childContextTypes: _.DEFINE_MANY,
        getDefaultProps: _.DEFINE_MANY_MERGED,
        getInitialState: _.DEFINE_MANY_MERGED,
        getChildContext: _.DEFINE_MANY_MERGED,
        render: _.DEFINE_ONCE,
        componentWillMount: _.DEFINE_MANY,
        componentDidMount: _.DEFINE_MANY,
        componentWillReceiveProps: _.DEFINE_MANY,
        shouldComponentUpdate: _.DEFINE_ONCE,
        componentWillUpdate: _.DEFINE_MANY,
        componentDidUpdate: _.DEFINE_MANY,
        componentWillUnmount: _.DEFINE_MANY,
        updateComponent: _.OVERRIDE_BASE
      }, M = {
        displayName: function(e, t) {
          e.displayName = t
        }, mixins: function(e, t) {
          if (t)for (var n = 0; n < t.length; n++)o(e, t[n])
        }, childContextTypes: function(e, t) {
          e.childContextTypes = g({}, e.childContextTypes, t)
        }, contextTypes: function(e, t) {
          e.contextTypes = g({}, e.contextTypes, t)
        }, getDefaultProps: function(e, t) {
          e.getDefaultProps ? e.getDefaultProps = u(e.getDefaultProps, t) : e.getDefaultProps = t
        }, propTypes: function(e, t) {
          e.propTypes = g({}, e.propTypes, t)
        }, statics: function(e, t) {
          i(e, t)
        }
      }, N = {
        replaceState: function(e, t) {
          v.enqueueReplaceState(this, e), t && v.enqueueCallback(this, t)
        }, isMounted: function() {
          var e = h.get(this);
          return e && e !== m.currentlyMountingInstance
        }, setProps: function(e, t) {
          v.enqueueSetProps(this, e), t && v.enqueueCallback(this, t)
        }, replaceProps: function(e, t) {
          v.enqueueReplaceProps(this, e), t && v.enqueueCallback(this, t)
        }
      }, I = function() {
      };
      g(I.prototype, p.prototype, N);
      var T = {
        createClass: function(e) {
          var t = function(e, t) {
            this.__reactAutoBindMap && c(this), this.props = e, this.context = t, this.state = null;
            var n = this.getInitialState ? this.getInitialState() : null;
            y("object" == typeof n && !Array.isArray(n)), this.state = n
          };
          t.prototype = new I, t.prototype.constructor = t, x.forEach(o.bind(null, t)), o(t, e), t.getDefaultProps && (t.defaultProps = t.getDefaultProps()), y(t.prototype.render);
          for (var n in D)t.prototype[n] || (t.prototype[n] = null);
          return t.type = t, t
        }, injection: {
          injectMixin: function(e) {
            x.push(e)
          }
        }
      };
      t.exports = T
    }, {
      133: 133,
      138: 138,
      139: 139,
      150: 150,
      27: 27,
      34: 34,
      39: 39,
      55: 55,
      58: 58,
      65: 65,
      66: 66,
      74: 74,
      75: 75,
      84: 84
    }],
    34: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        this.props = e, this.context = t
      }

      {
        var o = e(84), i = e(133);
        e(150)
      }
      r.prototype.setState = function(e, t) {
        i("object" == typeof e || "function" == typeof e || null == e), o.enqueueSetState(this, e), t && o.enqueueCallback(this, t)
      }, r.prototype.forceUpdate = function(e) {
        o.enqueueForceUpdate(this), e && o.enqueueCallback(this, e)
      };
      t.exports = r
    }, { 133: 133, 150: 150, 84: 84 }],
    35: [function(e, t, n) {
      "use strict";
      var r = e(44), o = e(68), i = {
        processChildrenUpdates: r.dangerouslyProcessChildrenUpdates,
        replaceNodeWithMarkupByID: r.dangerouslyReplaceNodeWithMarkupByID,
        unmountIDFromEnvironment: function(e) {
          o.purgeID(e)
        }
      };
      t.exports = i
    }, { 44: 44, 68: 68 }],
    36: [function(e, t, n) {
      "use strict";
      var r = e(133), o = !1, i = {
        unmountIDFromEnvironment: null,
        replaceNodeWithMarkupByID: null,
        processChildrenUpdates: null,
        injection: {
          injectEnvironment: function(e) {
            r(!o), i.unmountIDFromEnvironment = e.unmountIDFromEnvironment, i.replaceNodeWithMarkupByID = e.replaceNodeWithMarkupByID, i.processChildrenUpdates = e.processChildrenUpdates, o = !0
          }
        }
      };
      t.exports = i
    }, { 133: 133 }],
    37: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = e._currentElement._owner || null;
        if (t) {
          var n = t.getName();
          if (n)return " Check the render method of `" + n + "`."
        }
        return ""
      }

      var o = e(36), i = e(38), a = e(39), u = e(55), s = (e(56), e(65)), l = e(66), c = e(71), p = e(73), d = e(75), f = (e(74), e(79)), h = e(85), m = e(27), v = e(113), g = e(133), y = e(147), C = (e(150), 1), E = {
        construct: function(e) {
          this._currentElement = e, this._rootNodeID = null, this._instance = null, this._pendingElement = null, this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1, this._renderedComponent = null, this._context = null, this._mountOrder = 0, this._isTopLevel = !1, this._pendingCallbacks = null
        }, mountComponent: function(e, t, n) {
          this._context = n, this._mountOrder = C++, this._rootNodeID = e;
          var r = this._processProps(this._currentElement.props), o = this._processContext(this._currentElement._context), i = c.getComponentClassForElement(this._currentElement), a = new i(r, o);
          a.props = r, a.context = o, a.refs = v, this._instance = a, s.set(a, this);
          var u = a.state;
          void 0 === u && (a.state = u = null), g("object" == typeof u && !Array.isArray(u)), this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1;
          var p, d, h = l.currentlyMountingInstance;
          l.currentlyMountingInstance = this;
          try {
            a.componentWillMount && (a.componentWillMount(), this._pendingStateQueue && (a.state = this._processPendingState(a.props, a.context))), p = this._getValidatedChildContext(n), d = this._renderValidatedComponent(p)
          } finally {
            l.currentlyMountingInstance = h
          }
          this._renderedComponent = this._instantiateReactComponent(d, this._currentElement.type);
          var m = f.mountComponent(this._renderedComponent, e, t, this._mergeChildContext(n, p));
          return a.componentDidMount && t.getReactMountReady().enqueue(a.componentDidMount, a), m
        }, unmountComponent: function() {
          var e = this._instance;
          if (e.componentWillUnmount) {
            var t = l.currentlyUnmountingInstance;
            l.currentlyUnmountingInstance = this;
            try {
              e.componentWillUnmount()
            } finally {
              l.currentlyUnmountingInstance = t
            }
          }
          f.unmountComponent(this._renderedComponent), this._renderedComponent = null, this._pendingStateQueue = null, this._pendingReplaceState = !1, this._pendingForceUpdate = !1, this._pendingCallbacks = null, this._pendingElement = null, this._context = null, this._rootNodeID = null, s.remove(e)
        }, _setPropsInternal: function(e, t) {
          var n = this._pendingElement || this._currentElement;
          this._pendingElement = u.cloneAndReplaceProps(n, m({}, n.props, e)), h.enqueueUpdate(this, t)
        }, _maskContext: function(e) {
          var t = null;
          if ("string" == typeof this._currentElement.type)return v;
          var n = this._currentElement.type.contextTypes;
          if (!n)return v;
          t = {};
          for (var r in n)t[r] = e[r];
          return t
        }, _processContext: function(e) {
          var t = this._maskContext(e);
          return t
        }, _getValidatedChildContext: function(e) {
          var t = this._instance, n = t.getChildContext && t.getChildContext();
          if (n) {
            g("object" == typeof t.constructor.childContextTypes);
            for (var r in n)g(r in t.constructor.childContextTypes);
            return n
          }
          return null
        }, _mergeChildContext: function(e, t) {
          return t ? m({}, e, t) : e
        }, _processProps: function(e) {
          return e
        }, _checkPropTypes: function(e, t, n) {
          var o = this.getName();
          for (var i in e)if (e.hasOwnProperty(i)) {
            var a;
            try {
              g("function" == typeof e[i]), a = e[i](t, i, o, n)
            } catch (u) {
              a = u
            }
            a instanceof Error && (r(this), n === d.prop)
          }
        }, receiveComponent: function(e, t, n) {
          var r = this._currentElement, o = this._context;
          this._pendingElement = null, this.updateComponent(t, r, e, o, n)
        }, performUpdateIfNecessary: function(e) {
          null != this._pendingElement && f.receiveComponent(this, this._pendingElement || this._currentElement, e, this._context), (null !== this._pendingStateQueue || this._pendingForceUpdate) && this.updateComponent(e, this._currentElement, this._currentElement, this._context, this._context)
        }, _warnIfContextsDiffer: function(e, t) {
          e = this._maskContext(e), t = this._maskContext(t);
          for (var n = Object.keys(t).sort(), r = (this.getName() || "ReactCompositeComponent", 0); r < n.length; r++)n[r]
        }, updateComponent: function(e, t, n, r, o) {
          var i = this._instance, a = i.context, u = i.props;
          t !== n && (a = this._processContext(n._context), u = this._processProps(n.props), i.componentWillReceiveProps && i.componentWillReceiveProps(u, a));
          var s = this._processPendingState(u, a), l = this._pendingForceUpdate || !i.shouldComponentUpdate || i.shouldComponentUpdate(u, s, a);
          l ? (this._pendingForceUpdate = !1, this._performComponentUpdate(n, u, s, a, e, o)) : (this._currentElement = n, this._context = o, i.props = u, i.state = s, i.context = a)
        }, _processPendingState: function(e, t) {
          var n = this._instance, r = this._pendingStateQueue, o = this._pendingReplaceState;
          if (this._pendingReplaceState = !1, this._pendingStateQueue = null, !r)return n.state;
          if (o && 1 === r.length)return r[0];
          for (var i = m({}, o ? r[0] : n.state), a = o ? 1 : 0; a < r.length; a++) {
            var u = r[a];
            m(i, "function" == typeof u ? u.call(n, i, e, t) : u)
          }
          return i
        }, _performComponentUpdate: function(e, t, n, r, o, i) {
          var a = this._instance, u = a.props, s = a.state, l = a.context;
          a.componentWillUpdate && a.componentWillUpdate(t, n, r), this._currentElement = e, this._context = i, a.props = t, a.state = n, a.context = r, this._updateRenderedComponent(o, i), a.componentDidUpdate && o.getReactMountReady().enqueue(a.componentDidUpdate.bind(a, u, s, l), a)
        }, _updateRenderedComponent: function(e, t) {
          var n = this._renderedComponent, r = n._currentElement, o = this._getValidatedChildContext(), i = this._renderValidatedComponent(o);
          if (y(r, i))f.receiveComponent(n, i, e, this._mergeChildContext(t, o)); else {
            var a = this._rootNodeID, u = n._rootNodeID;
            f.unmountComponent(n), this._renderedComponent = this._instantiateReactComponent(i, this._currentElement.type);
            var s = f.mountComponent(this._renderedComponent, a, e, this._mergeChildContext(t, o));
            this._replaceNodeWithMarkupByID(u, s)
          }
        }, _replaceNodeWithMarkupByID: function(e, t) {
          o.replaceNodeWithMarkupByID(e, t)
        }, _renderValidatedComponentWithoutOwnerOrContext: function() {
          var e = this._instance, t = e.render();
          return t
        }, _renderValidatedComponent: function(e) {
          var t, n = i.current;
          i.current = this._mergeChildContext(this._currentElement._context, e), a.current = this;
          try {
            t = this._renderValidatedComponentWithoutOwnerOrContext()
          } finally {
            i.current = n, a.current = null
          }
          return g(null === t || t === !1 || u.isValidElement(t)), t
        }, attachRef: function(e, t) {
          var n = this.getPublicInstance(), r = n.refs === v ? n.refs = {} : n.refs;
          r[e] = t.getPublicInstance()
        }, detachRef: function(e) {
          var t = this.getPublicInstance().refs;
          delete t[e]
        }, getName: function() {
          var e = this._currentElement.type, t = this._instance && this._instance.constructor;
          return e.displayName || t && t.displayName || e.name || t && t.name || null
        }, getPublicInstance: function() {
          return this._instance
        }, _instantiateReactComponent: null
      };
      p.measureMethods(E, "ReactCompositeComponent", {
        mountComponent: "mountComponent",
        updateComponent: "updateComponent",
        _renderValidatedComponent: "_renderValidatedComponent"
      });
      var b = { Mixin: E };
      t.exports = b
    }, {
      113: 113,
      133: 133,
      147: 147,
      150: 150,
      27: 27,
      36: 36,
      38: 38,
      39: 39,
      55: 55,
      56: 56,
      65: 65,
      66: 66,
      71: 71,
      73: 73,
      74: 74,
      75: 75,
      79: 79,
      85: 85
    }],
    38: [function(e, t, n) {
      "use strict";
      var r = e(27), o = e(113), i = (e(150), {
        current: o, withContext: function(e, t) {
          var n, o = i.current;
          i.current = r({}, o, e);
          try {
            n = t()
          } finally {
            i.current = o
          }
          return n
        }
      });
      t.exports = i
    }, { 113: 113, 150: 150, 27: 27 }],
    39: [function(e, t, n) {
      "use strict";
      var r = { current: null };
      t.exports = r
    }, {}],
    40: [function(e, t, n) {
      "use strict";
      function r(e) {
        return o.createFactory(e)
      }

      var o = e(55), i = (e(56), e(140)), a = i({
        a: "a",
        abbr: "abbr",
        address: "address",
        area: "area",
        article: "article",
        aside: "aside",
        audio: "audio",
        b: "b",
        base: "base",
        bdi: "bdi",
        bdo: "bdo",
        big: "big",
        blockquote: "blockquote",
        body: "body",
        br: "br",
        button: "button",
        canvas: "canvas",
        caption: "caption",
        cite: "cite",
        code: "code",
        col: "col",
        colgroup: "colgroup",
        data: "data",
        datalist: "datalist",
        dd: "dd",
        del: "del",
        details: "details",
        dfn: "dfn",
        dialog: "dialog",
        div: "div",
        dl: "dl",
        dt: "dt",
        em: "em",
        embed: "embed",
        fieldset: "fieldset",
        figcaption: "figcaption",
        figure: "figure",
        footer: "footer",
        form: "form",
        h1: "h1",
        h2: "h2",
        h3: "h3",
        h4: "h4",
        h5: "h5",
        h6: "h6",
        head: "head",
        header: "header",
        hr: "hr",
        html: "html",
        i: "i",
        iframe: "iframe",
        img: "img",
        input: "input",
        ins: "ins",
        kbd: "kbd",
        keygen: "keygen",
        label: "label",
        legend: "legend",
        li: "li",
        link: "link",
        main: "main",
        map: "map",
        mark: "mark",
        menu: "menu",
        menuitem: "menuitem",
        meta: "meta",
        meter: "meter",
        nav: "nav",
        noscript: "noscript",
        object: "object",
        ol: "ol",
        optgroup: "optgroup",
        option: "option",
        output: "output",
        p: "p",
        param: "param",
        picture: "picture",
        pre: "pre",
        progress: "progress",
        q: "q",
        rp: "rp",
        rt: "rt",
        ruby: "ruby",
        s: "s",
        samp: "samp",
        script: "script",
        section: "section",
        select: "select",
        small: "small",
        source: "source",
        span: "span",
        strong: "strong",
        style: "style",
        sub: "sub",
        summary: "summary",
        sup: "sup",
        table: "table",
        tbody: "tbody",
        td: "td",
        textarea: "textarea",
        tfoot: "tfoot",
        th: "th",
        thead: "thead",
        time: "time",
        title: "title",
        tr: "tr",
        track: "track",
        u: "u",
        ul: "ul",
        "var": "var",
        video: "video",
        wbr: "wbr",
        circle: "circle",
        clipPath: "clipPath",
        defs: "defs",
        ellipse: "ellipse",
        g: "g",
        line: "line",
        linearGradient: "linearGradient",
        mask: "mask",
        path: "path",
        pattern: "pattern",
        polygon: "polygon",
        polyline: "polyline",
        radialGradient: "radialGradient",
        rect: "rect",
        stop: "stop",
        svg: "svg",
        text: "text",
        tspan: "tspan"
      }, r);
      t.exports = a
    }, { 140: 140, 55: 55, 56: 56 }],
    41: [function(e, t, n) {
      "use strict";
      var r = e(2), o = e(29), i = e(33), a = e(55), u = e(138), s = a.createFactory("button"), l = u({
        onClick: !0,
        onDoubleClick: !0,
        onMouseDown: !0,
        onMouseMove: !0,
        onMouseUp: !0,
        onClickCapture: !0,
        onDoubleClickCapture: !0,
        onMouseDownCapture: !0,
        onMouseMoveCapture: !0,
        onMouseUpCapture: !0
      }), c = i.createClass({
        displayName: "ReactDOMButton", tagName: "BUTTON", mixins: [r, o], render: function() {
          var e = {};
          for (var t in this.props)!this.props.hasOwnProperty(t) || this.props.disabled && l[t] || (e[t] = this.props[t]);
          return s(e, this.props.children)
        }
      });
      t.exports = c
    }, { 138: 138, 2: 2, 29: 29, 33: 33, 55: 55 }],
    42: [function(e, t, n) {
      "use strict";
      function r(e) {
        e && (null != e.dangerouslySetInnerHTML && (g(null == e.children), g("object" == typeof e.dangerouslySetInnerHTML && "__html" in e.dangerouslySetInnerHTML)), g(null == e.style || "object" == typeof e.style))
      }

      function o(e, t, n, r) {
        var o = d.findReactContainerForID(e);
        if (o) {
          var i = o.nodeType === D ? o.ownerDocument : o;
          E(t, i)
        }
        r.getPutListenerQueue().enqueuePutListener(e, t, n)
      }

      function i(e) {
        P.call(T, e) || (g(I.test(e)), T[e] = !0)
      }

      function a(e) {
        i(e), this._tag = e, this._renderedChildren = null, this._previousStyleCopy = null, this._rootNodeID = null
      }

      var u = e(5), s = e(10), l = e(11), c = e(30), p = e(35), d = e(68), f = e(69), h = e(73), m = e(27), v = e(114), g = e(133), y = (e(134), e(139)), C = (e(150), c.deleteListener), E = c.listenTo, b = c.registrationNameModules, _ = {
        string: !0,
        number: !0
      }, x = y({ style: null }), D = 1, M = null, N = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, I = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, T = {}, P = {}.hasOwnProperty;
      a.displayName = "ReactDOMComponent", a.Mixin = {
        construct: function(e) {
          this._currentElement = e
        }, mountComponent: function(e, t, n) {
          this._rootNodeID = e, r(this._currentElement.props);
          var o = N[this._tag] ? "" : "</" + this._tag + ">";
          return this._createOpenTagMarkupAndPutListeners(t) + this._createContentMarkup(t, n) + o
        }, _createOpenTagMarkupAndPutListeners: function(e) {
          var t = this._currentElement.props, n = "<" + this._tag;
          for (var r in t)if (t.hasOwnProperty(r)) {
            var i = t[r];
            if (null != i)if (b.hasOwnProperty(r))o(this._rootNodeID, r, i, e); else {
              r === x && (i && (i = this._previousStyleCopy = m({}, t.style)), i = u.createMarkupForStyles(i));
              var a = l.createMarkupForProperty(r, i);
              a && (n += " " + a)
            }
          }
          if (e.renderToStaticMarkup)return n + ">";
          var s = l.createMarkupForID(this._rootNodeID);
          return n + " " + s + ">"
        }, _createContentMarkup: function(e, t) {
          var n = "";
          ("listing" === this._tag || "pre" === this._tag || "textarea" === this._tag) && (n = "\n");
          var r = this._currentElement.props, o = r.dangerouslySetInnerHTML;
          if (null != o) {
            if (null != o.__html)return n + o.__html
          } else {
            var i = _[typeof r.children] ? r.children : null, a = null != i ? null : r.children;
            if (null != i)return n + v(i);
            if (null != a) {
              var u = this.mountChildren(a, e, t);
              return n + u.join("")
            }
          }
          return n
        }, receiveComponent: function(e, t, n) {
          var r = this._currentElement;
          this._currentElement = e, this.updateComponent(t, r, e, n)
        }, updateComponent: function(e, t, n, o) {
          r(this._currentElement.props), this._updateDOMProperties(t.props, e), this._updateDOMChildren(t.props, e, o)
        }, _updateDOMProperties: function(e, t) {
          var n, r, i, a = this._currentElement.props;
          for (n in e)if (!a.hasOwnProperty(n) && e.hasOwnProperty(n))if (n === x) {
            var u = this._previousStyleCopy;
            for (r in u)u.hasOwnProperty(r) && (i = i || {}, i[r] = "");
            this._previousStyleCopy = null
          } else b.hasOwnProperty(n) ? C(this._rootNodeID, n) : (s.isStandardName[n] || s.isCustomAttribute(n)) && M.deletePropertyByID(this._rootNodeID, n);
          for (n in a) {
            var l = a[n], c = n === x ? this._previousStyleCopy : e[n];
            if (a.hasOwnProperty(n) && l !== c)if (n === x)if (l ? l = this._previousStyleCopy = m({}, l) : this._previousStyleCopy = null, c) {
              for (r in c)!c.hasOwnProperty(r) || l && l.hasOwnProperty(r) || (i = i || {}, i[r] = "");
              for (r in l)l.hasOwnProperty(r) && c[r] !== l[r] && (i = i || {}, i[r] = l[r])
            } else i = l; else b.hasOwnProperty(n) ? o(this._rootNodeID, n, l, t) : (s.isStandardName[n] || s.isCustomAttribute(n)) && M.updatePropertyByID(this._rootNodeID, n, l)
          }
          i && M.updateStylesByID(this._rootNodeID, i)
        }, _updateDOMChildren: function(e, t, n) {
          var r = this._currentElement.props, o = _[typeof e.children] ? e.children : null, i = _[typeof r.children] ? r.children : null, a = e.dangerouslySetInnerHTML && e.dangerouslySetInnerHTML.__html, u = r.dangerouslySetInnerHTML && r.dangerouslySetInnerHTML.__html, s = null != o ? null : e.children, l = null != i ? null : r.children, c = null != o || null != a, p = null != i || null != u;
          null != s && null == l ? this.updateChildren(null, t, n) : c && !p && this.updateTextContent(""), null != i ? o !== i && this.updateTextContent("" + i) : null != u ? a !== u && M.updateInnerHTMLByID(this._rootNodeID, u) : null != l && this.updateChildren(l, t, n)
        }, unmountComponent: function() {
          this.unmountChildren(), c.deleteAllListeners(this._rootNodeID), p.unmountIDFromEnvironment(this._rootNodeID), this._rootNodeID = null
        }
      }, h.measureMethods(a, "ReactDOMComponent", {
        mountComponent: "mountComponent",
        updateComponent: "updateComponent"
      }), m(a.prototype, a.Mixin, f.Mixin), a.injection = {
        injectIDOperations: function(e) {
          a.BackendIDOperations = M = e
        }
      }, t.exports = a
    }, {
      10: 10,
      11: 11,
      114: 114,
      133: 133,
      134: 134,
      139: 139,
      150: 150,
      27: 27,
      30: 30,
      35: 35,
      5: 5,
      68: 68,
      69: 69,
      73: 73
    }],
    43: [function(e, t, n) {
      "use strict";
      var r = e(15), o = e(25), i = e(29), a = e(33), u = e(55), s = u.createFactory("form"), l = a.createClass({
        displayName: "ReactDOMForm",
        tagName: "FORM",
        mixins: [i, o],
        render: function() {
          return s(this.props)
        },
        componentDidMount: function() {
          this.trapBubbledEvent(r.topLevelTypes.topReset, "reset"), this.trapBubbledEvent(r.topLevelTypes.topSubmit, "submit")
        }
      });
      t.exports = l
    }, { 15: 15, 25: 25, 29: 29, 33: 33, 55: 55 }],
    44: [function(e, t, n) {
      "use strict";
      var r = e(5), o = e(9), i = e(11), a = e(68), u = e(73), s = e(133), l = e(144), c = {
        dangerouslySetInnerHTML: "`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.",
        style: "`style` must be set using `updateStylesByID()`."
      }, p = {
        updatePropertyByID: function(e, t, n) {
          var r = a.getNode(e);
          s(!c.hasOwnProperty(t)), null != n ? i.setValueForProperty(r, t, n) : i.deleteValueForProperty(r, t)
        }, deletePropertyByID: function(e, t, n) {
          var r = a.getNode(e);
          s(!c.hasOwnProperty(t)), i.deleteValueForProperty(r, t, n)
        }, updateStylesByID: function(e, t) {
          var n = a.getNode(e);
          r.setValueForStyles(n, t)
        }, updateInnerHTMLByID: function(e, t) {
          var n = a.getNode(e);
          l(n, t)
        }, updateTextContentByID: function(e, t) {
          var n = a.getNode(e);
          o.updateTextContent(n, t)
        }, dangerouslyReplaceNodeWithMarkupByID: function(e, t) {
          var n = a.getNode(e);
          o.dangerouslyReplaceNodeWithMarkup(n, t)
        }, dangerouslyProcessChildrenUpdates: function(e, t) {
          for (var n = 0; n < e.length; n++)e[n].parentNode = a.getNode(e[n].parentID);
          o.processUpdates(e, t)
        }
      };
      u.measureMethods(p, "ReactDOMIDOperations", {
        updatePropertyByID: "updatePropertyByID",
        deletePropertyByID: "deletePropertyByID",
        updateStylesByID: "updateStylesByID",
        updateInnerHTMLByID: "updateInnerHTMLByID",
        updateTextContentByID: "updateTextContentByID",
        dangerouslyReplaceNodeWithMarkupByID: "dangerouslyReplaceNodeWithMarkupByID",
        dangerouslyProcessChildrenUpdates: "dangerouslyProcessChildrenUpdates"
      }), t.exports = p
    }, { 11: 11, 133: 133, 144: 144, 5: 5, 68: 68, 73: 73, 9: 9 }],
    45: [function(e, t, n) {
      "use strict";
      var r = e(15), o = e(25), i = e(29), a = e(33), u = e(55), s = u.createFactory("iframe"), l = a.createClass({
        displayName: "ReactDOMIframe",
        tagName: "IFRAME",
        mixins: [i, o],
        render: function() {
          return s(this.props)
        },
        componentDidMount: function() {
          this.trapBubbledEvent(r.topLevelTypes.topLoad, "load")
        }
      });
      t.exports = l
    }, { 15: 15, 25: 25, 29: 29, 33: 33, 55: 55 }],
    46: [function(e, t, n) {
      "use strict";
      var r = e(15), o = e(25), i = e(29), a = e(33), u = e(55), s = u.createFactory("img"), l = a.createClass({
        displayName: "ReactDOMImg",
        tagName: "IMG",
        mixins: [i, o],
        render: function() {
          return s(this.props)
        },
        componentDidMount: function() {
          this.trapBubbledEvent(r.topLevelTypes.topLoad, "load"), this.trapBubbledEvent(r.topLevelTypes.topError, "error")
        }
      });
      t.exports = l
    }, { 15: 15, 25: 25, 29: 29, 33: 33, 55: 55 }],
    47: [function(e, t, n) {
      "use strict";
      function r() {
        this.isMounted() && this.forceUpdate()
      }

      var o = e(2), i = e(11), a = e(24), u = e(29), s = e(33), l = e(55), c = e(68), p = e(85), d = e(27), f = e(133), h = l.createFactory("input"), m = {}, v = s.createClass({
        displayName: "ReactDOMInput",
        tagName: "INPUT",
        mixins: [o, a.Mixin, u],
        getInitialState: function() {
          var e = this.props.defaultValue;
          return { initialChecked: this.props.defaultChecked || !1, initialValue: null != e ? e : null }
        },
        render: function() {
          var e = d({}, this.props);
          e.defaultChecked = null, e.defaultValue = null;
          var t = a.getValue(this);
          e.value = null != t ? t : this.state.initialValue;
          var n = a.getChecked(this);
          return e.checked = null != n ? n : this.state.initialChecked, e.onChange = this._handleChange, h(e, this.props.children)
        },
        componentDidMount: function() {
          var e = c.getID(this.getDOMNode());
          m[e] = this
        },
        componentWillUnmount: function() {
          var e = this.getDOMNode(), t = c.getID(e);
          delete m[t]
        },
        componentDidUpdate: function(e, t, n) {
          var r = this.getDOMNode();
          null != this.props.checked && i.setValueForProperty(r, "checked", this.props.checked || !1);
          var o = a.getValue(this);
          null != o && i.setValueForProperty(r, "value", "" + o)
        },
        _handleChange: function(e) {
          var t, n = a.getOnChange(this);
          n && (t = n.call(this, e)), p.asap(r, this);
          var o = this.props.name;
          if ("radio" === this.props.type && null != o) {
            for (var i = this.getDOMNode(), u = i; u.parentNode;)u = u.parentNode;
            for (var s = u.querySelectorAll("input[name=" + JSON.stringify("" + o) + '][type="radio"]'), l = 0, d = s.length; d > l; l++) {
              var h = s[l];
              if (h !== i && h.form === i.form) {
                var v = c.getID(h);
                f(v);
                var g = m[v];
                f(g), p.asap(r, g)
              }
            }
          }
          return t
        }
      });
      t.exports = v
    }, { 11: 11, 133: 133, 2: 2, 24: 24, 27: 27, 29: 29, 33: 33, 55: 55, 68: 68, 85: 85 }],
    48: [function(e, t, n) {
      "use strict";
      var r = e(29), o = e(33), i = e(55), a = (e(150), i.createFactory("option")), u = o.createClass({
        displayName: "ReactDOMOption",
        tagName: "OPTION",
        mixins: [r],
        componentWillMount: function() {
        },
        render: function() {
          return a(this.props, this.props.children)
        }
      });
      t.exports = u
    }, { 150: 150, 29: 29, 33: 33, 55: 55 }],
    49: [function(e, t, n) {
      "use strict";
      function r() {
        if (this._pendingUpdate) {
          this._pendingUpdate = !1;
          var e = u.getValue(this);
          null != e && this.isMounted() && i(this, e)
        }
      }

      function o(e, t, n) {
        if (null == e[t])return null;
        if (e.multiple) {
          if (!Array.isArray(e[t]))return new Error("The `" + t + "` prop supplied to <select> must be an array if `multiple` is true.")
        } else if (Array.isArray(e[t]))return new Error("The `" + t + "` prop supplied to <select> must be a scalar value if `multiple` is false.")
      }

      function i(e, t) {
        var n, r, o, i = e.getDOMNode().options;
        if (e.props.multiple) {
          for (n = {}, r = 0, o = t.length; o > r; r++)n["" + t[r]] = !0;
          for (r = 0, o = i.length; o > r; r++) {
            var a = n.hasOwnProperty(i[r].value);
            i[r].selected !== a && (i[r].selected = a)
          }
        } else {
          for (n = "" + t, r = 0, o = i.length; o > r; r++)if (i[r].value === n)return void(i[r].selected = !0);
          i.length && (i[0].selected = !0)
        }
      }

      var a = e(2), u = e(24), s = e(29), l = e(33), c = e(55), p = e(85), d = e(27), f = c.createFactory("select"), h = l.createClass({
        displayName: "ReactDOMSelect",
        tagName: "SELECT",
        mixins: [a, u.Mixin, s],
        propTypes: { defaultValue: o, value: o },
        render: function() {
          var e = d({}, this.props);
          return e.onChange = this._handleChange, e.value = null, f(e, this.props.children)
        },
        componentWillMount: function() {
          this._pendingUpdate = !1
        },
        componentDidMount: function() {
          var e = u.getValue(this);
          null != e ? i(this, e) : null != this.props.defaultValue && i(this, this.props.defaultValue)
        },
        componentDidUpdate: function(e) {
          var t = u.getValue(this);
          null != t ? (this._pendingUpdate = !1, i(this, t)) : !e.multiple != !this.props.multiple && (null != this.props.defaultValue ? i(this, this.props.defaultValue) : i(this, this.props.multiple ? [] : ""))
        },
        _handleChange: function(e) {
          var t, n = u.getOnChange(this);
          return n && (t = n.call(this, e)), this._pendingUpdate = !0, p.asap(r, this), t
        }
      });
      t.exports = h
    }, { 2: 2, 24: 24, 27: 27, 29: 29, 33: 33, 55: 55, 85: 85 }],
    50: [function(e, t, n) {
      "use strict";
      function r(e, t, n, r) {
        return e === n && t === r
      }

      function o(e) {
        var t = document.selection, n = t.createRange(), r = n.text.length, o = n.duplicate();
        o.moveToElementText(e), o.setEndPoint("EndToStart", n);
        var i = o.text.length, a = i + r;
        return { start: i, end: a }
      }

      function i(e) {
        var t = window.getSelection && window.getSelection();
        if (!t || 0 === t.rangeCount)return null;
        var n = t.anchorNode, o = t.anchorOffset, i = t.focusNode, a = t.focusOffset, u = t.getRangeAt(0), s = r(t.anchorNode, t.anchorOffset, t.focusNode, t.focusOffset), l = s ? 0 : u.toString().length, c = u.cloneRange();
        c.selectNodeContents(e), c.setEnd(u.startContainer, u.startOffset);
        var p = r(c.startContainer, c.startOffset, c.endContainer, c.endOffset), d = p ? 0 : c.toString().length, f = d + l, h = document.createRange();
        h.setStart(n, o), h.setEnd(i, a);
        var m = h.collapsed;
        return { start: m ? f : d, end: m ? d : f }
      }

      function a(e, t) {
        var n, r, o = document.selection.createRange().duplicate();
        "undefined" == typeof t.end ? (n = t.start, r = n) : t.start > t.end ? (n = t.end, r = t.start) : (n = t.start, r = t.end), o.moveToElementText(e), o.moveStart("character", n), o.setEndPoint("EndToStart", o), o.moveEnd("character", r - n), o.select()
      }

      function u(e, t) {
        if (window.getSelection) {
          var n = window.getSelection(), r = e[c()].length, o = Math.min(t.start, r), i = "undefined" == typeof t.end ? o : Math.min(t.end, r);
          if (!n.extend && o > i) {
            var a = i;
            i = o, o = a
          }
          var u = l(e, o), s = l(e, i);
          if (u && s) {
            var p = document.createRange();
            p.setStart(u.node, u.offset), n.removeAllRanges(), o > i ? (n.addRange(p), n.extend(s.node, s.offset)) : (p.setEnd(s.node, s.offset), n.addRange(p))
          }
        }
      }

      var s = e(21), l = e(126), c = e(128), p = s.canUseDOM && "selection" in document && !("getSelection" in window), d = {
        getOffsets: p ? o : i,
        setOffsets: p ? a : u
      };
      t.exports = d
    }, { 126: 126, 128: 128, 21: 21 }],
    51: [function(e, t, n) {
      "use strict";
      var r = e(11), o = e(35), i = e(42), a = e(27), u = e(114), s = function(e) {
      };
      a(s.prototype, {
        construct: function(e) {
          this._currentElement = e, this._stringText = "" + e, this._rootNodeID = null, this._mountIndex = 0
        }, mountComponent: function(e, t, n) {
          this._rootNodeID = e;
          var o = u(this._stringText);
          return t.renderToStaticMarkup ? o : "<span " + r.createMarkupForID(e) + ">" + o + "</span>"
        }, receiveComponent: function(e, t) {
          if (e !== this._currentElement) {
            this._currentElement = e;
            var n = "" + e;
            n !== this._stringText && (this._stringText = n, i.BackendIDOperations.updateTextContentByID(this._rootNodeID, n))
          }
        }, unmountComponent: function() {
          o.unmountIDFromEnvironment(this._rootNodeID)
        }
      }), t.exports = s
    }, { 11: 11, 114: 114, 27: 27, 35: 35, 42: 42 }],
    52: [function(e, t, n) {
      "use strict";
      function r() {
        this.isMounted() && this.forceUpdate()
      }

      var o = e(2), i = e(11), a = e(24), u = e(29), s = e(33), l = e(55), c = e(85), p = e(27), d = e(133), f = (e(150), l.createFactory("textarea")), h = s.createClass({
        displayName: "ReactDOMTextarea",
        tagName: "TEXTAREA",
        mixins: [o, a.Mixin, u],
        getInitialState: function() {
          var e = this.props.defaultValue, t = this.props.children;
          null != t && (d(null == e), Array.isArray(t) && (d(t.length <= 1), t = t[0]), e = "" + t), null == e && (e = "");
          var n = a.getValue(this);
          return { initialValue: "" + (null != n ? n : e) }
        },
        render: function() {
          var e = p({}, this.props);
          return d(null == e.dangerouslySetInnerHTML), e.defaultValue = null, e.value = null, e.onChange = this._handleChange, f(e, this.state.initialValue)
        },
        componentDidUpdate: function(e, t, n) {
          var r = a.getValue(this);
          if (null != r) {
            var o = this.getDOMNode();
            i.setValueForProperty(o, "value", "" + r)
          }
        },
        _handleChange: function(e) {
          var t, n = a.getOnChange(this);
          return n && (t = n.call(this, e)), c.asap(r, this), t
        }
      });
      t.exports = h
    }, { 11: 11, 133: 133, 150: 150, 2: 2, 24: 24, 27: 27, 29: 29, 33: 33, 55: 55, 85: 85 }],
    53: [function(e, t, n) {
      "use strict";
      function r() {
        this.reinitializeTransaction()
      }

      var o = e(85), i = e(101), a = e(27), u = e(112), s = {
        initialize: u, close: function() {
          d.isBatchingUpdates = !1
        }
      }, l = { initialize: u, close: o.flushBatchedUpdates.bind(o) }, c = [l, s];
      a(r.prototype, i.Mixin, {
        getTransactionWrappers: function() {
          return c
        }
      });
      var p = new r, d = {
        isBatchingUpdates: !1, batchedUpdates: function(e, t, n, r, o) {
          var i = d.isBatchingUpdates;
          d.isBatchingUpdates = !0, i ? e(t, n, r, o) : p.perform(e, null, t, n, r, o)
        }
      };
      t.exports = d
    }, { 101: 101, 112: 112, 27: 27, 85: 85 }],
    54: [function(e, t, n) {
      "use strict";
      function r(e) {
        return h.createClass({
          tagName: e.toUpperCase(), render: function() {
            return new T(e, null, null, null, null, this.props)
          }
        })
      }

      function o() {
        R.EventEmitter.injectReactEventListener(P), R.EventPluginHub.injectEventPluginOrder(s), R.EventPluginHub.injectInstanceHandle(w), R.EventPluginHub.injectMount(O), R.EventPluginHub.injectEventPluginsByName({
          SimpleEventPlugin: L,
          EnterLeaveEventPlugin: l,
          ChangeEventPlugin: a,
          MobileSafariClickEventPlugin: d,
          SelectEventPlugin: A,
          BeforeInputEventPlugin: i
        }), R.NativeComponent.injectGenericComponentClass(g), R.NativeComponent.injectTextComponentClass(I), R.NativeComponent.injectAutoWrapper(r), R.Class.injectMixin(f), R.NativeComponent.injectComponentClasses({
          button: y,
          form: C,
          iframe: _,
          img: E,
          input: x,
          option: D,
          select: M,
          textarea: N,
          html: F("html"),
          head: F("head"),
          body: F("body")
        }), R.DOMProperty.injectDOMPropertyConfig(p), R.DOMProperty.injectDOMPropertyConfig(U), R.EmptyComponent.injectEmptyComponent("noscript"), R.Updates.injectReconcileTransaction(S), R.Updates.injectBatchingStrategy(v), R.RootIndex.injectCreateReactRootIndex(c.canUseDOM ? u.createReactRootIndex : k.createReactRootIndex), R.Component.injectEnvironment(m), R.DOMComponent.injectIDOperations(b)
      }

      var i = e(3), a = e(7), u = e(8), s = e(13), l = e(14), c = e(21), p = e(23), d = e(26), f = e(29), h = e(33), m = e(35), v = e(53), g = e(42), y = e(41), C = e(43), E = e(46), b = e(44), _ = e(45), x = e(47), D = e(48), M = e(49), N = e(52), I = e(51), T = e(55), P = e(60), R = e(62), w = e(64), O = e(68), S = e(78), A = e(87), k = e(88), L = e(89), U = e(86), F = e(109);
      t.exports = { inject: o }
    }, {
      109: 109,
      13: 13,
      14: 14,
      21: 21,
      23: 23,
      26: 26,
      29: 29,
      3: 3,
      33: 33,
      35: 35,
      41: 41,
      42: 42,
      43: 43,
      44: 44,
      45: 45,
      46: 46,
      47: 47,
      48: 48,
      49: 49,
      51: 51,
      52: 52,
      53: 53,
      55: 55,
      60: 60,
      62: 62,
      64: 64,
      68: 68,
      7: 7,
      78: 78,
      8: 8,
      86: 86,
      87: 87,
      88: 88,
      89: 89
    }],
    55: [function(e, t, n) {
      "use strict";
      var r = e(38), o = e(39), i = e(27), a = (e(150), { key: !0, ref: !0 }), u = function(e, t, n, r, o, i) {
        this.type = e, this.key = t, this.ref = n, this._owner = r, this._context = o, this.props = i
      };
      u.prototype = { _isReactElement: !0 }, u.createElement = function(e, t, n) {
        var i, s = {}, l = null, c = null;
        if (null != t) {
          c = void 0 === t.ref ? null : t.ref, l = void 0 === t.key ? null : "" + t.key;
          for (i in t)t.hasOwnProperty(i) && !a.hasOwnProperty(i) && (s[i] = t[i])
        }
        var p = arguments.length - 2;
        if (1 === p)s.children = n; else if (p > 1) {
          for (var d = Array(p), f = 0; p > f; f++)d[f] = arguments[f + 2];
          s.children = d
        }
        if (e && e.defaultProps) {
          var h = e.defaultProps;
          for (i in h)"undefined" == typeof s[i] && (s[i] = h[i])
        }
        return new u(e, l, c, o.current, r.current, s)
      }, u.createFactory = function(e) {
        var t = u.createElement.bind(null, e);
        return t.type = e, t
      }, u.cloneAndReplaceProps = function(e, t) {
        var n = new u(e.type, e.key, e.ref, e._owner, e._context, t);
        return n
      }, u.cloneElement = function(e, t, n) {
        var r, s = i({}, e.props), l = e.key, c = e.ref, p = e._owner;
        if (null != t) {
          void 0 !== t.ref && (c = t.ref, p = o.current), void 0 !== t.key && (l = "" + t.key);
          for (r in t)t.hasOwnProperty(r) && !a.hasOwnProperty(r) && (s[r] = t[r])
        }
        var d = arguments.length - 2;
        if (1 === d)s.children = n; else if (d > 1) {
          for (var f = Array(d), h = 0; d > h; h++)f[h] = arguments[h + 2];
          s.children = f
        }
        return new u(e.type, l, c, p, e._context, s)
      }, u.isValidElement = function(e) {
        var t = !(!e || !e._isReactElement);
        return t
      }, t.exports = u
    }, { 150: 150, 27: 27, 38: 38, 39: 39 }],
    56: [function(e, t, n) {
      "use strict";
      function r() {
        if (y.current) {
          var e = y.current.getName();
          if (e)return " Check the render method of `" + e + "`."
        }
        return ""
      }

      function o(e) {
        var t = e && e.getPublicInstance();
        if (!t)return void 0;
        var n = t.constructor;
        return n ? n.displayName || n.name || void 0 : void 0
      }

      function i() {
        var e = y.current;
        return e && o(e) || void 0
      }

      function a(e, t) {
        e._store.validated || null != e.key || (e._store.validated = !0, s('Each child in an array or iterator should have a unique "key" prop.', e, t))
      }

      function u(e, t, n) {
        D.test(e) && s("Child objects should have non-numeric keys so ordering is preserved.", t, n)
      }

      function s(e, t, n) {
        var r = i(), a = "string" == typeof n ? n : n.displayName || n.name, u = r || a, s = _[e] || (_[e] = {});
        if (!s.hasOwnProperty(u)) {
          s[u] = !0;
          var l = "";
          if (t && t._owner && t._owner !== y.current) {
            var c = o(t._owner);
            l = " It was passed a child from " + c + "."
          }
        }
      }

      function l(e, t) {
        if (Array.isArray(e))for (var n = 0; n < e.length; n++) {
          var r = e[n];
          m.isValidElement(r) && a(r, t)
        } else if (m.isValidElement(e))e._store.validated = !0; else if (e) {
          var o = E(e);
          if (o) {
            if (o !== e.entries)for (var i, s = o.call(e); !(i = s.next()).done;)m.isValidElement(i.value) && a(i.value, t)
          } else if ("object" == typeof e) {
            var l = v.extractIfFragment(e);
            for (var c in l)l.hasOwnProperty(c) && u(c, l[c], t)
          }
        }
      }

      function c(e, t, n, o) {
        for (var i in t)if (t.hasOwnProperty(i)) {
          var a;
          try {
            b("function" == typeof t[i]), a = t[i](n, i, e, o)
          } catch (u) {
            a = u
          }
          a instanceof Error && !(a.message in x) && (x[a.message] = !0, r(this))
        }
      }

      function p(e, t) {
        var n = t.type, r = "string" == typeof n ? n : n.displayName, o = t._owner ? t._owner.getPublicInstance().constructor.displayName : null, i = e + "|" + r + "|" + o;
        if (!M.hasOwnProperty(i)) {
          M[i] = !0;
          var a = "";
          r && (a = " <" + r + " />");
          var u = "";
          o && (u = " The element was created by " + o + ".")
        }
      }

      function d(e, t) {
        return e !== e ? t !== t : 0 === e && 0 === t ? 1 / e === 1 / t : e === t
      }

      function f(e) {
        if (e._store) {
          var t = e._store.originalProps, n = e.props;
          for (var r in n)n.hasOwnProperty(r) && (t.hasOwnProperty(r) && d(t[r], n[r]) || (p(r, e), t[r] = n[r]))
        }
      }

      function h(e) {
        if (null != e.type) {
          var t = C.getComponentClassForElement(e), n = t.displayName || t.name;
          t.propTypes && c(n, t.propTypes, e.props, g.prop), "function" == typeof t.getDefaultProps
        }
      }

      var m = e(55), v = e(61), g = e(75), y = (e(74), e(39)), C = e(71), E = e(124), b = e(133), _ = (e(150), {}), x = {}, D = /^\d+$/, M = {}, N = {
        checkAndWarnForMutatedProps: f,
        createElement: function(e, t, n) {
          var r = m.createElement.apply(this, arguments);
          if (null == r)return r;
          for (var o = 2; o < arguments.length; o++)l(arguments[o], e);
          return h(r), r
        },
        createFactory: function(e) {
          var t = N.createElement.bind(null, e);
          return t.type = e, t
        },
        cloneElement: function(e, t, n) {
          for (var r = m.cloneElement.apply(this, arguments), o = 2; o < arguments.length; o++)l(arguments[o], r.type);
          return h(r), r
        }
      };
      t.exports = N
    }, { 124: 124, 133: 133, 150: 150, 39: 39, 55: 55, 61: 61, 71: 71, 74: 74, 75: 75 }],
    57: [function(e, t, n) {
      "use strict";
      function r(e) {
        c[e] = !0
      }

      function o(e) {
        delete c[e]
      }

      function i(e) {
        return !!c[e]
      }

      var a, u = e(55), s = e(65), l = e(133), c = {}, p = {
        injectEmptyComponent: function(e) {
          a = u.createFactory(e)
        }
      }, d = function() {
      };
      d.prototype.componentDidMount = function() {
        var e = s.get(this);
        e && r(e._rootNodeID)
      }, d.prototype.componentWillUnmount = function() {
        var e = s.get(this);
        e && o(e._rootNodeID)
      }, d.prototype.render = function() {
        return l(a), a()
      };
      var f = u.createElement(d), h = { emptyElement: f, injection: p, isNullComponentID: i };
      t.exports = h
    }, { 133: 133, 55: 55, 65: 65 }],
    58: [function(e, t, n) {
      "use strict";
      var r = {
        guard: function(e, t) {
          return e
        }
      };
      t.exports = r
    }, {}],
    59: [function(e, t, n) {
      "use strict";
      function r(e) {
        o.enqueueEvents(e), o.processEventQueue()
      }

      var o = e(17), i = {
        handleTopLevel: function(e, t, n, i) {
          var a = o.extractEvents(e, t, n, i);
          r(a)
        }
      };
      t.exports = i
    }, { 17: 17 }],
    60: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = p.getID(e), n = c.getReactRootIDFromNodeID(t), r = p.findReactContainerForID(n), o = p.getFirstReactDOM(r);
        return o
      }

      function o(e, t) {
        this.topLevelType = e, this.nativeEvent = t, this.ancestors = []
      }

      function i(e) {
        for (var t = p.getFirstReactDOM(h(e.nativeEvent)) || window, n = t; n;)e.ancestors.push(n), n = r(n);
        for (var o = 0, i = e.ancestors.length; i > o; o++) {
          t = e.ancestors[o];
          var a = p.getID(t) || "";
          v._handleTopLevel(e.topLevelType, t, a, e.nativeEvent)
        }
      }

      function a(e) {
        var t = m(window);
        e(t)
      }

      var u = e(16), s = e(21), l = e(28), c = e(64), p = e(68), d = e(85), f = e(27), h = e(123), m = e(129);
      f(o.prototype, {
        destructor: function() {
          this.topLevelType = null, this.nativeEvent = null, this.ancestors.length = 0
        }
      }), l.addPoolingTo(o, l.twoArgumentPooler);
      var v = {
        _enabled: !0,
        _handleTopLevel: null,
        WINDOW_HANDLE: s.canUseDOM ? window : null,
        setHandleTopLevel: function(e) {
          v._handleTopLevel = e
        },
        setEnabled: function(e) {
          v._enabled = !!e
        },
        isEnabled: function() {
          return v._enabled
        },
        trapBubbledEvent: function(e, t, n) {
          var r = n;
          return r ? u.listen(r, t, v.dispatchEvent.bind(null, e)) : null
        },
        trapCapturedEvent: function(e, t, n) {
          var r = n;
          return r ? u.capture(r, t, v.dispatchEvent.bind(null, e)) : null
        },
        monitorScrollValue: function(e) {
          var t = a.bind(null, e);
          u.listen(window, "scroll", t)
        },
        dispatchEvent: function(e, t) {
          if (v._enabled) {
            var n = o.getPooled(e, t);
            try {
              d.batchedUpdates(i, n)
            } finally {
              o.release(n)
            }
          }
        }
      };
      t.exports = v
    }, { 123: 123, 129: 129, 16: 16, 21: 21, 27: 27, 28: 28, 64: 64, 68: 68, 85: 85 }],
    61: [function(e, t, n) {
      "use strict";
      var r = (e(55), e(150), {
        create: function(e) {
          return e
        }, extract: function(e) {
          return e
        }, extractIfFragment: function(e) {
          return e
        }
      });
      t.exports = r
    }, { 150: 150, 55: 55 }],
    62: [function(e, t, n) {
      "use strict";
      var r = e(10), o = e(17), i = e(36), a = e(33), u = e(57), s = e(30), l = e(71), c = e(42), p = e(73), d = e(81), f = e(85), h = {
        Component: i.injection,
        Class: a.injection,
        DOMComponent: c.injection,
        DOMProperty: r.injection,
        EmptyComponent: u.injection,
        EventPluginHub: o.injection,
        EventEmitter: s.injection,
        NativeComponent: l.injection,
        Perf: p.injection,
        RootIndex: d.injection,
        Updates: f.injection
      };
      t.exports = h
    }, { 10: 10, 17: 17, 30: 30, 33: 33, 36: 36, 42: 42, 57: 57, 71: 71, 73: 73, 81: 81, 85: 85 }],
    63: [function(e, t, n) {
      "use strict";
      function r(e) {
        return i(document.documentElement, e)
      }

      var o = e(50), i = e(107), a = e(117), u = e(119), s = {
        hasSelectionCapabilities: function(e) {
          return e && ("INPUT" === e.nodeName && "text" === e.type || "TEXTAREA" === e.nodeName || "true" === e.contentEditable)
        }, getSelectionInformation: function() {
          var e = u();
          return { focusedElem: e, selectionRange: s.hasSelectionCapabilities(e) ? s.getSelection(e) : null }
        }, restoreSelection: function(e) {
          var t = u(), n = e.focusedElem, o = e.selectionRange;
          t !== n && r(n) && (s.hasSelectionCapabilities(n) && s.setSelection(n, o), a(n))
        }, getSelection: function(e) {
          var t;
          if ("selectionStart" in e)t = {
            start: e.selectionStart,
            end: e.selectionEnd
          }; else if (document.selection && "INPUT" === e.nodeName) {
            var n = document.selection.createRange();
            n.parentElement() === e && (t = {
              start: -n.moveStart("character", -e.value.length),
              end: -n.moveEnd("character", -e.value.length)
            })
          } else t = o.getOffsets(e);
          return t || { start: 0, end: 0 }
        }, setSelection: function(e, t) {
          var n = t.start, r = t.end;
          if ("undefined" == typeof r && (r = n), "selectionStart" in e)e.selectionStart = n, e.selectionEnd = Math.min(r, e.value.length); else if (document.selection && "INPUT" === e.nodeName) {
            var i = e.createTextRange();
            i.collapse(!0), i.moveStart("character", n), i.moveEnd("character", r - n), i.select()
          } else o.setOffsets(e, t)
        }
      };
      t.exports = s
    }, { 107: 107, 117: 117, 119: 119, 50: 50 }],
    64: [function(e, t, n) {
      "use strict";
      function r(e) {
        return f + e.toString(36)
      }

      function o(e, t) {
        return e.charAt(t) === f || t === e.length
      }

      function i(e) {
        return "" === e || e.charAt(0) === f && e.charAt(e.length - 1) !== f
      }

      function a(e, t) {
        return 0 === t.indexOf(e) && o(t, e.length)
      }

      function u(e) {
        return e ? e.substr(0, e.lastIndexOf(f)) : ""
      }

      function s(e, t) {
        if (d(i(e) && i(t)), d(a(e, t)), e === t)return e;
        var n, r = e.length + h;
        for (n = r; n < t.length && !o(t, n); n++);
        return t.substr(0, n)
      }

      function l(e, t) {
        var n = Math.min(e.length, t.length);
        if (0 === n)return "";
        for (var r = 0, a = 0; n >= a; a++)if (o(e, a) && o(t, a))r = a; else if (e.charAt(a) !== t.charAt(a))break;
        var u = e.substr(0, r);
        return d(i(u)), u
      }

      function c(e, t, n, r, o, i) {
        e = e || "", t = t || "", d(e !== t);
        var l = a(t, e);
        d(l || a(e, t));
        for (var c = 0, p = l ? u : s, f = e; ; f = p(f, t)) {
          var h;
          if (o && f === e || i && f === t || (h = n(f, l, r)), h === !1 || f === t)break;
          d(c++ < m)
        }
      }

      var p = e(81), d = e(133), f = ".", h = f.length, m = 100, v = {
        createReactRootID: function() {
          return r(p.createReactRootIndex())
        }, createReactID: function(e, t) {
          return e + t
        }, getReactRootIDFromNodeID: function(e) {
          if (e && e.charAt(0) === f && e.length > 1) {
            var t = e.indexOf(f, 1);
            return t > -1 ? e.substr(0, t) : e
          }
          return null
        }, traverseEnterLeave: function(e, t, n, r, o) {
          var i = l(e, t);
          i !== e && c(e, i, n, r, !1, !0), i !== t && c(i, t, n, o, !0, !1)
        }, traverseTwoPhase: function(e, t, n) {
          e && (c("", e, t, n, !0, !1), c(e, "", t, n, !1, !0))
        }, traverseAncestors: function(e, t, n) {
          c("", e, t, n, !0, !1)
        }, _getFirstCommonAncestorID: l, _getNextDescendantID: s, isAncestorIDOf: a, SEPARATOR: f
      };
      t.exports = v
    }, { 133: 133, 81: 81 }],
    65: [function(e, t, n) {
      "use strict";
      var r = {
        remove: function(e) {
          e._reactInternalInstance = void 0
        }, get: function(e) {
          return e._reactInternalInstance
        }, has: function(e) {
          return void 0 !== e._reactInternalInstance
        }, set: function(e, t) {
          e._reactInternalInstance = t
        }
      };
      t.exports = r
    }, {}],
    66: [function(e, t, n) {
      "use strict";
      var r = { currentlyMountingInstance: null, currentlyUnmountingInstance: null };
      t.exports = r
    }, {}],
    67: [function(e, t, n) {
      "use strict";
      var r = e(104), o = {
        CHECKSUM_ATTR_NAME: "data-react-checksum", addChecksumToMarkup: function(e) {
          var t = r(e);
          return e.replace(">", " " + o.CHECKSUM_ATTR_NAME + '="' + t + '">')
        }, canReuseMarkup: function(e, t) {
          var n = t.getAttribute(o.CHECKSUM_ATTR_NAME);
          n = n && parseInt(n, 10);
          var i = r(e);
          return i === n
        }
      };
      t.exports = o
    }, { 104: 104 }],
    68: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        for (var n = Math.min(e.length, t.length), r = 0; n > r; r++)if (e.charAt(r) !== t.charAt(r))return r;
        return e.length === t.length ? -1 : n
      }

      function o(e) {
        var t = P(e);
        return t && K.getID(t)
      }

      function i(e) {
        var t = a(e);
        if (t)if (L.hasOwnProperty(t)) {
          var n = L[t];
          n !== e && (w(!c(n, t)), L[t] = e)
        } else L[t] = e;
        return t
      }

      function a(e) {
        return e && e.getAttribute && e.getAttribute(k) || ""
      }

      function u(e, t) {
        var n = a(e);
        n !== t && delete L[n], e.setAttribute(k, t), L[t] = e
      }

      function s(e) {
        return L.hasOwnProperty(e) && c(L[e], e) || (L[e] = K.findReactNodeByID(e)), L[e]
      }

      function l(e) {
        var t = b.get(e)._rootNodeID;
        return C.isNullComponentID(t) ? null : (L.hasOwnProperty(t) && c(L[t], t) || (L[t] = K.findReactNodeByID(t)), L[t])
      }

      function c(e, t) {
        if (e) {
          w(a(e) === t);
          var n = K.findReactContainerForID(t);
          if (n && T(n, e))return !0
        }
        return !1
      }

      function p(e) {
        delete L[e]
      }

      function d(e) {
        var t = L[e];
        return t && c(t, e) ? void(W = t) : !1
      }

      function f(e) {
        W = null, E.traverseAncestors(e, d);
        var t = W;
        return W = null, t
      }

      function h(e, t, n, r, o) {
        var i = D.mountComponent(e, t, r, I);
        e._isTopLevel = !0, K._mountImageIntoNode(i, n, o)
      }

      function m(e, t, n, r) {
        var o = N.ReactReconcileTransaction.getPooled();
        o.perform(h, null, e, t, n, o, r), N.ReactReconcileTransaction.release(o)
      }

      var v = e(10), g = e(30), y = (e(39), e(55)), C = (e(56), e(57)), E = e(64), b = e(65), _ = e(67), x = e(73), D = e(79), M = e(84), N = e(85), I = e(113), T = e(107), P = e(127), R = e(132), w = e(133), O = e(144), S = e(147), A = (e(150), E.SEPARATOR), k = v.ID_ATTRIBUTE_NAME, L = {}, U = 1, F = 9, B = {}, V = {}, j = [], W = null, K = {
        _instancesByReactRootID: B,
        scrollMonitor: function(e, t) {
          t()
        },
        _updateRootComponent: function(e, t, n, r) {
          return K.scrollMonitor(n, function() {
            M.enqueueElementInternal(e, t), r && M.enqueueCallbackInternal(e, r)
          }), e
        },
        _registerComponent: function(e, t) {
          w(t && (t.nodeType === U || t.nodeType === F)), g.ensureScrollValueMonitoring();
          var n = K.registerContainer(t);
          return B[n] = e, n
        },
        _renderNewRootComponent: function(e, t, n) {
          var r = R(e, null), o = K._registerComponent(r, t);
          return N.batchedUpdates(m, r, o, t, n), r
        },
        render: function(e, t, n) {
          w(y.isValidElement(e));
          var r = B[o(t)];
          if (r) {
            var i = r._currentElement;
            if (S(i, e))return K._updateRootComponent(r, e, t, n).getPublicInstance();
            K.unmountComponentAtNode(t)
          }
          var a = P(t), u = a && K.isRenderedByReact(a), s = u && !r, l = K._renderNewRootComponent(e, t, s).getPublicInstance();
          return n && n.call(l), l
        },
        constructAndRenderComponent: function(e, t, n) {
          var r = y.createElement(e, t);
          return K.render(r, n)
        },
        constructAndRenderComponentByID: function(e, t, n) {
          var r = document.getElementById(n);
          return w(r), K.constructAndRenderComponent(e, t, r)
        },
        registerContainer: function(e) {
          var t = o(e);
          return t && (t = E.getReactRootIDFromNodeID(t)), t || (t = E.createReactRootID()), V[t] = e, t
        },
        unmountComponentAtNode: function(e) {
          w(e && (e.nodeType === U || e.nodeType === F));
          var t = o(e), n = B[t];
          return n ? (K.unmountComponentFromNode(n, e), delete B[t], delete V[t], !0) : !1
        },
        unmountComponentFromNode: function(e, t) {
          for (D.unmountComponent(e), t.nodeType === F && (t = t.documentElement); t.lastChild;)t.removeChild(t.lastChild)
        },
        findReactContainerForID: function(e) {
          var t = E.getReactRootIDFromNodeID(e), n = V[t];
          return n
        },
        findReactNodeByID: function(e) {
          var t = K.findReactContainerForID(e);
          return K.findComponentRoot(t, e)
        },
        isRenderedByReact: function(e) {
          if (1 !== e.nodeType)return !1;
          var t = K.getID(e);
          return t ? t.charAt(0) === A : !1
        },
        getFirstReactDOM: function(e) {
          for (var t = e; t && t.parentNode !== t;) {
            if (K.isRenderedByReact(t))return t;
            t = t.parentNode
          }
          return null
        },
        findComponentRoot: function(e, t) {
          var n = j, r = 0, o = f(t) || e;
          for (n[0] = o.firstChild, n.length = 1; r < n.length;) {
            for (var i, a = n[r++]; a;) {
              var u = K.getID(a);
              u ? t === u ? i = a : E.isAncestorIDOf(u, t) && (n.length = r = 0, n.push(a.firstChild)) : n.push(a.firstChild), a = a.nextSibling
            }
            if (i)return n.length = 0, i
          }
          n.length = 0, w(!1)
        },
        _mountImageIntoNode: function(e, t, n) {
          if (w(t && (t.nodeType === U || t.nodeType === F)), n) {
            var o = P(t);
            if (_.canReuseMarkup(e, o))return;
            var i = o.getAttribute(_.CHECKSUM_ATTR_NAME);
            o.removeAttribute(_.CHECKSUM_ATTR_NAME);
            var a = o.outerHTML;
            o.setAttribute(_.CHECKSUM_ATTR_NAME, i);
            var u = r(e, a);
            " (client) " + e.substring(u - 20, u + 20) + "\n (server) " + a.substring(u - 20, u + 20), w(t.nodeType !== F)
          }
          w(t.nodeType !== F), O(t, e)
        },
        getReactRootID: o,
        getID: i,
        setID: u,
        getNode: s,
        getNodeFromInstance: l,
        purgeID: p
      };
      x.measureMethods(K, "ReactMount", {
        _renderNewRootComponent: "_renderNewRootComponent",
        _mountImageIntoNode: "_mountImageIntoNode"
      }), t.exports = K
    }, {
      10: 10,
      107: 107,
      113: 113,
      127: 127,
      132: 132,
      133: 133,
      144: 144,
      147: 147,
      150: 150,
      30: 30,
      39: 39,
      55: 55,
      56: 56,
      57: 57,
      64: 64,
      65: 65,
      67: 67,
      73: 73,
      79: 79,
      84: 84,
      85: 85
    }],
    69: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        h.push({
          parentID: e,
          parentNode: null,
          type: c.INSERT_MARKUP,
          markupIndex: m.push(t) - 1,
          textContent: null,
          fromIndex: null,
          toIndex: n
        })
      }

      function o(e, t, n) {
        h.push({
          parentID: e,
          parentNode: null,
          type: c.MOVE_EXISTING,
          markupIndex: null,
          textContent: null,
          fromIndex: t,
          toIndex: n
        })
      }

      function i(e, t) {
        h.push({
          parentID: e,
          parentNode: null,
          type: c.REMOVE_NODE,
          markupIndex: null,
          textContent: null,
          fromIndex: t,
          toIndex: null
        })
      }

      function a(e, t) {
        h.push({
          parentID: e,
          parentNode: null,
          type: c.TEXT_CONTENT,
          markupIndex: null,
          textContent: t,
          fromIndex: null,
          toIndex: null
        })
      }

      function u() {
        h.length && (l.processChildrenUpdates(h, m), s())
      }

      function s() {
        h.length = 0, m.length = 0
      }

      var l = e(36), c = e(70), p = e(79), d = e(31), f = 0, h = [], m = [], v = {
        Mixin: {
          mountChildren: function(e, t, n) {
            var r = d.instantiateChildren(e, t, n);
            this._renderedChildren = r;
            var o = [], i = 0;
            for (var a in r)if (r.hasOwnProperty(a)) {
              var u = r[a], s = this._rootNodeID + a, l = p.mountComponent(u, s, t, n);
              u._mountIndex = i, o.push(l), i++
            }
            return o
          }, updateTextContent: function(e) {
            f++;
            var t = !0;
            try {
              var n = this._renderedChildren;
              d.unmountChildren(n);
              for (var r in n)n.hasOwnProperty(r) && this._unmountChildByName(n[r], r);
              this.setTextContent(e), t = !1
            } finally {
              f--, f || (t ? s() : u())
            }
          }, updateChildren: function(e, t, n) {
            f++;
            var r = !0;
            try {
              this._updateChildren(e, t, n), r = !1
            } finally {
              f--, f || (r ? s() : u())
            }
          }, _updateChildren: function(e, t, n) {
            var r = this._renderedChildren, o = d.updateChildren(r, e, t, n);
            if (this._renderedChildren = o, o || r) {
              var i, a = 0, u = 0;
              for (i in o)if (o.hasOwnProperty(i)) {
                var s = r && r[i], l = o[i];
                s === l ? (this.moveChild(s, u, a), a = Math.max(s._mountIndex, a), s._mountIndex = u) : (s && (a = Math.max(s._mountIndex, a), this._unmountChildByName(s, i)), this._mountChildByNameAtIndex(l, i, u, t, n)), u++
              }
              for (i in r)!r.hasOwnProperty(i) || o && o.hasOwnProperty(i) || this._unmountChildByName(r[i], i)
            }
          }, unmountChildren: function() {
            var e = this._renderedChildren;
            d.unmountChildren(e), this._renderedChildren = null
          }, moveChild: function(e, t, n) {
            e._mountIndex < n && o(this._rootNodeID, e._mountIndex, t)
          }, createChild: function(e, t) {
            r(this._rootNodeID, t, e._mountIndex)
          }, removeChild: function(e) {
            i(this._rootNodeID, e._mountIndex)
          }, setTextContent: function(e) {
            a(this._rootNodeID, e)
          }, _mountChildByNameAtIndex: function(e, t, n, r, o) {
            var i = this._rootNodeID + t, a = p.mountComponent(e, i, r, o);
            e._mountIndex = n, this.createChild(e, a)
          }, _unmountChildByName: function(e, t) {
            this.removeChild(e), e._mountIndex = null
          }
        }
      };
      t.exports = v
    }, { 31: 31, 36: 36, 70: 70, 79: 79 }],
    70: [function(e, t, n) {
      "use strict";
      var r = e(138), o = r({ INSERT_MARKUP: null, MOVE_EXISTING: null, REMOVE_NODE: null, TEXT_CONTENT: null });
      t.exports = o
    }, { 138: 138 }],
    71: [function(e, t, n) {
      "use strict";
      function r(e) {
        if ("function" == typeof e.type)return e.type;
        var t = e.type, n = p[t];
        return null == n && (p[t] = n = l(t)), n
      }

      function o(e) {
        return s(c), new c(e.type, e.props)
      }

      function i(e) {
        return new d(e)
      }

      function a(e) {
        return e instanceof d
      }

      var u = e(27), s = e(133), l = null, c = null, p = {}, d = null, f = {
        injectGenericComponentClass: function(e) {
          c = e
        }, injectTextComponentClass: function(e) {
          d = e
        }, injectComponentClasses: function(e) {
          u(p, e)
        }, injectAutoWrapper: function(e) {
          l = e
        }
      }, h = {
        getComponentClassForElement: r,
        createInternalComponent: o,
        createInstanceForText: i,
        isTextComponent: a,
        injection: f
      };
      t.exports = h
    }, { 133: 133, 27: 27 }],
    72: [function(e, t, n) {
      "use strict";
      var r = e(133), o = {
        isValidOwner: function(e) {
          return !(!e || "function" != typeof e.attachRef || "function" != typeof e.detachRef)
        }, addComponentAsRefTo: function(e, t, n) {
          r(o.isValidOwner(n)), n.attachRef(t, e)
        }, removeComponentAsRefFrom: function(e, t, n) {
          r(o.isValidOwner(n)), n.getPublicInstance().refs[t] === e.getPublicInstance() && n.detachRef(t)
        }
      };
      t.exports = o
    }, { 133: 133 }],
    73: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        return n
      }

      var o = {
        enableMeasure: !1, storedMeasure: r, measureMethods: function(e, t, n) {
        }, measure: function(e, t, n) {
          return n
        }, injection: {
          injectMeasure: function(e) {
            o.storedMeasure = e
          }
        }
      };
      t.exports = o
    }, {}],
    74: [function(e, t, n) {
      "use strict";
      var r = {};
      t.exports = r
    }, {}],
    75: [function(e, t, n) {
      "use strict";
      var r = e(138), o = r({ prop: null, context: null, childContext: null });
      t.exports = o
    }, { 138: 138 }],
    76: [function(e, t, n) {
      "use strict";
      function r(e) {
        function t(t, n, r, o, i) {
          if (o = o || b, null == n[r]) {
            var a = C[i];
            return t ? new Error("Required " + a + " `" + r + "` was not specified in " + ("`" + o + "`.")) : null
          }
          return e(n, r, o, i)
        }

        var n = t.bind(null, !1);
        return n.isRequired = t.bind(null, !0), n
      }

      function o(e) {
        function t(t, n, r, o) {
          var i = t[n], a = m(i);
          if (a !== e) {
            var u = C[o], s = v(i);
            return new Error("Invalid " + u + " `" + n + "` of type `" + s + "` " + ("supplied to `" + r + "`, expected `" + e + "`."))
          }
          return null
        }

        return r(t)
      }

      function i() {
        return r(E.thatReturns(null))
      }

      function a(e) {
        function t(t, n, r, o) {
          var i = t[n];
          if (!Array.isArray(i)) {
            var a = C[o], u = m(i);
            return new Error("Invalid " + a + " `" + n + "` of type " + ("`" + u + "` supplied to `" + r + "`, expected an array."))
          }
          for (var s = 0; s < i.length; s++) {
            var l = e(i, s, r, o);
            if (l instanceof Error)return l
          }
          return null
        }

        return r(t)
      }

      function u() {
        function e(e, t, n, r) {
          if (!g.isValidElement(e[t])) {
            var o = C[r];
            return new Error("Invalid " + o + " `" + t + "` supplied to " + ("`" + n + "`, expected a ReactElement."))
          }
          return null
        }

        return r(e)
      }

      function s(e) {
        function t(t, n, r, o) {
          if (!(t[n] instanceof e)) {
            var i = C[o], a = e.name || b;
            return new Error("Invalid " + i + " `" + n + "` supplied to " + ("`" + r + "`, expected instance of `" + a + "`."))
          }
          return null
        }

        return r(t)
      }

      function l(e) {
        function t(t, n, r, o) {
          for (var i = t[n], a = 0; a < e.length; a++)if (i === e[a])return null;
          var u = C[o], s = JSON.stringify(e);
          return new Error("Invalid " + u + " `" + n + "` of value `" + i + "` " + ("supplied to `" + r + "`, expected one of " + s + "."))
        }

        return r(t)
      }

      function c(e) {
        function t(t, n, r, o) {
          var i = t[n], a = m(i);
          if ("object" !== a) {
            var u = C[o];
            return new Error("Invalid " + u + " `" + n + "` of type " + ("`" + a + "` supplied to `" + r + "`, expected an object."))
          }
          for (var s in i)if (i.hasOwnProperty(s)) {
            var l = e(i, s, r, o);
            if (l instanceof Error)return l
          }
          return null
        }

        return r(t)
      }

      function p(e) {
        function t(t, n, r, o) {
          for (var i = 0; i < e.length; i++) {
            var a = e[i];
            if (null == a(t, n, r, o))return null
          }
          var u = C[o];
          return new Error("Invalid " + u + " `" + n + "` supplied to " + ("`" + r + "`."))
        }

        return r(t)
      }

      function d() {
        function e(e, t, n, r) {
          if (!h(e[t])) {
            var o = C[r];
            return new Error("Invalid " + o + " `" + t + "` supplied to " + ("`" + n + "`, expected a ReactNode."))
          }
          return null
        }

        return r(e)
      }

      function f(e) {
        function t(t, n, r, o) {
          var i = t[n], a = m(i);
          if ("object" !== a) {
            var u = C[o];
            return new Error("Invalid " + u + " `" + n + "` of type `" + a + "` " + ("supplied to `" + r + "`, expected `object`."))
          }
          for (var s in e) {
            var l = e[s];
            if (l) {
              var c = l(i, s, r, o);
              if (c)return c
            }
          }
          return null
        }

        return r(t)
      }

      function h(e) {
        switch (typeof e) {
          case"number":
          case"string":
          case"undefined":
            return !0;
          case"boolean":
            return !e;
          case"object":
            if (Array.isArray(e))return e.every(h);
            if (null === e || g.isValidElement(e))return !0;
            e = y.extractIfFragment(e);
            for (var t in e)if (!h(e[t]))return !1;
            return !0;
          default:
            return !1
        }
      }

      function m(e) {
        var t = typeof e;
        return Array.isArray(e) ? "array" : e instanceof RegExp ? "object" : t
      }

      function v(e) {
        var t = m(e);
        if ("object" === t) {
          if (e instanceof Date)return "date";
          if (e instanceof RegExp)return "regexp"
        }
        return t
      }

      var g = e(55), y = e(61), C = e(74), E = e(112), b = "<<anonymous>>", _ = u(), x = d(), D = {
        array: o("array"),
        bool: o("boolean"),
        func: o("function"),
        number: o("number"),
        object: o("object"),
        string: o("string"),
        any: i(),
        arrayOf: a,
        element: _,
        instanceOf: s,
        node: x,
        objectOf: c,
        oneOf: l,
        oneOfType: p,
        shape: f
      };
      t.exports = D
    }, { 112: 112, 55: 55, 61: 61, 74: 74 }],
    77: [function(e, t, n) {
      "use strict";
      function r() {
        this.listenersToPut = []
      }

      var o = e(28), i = e(30), a = e(27);
      a(r.prototype, {
        enqueuePutListener: function(e, t, n) {
          this.listenersToPut.push({ rootNodeID: e, propKey: t, propValue: n })
        }, putListeners: function() {
          for (var e = 0; e < this.listenersToPut.length; e++) {
            var t = this.listenersToPut[e];
            i.putListener(t.rootNodeID, t.propKey, t.propValue)
          }
        }, reset: function() {
          this.listenersToPut.length = 0
        }, destructor: function() {
          this.reset()
        }
      }), o.addPoolingTo(r), t.exports = r
    }, { 27: 27, 28: 28, 30: 30 }],
    78: [function(e, t, n) {
      "use strict";
      function r() {
        this.reinitializeTransaction(), this.renderToStaticMarkup = !1, this.reactMountReady = o.getPooled(null), this.putListenerQueue = s.getPooled()
      }

      var o = e(6), i = e(28), a = e(30), u = e(63), s = e(77), l = e(101), c = e(27), p = {
        initialize: u.getSelectionInformation,
        close: u.restoreSelection
      }, d = {
        initialize: function() {
          var e = a.isEnabled();
          return a.setEnabled(!1), e
        }, close: function(e) {
          a.setEnabled(e)
        }
      }, f = {
        initialize: function() {
          this.reactMountReady.reset()
        }, close: function() {
          this.reactMountReady.notifyAll()
        }
      }, h = {
        initialize: function() {
          this.putListenerQueue.reset()
        }, close: function() {
          this.putListenerQueue.putListeners()
        }
      }, m = [h, p, d, f], v = {
        getTransactionWrappers: function() {
          return m
        }, getReactMountReady: function() {
          return this.reactMountReady
        }, getPutListenerQueue: function() {
          return this.putListenerQueue
        }, destructor: function() {
          o.release(this.reactMountReady), this.reactMountReady = null, s.release(this.putListenerQueue), this.putListenerQueue = null
        }
      };
      c(r.prototype, l.Mixin, v), i.addPoolingTo(r), t.exports = r
    }, { 101: 101, 27: 27, 28: 28, 30: 30, 6: 6, 63: 63, 77: 77 }],
    79: [function(e, t, n) {
      "use strict";
      function r() {
        o.attachRefs(this, this._currentElement)
      }

      var o = e(80), i = (e(56), {
        mountComponent: function(e, t, n, o) {
          var i = e.mountComponent(t, n, o);
          return n.getReactMountReady().enqueue(r, e), i
        }, unmountComponent: function(e) {
          o.detachRefs(e, e._currentElement), e.unmountComponent()
        }, receiveComponent: function(e, t, n, i) {
          var a = e._currentElement;
          if (t !== a || null == t._owner) {
            var u = o.shouldUpdateRefs(a, t);
            u && o.detachRefs(e, a), e.receiveComponent(t, n, i), u && n.getReactMountReady().enqueue(r, e)
          }
        }, performUpdateIfNecessary: function(e, t) {
          e.performUpdateIfNecessary(t)
        }
      });
      t.exports = i
    }, { 56: 56, 80: 80 }],
    80: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        "function" == typeof e ? e(t.getPublicInstance()) : i.addComponentAsRefTo(t, e, n)
      }

      function o(e, t, n) {
        "function" == typeof e ? e(null) : i.removeComponentAsRefFrom(t, e, n)
      }

      var i = e(72), a = {};
      a.attachRefs = function(e, t) {
        var n = t.ref;
        null != n && r(n, e, t._owner)
      }, a.shouldUpdateRefs = function(e, t) {
        return t._owner !== e._owner || t.ref !== e.ref
      }, a.detachRefs = function(e, t) {
        var n = t.ref;
        null != n && o(n, e, t._owner)
      }, t.exports = a
    }, { 72: 72 }],
    81: [function(e, t, n) {
      "use strict";
      var r = {
        injectCreateReactRootIndex: function(e) {
          o.createReactRootIndex = e
        }
      }, o = { createReactRootIndex: null, injection: r };
      t.exports = o
    }, {}],
    82: [function(e, t, n) {
      "use strict";
      function r(e) {
        p(i.isValidElement(e));
        var t;
        try {
          var n = a.createReactRootID();
          return t = s.getPooled(!1), t.perform(function() {
            var r = c(e, null), o = r.mountComponent(n, t, l);
            return u.addChecksumToMarkup(o)
          }, null)
        } finally {
          s.release(t)
        }
      }

      function o(e) {
        p(i.isValidElement(e));
        var t;
        try {
          var n = a.createReactRootID();
          return t = s.getPooled(!0), t.perform(function() {
            var r = c(e, null);
            return r.mountComponent(n, t, l)
          }, null)
        } finally {
          s.release(t)
        }
      }

      var i = e(55), a = e(64), u = e(67), s = e(83), l = e(113), c = e(132), p = e(133);
      t.exports = { renderToString: r, renderToStaticMarkup: o }
    }, { 113: 113, 132: 132, 133: 133, 55: 55, 64: 64, 67: 67, 83: 83 }],
    83: [function(e, t, n) {
      "use strict";
      function r(e) {
        this.reinitializeTransaction(), this.renderToStaticMarkup = e, this.reactMountReady = i.getPooled(null), this.putListenerQueue = a.getPooled()
      }

      var o = e(28), i = e(6), a = e(77), u = e(101), s = e(27), l = e(112), c = {
        initialize: function() {
          this.reactMountReady.reset()
        }, close: l
      }, p = {
        initialize: function() {
          this.putListenerQueue.reset()
        }, close: l
      }, d = [p, c], f = {
        getTransactionWrappers: function() {
          return d
        }, getReactMountReady: function() {
          return this.reactMountReady
        }, getPutListenerQueue: function() {
          return this.putListenerQueue
        }, destructor: function() {
          i.release(this.reactMountReady), this.reactMountReady = null, a.release(this.putListenerQueue), this.putListenerQueue = null
        }
      };
      s(r.prototype, u.Mixin, f), o.addPoolingTo(r), t.exports = r
    }, { 101: 101, 112: 112, 27: 27, 28: 28, 6: 6, 77: 77 }],
    84: [function(e, t, n) {
      "use strict";
      function r(e) {
        e !== i.currentlyMountingInstance && l.enqueueUpdate(e)
      }

      function o(e, t) {
        p(null == a.current);
        var n = s.get(e);
        return n ? n === i.currentlyUnmountingInstance ? null : n : null
      }

      var i = e(66), a = e(39), u = e(55), s = e(65), l = e(85), c = e(27), p = e(133), d = (e(150), {
        enqueueCallback: function(e, t) {
          p("function" == typeof t);
          var n = o(e);
          return n && n !== i.currentlyMountingInstance ? (n._pendingCallbacks ? n._pendingCallbacks.push(t) : n._pendingCallbacks = [t], void r(n)) : null
        }, enqueueCallbackInternal: function(e, t) {
          p("function" == typeof t), e._pendingCallbacks ? e._pendingCallbacks.push(t) : e._pendingCallbacks = [t], r(e)
        }, enqueueForceUpdate: function(e) {
          var t = o(e, "forceUpdate");
          t && (t._pendingForceUpdate = !0, r(t))
        }, enqueueReplaceState: function(e, t) {
          var n = o(e, "replaceState");
          n && (n._pendingStateQueue = [t], n._pendingReplaceState = !0, r(n))
        }, enqueueSetState: function(e, t) {
          var n = o(e, "setState");
          if (n) {
            var i = n._pendingStateQueue || (n._pendingStateQueue = []);
            i.push(t), r(n)
          }
        }, enqueueSetProps: function(e, t) {
          var n = o(e, "setProps");
          if (n) {
            p(n._isTopLevel);
            var i = n._pendingElement || n._currentElement, a = c({}, i.props, t);
            n._pendingElement = u.cloneAndReplaceProps(i, a), r(n)
          }
        }, enqueueReplaceProps: function(e, t) {
          var n = o(e, "replaceProps");
          if (n) {
            p(n._isTopLevel);
            var i = n._pendingElement || n._currentElement;
            n._pendingElement = u.cloneAndReplaceProps(i, t), r(n)
          }
        }, enqueueElementInternal: function(e, t) {
          e._pendingElement = t, r(e)
        }
      });
      t.exports = d
    }, { 133: 133, 150: 150, 27: 27, 39: 39, 55: 55, 65: 65, 66: 66, 85: 85 }],
    85: [function(e, t, n) {
      "use strict";
      function r() {
        v(N.ReactReconcileTransaction && E)
      }

      function o() {
        this.reinitializeTransaction(), this.dirtyComponentsLength = null, this.callbackQueue = c.getPooled(), this.reconcileTransaction = N.ReactReconcileTransaction.getPooled()
      }

      function i(e, t, n, o, i) {
        r(), E.batchedUpdates(e, t, n, o, i)
      }

      function a(e, t) {
        return e._mountOrder - t._mountOrder
      }

      function u(e) {
        var t = e.dirtyComponentsLength;
        v(t === g.length), g.sort(a);
        for (var n = 0; t > n; n++) {
          var r = g[n], o = r._pendingCallbacks;
          if (r._pendingCallbacks = null, f.performUpdateIfNecessary(r, e.reconcileTransaction), o)for (var i = 0; i < o.length; i++)e.callbackQueue.enqueue(o[i], r.getPublicInstance())
        }
      }

      function s(e) {
        return r(), E.isBatchingUpdates ? void g.push(e) : void E.batchedUpdates(s, e)
      }

      function l(e, t) {
        v(E.isBatchingUpdates), y.enqueue(e, t), C = !0
      }

      var c = e(6), p = e(28), d = (e(39), e(73)), f = e(79), h = e(101), m = e(27), v = e(133), g = (e(150), []), y = c.getPooled(), C = !1, E = null, b = {
        initialize: function() {
          this.dirtyComponentsLength = g.length
        }, close: function() {
          this.dirtyComponentsLength !== g.length ? (g.splice(0, this.dirtyComponentsLength), D()) : g.length = 0
        }
      }, _ = {
        initialize: function() {
          this.callbackQueue.reset()
        }, close: function() {
          this.callbackQueue.notifyAll()
        }
      }, x = [b, _];
      m(o.prototype, h.Mixin, {
        getTransactionWrappers: function() {
          return x
        }, destructor: function() {
          this.dirtyComponentsLength = null, c.release(this.callbackQueue), this.callbackQueue = null, N.ReactReconcileTransaction.release(this.reconcileTransaction), this.reconcileTransaction = null
        }, perform: function(e, t, n) {
          return h.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, e, t, n)
        }
      }), p.addPoolingTo(o);
      var D = function() {
        for (; g.length || C;) {
          if (g.length) {
            var e = o.getPooled();
            e.perform(u, null, e), o.release(e)
          }
          if (C) {
            C = !1;
            var t = y;
            y = c.getPooled(), t.notifyAll(), c.release(t)
          }
        }
      };
      D = d.measure("ReactUpdates", "flushBatchedUpdates", D);
      var M = {
        injectReconcileTransaction: function(e) {
          v(e), N.ReactReconcileTransaction = e
        }, injectBatchingStrategy: function(e) {
          v(e), v("function" == typeof e.batchedUpdates), v("boolean" == typeof e.isBatchingUpdates), E = e
        }
      }, N = {
        ReactReconcileTransaction: null,
        batchedUpdates: i,
        enqueueUpdate: s,
        flushBatchedUpdates: D,
        injection: M,
        asap: l
      };
      t.exports = N
    }, { 101: 101, 133: 133, 150: 150, 27: 27, 28: 28, 39: 39, 6: 6, 73: 73, 79: 79 }],
    86: [function(e, t, n) {
      "use strict";
      var r = e(10), o = r.injection.MUST_USE_ATTRIBUTE, i = {
        Properties: {
          clipPath: o,
          cx: o,
          cy: o,
          d: o,
          dx: o,
          dy: o,
          fill: o,
          fillOpacity: o,
          fontFamily: o,
          fontSize: o,
          fx: o,
          fy: o,
          gradientTransform: o,
          gradientUnits: o,
          markerEnd: o,
          markerMid: o,
          markerStart: o,
          offset: o,
          opacity: o,
          patternContentUnits: o,
          patternUnits: o,
          points: o,
          preserveAspectRatio: o,
          r: o,
          rx: o,
          ry: o,
          spreadMethod: o,
          stopColor: o,
          stopOpacity: o,
          stroke: o,
          strokeDasharray: o,
          strokeLinecap: o,
          strokeOpacity: o,
          strokeWidth: o,
          textAnchor: o,
          transform: o,
          version: o,
          viewBox: o,
          x1: o,
          x2: o,
          x: o,
          y1: o,
          y2: o,
          y: o
        },
        DOMAttributeNames: {
          clipPath: "clip-path",
          fillOpacity: "fill-opacity",
          fontFamily: "font-family",
          fontSize: "font-size",
          gradientTransform: "gradientTransform",
          gradientUnits: "gradientUnits",
          markerEnd: "marker-end",
          markerMid: "marker-mid",
          markerStart: "marker-start",
          patternContentUnits: "patternContentUnits",
          patternUnits: "patternUnits",
          preserveAspectRatio: "preserveAspectRatio",
          spreadMethod: "spreadMethod",
          stopColor: "stop-color",
          stopOpacity: "stop-opacity",
          strokeDasharray: "stroke-dasharray",
          strokeLinecap: "stroke-linecap",
          strokeOpacity: "stroke-opacity",
          strokeWidth: "stroke-width",
          textAnchor: "text-anchor",
          viewBox: "viewBox"
        }
      };
      t.exports = i
    }, { 10: 10 }],
    87: [function(e, t, n) {
      "use strict";
      function r(e) {
        if ("selectionStart" in e && u.hasSelectionCapabilities(e))return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
        if (window.getSelection) {
          var t = window.getSelection();
          return {
            anchorNode: t.anchorNode,
            anchorOffset: t.anchorOffset,
            focusNode: t.focusNode,
            focusOffset: t.focusOffset
          }
        }
        if (document.selection) {
          var n = document.selection.createRange();
          return { parentElement: n.parentElement(), text: n.text, top: n.boundingTop, left: n.boundingLeft }
        }
      }

      function o(e) {
        if (y || null == m || m !== l())return null;
        var t = r(m);
        if (!g || !d(g, t)) {
          g = t;
          var n = s.getPooled(h.select, v, e);
          return n.type = "select", n.target = m, a.accumulateTwoPhaseDispatches(n), n
        }
      }

      var i = e(15), a = e(20), u = e(63), s = e(93), l = e(119), c = e(136), p = e(139), d = e(146), f = i.topLevelTypes, h = {
        select: {
          phasedRegistrationNames: { bubbled: p({ onSelect: null }), captured: p({ onSelectCapture: null }) },
          dependencies: [f.topBlur, f.topContextMenu, f.topFocus, f.topKeyDown, f.topMouseDown, f.topMouseUp, f.topSelectionChange]
        }
      }, m = null, v = null, g = null, y = !1, C = {
        eventTypes: h, extractEvents: function(e, t, n, r) {
          switch (e) {
            case f.topFocus:
              (c(t) || "true" === t.contentEditable) && (m = t, v = n, g = null);
              break;
            case f.topBlur:
              m = null, v = null, g = null;
              break;
            case f.topMouseDown:
              y = !0;
              break;
            case f.topContextMenu:
            case f.topMouseUp:
              return y = !1, o(r);
            case f.topSelectionChange:
            case f.topKeyDown:
            case f.topKeyUp:
              return o(r)
          }
        }
      };
      t.exports = C
    }, { 119: 119, 136: 136, 139: 139, 146: 146, 15: 15, 20: 20, 63: 63, 93: 93 }],
    88: [function(e, t, n) {
      "use strict";
      var r = Math.pow(2, 53), o = {
        createReactRootIndex: function() {
          return Math.ceil(Math.random() * r)
        }
      };
      t.exports = o
    }, {}],
    89: [function(e, t, n) {
      "use strict";
      var r = e(15), o = e(19), i = e(20), a = e(90), u = e(93), s = e(94), l = e(96), c = e(97), p = e(92), d = e(98), f = e(99), h = e(100), m = e(120), v = e(133), g = e(139), y = (e(150), r.topLevelTypes), C = {
        blur: {
          phasedRegistrationNames: {
            bubbled: g({ onBlur: !0 }),
            captured: g({ onBlurCapture: !0 })
          }
        },
        click: { phasedRegistrationNames: { bubbled: g({ onClick: !0 }), captured: g({ onClickCapture: !0 }) } },
        contextMenu: {
          phasedRegistrationNames: {
            bubbled: g({ onContextMenu: !0 }),
            captured: g({ onContextMenuCapture: !0 })
          }
        },
        copy: { phasedRegistrationNames: { bubbled: g({ onCopy: !0 }), captured: g({ onCopyCapture: !0 }) } },
        cut: { phasedRegistrationNames: { bubbled: g({ onCut: !0 }), captured: g({ onCutCapture: !0 }) } },
        doubleClick: {
          phasedRegistrationNames: {
            bubbled: g({ onDoubleClick: !0 }),
            captured: g({ onDoubleClickCapture: !0 })
          }
        },
        drag: { phasedRegistrationNames: { bubbled: g({ onDrag: !0 }), captured: g({ onDragCapture: !0 }) } },
        dragEnd: { phasedRegistrationNames: { bubbled: g({ onDragEnd: !0 }), captured: g({ onDragEndCapture: !0 }) } },
        dragEnter: {
          phasedRegistrationNames: {
            bubbled: g({ onDragEnter: !0 }),
            captured: g({ onDragEnterCapture: !0 })
          }
        },
        dragExit: {
          phasedRegistrationNames: {
            bubbled: g({ onDragExit: !0 }),
            captured: g({ onDragExitCapture: !0 })
          }
        },
        dragLeave: {
          phasedRegistrationNames: {
            bubbled: g({ onDragLeave: !0 }),
            captured: g({ onDragLeaveCapture: !0 })
          }
        },
        dragOver: {
          phasedRegistrationNames: {
            bubbled: g({ onDragOver: !0 }),
            captured: g({ onDragOverCapture: !0 })
          }
        },
        dragStart: {
          phasedRegistrationNames: {
            bubbled: g({ onDragStart: !0 }),
            captured: g({ onDragStartCapture: !0 })
          }
        },
        drop: { phasedRegistrationNames: { bubbled: g({ onDrop: !0 }), captured: g({ onDropCapture: !0 }) } },
        focus: { phasedRegistrationNames: { bubbled: g({ onFocus: !0 }), captured: g({ onFocusCapture: !0 }) } },
        input: { phasedRegistrationNames: { bubbled: g({ onInput: !0 }), captured: g({ onInputCapture: !0 }) } },
        keyDown: { phasedRegistrationNames: { bubbled: g({ onKeyDown: !0 }), captured: g({ onKeyDownCapture: !0 }) } },
        keyPress: {
          phasedRegistrationNames: {
            bubbled: g({ onKeyPress: !0 }),
            captured: g({ onKeyPressCapture: !0 })
          }
        },
        keyUp: { phasedRegistrationNames: { bubbled: g({ onKeyUp: !0 }), captured: g({ onKeyUpCapture: !0 }) } },
        load: { phasedRegistrationNames: { bubbled: g({ onLoad: !0 }), captured: g({ onLoadCapture: !0 }) } },
        error: { phasedRegistrationNames: { bubbled: g({ onError: !0 }), captured: g({ onErrorCapture: !0 }) } },
        mouseDown: {
          phasedRegistrationNames: {
            bubbled: g({ onMouseDown: !0 }),
            captured: g({ onMouseDownCapture: !0 })
          }
        },
        mouseMove: {
          phasedRegistrationNames: {
            bubbled: g({ onMouseMove: !0 }),
            captured: g({ onMouseMoveCapture: !0 })
          }
        },
        mouseOut: {
          phasedRegistrationNames: {
            bubbled: g({ onMouseOut: !0 }),
            captured: g({ onMouseOutCapture: !0 })
          }
        },
        mouseOver: {
          phasedRegistrationNames: {
            bubbled: g({ onMouseOver: !0 }),
            captured: g({ onMouseOverCapture: !0 })
          }
        },
        mouseUp: { phasedRegistrationNames: { bubbled: g({ onMouseUp: !0 }), captured: g({ onMouseUpCapture: !0 }) } },
        paste: { phasedRegistrationNames: { bubbled: g({ onPaste: !0 }), captured: g({ onPasteCapture: !0 }) } },
        reset: { phasedRegistrationNames: { bubbled: g({ onReset: !0 }), captured: g({ onResetCapture: !0 }) } },
        scroll: { phasedRegistrationNames: { bubbled: g({ onScroll: !0 }), captured: g({ onScrollCapture: !0 }) } },
        submit: { phasedRegistrationNames: { bubbled: g({ onSubmit: !0 }), captured: g({ onSubmitCapture: !0 }) } },
        touchCancel: {
          phasedRegistrationNames: {
            bubbled: g({ onTouchCancel: !0 }),
            captured: g({ onTouchCancelCapture: !0 })
          }
        },
        touchEnd: {
          phasedRegistrationNames: {
            bubbled: g({ onTouchEnd: !0 }),
            captured: g({ onTouchEndCapture: !0 })
          }
        },
        touchMove: {
          phasedRegistrationNames: {
            bubbled: g({ onTouchMove: !0 }),
            captured: g({ onTouchMoveCapture: !0 })
          }
        },
        touchStart: {
          phasedRegistrationNames: {
            bubbled: g({ onTouchStart: !0 }),
            captured: g({ onTouchStartCapture: !0 })
          }
        },
        wheel: { phasedRegistrationNames: { bubbled: g({ onWheel: !0 }), captured: g({ onWheelCapture: !0 }) } }
      }, E = {
        topBlur: C.blur,
        topClick: C.click,
        topContextMenu: C.contextMenu,
        topCopy: C.copy,
        topCut: C.cut,
        topDoubleClick: C.doubleClick,
        topDrag: C.drag,
        topDragEnd: C.dragEnd,
        topDragEnter: C.dragEnter,
        topDragExit: C.dragExit,
        topDragLeave: C.dragLeave,
        topDragOver: C.dragOver,
        topDragStart: C.dragStart,
        topDrop: C.drop,
        topError: C.error,
        topFocus: C.focus,
        topInput: C.input,
        topKeyDown: C.keyDown,
        topKeyPress: C.keyPress,
        topKeyUp: C.keyUp,
        topLoad: C.load,
        topMouseDown: C.mouseDown,
        topMouseMove: C.mouseMove,
        topMouseOut: C.mouseOut,
        topMouseOver: C.mouseOver,
        topMouseUp: C.mouseUp,
        topPaste: C.paste,
        topReset: C.reset,
        topScroll: C.scroll,
        topSubmit: C.submit,
        topTouchCancel: C.touchCancel,
        topTouchEnd: C.touchEnd,
        topTouchMove: C.touchMove,
        topTouchStart: C.touchStart,
        topWheel: C.wheel
      };
      for (var b in E)E[b].dependencies = [b];
      var _ = {
        eventTypes: C, executeDispatch: function(e, t, n) {
          var r = o.executeDispatch(e, t, n);
          r === !1 && (e.stopPropagation(), e.preventDefault())
        }, extractEvents: function(e, t, n, r) {
          var o = E[e];
          if (!o)return null;
          var g;
          switch (e) {
            case y.topInput:
            case y.topLoad:
            case y.topError:
            case y.topReset:
            case y.topSubmit:
              g = u;
              break;
            case y.topKeyPress:
              if (0 === m(r))return null;
            case y.topKeyDown:
            case y.topKeyUp:
              g = l;
              break;
            case y.topBlur:
            case y.topFocus:
              g = s;
              break;
            case y.topClick:
              if (2 === r.button)return null;
            case y.topContextMenu:
            case y.topDoubleClick:
            case y.topMouseDown:
            case y.topMouseMove:
            case y.topMouseOut:
            case y.topMouseOver:
            case y.topMouseUp:
              g = c;
              break;
            case y.topDrag:
            case y.topDragEnd:
            case y.topDragEnter:
            case y.topDragExit:
            case y.topDragLeave:
            case y.topDragOver:
            case y.topDragStart:
            case y.topDrop:
              g = p;
              break;
            case y.topTouchCancel:
            case y.topTouchEnd:
            case y.topTouchMove:
            case y.topTouchStart:
              g = d;
              break;
            case y.topScroll:
              g = f;
              break;
            case y.topWheel:
              g = h;
              break;
            case y.topCopy:
            case y.topCut:
            case y.topPaste:
              g = a
          }
          v(g);
          var C = g.getPooled(o, n, r);
          return i.accumulateTwoPhaseDispatches(C), C
        }
      };
      t.exports = _
    }, {
      100: 100,
      120: 120,
      133: 133,
      139: 139,
      15: 15,
      150: 150,
      19: 19,
      20: 20,
      90: 90,
      92: 92,
      93: 93,
      94: 94,
      96: 96,
      97: 97,
      98: 98,
      99: 99
    }],
    90: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(93), i = {
        clipboardData: function(e) {
          return "clipboardData" in e ? e.clipboardData : window.clipboardData
        }
      };
      o.augmentClass(r, i), t.exports = r
    }, { 93: 93 }],
    91: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(93), i = { data: null };
      o.augmentClass(r, i), t.exports = r
    }, { 93: 93 }],
    92: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(97), i = { dataTransfer: null };
      o.augmentClass(r, i), t.exports = r
    }, { 97: 97 }],
    93: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        this.dispatchConfig = e, this.dispatchMarker = t, this.nativeEvent = n;
        var r = this.constructor.Interface;
        for (var o in r)if (r.hasOwnProperty(o)) {
          var i = r[o];
          i ? this[o] = i(n) : this[o] = n[o]
        }
        var u = null != n.defaultPrevented ? n.defaultPrevented : n.returnValue === !1;
        u ? this.isDefaultPrevented = a.thatReturnsTrue : this.isDefaultPrevented = a.thatReturnsFalse, this.isPropagationStopped = a.thatReturnsFalse
      }

      var o = e(28), i = e(27), a = e(112), u = e(123), s = {
        type: null,
        target: u,
        currentTarget: a.thatReturnsNull,
        eventPhase: null,
        bubbles: null,
        cancelable: null,
        timeStamp: function(e) {
          return e.timeStamp || Date.now()
        },
        defaultPrevented: null,
        isTrusted: null
      };
      i(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var e = this.nativeEvent;
          e.preventDefault ? e.preventDefault() : e.returnValue = !1, this.isDefaultPrevented = a.thatReturnsTrue
        }, stopPropagation: function() {
          var e = this.nativeEvent;
          e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0, this.isPropagationStopped = a.thatReturnsTrue
        }, persist: function() {
          this.isPersistent = a.thatReturnsTrue
        }, isPersistent: a.thatReturnsFalse, destructor: function() {
          var e = this.constructor.Interface;
          for (var t in e)this[t] = null;
          this.dispatchConfig = null, this.dispatchMarker = null, this.nativeEvent = null
        }
      }), r.Interface = s, r.augmentClass = function(e, t) {
        var n = this, r = Object.create(n.prototype);
        i(r, e.prototype), e.prototype = r, e.prototype.constructor = e, e.Interface = i({}, n.Interface, t), e.augmentClass = n.augmentClass, o.addPoolingTo(e, o.threeArgumentPooler)
      }, o.addPoolingTo(r, o.threeArgumentPooler), t.exports = r
    }, { 112: 112, 123: 123, 27: 27, 28: 28 }],
    94: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(99), i = { relatedTarget: null };
      o.augmentClass(r, i), t.exports = r
    }, { 99: 99 }],
    95: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(93), i = { data: null };
      o.augmentClass(r, i), t.exports = r
    }, { 93: 93 }],
    96: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(99), i = e(120), a = e(121), u = e(122), s = {
        key: a,
        location: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        repeat: null,
        locale: null,
        getModifierState: u,
        charCode: function(e) {
          return "keypress" === e.type ? i(e) : 0
        },
        keyCode: function(e) {
          return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
        },
        which: function(e) {
          return "keypress" === e.type ? i(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
        }
      };
      o.augmentClass(r, s), t.exports = r
    }, { 120: 120, 121: 121, 122: 122, 99: 99 }],
    97: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(99), i = e(102), a = e(122), u = {
        screenX: null,
        screenY: null,
        clientX: null,
        clientY: null,
        ctrlKey: null,
        shiftKey: null,
        altKey: null,
        metaKey: null,
        getModifierState: a,
        button: function(e) {
          var t = e.button;
          return "which" in e ? t : 2 === t ? 2 : 4 === t ? 1 : 0
        },
        buttons: null,
        relatedTarget: function(e) {
          return e.relatedTarget || (e.fromElement === e.srcElement ? e.toElement : e.fromElement)
        },
        pageX: function(e) {
          return "pageX" in e ? e.pageX : e.clientX + i.currentScrollLeft
        },
        pageY: function(e) {
          return "pageY" in e ? e.pageY : e.clientY + i.currentScrollTop
        }
      };
      o.augmentClass(r, u), t.exports = r
    }, { 102: 102, 122: 122, 99: 99 }],
    98: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(99), i = e(122), a = {
        touches: null,
        targetTouches: null,
        changedTouches: null,
        altKey: null,
        metaKey: null,
        ctrlKey: null,
        shiftKey: null,
        getModifierState: i
      };
      o.augmentClass(r, a), t.exports = r
    }, { 122: 122, 99: 99 }],
    99: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(93), i = e(123), a = {
        view: function(e) {
          if (e.view)return e.view;
          var t = i(e);
          if (null != t && t.window === t)return t;
          var n = t.ownerDocument;
          return n ? n.defaultView || n.parentWindow : window
        }, detail: function(e) {
          return e.detail || 0
        }
      };
      o.augmentClass(r, a), t.exports = r
    }, { 123: 123, 93: 93 }],
    100: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        o.call(this, e, t, n)
      }

      var o = e(97), i = {
        deltaX: function(e) {
          return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        }, deltaY: function(e) {
          return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
        }, deltaZ: null, deltaMode: null
      };
      o.augmentClass(r, i), t.exports = r
    }, { 97: 97 }],
    101: [function(e, t, n) {
      "use strict";
      var r = e(133), o = {
        reinitializeTransaction: function() {
          this.transactionWrappers = this.getTransactionWrappers(), this.wrapperInitData ? this.wrapperInitData.length = 0 : this.wrapperInitData = [], this._isInTransaction = !1
        }, _isInTransaction: !1, getTransactionWrappers: null, isInTransaction: function() {
          return !!this._isInTransaction
        }, perform: function(e, t, n, o, i, a, u, s) {
          r(!this.isInTransaction());
          var l, c;
          try {
            this._isInTransaction = !0, l = !0, this.initializeAll(0), c = e.call(t, n, o, i, a, u, s), l = !1
          } finally {
            try {
              if (l)try {
                this.closeAll(0)
              } catch (p) {
              } else this.closeAll(0)
            } finally {
              this._isInTransaction = !1
            }
          }
          return c
        }, initializeAll: function(e) {
          for (var t = this.transactionWrappers, n = e; n < t.length; n++) {
            var r = t[n];
            try {
              this.wrapperInitData[n] = i.OBSERVED_ERROR, this.wrapperInitData[n] = r.initialize ? r.initialize.call(this) : null
            } finally {
              if (this.wrapperInitData[n] === i.OBSERVED_ERROR)try {
                this.initializeAll(n + 1)
              } catch (o) {
              }
            }
          }
        }, closeAll: function(e) {
          r(this.isInTransaction());
          for (var t = this.transactionWrappers, n = e; n < t.length; n++) {
            var o, a = t[n], u = this.wrapperInitData[n];
            try {
              o = !0, u !== i.OBSERVED_ERROR && a.close && a.close.call(this, u), o = !1
            } finally {
              if (o)try {
                this.closeAll(n + 1)
              } catch (s) {
              }
            }
          }
          this.wrapperInitData.length = 0
        }
      }, i = { Mixin: o, OBSERVED_ERROR: {} };
      t.exports = i
    }, { 133: 133 }],
    102: [function(e, t, n) {
      "use strict";
      var r = {
        currentScrollLeft: 0, currentScrollTop: 0, refreshScrollValues: function(e) {
          r.currentScrollLeft = e.x, r.currentScrollTop = e.y
        }
      };
      t.exports = r
    }, {}],
    103: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        if (o(null != t), null == e)return t;
        var n = Array.isArray(e), r = Array.isArray(t);
        return n && r ? (e.push.apply(e, t), e) : n ? (e.push(t), e) : r ? [e].concat(t) : [e, t]
      }

      var o = e(133);
      t.exports = r
    }, { 133: 133 }],
    104: [function(e, t, n) {
      "use strict";
      function r(e) {
        for (var t = 1, n = 0, r = 0; r < e.length; r++)t = (t + e.charCodeAt(r)) % o, n = (n + t) % o;
        return t | n << 16
      }

      var o = 65521;
      t.exports = r
    }, {}],
    105: [function(e, t, n) {
      function r(e) {
        return e.replace(o, function(e, t) {
          return t.toUpperCase()
        })
      }

      var o = /-(.)/g;
      t.exports = r
    }, {}],
    106: [function(e, t, n) {
      "use strict";
      function r(e) {
        return o(e.replace(i, "ms-"))
      }

      var o = e(105), i = /^-ms-/;
      t.exports = r
    }, { 105: 105 }],
    107: [function(e, t, n) {
      function r(e, t) {
        return e && t ? e === t ? !0 : o(e) ? !1 : o(t) ? r(e, t.parentNode) : e.contains ? e.contains(t) : e.compareDocumentPosition ? !!(16 & e.compareDocumentPosition(t)) : !1 : !1
      }

      var o = e(137);
      t.exports = r
    }, { 137: 137 }],
    108: [function(e, t, n) {
      function r(e) {
        return !!e && ("object" == typeof e || "function" == typeof e) && "length" in e && !("setInterval" in e) && "number" != typeof e.nodeType && (Array.isArray(e) || "callee" in e || "item" in e)
      }

      function o(e) {
        return r(e) ? Array.isArray(e) ? e.slice() : i(e) : [e]
      }

      var i = e(148);
      t.exports = o
    }, { 148: 148 }],
    109: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = i.createFactory(e), n = o.createClass({
          tagName: e.toUpperCase(),
          displayName: "ReactFullPageComponent" + e,
          componentWillUnmount: function() {
            a(!1)
          },
          render: function() {
            return t(this.props)
          }
        });
        return n
      }

      var o = e(33), i = e(55), a = e(133);
      t.exports = r
    }, { 133: 133, 33: 33, 55: 55 }],
    110: [function(e, t, n) {
      function r(e) {
        var t = e.match(c);
        return t && t[1].toLowerCase()
      }

      function o(e, t) {
        var n = l;
        s(!!l);
        var o = r(e), i = o && u(o);
        if (i) {
          n.innerHTML = i[1] + e + i[2];
          for (var c = i[0]; c--;)n = n.lastChild
        } else n.innerHTML = e;
        var p = n.getElementsByTagName("script");
        p.length && (s(t), a(p).forEach(t));
        for (var d = a(n.childNodes); n.lastChild;)n.removeChild(n.lastChild);
        return d
      }

      var i = e(21), a = e(108), u = e(125), s = e(133), l = i.canUseDOM ? document.createElement("div") : null, c = /^\s*<(\w+)/;
      t.exports = o
    }, { 108: 108, 125: 125, 133: 133, 21: 21 }],
    111: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        var n = null == t || "boolean" == typeof t || "" === t;
        if (n)return "";
        var r = isNaN(t);
        return r || 0 === t || i.hasOwnProperty(e) && i[e] ? "" + t : ("string" == typeof t && (t = t.trim()), t + "px")
      }

      var o = e(4), i = o.isUnitlessNumber;
      t.exports = r
    }, { 4: 4 }],
    112: [function(e, t, n) {
      function r(e) {
        return function() {
          return e
        }
      }

      function o() {
      }

      o.thatReturns = r, o.thatReturnsFalse = r(!1), o.thatReturnsTrue = r(!0), o.thatReturnsNull = r(null), o.thatReturnsThis = function() {
        return this
      }, o.thatReturnsArgument = function(e) {
        return e
      }, t.exports = o
    }, {}],
    113: [function(e, t, n) {
      "use strict";
      var r = {};
      t.exports = r
    }, {}],
    114: [function(e, t, n) {
      "use strict";
      function r(e) {
        return i[e]
      }

      function o(e) {
        return ("" + e).replace(a, r)
      }

      var i = { "&": "&amp;", ">": "&gt;", "<": "&lt;", '"': "&quot;", "'": "&#x27;" }, a = /[&><"']/g;
      t.exports = o
    }, {}],
    115: [function(e, t, n) {
      "use strict";
      function r(e) {
        return null == e ? null : u(e) ? e : o.has(e) ? i.getNodeFromInstance(e) : (a(null == e.render || "function" != typeof e.render), void a(!1))
      }

      {
        var o = (e(39), e(65)), i = e(68), a = e(133), u = e(135);
        e(150)
      }
      t.exports = r
    }, { 133: 133, 135: 135, 150: 150, 39: 39, 65: 65, 68: 68 }],
    116: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        var r = e, o = !r.hasOwnProperty(n);
        o && null != t && (r[n] = t)
      }

      function o(e) {
        if (null == e)return e;
        var t = {};
        return i(e, r, t), t
      }

      {
        var i = e(149);
        e(150)
      }
      t.exports = o
    }, { 149: 149, 150: 150 }],
    117: [function(e, t, n) {
      "use strict";
      function r(e) {
        try {
          e.focus()
        } catch (t) {
        }
      }

      t.exports = r
    }, {}],
    118: [function(e, t, n) {
      "use strict";
      var r = function(e, t, n) {
        Array.isArray(e) ? e.forEach(t, n) : e && t.call(n, e)
      };
      t.exports = r
    }, {}],
    119: [function(e, t, n) {
      function r() {
        try {
          return document.activeElement || document.body
        } catch (e) {
          return document.body
        }
      }

      t.exports = r
    }, {}],
    120: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t, n = e.keyCode;
        return "charCode" in e ? (t = e.charCode, 0 === t && 13 === n && (t = 13)) : t = n, t >= 32 || 13 === t ? t : 0
      }

      t.exports = r
    }, {}],
    121: [function(e, t, n) {
      "use strict";
      function r(e) {
        if (e.key) {
          var t = i[e.key] || e.key;
          if ("Unidentified" !== t)return t
        }
        if ("keypress" === e.type) {
          var n = o(e);
          return 13 === n ? "Enter" : String.fromCharCode(n)
        }
        return "keydown" === e.type || "keyup" === e.type ? a[e.keyCode] || "Unidentified" : ""
      }

      var o = e(120), i = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, a = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      t.exports = r
    }, { 120: 120 }],
    122: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = this, n = t.nativeEvent;
        if (n.getModifierState)return n.getModifierState(e);
        var r = i[e];
        return r ? !!n[r] : !1
      }

      function o(e) {
        return r
      }

      var i = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      t.exports = o
    }, {}],
    123: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = e.target || e.srcElement || window;
        return 3 === t.nodeType ? t.parentNode : t
      }

      t.exports = r
    }, {}],
    124: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = e && (o && e[o] || e[i]);
        return "function" == typeof t ? t : void 0
      }

      var o = "function" == typeof Symbol && Symbol.iterator, i = "@@iterator";
      t.exports = r
    }, {}],
    125: [function(e, t, n) {
      function r(e) {
        return i(!!a), d.hasOwnProperty(e) || (e = "*"), u.hasOwnProperty(e) || ("*" === e ? a.innerHTML = "<link />" : a.innerHTML = "<" + e + "></" + e + ">", u[e] = !a.firstChild), u[e] ? d[e] : null
      }

      var o = e(21), i = e(133), a = o.canUseDOM ? document.createElement("div") : null, u = {
        circle: !0,
        clipPath: !0,
        defs: !0,
        ellipse: !0,
        g: !0,
        line: !0,
        linearGradient: !0,
        path: !0,
        polygon: !0,
        polyline: !0,
        radialGradient: !0,
        rect: !0,
        stop: !0,
        text: !0
      }, s = [1, '<select multiple="true">', "</select>"], l = [1, "<table>", "</table>"], c = [3, "<table><tbody><tr>", "</tr></tbody></table>"], p = [1, "<svg>", "</svg>"], d = {
        "*": [1, "?<div>", "</div>"],
        area: [1, "<map>", "</map>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        param: [1, "<object>", "</object>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        optgroup: s,
        option: s,
        caption: l,
        colgroup: l,
        tbody: l,
        tfoot: l,
        thead: l,
        td: c,
        th: c,
        circle: p,
        clipPath: p,
        defs: p,
        ellipse: p,
        g: p,
        line: p,
        linearGradient: p,
        path: p,
        polygon: p,
        polyline: p,
        radialGradient: p,
        rect: p,
        stop: p,
        text: p
      };
      t.exports = r
    }, { 133: 133, 21: 21 }],
    126: [function(e, t, n) {
      "use strict";
      function r(e) {
        for (; e && e.firstChild;)e = e.firstChild;
        return e
      }

      function o(e) {
        for (; e;) {
          if (e.nextSibling)return e.nextSibling;
          e = e.parentNode
        }
      }

      function i(e, t) {
        for (var n = r(e), i = 0, a = 0; n;) {
          if (3 === n.nodeType) {
            if (a = i + n.textContent.length, t >= i && a >= t)return { node: n, offset: t - i };
            i = a
          }
          n = r(o(n))
        }
      }

      t.exports = i
    }, {}],
    127: [function(e, t, n) {
      "use strict";
      function r(e) {
        return e ? e.nodeType === o ? e.documentElement : e.firstChild : null
      }

      var o = 9;
      t.exports = r
    }, {}],
    128: [function(e, t, n) {
      "use strict";
      function r() {
        return !i && o.canUseDOM && (i = "textContent" in document.documentElement ? "textContent" : "innerText"), i
      }

      var o = e(21), i = null;
      t.exports = r
    }, { 21: 21 }],
    129: [function(e, t, n) {
      "use strict";
      function r(e) {
        return e === window ? {
          x: window.pageXOffset || document.documentElement.scrollLeft,
          y: window.pageYOffset || document.documentElement.scrollTop
        } : { x: e.scrollLeft, y: e.scrollTop }
      }

      t.exports = r
    }, {}],
    130: [function(e, t, n) {
      function r(e) {
        return e.replace(o, "-$1").toLowerCase()
      }

      var o = /([A-Z])/g;
      t.exports = r
    }, {}],
    131: [function(e, t, n) {
      "use strict";
      function r(e) {
        return o(e).replace(i, "-ms-")
      }

      var o = e(130), i = /^ms-/;
      t.exports = r
    }, { 130: 130 }],
    132: [function(e, t, n) {
      "use strict";
      function r(e) {
        return "function" == typeof e && "undefined" != typeof e.prototype && "function" == typeof e.prototype.mountComponent && "function" == typeof e.prototype.receiveComponent
      }

      function o(e, t) {
        var n;
        if ((null === e || e === !1) && (e = a.emptyElement), "object" == typeof e) {
          var o = e;
          n = t === o.type && "string" == typeof o.type ? u.createInternalComponent(o) : r(o.type) ? new o.type(o) : new c
        } else"string" == typeof e || "number" == typeof e ? n = u.createInstanceForText(e) : l(!1);
        return n.construct(e), n._mountIndex = 0, n._mountImage = null, n
      }

      var i = e(37), a = e(57), u = e(71), s = e(27), l = e(133), c = (e(150), function() {
      });
      s(c.prototype, i.Mixin, { _instantiateReactComponent: o }), t.exports = o
    }, { 133: 133, 150: 150, 27: 27, 37: 37, 57: 57, 71: 71 }],
    133: [function(e, t, n) {
      "use strict";
      var r = function(e, t, n, r, o, i, a, u) {
        if (!e) {
          var s;
          if (void 0 === t)s = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
            var l = [n, r, o, i, a, u], c = 0;
            s = new Error("Invariant Violation: " + t.replace(/%s/g, function() {
                      return l[c++]
                    }))
          }
          throw s.framesToPop = 1, s
        }
      };
      t.exports = r
    }, {}],
    134: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        if (!i.canUseDOM || t && !("addEventListener" in document))return !1;
        var n = "on" + e, r = n in document;
        if (!r) {
          var a = document.createElement("div");
          a.setAttribute(n, "return;"), r = "function" == typeof a[n]
        }
        return !r && o && "wheel" === e && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r
      }

      var o, i = e(21);
      i.canUseDOM && (o = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0), t.exports = r
    }, { 21: 21 }],
    135: [function(e, t, n) {
      function r(e) {
        return !(!e || !("function" == typeof Node ? e instanceof Node : "object" == typeof e && "number" == typeof e.nodeType && "string" == typeof e.nodeName))
      }

      t.exports = r
    }, {}],
    136: [function(e, t, n) {
      "use strict";
      function r(e) {
        return e && ("INPUT" === e.nodeName && o[e.type] || "TEXTAREA" === e.nodeName)
      }

      var o = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      };
      t.exports = r
    }, {}],
    137: [function(e, t, n) {
      function r(e) {
        return o(e) && 3 == e.nodeType
      }

      var o = e(135);
      t.exports = r
    }, { 135: 135 }],
    138: [function(e, t, n) {
      "use strict";
      var r = e(133), o = function(e) {
        var t, n = {};
        r(e instanceof Object && !Array.isArray(e));
        for (t in e)e.hasOwnProperty(t) && (n[t] = t);
        return n
      };
      t.exports = o
    }, { 133: 133 }],
    139: [function(e, t, n) {
      var r = function(e) {
        var t;
        for (t in e)if (e.hasOwnProperty(t))return t;
        return null
      };
      t.exports = r
    }, {}],
    140: [function(e, t, n) {
      "use strict";
      function r(e, t, n) {
        if (!e)return null;
        var r = {};
        for (var i in e)o.call(e, i) && (r[i] = t.call(n, e[i], i, e));
        return r
      }

      var o = Object.prototype.hasOwnProperty;
      t.exports = r
    }, {}],
    141: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = {};
        return function(n) {
          return t.hasOwnProperty(n) || (t[n] = e.call(this, n)), t[n]
        }
      }

      t.exports = r
    }, {}],
    142: [function(e, t, n) {
      "use strict";
      function r(e) {
        return i(o.isValidElement(e)), e
      }

      var o = e(55), i = e(133);
      t.exports = r
    }, { 133: 133, 55: 55 }],
    143: [function(e, t, n) {
      "use strict";
      function r(e) {
        return '"' + o(e) + '"'
      }

      var o = e(114);
      t.exports = r
    }, { 114: 114 }],
    144: [function(e, t, n) {
      "use strict";
      var r = e(21), o = /^[ \r\n\t\f]/, i = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/, a = function(e, t) {
        e.innerHTML = t
      };
      if ("undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction && (a = function(e, t) {
                MSApp.execUnsafeLocalFunction(function() {
                  e.innerHTML = t
                })
              }), r.canUseDOM) {
        var u = document.createElement("div");
        u.innerHTML = " ", "" === u.innerHTML && (a = function(e, t) {
          if (e.parentNode && e.parentNode.replaceChild(e, e), o.test(t) || "<" === t[0] && i.test(t)) {
            e.innerHTML = "\ufeff" + t;
            var n = e.firstChild;
            1 === n.data.length ? e.removeChild(n) : n.deleteData(0, 1)
          } else e.innerHTML = t
        })
      }
      t.exports = a
    }, { 21: 21 }],
    145: [function(e, t, n) {
      "use strict";
      var r = e(21), o = e(114), i = e(144), a = function(e, t) {
        e.textContent = t
      };
      r.canUseDOM && ("textContent" in document.documentElement || (a = function(e, t) {
        i(e, o(t))
      })), t.exports = a
    }, { 114: 114, 144: 144, 21: 21 }],
    146: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        if (e === t)return !0;
        var n;
        for (n in e)if (e.hasOwnProperty(n) && (!t.hasOwnProperty(n) || e[n] !== t[n]))return !1;
        for (n in t)if (t.hasOwnProperty(n) && !e.hasOwnProperty(n))return !1;
        return !0
      }

      t.exports = r
    }, {}],
    147: [function(e, t, n) {
      "use strict";
      function r(e, t) {
        if (null != e && null != t) {
          var n = typeof e, r = typeof t;
          if ("string" === n || "number" === n)return "string" === r || "number" === r;
          if ("object" === r && e.type === t.type && e.key === t.key) {
            var o = e._owner === t._owner;
            return o
          }
        }
        return !1
      }

      e(150);
      t.exports = r
    }, { 150: 150 }],
    148: [function(e, t, n) {
      function r(e) {
        var t = e.length;
        if (o(!Array.isArray(e) && ("object" == typeof e || "function" == typeof e)), o("number" == typeof t), o(0 === t || t - 1 in e), e.hasOwnProperty)try {
          return Array.prototype.slice.call(e)
        } catch (n) {
        }
        for (var r = Array(t), i = 0; t > i; i++)r[i] = e[i];
        return r
      }

      var o = e(133);
      t.exports = r
    }, { 133: 133 }],
    149: [function(e, t, n) {
      "use strict";
      function r(e) {
        return v[e]
      }

      function o(e, t) {
        return e && null != e.key ? a(e.key) : t.toString(36)
      }

      function i(e) {
        return ("" + e).replace(g, r)
      }

      function a(e) {
        return "$" + i(e)
      }

      function u(e, t, n, r, i) {
        var s = typeof e;
        if (("undefined" === s || "boolean" === s) && (e = null), null === e || "string" === s || "number" === s || l.isValidElement(e))return r(i, e, "" === t ? h + o(e, 0) : t, n), 1;
        var p, v, g, y = 0;
        if (Array.isArray(e))for (var C = 0; C < e.length; C++)p = e[C], v = ("" !== t ? t + m : h) + o(p, C), g = n + y, y += u(p, v, g, r, i); else {
          var E = d(e);
          if (E) {
            var b, _ = E.call(e);
            if (E !== e.entries)for (var x = 0; !(b = _.next()).done;)p = b.value, v = ("" !== t ? t + m : h) + o(p, x++), g = n + y, y += u(p, v, g, r, i); else for (; !(b = _.next()).done;) {
              var D = b.value;
              D && (p = D[1], v = ("" !== t ? t + m : h) + a(D[0]) + m + o(p, 0), g = n + y, y += u(p, v, g, r, i))
            }
          } else if ("object" === s) {
            f(1 !== e.nodeType);
            var M = c.extract(e);
            for (var N in M)M.hasOwnProperty(N) && (p = M[N], v = ("" !== t ? t + m : h) + a(N) + m + o(p, 0), g = n + y, y += u(p, v, g, r, i))
          }
        }
        return y
      }

      function s(e, t, n) {
        return null == e ? 0 : u(e, "", 0, t, n)
      }

      var l = e(55), c = e(61), p = e(64), d = e(124), f = e(133), h = (e(150), p.SEPARATOR), m = ":", v = {
        "=": "=0",
        ".": "=1",
        ":": "=2"
      }, g = /[=.:]/g;
      t.exports = s
    }, { 124: 124, 133: 133, 150: 150, 55: 55, 61: 61, 64: 64 }],
    150: [function(e, t, n) {
      "use strict";
      var r = e(112), o = r;
      t.exports = o
    }, { 112: 112 }]
  }, {}, [1])(1)
});